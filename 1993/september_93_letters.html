<html>
<head>
<!-- Article ID: 28 - Extracted from develop-1993 -->
<!-- on 2024-02-19 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by copyright of their respective owners -->
<title>September 93 - Letters</title>
<link href="../common/styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h2>LETTERS</h2>
<b>NEW TECH NOTE NUMBERS</b><br>
In <i>develop</i> Issue 14 Peter Fink complains about the loss of Tech Note numbering.&nbsp;&nbsp;In<br>
your answer you write: "We're always open to suggestion, but so far you're the only<br>
one to mention this. If others reading this reply have similar feedback, I hope they'll<br>
let us know."<br>
<p>
Actually, I and others have complained about the loss of Tech Note numbers for quite<br>
some time, but sometimes talking about these things is like complaining about the<br>
weather. I suspect most people just grumble along and don't complain in writing.<br>
-- Johan G. E. Strandberg
</p>
<p>
<i>Good news: Numbers are back; see the editorial on page 2 and the Tech Notes on this</i><br>
<i>issue's CD. It's too bad when people grumble without writing; the latter is much more</i><br>
<i>effective, and we really appreciate the effort. Thanks!</i><br>
<i>-- Caroline Rose</i>
</p>
<p>
<b>DEBUGGING LESSON FLUB</b><br>
There seems to be a problem with the point made in the "Debugging Lesson" letter in<br>
the Letters section of <i>develop </i>Issue 14. According to the source listed, there would be<br>
no problem even if memory moved when FillWithData was called. Since the handle is<br>
being passed as a handle (that is, not dereferenced), and handles are 4-byte pointers<br>
(which get pushed onto the stack as is), FillWithData would always get a valid handle,<br>
which it can dereference internally to its heart's content.
</p>
<p>
Unfortunately, there seems to be a lot of confusion (and a great deal of paranoia) over<br>
the usage of handles. As long as you pass handles as handles (and watch your<br>
dereferencing), you'll be OK.<br>
--Charlie Reading
</p>
<p>
<i>Um, oops. (Imagine, if you will, me standing gaping and red-faced, astonished at my</i><br>
<i>own carelessness and idiocy.)</i>
</p>
<p>
<i>You're right, of course; the danger is only in passing </i> dereferenced <i>handles to routines</i><br>
<i>in other segments, and the code in the letter passes the handle itself. I guess I just read</i><br>
<i>the text and didn't really look closely at the code before replying. Obviously, it was</i><br>
<i>only intended as an example, and the writer's point is still valid: passing dereferenced</i><br>
<i>handles to routines in other segments is dangerous. You should either pass the handle</i><br>
<i>itself (as the example code did!) or lock the handle first.</i>
</p>
<p>
<i>Sorry about the confusion.</i><br>
<i>--Dave Johnson</i>
</p>
<p>
<b>BABBLING ON</b><br>
I enjoyed reading Dave Johnson's column in <i> develop </i>Issue 13 ("Tower of Babble").<br>
While reading his discussion of natural versus programming languages, I think I was<br>
able to put my finger on what has bugged me about HyperTalk&#174; for years. Natural<br>
languages imply a fluidity of meaning, giving its users great flexibility for nuances,<br>
emphasis, and brevity.&nbsp;&nbsp;HyperTalk <i> looks </i>like a natural language, but it possesses none<br>
of that fluidity of meaning. In HyperCard &#174;, SET has but one meaning.&nbsp;&nbsp;But in my<br>
Oxford dictionary, "set" has 194 definitions! In other words, HyperCard looks so much<br>
like English, one winds up assuming that all kinds of structures could be used as long<br>
as they make sense in English (for example, "set me to true").
</p>
<p>
Allow me to submit a suggestion, which you may wish to pass along to the software<br>
gods. Since Apple has now all but declared that C and C++ are the only computer<br>
languages the human race will ever need, maybe it would be great to have a<br>
HyperTalk-to-C translator. Why? Well, C is a write- only language (no one ever can<br>
figure out what's happening in someone else's C listing) and HyperTalk is a read-only<br>
language (it's a cinch to understand, but impossible to code in). With a translator, we<br>
could write code that still could be understood, just like when we used to code in<br>
Pascal. (Yes, this is a joke, from a die-hard Pascal enthusiast.) Thanks again for a<br>
nifty column!<br>
--Kevin Killion
</p>
<p>
<i>I'm glad you liked the column. Your comment about HyperTalk is very well taken! I</i><br>
<i>think that's what always bothered me about it, too, though it was just a sort of vague</i><br>
<i>unease. Unfortunately, I think people who didn't learn "regular" programming</i><br>
<i>languages first may have a distinct disadvantage: we "real" programmers know up</i><br>
<i>front how limited and terse and strict programming languages are, and we don't expect</i><br>
<i>anything more. But power&nbsp;&nbsp;users who learn HyperTalk (or, more likely now,</i><br>
<i>AppleScript) as their very first programming language may be in for a struggle if</i><br>
<i>they don't keep reminding themselves that it's </i> not <i> a natural language.</i>
</p>
<p>
<i>As a die-hard C enthusiast, I'll graciously ignore your slams against my favorite</i><br>
<i>language, and assume that since you're obviously an intelligent person, sooner or later</i><br>
<i>you'll realize the error of your ways and come around to the truth, bemoaning the</i><br>
<i>years you've spent in bondage to an uptight compiler. </i><br>
<i>--Dave Johnson</i>
</p>
<p>
<b>ASYNCH SUPPORT ON A/UX</b><br>
After reading through Jim Luther's Asynchronous Routines article in <i> develop </i>Issue<br>
13, I spiffed up my application to make all my file handling asynchronous,<br>
anticipating the glorious day when all the drivers on my Macintosh support<br>
asynchronous calls. But since the SCSI Manager isn't asynchronous yet, there's no<br>
apparent difference to the user of my code (or to me, the hard-working programmer<br>
who wants payoff for my labors).
</p>
<p>
Is there any platform or configuration I can test my application on and see the results<br>
of my effort?<br>
--Tony Amaretto
</p>
<p>
<i>Try your code on A/UX 3.0.1 (the operating system for the Apple Workgroup Server</i><br>
<i>95); it features an enhanced File Manager that supports asynchronous calls to UNIX</i> &#174;<br>
<i>file systems simply by using the techniques in Jim Luther's article. AppleShare Pro</i><br>
<i>takes advantage of this capability on AWS 95 to get performance up to four times</i><br>
<i>better than AppleShare 3.0's under System 7 (your mileage, as always, will vary).</i>
</p>
<p>
<i>For more information related to the Asynchronus Routines article, see the box on the</i><br>
<i>next page. Have fun!</i><br>
<i>--Dave Johnson</i>
</p>
<h2>MORE ON ASYNCHRONOUS ROUTINES IN ISSUE 13</h2>
<p>
For developers interested in the "Asynchronous Routines on the Macintosh" article in <br>
<i>develop </i>Issue 13, here's some new information that has surfaced since then.
</p>
<p>
<b>StackSpace.</b> Contrary to the advice on page 28 of the article, you should not call<br>
StackSpace at interrupt time, because the Memory Manager might not be in a<br>
consistent state. Furthermore, StackSpace clears MemErr, which may have an adverse<br>
effect on the current process's handling of Memory Manager errors.
</p>
<p>
<b>PPC polling.</b> Unlike the Device Manager and File Manager, the PPC Toolbox stuffs<br>
the result of an asynchronous routine into ioResult <i>before</i> it's really done with the<br>
parameter block. If your interrupt code -- such&nbsp;&nbsp;as a VBL task -- polls ioResult<br>
periodically to check for completion and reuses the parameter block to make another<br>
call, the system can crash because one or more system queues will be corrupted.
</p>
<p>
<b>Context switching.</b> The System 7 Process Manager (and MultiFinder under System<br>
6) will wait until all currently active asynchronous requests to the File Manager have<br>
completed before performing a context switch. This check was added for compatibility<br>
reasons to prevent system crashes caused by a few applications that accessed program<br>
globals within File Manager completion routines without restoring their A5 world.<br>
What this means to you is that if your application makes an asynchronous File Manager<br>
call and then calls WaitNextEvent or GetNextEvent, the system may wait for your call<br>
to complete. If the asynchronous File Manager call takes a long time to complete, it<br>
will appear to the user that the system isn't responding.
</p>
<p>
<b>Synchronous drivers.</b> Although you can execute low-level file access routines<br>
asynchronously, a volume's underlying device driver may not support asynchronous<br>
operations. Once the File Manager passes a request to a synchronous driver, that<br>
driver doesn't give up control until it has completed the task. Synchronous drivers<br>
(such as those using the current SCSI Manager) affect programs using asynchronous<br>
File Manager calls in two ways: unexpected pauses and unsightly stack frame buildup.
</p>
<ul>
<li>When calling the File Manager asynchronously, your program passes<br>
control to the File Manager and the request is placed in a queue or, if the queue<br>
is empty, the request is handled immediately. Either way, once a synchronous<br>
driver gets the request, it retains control until it has responded to the request.<br>
If the request takes a long time to complete, the user may think the system<br>
isn't responding. If your program is a background task, these pauses will<br>
affect the performance of the current foreground application. To keep this to a<br>
minimum, avoid time-consuming asynchronous File Manager requests.</li>
<li>Chaining asynchronous File Manager calls will work on volumes<br>
controlled by synchronous drivers, but watch out: When the driver is<br>
synchronous, the stack frames from the system and your completion routines<br>
will keep building up on the current stack until the last asynchronous call in<br>
the chain completes, or until the stack overwrites the current heap. You'll<br>
need to break the asynchronous File Manager call chain every few completion<br>
routines. A simple way to do this is to start a Time Manager or VBL task from<br>
your File Manager call's completion routine, and let the task start the next<br>
asynchronous File Manager call in the chain.</li>
</ul>
<p>
<b>File Sharing and AppleShare.</b> Chained asynchronous File Manager calls can fail<br>
when either the Macintosh File Sharing or AppleShare 3.0 (not 3.0.1) file server is<br>
running. The file server software intercepts almost all calls made to the File Manager.<br>
Due to how the file server keeps track of what requests it has or hasn't seen, there are<br>
a few situations where the file server can do the wrong thing with chained<br>
asynchronous File Manager calls. To make sure the file server sees and handles all<br>
chained asynchronous File Manager calls correctly, use two parameter blocks for the<br>
chained calls and switch parameter blocks at every completion routine.
</p>
<p class="spacer">&nbsp;</p>
<p>
<b>WE HATE IT WHEN YOU DON'T WRITE </b>We welcome timely letters to the editors,<br>
especially from readers reacting to articles that we publish in <i> develop</i>. Letters should<br>
be addressed to Caroline Rose (or, if technical <i> develop</i>-related questions, to Dave<br>
Johnson) at Apple Computer, Inc., 20525 Mariani Avenue, M/S 303-4DP, Cupertino,<br>
CA 95014 (AppleLink CROSE or JOHNSON.DK). All letters should include your name<br>
and company name as well as your address and phone number. Letters may be<br>
excerpted or edited for clarity (or to make them say what we wish they did). *
</p>
<p>
<b>SUBSCRIPTION INFORMATION</b>Subscriptions to <i>develop </i>are available through<br>
APDA (see inside back cover for APDA information), or you can use the subscription<br>
card in the back of this issue. Please address all subscription-related inquiries to <br>
<i>develop, </i>Apple Computer, Inc., P.O. Box 531, Mt. Morris, IL 61054 (or AppleLink<br>
DEV.SUBS). *
</p>
<p>
<b>BACK ISSUES </b>For information about back issues of <i>develop </i>and how to obtain them,<br>
see the last page of this issue. Back issues are also on the<i> develop Bookmark</i> CD and the<br>
<i>Developer CD Series</i> disc (Reference Library edition).*
</p>
<p>
<b>Thanks </b>to Fran&#231;ois Grieu and Lawrence D'Oliveiro for providing some of this<br>
information. *
</p>
</body>
</html>
