<html>
<head>
<!-- Article ID: 23 - Extracted from develop-1993 -->
<!-- on 2024-02-03 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by the copyright of its respective owners -->
<title>June 93 - 3-D ROTATION USING A 2-D INPUT DEVICE</title>
<link href="../common/styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h2>3-D ROTATION USING A 2-D INPUT DEVICE</h2>
<h1>MICHAEL CHEN</h1>
<p>
<img src="img/177.gif" width="216 px"></img>
</p>
<p>
<i>&nbsp;One essential part of any 3-D graphics application is the ability to turn an object so</i><br>
<i>that it can be viewed from different sides. This article describes a user interface</i><br>
<i>technique called the Virtual Sphere that allows you to perform continuous 3-D</i><br>
<i>rotation using a 2-D input device such as a mouse. For those who have played with my</i><br>
<i>Rotation Controller application and have been waiting for source code, here it is! For</i><br>
<i>others, this article is a good way to learn something about interactive 3-D graphics</i><br>
<i>and user interfaces for 3-D.</i>
</p>
<p class="spacer">&nbsp;</p>
<p>
&nbsp;There are many situations in which users might want to view a 3-D graphics object<br>
from different sides. They might want to do so while constructing an object or<br>
rearranging objects in a scene. Or they may be viewing a multimedia document and<br>
want to turn around a 3-D object that's embedded in the page. Whatever the context,<br>
it's important to provide a simple, intuitive interface for the task that's available to a<br>
wide user base.
</p>
<p>
&nbsp;The problem of 3-D rotation has been approached in many ways. Some people have<br>
designed their applications to use higher-degrees-of-freedom input devices such as<br>
3-D mice, 3-D trackballs, the 6-D Spaceball, and the 6-D Polhemus. These devices<br>
let you control values for<i>x</i>,<i> y</i>, and<i> z</i> (and perhaps roll, pitch, and yaw) at the same<br>
time. Unfortunately, these input devices incur extra cost and must be available on the<br>
machine currently being used. The user must also learn how to use the device and<br>
possibly learn a new interface paradigm. 
</p>
<p>
&nbsp;Other applications have stayed with 2-D input devices because of their familiarity<br>
and availability.&nbsp;&nbsp;&nbsp;However, many of these applications will let you perform rotation<br>
only about the<i>x, y,</i> or<i> z</i> axis, while others will let you use the mouse to perform only<br>
"2-D rotations," in which the user must specify an axis of rotation lying on, say,<br>
the<i>x-y</i> plane. In both cases, the user needs to change tools or hold down modifier keys<br>
(or mouse buttons) to specify rotations about other axes. This is cumbersome, but<br>
many have accepted the fact that they have only two degrees of freedom when using a<br>
device like a mouse.
</p>
<p>
&nbsp;The Virtual Sphere controller is a user interface tool developed to solve the problem<br>
of 3-D rotation using a 2-D input device. The controller allows continuous rotation<br>
about an arbitrary axis in three- dimensional space. Because the controller works<br>
with a 2-D input device, the interface can be used on a wide range of machines with a<br>
mouse, trackball, touch screen, or similar device. (This article will assume the use of<br>
a mouse.) An important part of the design effort was user testing. Not only must the<br>
controller be technologically sound, it must also be easy to learn and use. Testing<br>
results will be discussed later. 
</p>
<p>
<img src="img/178.gif" width="479 px"></img>
</p>
<p>
Grayscale version
</p>
<p>
<img src="img/179.gif" width="341 px"></img>
</p>
<p>
Dithered version
</p>
<p>
<b>&nbsp;Figure 1</b> The Initial Window, in Grayscale and With Dithering
</p>
<h2>&nbsp;USING THE VIRTUAL SPHERE INTERFACE</h2>
<p>
Before getting into the design and implementation of the Virtual Sphere interface, let's<br>
first play a bit with the sample application. You'll need to use a machine running<br>
System 7 or a System 6 machine with 32-Bit QuickDraw. Find and launch the<br>
application VirtualSphereSample, provided on this issue's CD. As shown in Figure 1,<br>
you'll see a 3-D house enclosed by the circular Virtual Sphere controller (hereafter<br>
called the<i>cue</i>). 
</p>
<p>
&nbsp;You'll see a color, grayscale, or dithered rendering of the house, depending on your<br>
monitor and bit depth. To rotate the house, move the pointer inside the cue and then<br>
drag the pointer around.&nbsp;&nbsp;&nbsp;Observe what happens to the house when you drag in the<br>
following directions:
</p>
<ul>
<li>left and right, beginning with the pointer at the center of the cue</li>
<li> up and down, beginning with the pointer at the center of the cue</li>
<li> around the edge of or outside the cue</li>
</ul>
<p>
See if you can position the house in a desired orientation. 
</p>
<p>
The Virtual Sphere controller simulates the mechanics of a physical 3-D trackball<br>
that can freely rotate about any arbitrary axis in three-dimensional space. The user<br>
can imagine the cue to be a glass sphere that's encasing the object to be rotated.<br>
Rotation is a matter of rolling the sphere and therefore the object with the pointer.<br>
Up-and-down and left-and-right movement at the center of the cue is equivalent to<br>
"rolling" the imaginary sphere at its apex and produces rotation about an axis lying on<br>
the plane of the screen. Movement along (or completely outside) the edge of the cue is<br>
equivalent to rolling the sphere at the edge and produces rotation about the axis<br>
perpendicular to the screen. 
</p>
<p>
The Virtual Sphere is unusual in the sense that you seem to be able to squeeze an extra<br>
degree of freedom out of a 2-D input device. The action of rolling the Virtual Sphere<br>
lets you specify an arbitrary rotation axis in three-dimensional space, with the<br>
advantage that you don't need to think about the rotation axis. You just roll, and the<br>
object turns in the expected way. 
</p>
<p>
To validate the usefulness of the Virtual Sphere interface, two colleagues and I designed<br>
an experiment to compare the performance of different rotational interfaces in a<br>
matching task. In the experiment, the computer displays a house at a certain<br>
orientation, and the user has to use the given rotational interface to match that<br>
orientation. The performance measurement is based on time and accuracy. The result<br>
showed that the Virtual Sphere was indeed easy to use and was fastest for complex<br>
rotations. If you're interested in the details of the other rotational interfaces and the<br>
experiment, they're described in "A Study in Interactive 3-D Rotation Using 2-D<br>
Control Devices" (see "Recommended Reading" at the end of this article). A version of<br>
the rotation controllers and computer experiment is available on this issue's CD. 
</p>
<h2>HOW THE VIRTUAL SPHERE INTERFACE WORKS</h2>
<p>
The general idea of this interface is that the Virtual Sphere cue is drawn around the<br>
object to be rotated. The cue is centered over the object's center of rotation and should<br>
be just large enough to enclose the object. When the user drags over the cue, the<br>
successive<i>x-y</i> locations of the pointer are used to incrementally rotate the object. The<br>
next few paragraphs delve into the mathematics of this process. Those of you with an<br>
aversion to vectors and trigonometry may want to skip ahead to the next section. 
</p>
<p>
The orientation of the object is represented in the sample code by a 4 x 4 rotation<br>
matrix. At each movement of the pointer, an incremental rotation matrix is computed,<br>
using the Virtual Sphere algorithm. This matrix is then concatenated with the object's<br>
matrix, and the object is redisplayed.&nbsp;&nbsp;&nbsp;This process is repeated until the user releases<br>
the mouse button. 
</p>
<p>
The incremental rotation matrix is computed using the Virtual Sphere algorithm as<br>
follows: Figure 2 shows a cue as it appears on the screen and also gives the<br>
corresponding 3-D view. The cue is conceptually a hemisphere protruding from the<br>
screen. When the pointer is moved from point<i>p</i> to point<i>q</i> on the screen, we think of it<br>
as moving from point<i>p'</i> to point<i>q'</i> on the surface of the imaginary hemisphere. We<br>
compute the points<i>p'</i> and<i> q'</i>by projecting points<i>p</i> and<i> q</i> upward (that is, straight out<br>
from the screen) from the circle to the surface of the hemisphere. To simplify the<br>
math, we'll assume that the cue and hemisphere each have a radius of 1. 
</p>
<p>
<img src="img/180.gif" width="728 px"></img>
</p>
<p>
<b>Figure 2</b> The Virtual Sphere Cue and Its Corresponding 3-D Hemisphere
</p>
        <p>
            Given that we now have points <i>p'</i> and <i>q'</i>, we create vectors from the center of the <br>
            hemisphere, <i>o'</i>, calling them vectors 
            <math>
                <mover>
                    <mi><i>o'p'</i></mi>
                    <mo>&rarr;</mo>
                </mover>
            </math> 
            and 
            <math>
                <mover>
                    <mi><i>o'q'</i></mi>
                    <mo>&rarr;</mo>
                </mover>
            </math>. The axis of rotation, 
            <math>
                <mover>
                    <mi><i>a</i></mi>
                    <mo>&rarr;</mo>
                </mover>
            </math>, is <br>
            perpendicular to the two vectors and can be computed using the vector cross-product <br>
            (see Figure 3) <br>
        </p>
        <p>
            <math>
                <mrow>
                    <mover>
                        <mi><i>a</i></mi>
                        <mo>&rarr;</mo>
                    </mover>
                    <mo>=</mo>
                    <mover>
                        <mi><i>o'p'</i></mi>
                        <mo>&rarr;</mo>
                    </mover>
                    <mo>&Cross;</mo>
                    <mover>
                        <mi><i>o'q'</i></mi>
                        <mo>&rarr;</mo>
                    </mover>
                </mrow>
            </math>
        </p>
        
<p>
<img src="img/181.gif" width="432 px"></img>
</p>
<p>
<b>&nbsp;Figure 3</b> Computing the Axis of Rotation
</p>
        <p>
            The amount of rotation, <i>&theta;</i>, is the angle between the vectors, and is computed from <br>
            the arc sine of the length of 
            <math>
                <mover>
                    <mi><i>a</i></mi>
                    <mo>&rarr;</mo>
                </mover>
            </math>:
        </p>
        <p>
            <math>
                <mrow>
                    <mi><i>&theta;</i></mi>
                    <mo>=</mo>
                    <msup>
                        <mi>sin</mi>
                        <mn>-1</mn>
                    </msup>
                    <mo>&InvisibleTimes;</mo>
                    <mrow>
                        <mo>|</mo>
                        <mover>
                            <mi><i>a</i></mi>
                            <mo>&rarr;</mo>
                        </mover>
                        <mo>|</mo>
                    </mrow>
                </mrow>
            </math>
        </p>
        <p>
            The corresponding 4 x 4 incremental rotation matrix is
        </p>
        <p>
            <math>
                <mrow>
                    <mo>[</mo>
                    <mtable>
                        <mtr>
                            <mtd>
                                <mrow>
                                    <mi>t</mi>
                                    <mo>&InvisibleTimes;</mo>
                                    <msubsup>
                                        <mi>a</mi>
                                        <mpadded depth="10%">
                                            <mn>x</mn>
                                        </mpadded>
                                        <mn>2</mn>
                                    </msubsup>
                                    <mo>+</mo>
                                    <mi>c</mi>
                                </mrow>
                            </mtd>
                            <mtd>
                                <mrow>
                                    <mi>t</mi>
                                    <mo>&InvisibleTimes;</mo>
                                    <msub>
                                        <mi>a</mi>
                                        <mpadded depth="10%">
                                            <mi>x</mi>
                                        </mpadded>
                                    </msub>
                                    <mo>&InvisibleTimes;</mo>
                                    <msub>
                                        <mi>a</mi>
                                        <mpadded depth="10%">
                                            <mi>y</mi>
                                        </mpadded>
                                    </msub>
                                    <mo>+</mo>
                                    <mi>s</mi>
                                    <mo>&InvisibleTimes;</mo>
                                    <msub>
                                        <mi>a</mi>
                                        <mpadded depth="10%">
                                            <mi>z</mi>
                                        </mpadded>
                                    </msub>
                                </mrow>
                            </mtd>
                            <mtd>
                                <mrow>
                                    <mi>t</mi>
                                    <mo>&InvisibleTimes;</mo>
                                    <msub>
                                        <mi>a</mi>
                                        <mpadded depth="10%">
                                            <mi>x</mi>
                                        </mpadded>
                                    </msub>
                                    <mo>&InvisibleTimes;</mo>
                                    <msub>
                                        <mi>a</mi>
                                        <mpadded depth="10%">
                                            <mi>z</mi>
                                        </mpadded>
                                    </msub>
                                    <mo>-</mo>
                                    <mi>s</mi>
                                    <mo>&InvisibleTimes;</mo>
                                    <msub>
                                        <mi>a</mi>
                                        <mpadded depth="10%">
                                            <mi>y</mi>
                                        </mpadded>
                                    </msub>
                                </mrow>
                            </mtd>
                            <mtd>
                                <mn>0</mn>
                            </mtd>
                        </mtr>
                        <mtr>
                            <mtd>
                                <mrow>
                                    <mi>t</mi>
                                    <mo>&InvisibleTimes;</mo>
                                    <msub>
                                        <mi>a</mi>
                                        <mpadded depth="10%">
                                            <mi>x</mi>
                                        </mpadded>
                                    </msub>
                                    <mo>&InvisibleTimes;</mo>
                                    <msub>
                                        <mi>a</mi>
                                        <mpadded depth="10%">
                                            <mi>y</mi>
                                        </mpadded>
                                    </msub>
                                    <mo>-</mo>
                                    <mi>s</mi>
                                    <mo>&InvisibleTimes;</mo>
                                    <msub>
                                        <mi>a</mi>
                                        <mpadded depth="10%">
                                            <mi>z</mi>
                                        </mpadded>
                                    </msub>
                                </mrow>
                            </mtd>
                            <mtd>
                                <mrow>
                                    <mi>t</mi>
                                    <mo>&InvisibleTimes;</mo>
                                    <msubsup>
                                        <mi>a</mi>
                                        <mpadded depth="10%">
                                            <mn>y</mn>
                                        </mpadded>
                                        <mn>2</mn>
                                    </msubsup>
                                    <mo>+</mo>
                                    <mi>c</mi>
                                </mrow>
                            </mtd>
                            <mtd>
                                <mrow>
                                    <mi>t</mi>
                                    <mo>&InvisibleTimes;</mo>
                                    <msub>
                                        <mi>a</mi>
                                        <mpadded depth="10%">
                                            <mi>y</mi>
                                        </mpadded>
                                    </msub>
                                    <mo>&InvisibleTimes;</mo>
                                    <msub>
                                        <mi>a</mi>
                                        <mpadded depth="10%">
                                            <mi>z</mi>
                                        </mpadded>
                                    </msub>
                                    <mo>+</mo>
                                    <mi>s</mi>
                                    <mo>&InvisibleTimes;</mo>
                                    <msub>
                                        <mi>a</mi>
                                        <mpadded depth="10%">
                                            <mi>x</mi>
                                        </mpadded>
                                    </msub>
                                </mrow>
                            </mtd>
                            <mtd>
                                0
                            </mtd>  
                        </mtr>
                        <mtr>
                            <mtd>
                                <mrow>
                                    <mi>t</mi>
                                    <mo>&InvisibleTimes;</mo>
                                    <msub>
                                        <mi>a</mi>
                                        <mpadded depth="10%">
                                            <mi>x</mi>
                                        </mpadded>
                                    </msub>
                                    <mo>&InvisibleTimes;</mo>
                                    <msub>
                                        <mi>a</mi>
                                        <mpadded depth="10%">
                                            <mi>z</mi>
                                        </mpadded>
                                    </msub>
                                    <mo>+</mo>
                                    <mi>s</mi>
                                    <mo>&InvisibleTimes;</mo>
                                    <msub>
                                        <mi>a</mi>
                                        <mpadded depth="10%">
                                            <mi>y</mi>
                                        </mpadded>
                                    </msub>
                                </mrow>
                            </mtd>
                            <mtd>
                                <mrow>
                                    <mi>t</mi>
                                    <mo>&InvisibleTimes;</mo>
                                    <msub>
                                        <mi>a</mi>
                                        <mpadded depth="10%">
                                            <mi>y</mi>
                                        </mpadded>
                                    </msub>
                                    <mo>&InvisibleTimes;</mo>
                                    <msub>
                                        <mi>a</mi>
                                        <mpadded depth="10%">
                                            <mi>z</mi>
                                        </mpadded>
                                    </msub>
                                    <mo>-</mo>
                                    <mi>s</mi>
                                    <mo>&InvisibleTimes;</mo>
                                    <msub>
                                        <mi>a</mi>
                                        <mpadded depth="10%">
                                            <mi>x</mi>
                                        </mpadded>
                                    </msub>
                                </mrow>
                            </mtd>
                            <mtd>
                                <mrow>
                                    <mi>t</mi>
                                    <mo>&InvisibleTimes;</mo>
                                    <msubsup>
                                        <mi>a</mi>
                                        <mpadded depth="10%">
                                            <mn>z</mn>
                                        </mpadded>
                                        <mn>2</mn>
                                    </msubsup>
                                    <mo>+</mo>
                                    <mi>c</mi>
                                </mrow>
                            </mtd>
                            <mtd>
                                0
                            </mtd> 
                        </mtr>
                        <mtr>
                            <mtd>
                                0
                            </mtd>
                            <mtd>
                                0
                            </mtd>
                            <mtd>
                                0
                            </mtd>
                            <mtd>
                                1
                            </mtd>
                        </mtr>
                    </mtable>
                    <mo>]</mo>
                </mrow>
            </math>
        </p>
        <p>
            where
            <ul>
                <li>
                    <math>
                        <msub>
                            <mi>a</mi>    
                            <mpadded depth="10%">
                                <mi>x</mi>
                            </mpadded>
                        </msub>
                    </math>
                    ,
                    <math>
                        <msub>
                            <mi>a</mi>    
                            <mpadded depth="10%">
                                <mi>y</mi>
                            </mpadded>
                        </msub>
                    </math>
                    and
                    <math>
                        <msub>
                            <mi>a</mi>    
                            <mpadded depth="10%">
                                <mi>z</mi>
                            </mpadded>
                        </msub>
                    </math>
                    are the components of
                    <math>
                        <mover>
                            <mi><i>a</i></mi>
                            <mo>&rarr;</mo>
                        </mover>
                    </math>
                </li>
                <li>
                    <math>
                        <mrow>
                            <mi>s</mi>
                            <mo>=</mo>
                            <mi>sin</mi>
                            <mi>&theta;</mi>
                            <mo>=</mo>
                            <mrow>
                                <mo>|</mo>
                                <mover>
                                    <mi><i>a</i></mi>
                                    <mo>&rarr;</mo>
                                </mover>
                                <mo>|</mo>
                            </mrow>
                        </mrow>
                    </math>
                </li>
                <li>
                    <math>
                        <mrow>
                            <mi>c</mi>
                            <mo>=</mo>
                            <mi>cos</mi>
                            <mi>&theta;</mi>
                            <mo>=</mo>
                            <mrow>
                                <mover>
                                    <mi><i>o'p'</i></mi>
                                    <mo>&rarr;</mo>
                                </mover>
                            </mrow>
                            <mo>&sdot;</mo>
                            <mrow>
                                <mover>
                                    <mi><i>o'q'</i></mi>
                                    <mo>&rarr;</mo>
                                </mover>
                            </mrow>
                        </mrow>
                    </math>
                    (vector dot-product of 
                    <math>
                        <mrow>
                            <mover>
                                <mi><i>o'p'</i></mi>
                                <mo>&rarr;</mo>
                            </mover>
                        </mrow>
                    </math>
                    and
                    <math>
                        <mrow>
                            <mover>
                                <mi><i>o'q'</i></mi>
                                <mo>&rarr;</mo>
                            </mover>
                        </mrow>
                    </math>
                    )
                </li>
                <li>
                    <math>
                        <mrow>
                            <mi>t</mi>
                            <mo>=</mo>
                            <mn>1</mn>
                            <mo>-</mo>
                            <mi>c</mi>
                        </mrow>
                    </math>
                </li>
            </ul>
        </p>
        <p>
            Note that we have a choice here for computing the matrix. We can first compute the<br>
            angle of rotation and then use the sine and cosine functions to obtain <i>s</i> and <i>c</i>.<br>
            However, knowing vector
            <math>
                <mrow>
                    <mover>
                        <mi><i>o'p'</i></mi>
                        <mo>&rarr;</mo>
                    </mover>
                </mrow>
            </math>
            and
            <math>
                <mrow>
                    <mover>
                        <mi><i>o'q'</i></mi>
                        <mo>&rarr;</mo>
                    </mover>
                </mrow>
            </math>
            , we can also compute <i>s</i> and <i>c</i> using the length<br>
            of
            <math>
                <mover>
                    <mi><i>a</i></mi>
                    <mo>&rarr;</mo>
                </mover>
            </math>
            and the dot-product. The latter approach allows us to compute the matrix<br>
            efficiently without using any trigonometric calculations, which are expensive.
        </p>
        



<p>
&nbsp;The Virtual Sphere algorithm just described is an improvement over the one<br>
described in the paper "A Study in Interactive 3-D Rotation Using 2-D Control<br>
Devices." The paper used a three-step procedure to convert movement of a 2-D input<br>
device into a 3-D rotation matrix. However, it turns out that if we first convert the<br>
2-D input to 3-D, the Virtual Sphere calculation can be done much more efficiently. 
</p>
<p>
<b>&nbsp;IMPLEMENTING THE VIRTUAL SPHERE INTERFACE</b><br>
The preceding description of the Virtual Sphere algorithm probably sounds more<br>
complicated than it is. The actual implementation is really quite simple. In fact, the<br>
VirtualSphere module contains only one externally visible routine:
</p>
<p>
<code>pascal void VirtualSphere (Point p, Point q, Point cueCenter,</code><br>
<code>Integer cueRadius, Matrix4D rotationMatrix)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;CPoint3D&nbsp;&nbsp;&nbsp;&nbsp;op, oq;</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;/* Project mouse points to 3-D points on the +z hemisphere of a</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* unit sphere. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;PointOnUnitSphere (p, cueCenter, cueRadius, &amp;op);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;PointOnUnitSphere (q, cueCenter, cueRadius, &amp;oq);</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;/* Consider the two projected points as vectors from the center</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* of the unit sphere. Compute the rotation matrix that will</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* transform vector op to oq. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;SetRotationMatrix (rotationMatrix, &amp;op, &amp;oq);</code><br>
<code>}</code>
</p>
<p>
<b>&nbsp;USING THE VIRTUAL SPHERE INTERFACE</b><br>
Let's look at how we use the VirtualSphere routine to rotate a 3-D object<br>
interactively. 
</p>
<p>
<code>void DoRotation (WindowPtr window, EventRecord *event, Matrix4D</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;objectMatrix)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Point&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p, q;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dx, dy;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Point&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sphereCenter;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sphereRadius;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Matrix4D&nbsp;&nbsp;&nbsp;&nbsp;tempMatrix;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Matrix4D&nbsp;&nbsp;&nbsp;&nbsp;rotationMatrix;</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;p = event-&gt;where;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GlobalToLocal (&amp;p);&nbsp;&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Get mouse-down point in local coordinates.*/</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;/* Figure out where to place the Virtual Sphere cue. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;sphereCenter.h = kSphereCenterH;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;sphereCenter.v = kSphereCenterV;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;sphereRadius = kSphereRadius;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;while (StillDown()) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GetMouse (&amp;q);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dx = q.h - p.h;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dy = q.v - p.v;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (dx != 0 || dy != 0) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VirtualSphere (p, q, sphereCenter, sphereRadius,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rotationMatrix);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MultiplyMatrix (objectMatrix, rotationMatrix,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tempMatrix);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CopyMatrix (tempMatrix, objectMatrix);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawWindow (window);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Update the window. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p = q;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Remember previous mouse point for next iteration.*/</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code>}</code>
</p>
<p>
When DoRotation is called, the 3-D object's current matrix is passed in as<br>
objectMatrix. In the sample application, the Virtual Sphere cue is always centered on<br>
the window and has a fixed size. Thus, sphereCenter and sphereRadius are assigned<br>
with constants. In a general application, you'll need to determine which object is<br>
selected and figure out the size and location of the cue (in the window's coordinates) to<br>
surround the object. In any case, while the mouse button is still down and the mouse<br>
has moved, we call VirtualSphere to obtain the incremental rotation matrix. This<br>
matrix is concatenated onto the 3-D object's current matrix using MultiplyMatrix and<br>
CopyMatrix. We then redraw the window to display the object at its new orientation.<br>
This process is repeated until the mouse button is released. 
</p>
<h2>CREATING A SIMPLE 3-D GRAPHICS SYSTEM</h2>
<p>
The real point of this article and the sample code is to demonstrate the Virtual Sphere<br>
interface.&nbsp;&nbsp;&nbsp;However, it turned out that a large part of the effort involved went into<br>
creating a simple 3-D graphics system. It was much more work than the<br>
implementation of the Virtual Sphere algorithm itself! I wanted to provide a simple<br>
system that would be accessible by the majority of Macintosh programmers and would<br>
allow even low-end Macintosh models to do interactive 3-D graphics. 
</p>
<p>
The graphics system I came up with is based on Graf3D. Graf3D is a simple library for<br>
drawing 3-D graphics using a fixed-point interface to QuickDraw's integer<br>
coordinates. I chose Graf3D because it's included in the THINK C and MPW<br>
environments. It uses fixed-point math and runs reasonably quickly even on a<br>
Macintosh SE! This means that the sample code should be quite usable for<br>
all<i>develop</i>readers. 
</p>
<p>
One major caveat is that the Graf3D library is unsupported. Most people doing 3-D<br>
graphics on the Macintosh probably won't care about this point, because they write<br>
their own 3-D software and will simply port the Virtual Sphere code to their system.<br>
I've provided the sample code using Graf3D to show how the whole system works. Also,<br>
it's nice to be able to show that Graf3D is not as brain dead as some people might think.
</p>
<p class="spacer">&nbsp;</p>
<p>
<b>GRAPHICS SYSTEM SPECIFICATION</b><br>
The graphics system we need is extremely simple. It needs to be able to display only<br>
one relatively simple 3-D object at the center of a window. We'll assume that the<br>
entire object is visible so that we won't have to worry about 3-D polygon clipping<br>
(which, unfortunately, is left as an exercise for thestudents in most 3-D graphics<br>
courses). The object should be displayed with perspective projection.&nbsp;&nbsp;&nbsp;The displayed<br>
object can only be rotated. We predefine the center of rotation to be the center of the<br>
object. 
</p>
<p>
On the display screen, we define the origin of the 3-D coordinate system at the center<br>
of the screen, the<i>x</i> axis as extending to the right, the<i>y</i> axis as extending upward, and<br>
the<i>z</i> axis as coming out of the screen toward the viewer. Note that in the QuickDraw<br>
coordinate system, the<i>y</i> axis extends in the opposite direction. 
</p>
<p>
For the sake of cosmetics, the graphics system should adapt to the monitor bit depth so<br>
that the graphics can be shown on color, grayscale, and black-and-white displays. The<br>
system must use double buffering to eliminate screen flicker. 
</p>
<p>
To make the Virtual Sphere implementation easier to understand, I've used<br>
floating-point math to compute the axis of rotation, the angle of rotation, and the 4 x 4<br>
rotation matrix. However, we'll take advantage of the fixed-point math used in Graf3D<br>
to speed up graphics drawing. 
</p>
<p>
<b>SETTING UP GRAF3D</b><br>
To implement our simple graphics system using Graf3D, we create and associate a<br>
Port3D to the grafPort in which the 3-D object is to be displayed. We place the camera<br>
at some distance on the positive<i>z</i> axis, looking at the origin. We draw the object<br>
centered at the origin. With this setup, we have the 3-D view as specified above. 
</p>
<p>
<b>EXTENDING GRAF3D TO DRAW POLYGONS</b><br>
Graf3D provides only two calls, MoveTo3D and LineTo3D, to perform line drawings in<br>
3-D. These calls are analogous to the 2-D MoveTo and LineTo calls, except that the<br>
3-D calls require an additional<i> z</i> parameter. Graf3D doesn't have calls to draw 3-D<br>
polygons. However, that doesn't mean we have to write our own routine from scratch.<br>
We'll take advantage of the fact that MoveTo3D and LineTo3D, after performing the<br>
math to project 3-D onto 2-D, will call MoveTo and LineTo to draw the line on-screen<br>
(of course, it helps to have access to the source code for Graf3D). Hence, drawing a<br>
polygon projected from 3-D is no more difficult than drawing a regular 2-D polygon:<br>
we use the standard QuickDraw polygon routines. Here's an example that draws a filled<br>
3-D triangle:
</p>
<p>
<code>polyHdl= OpenPoly ();</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;MoveTo3D (Long2Fix(0),Long2Fix(0),Long2Fix(0));/* 1st point */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;LineTo3D (Long2Fix(2),Long2Fix(5),Long2Fix(0));/* 2nd point */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;LineTo3D (Long2Fix(5),Long2Fix(1),Long2Fix(0));/* 3rd point */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;LineTo3D (Long2Fix(0),Long2Fix(0),Long2Fix(0));</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* 1st point again */</code><br>
<code>ClosePoly ();</code><br>
<code>PolyColor (&amp;rGBColor);</code><br>
<code>FillPoly (polyHdl, lgPolyShade);</code><br>
<code>KillPoly (polyHdl);</code>
</p>
<p>
PolyColor is a new routine for specifying the color of the polygon; lgPolyShade<br>
specifies the polygon's fill pattern. These two items are explained in the next section.
</p>
<p>
<b>DEALING WITH BLACK-AND-WHITE AND COLOR QUICKDRAW</b><br>
In general, if you want to take advantage of a grayscale or color display when available,<br>
you have to write parallel code. You also need to worry about different versions of<br>
QuickDraw so that you don't make the mistake of making Color QuickDraw calls on<br>
machines with black-and-white QuickDraw.&nbsp;&nbsp;&nbsp;(See the Graphical Truffles column in<br>
this issue for a discussion of the different possible QuickDraw versions.) In our<br>
simple graphics system, we want to be able to draw in color when we can and draw in<br>
simulated grays using dither patterns when we have a 1-bit display. Parallel code is<br>
eliminated by hiding all the complexity of different QuickDraw versions inside the<br>
routine PolyColor. 
</p>
<p>
<code>static ConstPatternParam&nbsp;&nbsp;&nbsp;&nbsp;lgPolyShade;</code><br>
<code>pascal void PolyColor (const RGBColor *rGBColor)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (gDrawInColor) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lgPolyShade = qd.black;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RGBForeColor (rGBColor);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Convert rGBColor to a dither pattern. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned long index;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index = RGBToGrayscale (rGBColor,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(**lgDitherPatterns).patListSize);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lgPolyShade = (**lgDitherPatterns).patList [index];</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ForeColor (blackColor);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code>}</code>
</p>
<p>
PolyColor takes an RGBColor as an argument. If we're drawing in color (the global<br>
variable gDrawInColor is true), PolyColor simply calls RGBForeColor, and<br>
lgPolyShade is set to a black pattern. When FillPoly(polyHdl, lgPolyShade) is<br>
eventually called, the polygon will get drawn in that color. If we're drawing in black<br>
and white, PolyColor makes the foreground color black and converts the RGB value to<br>
one of 65 dither patterns (including white), which is assigned to lgPolyShade (see<br>
"Converting RGB Color to a Grayscale Value"). When FillPoly(polyHdl, lgPolyShade) is<br>
called, the polygon will be filled with that dither pattern. Note that lgDitherPatterns is<br>
just a (locked) handle to a PAT# resource. We're limited to 65 possible dither<br>
patterns because the Pattern data structure is 8 x 8. 
</p>
<p>
<b>DEALING WITH ROTATION</b><br>
In Graf3D, the Port3D data structure contains a 4 x 4 xForm matrix that defines how<br>
the object is to be transformed before it's displayed. Recall that in our DoRotation<br>
routine we compute the object's rotation matrix directly. Thus, all we need to do is<br>
copy this matrix to xForm before we display the object. However, we need to do some<br>
number conversions since the rotation matrix is in floating point and the xForm<br>
matrix is in fixed point. The routine Matrix2XfMatrix does the necessary conversion:
</p>
<p>
<code>pascal void Matrix2XfMatrix (Matrix4D fromMatrix, XfMatrix toMatrix)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Integer i, j;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;for (i=3; i&gt;=0; i--) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (j=3; j&gt;=0; j--) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toMatrix[i][j]= X2Fix (fromMatrix[i][j]);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code>}</code>
</p>
<p>
<b>DOUBLE BUFFERING</b><br>
The sample code contains a module for off-screen drawing that uses GWorlds to<br>
eliminate drawing flicker. The use of GWorlds means that graphics acceleration comes<br>
for free if it's available in hardware. This module provides a very simple way of<br>
dealing with GWorlds. It contains only five routines:
</p>
<p>
<code>pascal OSErr&nbsp;&nbsp;&nbsp;&nbsp;InitializeOffscreen (Boolean *gWorldAvailable);</code><br>
<code>pascal void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FreeOffscreen (GWorldPtr offscreenGWorld);</code><br>
<code>pascal QDErr&nbsp;&nbsp;&nbsp;&nbsp;CheckOffscreenForWindow (GWorldPtr *offscreenGWorld,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short pixelDepth, WindowPtr window);</code><br>
<code>pascal void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BeginDrawingOffscreen (GWorldPtr offscreenGWorld,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WindowPtr window);</code><br>
<code>pascal void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EndDrawingOffscreen (GWorldPtr offscreenGWorld,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WindowPtr window);</code>
</p>
<p>
The routine InitializeOffscreen determines whether GWorlds are available on a<br>
particular machine and internally remembers whether System 6 or 7 is running. The<br>
latter is needed because there aresubtle differences between the GWorld calls in<br>
System 6 and those in System 7 (see Offscreen.c and<i>Inside Macintosh</i>Volume VI, page<br>
21-19). 
</p>
<p>
The routine CheckOffscreenForWindow checks to see whether a GWorld has the proper<br>
bit depth and memory boundary aligned for efficient transfer using CopyBits. If a<br>
GWorld hasn't been allocated, a new one is created. If an existing GWorld has the wrong<br>
bit depth or isn't memory aligned, it's reallocated. This routine hides the subtle<br>
differences between the Toolbox NewGWorld and UpdateGWorld calls. You should call<br>
this routine when a window has just been created<i>and</i>whenever you think the GWorld is<br>
out of sync with the screen. 
</p>
<p>
The routine BeginDrawingOffscreen redirects drawing to the GWorld. The routine<br>
EndDrawingOffscreen ends the redirection and copies the off-screen buffer onto the<br>
window. The routine FreeOffscreen frees the GWorld when it's no longer needed. 
</p>
<p>
The basic calling sequence for this module is as follows:
</p>
<p>
<code>InitOffscreen (...);</code><br>
<code>window = GetNewWindow (...);</code><br>
<code>gWorld = nil;</code><br>
<code>CheckOffscreenForWindow (&amp;gWorld, window, ...);</code><br>
<code>. . .</code><br>
<code>while (still not done with drawing) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;CheckOffscreenForWindow (&amp;gWorld, window, ...);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;BeginDrawingOffscreen (&amp;gWorld, window);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;/* Draw something */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;EndDrawingOffscreen (&amp;gWorld, window);</code><br>
<code>}</code><br>
<code>FreeOffscreen (&amp;gWorld);</code>
</p>
<p>
In the actual code, CheckOffscreenForWindow is called only when there's an update<br>
event that could have been generated when the user changed the monitor bit depth. It's<br>
not necessary to call CheckOffscreenForWindow during the loop when the mouse is<br>
interacting with the object. 
</p>
<h2>CODE OPTIMIZATION</h2>
<p>
I didn't optimize the sample code because it would have detracted from presenting a<br>
clear implementation of the Virtual Sphere algorithm and the 3-D graphics system.<br>
For example, we deal only with 3-D rotation in this program, so we don't really need<br>
to have a general 4 x 4 matrix when a 3 x 3 matrix would do. Even if we were willing<br>
to waste storage, some of the math routines (such as CopyMatrix, MultiplyMatrix,<br>
SetRotationMatrix, and Matrix2XfMatrix) could have been optimized to use only the<br>
upper left 3 x 3 cells of the 4 x 4 matrix. It might also be worthwhile to do a full<br>
fixed- point implementation of the Virtual Sphere algorithm.
</p>
<h2>MPW C VERSUS THINK C</h2>
<p>
One of my objectives in creating this sample code was to make sure that it could be<br>
used in both the MPW and THINK C environments. I also wanted to allow the option of<br>
compiling the application using SANE or a hardware floating-point unit (FPU). This<br>
turned out to be a learning experience in itself. Here are a few things I picked up from<br>
the process:
</p>
<ul>
<li>The main difference between the two environments is the way in which<br>
floating- point numbers are handled. MPW provides an easy way of switching<br>
between SANE and a hardware FPU simply by switching compile flags and by<br>
including the proper versions of the math libraries. The header files need not<br>
be changed.&nbsp;&nbsp;&nbsp;With THINK C, the SANE and ANSI math libraries aren't<br>
integrated. You must include either SANE.h or Math.h, but not both.</li>
<li>In THINK C, some of the transcendental functions (for example, asin and<br>
atan2) are not available when SANE is used.</li>
<li> In THINK C, there are five floating-point formats. Some of the fixed-<br>
point/floating-point conversion routines (such as X2Fix and Fix2X) are<br>
incompatible when native floating-point format is used.</li>
</ul>
<p>
I created the files MyMath.h and MyMath.c to hide all the ugliness of floating-point<br>
math from the rest of the code. 
</p>
<p>
Compiling the code in both environments requires more careful coding. A version that<br>
compiled fine in one environment would get errors and warnings in the other. In<br>
general, MPW C is a bit pickier about type checking. 
</p>
<p>
On my wish list is a common pragma structure for changing compile options in the<br>
source code. I wanted to display an error message if the user launched a version of the<br>
sample application compiled for a hardware FPU on a non-floating-point machine.<br>
Here's an example of the gymnastics I had to go through to make sure the routine<br>
MessageAlert could be executed on all processors:
</p>
<p>
<code>#ifdef&nbsp;&nbsp;applec</code><br>
<code>#pragma push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* MPW: save compiler flags*/</code><br>
<code>#pragma processor 68000 /* Generate 68000 instructions only */</code><br>
<code>#endif</code><br>
<code>pascal void MessageAlert (Str255 message)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;#ifdef THINK_C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* THINK C: Generate 68020 instructions...*/</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;#pragma options(!mc68020)&nbsp;&nbsp;&nbsp;/* NOT! Silly way of saying 68000 */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;#endif&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* instructions only. Note this pragma */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* is defined only until end of routine. */</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;SetCursor (&amp;qd.arrow);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;ParamText (message, "", "", "");</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;SysBeep (10);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;(void) Alert (rMessageAlert, nil);</code><br>
<code>}</code><br>
<code>#ifdef applec</code><br>
<code>#pragma pop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* MPW: restore compiler flags&nbsp;&nbsp;*/</code><br>
<code>#endif</code>
</p>
<p>
Why should the processor pragma matter for such a simple routine? The reason is that<br>
MPW C with the -68020 flag will generate an RTD (not available on a 68000<br>
machine) instead of an RTS instruction for returning to the calling routine. This would<br>
cause the resulting sample application to crash on a 68000 machine instead of putting<br>
up an alert message. THINK C doesn't seem to generate the RTD instruction even when<br>
asked to generate 68020 code. However, I put the pragma in for THINK C just in case. 
</p>
<h2>GOING ON FROM HERE</h2>
<p>
I hope this article has whetted your appetite for 3-D graphics and 3-D user<br>
interfaces. Several companies have released commercial programs that improve on the<br>
Virtual Sphere concept. Silicon Graphics' Inventor Toolkit contains a version with<br>
three orthogonal "ribbons" around the sphere to provide constrained-axis rotation.<br>
Virtus Walkthrough contains a version with momentum -- the object continues to spin<br>
in the direction of the pointer movement when the mouse button is released.
</p>
<p>
The Virtual Sphere interface introduces a new interaction technique that was backed<br>
with user testing. If you're doing new interface development, I encourage you to use the<br>
same process: design followed by testing with iterations. Remember to keep the big<br>
picture in mind. 3-D rotation is just one small task that the user has to do in a 3-D<br>
application. All the interaction techniques for manipulating objects must work<br>
together and must be appropriate for the 3-D task the user wants to perform. 
</p>
<p>
<b>CONVERTING RGB COLOR TO A GRAYSCALE VALUE</b><br>
The conversion from an RGB value to a grayscale value can be done in a number of<br>
ways. The most obvious way is to have the R, G, and B components each contribute<br>
equally to the gray value. However, this implies that, for example, pure red, green,<br>
and blue colors will all map to one value, which might not be desirable. In the sample<br>
code, the conversion routine RGBToGrayscale employs a set of often-used weighting<br>
factors for the RGB components. The routine returns an integer value from 0 to<br>
maxGrayValue-1:
</p>
<p>
<code>unsigned long RGBToGrayscale (const RGBColor *rGBColor, Integer</code><br>
<code>maxGrayValue)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;#define&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kRWeight 3</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;#define&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kGWeight 6</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;#define&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kBWeight 1</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;#define&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kTotalWeight(kRWeight + kGWeight + kBWeight)</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;unsigned long&nbsp;&nbsp;&nbsp;intensity;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;unsigned long&nbsp;&nbsp;&nbsp;index;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;intensity = kRWeight*rGBColor-&gt;red + kGWeight*rGBColor-&gt;green +</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kBWeight*rGBColor-&gt;blue;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;index = intensity * maxGrayValue / kTotalWeight / (USHRT_MAX+1);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Note integer math. Order matters. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;return (index);</code><br>
<code>}</code>
</p>
<p>
<b>RECOMMENDED READING</b>
</p>
<ul>
<li>"A Study in Interactive 3-D Rotation Using 2-D Control Devices" by<br>
Michael Chen, S. Joy Mountford, and Abigail Sellen (<i>ACM Siggraph '88</i><br>
<i>Proceedings,</i> Volume 22, Number 4, August 1988, pages 121-129). An<br>
electronic version of this paper is available on this issue's CD.</li>
<li>"A Technique for Specifying Rotations in Three Dimensions Using a 2-D<br>
Input Device" by Michael Chen and K. C. Smith (<i>Proceedings IEEE Montech '87</i><br>
<i>-- Compint '87</i>, November 1987, pages 118-120).</li>
<li>"An Object-Oriented 3D Graphics Toolkit" by Paul Strauss and Rikk Carey<br>
(<i>ACM Siggraph '92 Proceedings,</i> Volume 26, Number 2, July 1992, pages<br>
341-349).</li>
<li>"Tablet Based Valuators That Provide One, Two or Three Degrees of<br>
Freedom" by K. B. Evans, Peter P. Tanner, and M. Wein (<i>ACM Siggraph '81</i><br>
<i>Proceedings,</i> Volume 15, Number 3, August 1988, pages 91-97).</li>
<li>"Iterative Design of an Interface for Easy 3-D Direct Manipulation" by<br>
Stephanie Houde (<i> ACM CHI '92 Proceedings</i>, May 1992, pages 135-142).</li>
<li>"Three-Dimensional Widgets" by B. Conner, S. Snibbe, K. Herndon, D.<br>
Robbins, R. Zeleznik, and A. Van Dam (<i>Proceedings of the 1992 Symposium on</i><br>
<i>Interactive 3D Graphics,</i> pages 183-188).</li>
<li>"Understanding Graf3D" by Scott Berfield (<i>The Essential MacTutor</i><br>
Volume 3, pages 230-238).</li>
<li><i>Computer Graphics</i>: <i>Principles and Practice</i>, 2nd ed., by J. D. Foley, A.<br>
Van Dam, S. K. Feiner, and J. F. Hughes (Addison-Wesley, 1990).</li>
</ul>
<p>
<b>MICHAEL CHEN </b>(AppleLink CHEN.M) works in Apple's Human Interface Group<br>
within the Advanced Technology Group. The "high point" of his five years at Apple was<br>
digitizing a QuickTime movie on a tower of the Golden Gate Bridge for John Sculley's<br>
keynote presentation at Macworld '92 in San Francisco. Michael and his two partners,<br>
Dan O'Sullivan and Ian Small, were insured for a total of $12 million for this one-day<br>
adventure. Of course, the insurance wasn't for protection against the loss of these<br>
valuable Apple researchers; it was to cover the company if one of them were to drop a<br>
Macintosh onto a car below. It turned out to be a thrilling but safe trip. When not<br>
staring at the computer screen wondering why you should poke everything with this<br>
little arrow, Michael enjoys playing flamenco guitar and fooling around with his MIDI<br>
toys. "Someday, someone is gonna figure out how you can read music without wondering<br>
what those tiny little notes are on the page."*
</p>
<p>
<b>THANKS TO OUR TECHNICAL REVIEWERS </b>Michael Chmilar, Forrest Tanaka, Dan<br>
Venolia *
</p>
</body>
</html>
