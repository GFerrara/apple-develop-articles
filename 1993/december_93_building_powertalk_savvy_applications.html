<html>
<head>
<!-- Article ID: 48 - Extracted from develop-1993 -->
<!-- on 2024-02-03 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by the copyright of its respective owners -->
<title>December 93 - BUILDING POWERTALK-SAVVY APPLICATIONS</title>
<link href="../common/styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h2>BUILDING POWERTALK-SAVVY APPLICATIONS</h2>
<h1>STEVE FALKENBURG</h1>
<p>
<img src="img/244.gif" width="180 px"></img>
</p>
<p>
<i>PowerTalk is a new software product based on the Apple Open Collaboration</i><br>
<i>Environment (AOCE). By adding support for PowerTalk to your application, you can</i><br>
<i>begin to take advantage of the wide range of services provided by the emerging world of</i><br>
<i>collaborative computing. This article touches on two areas of this environment --</i><br>
<i>electronic mail and digital signatures -- and shows how they can be incorporated into</i><br>
<i>a typical application program.</i>
</p>
<p class="spacer">&nbsp;</p>
<p>
AOCE consists of a set of human interface elements and programming interfaces that<br>
make collaboration on an electronic document simpler and more secure; PowerTalk is<br>
its client software component (and PowerShare its server software). Two elements of<br>
PowerTalk are the Standard Mail Package's mailer, which provides application-level<br>
electronic mail support, and the DigiSign digital signature mechanism, which<br>
safeguards documents from electronic tampering. Support for these features of<br>
PowerTalk should not be limited to networking and communications applications. The<br>
real power of PowerTalk lies in its ability to be built into a wide range of productivity<br>
applications, from spreadsheets to presentation packages. Ultimately, the Send and<br>
Sign menu items should be as pervasive as Print is today.
</p>
<p>
Using a small drawing application called CollaboDraw as our example, we'll go step by<br>
step through the process of adding support for the PowerTalk Standard Mail Package<br>
and Digital Signature Package. 
</p>
<h2>WHAT EVERY APPLICATION SHOULD KNOW ABOUT<br>
POWERTALK</h2>
<p>
Before walking through the code, we'll give a brief overview of the PowerTalk features<br>
we'll be adding to CollaboDraw. Very basic descriptions of the Standard Mail Package<br>
and Digital Signature Package follow. Additional information on PowerTalk can be found<br>
in the full PowerTalk API documentation. 
</p>
<p>
<b>PUSHING THE STANDARD MAIL ENVELOPE</b><br>
One of the unique features of PowerTalk is that it allows many individual applications<br>
to add support for mailing documents directly, without going through an intermediate<br>
e-mail application such as QuickMail or AppleLink. The Standard Mail Package<br>
provides a consistent interface for mailing documents from one user to another within<br>
applications, and includes all of the human interface elements needed to address, send,<br>
and receive messages. The major component of the Standard Mail Package is the<i>mailer</i> .<br>
The mailer is a window pane that's at the top of all documents that are mailed.&nbsp;&nbsp;&nbsp;The<br>
mailer window pane can be contracted to display only a single line or expanded to allow<br>
manipulation of the mailer's contents. Figure 1 shows a CollaboDraw window<br>
containing an expanded mailer window pane.
</p>
<p>
<img src="img/245.gif" width="600 px"></img>
</p>
<p>
<b>&nbsp;Figure 1</b> CollaboDraw Window With a Mailer
</p>
<p>
The mailer can be thought of as a kind of extended mailing label. It contains not only the<br>
names of the sender and receivers of the letter, but also a subject for the letter and an<br>
area where files and folders can be enclosed. 
</p>
<p>
Making an application mail-aware involves adding several standard menu items. In<br>
CollaboDraw, there's a separate Mail menu, but if this isn't a viable option, it's<br>
acceptable to add these menu items to the File menu. The standard Mail menu is shown<br>
in Figure 2. The items Reply to All, Open Next Letter, and Tag Letter are optional and<br>
not required for minimal mailer support. 
</p>
<p>
<img src="img/246.gif" width="311 px"></img>
</p>
<p>
<b>Figure 2</b> The Mail Menu
</p>
<p>
When users want to send a document from CollaboDraw, their favorite<br>
PowerTalk-savvy drawing program, they simply add a mailer to their drawing<br>
document, transforming the document into a letter. They fill out the mailer and choose<br>
Send from the Mail menu. The letter is then sent automatically to the recipient's<br>
mailbox in the Finder. Recipients of the document would, in turn, double-click the<br>
letter they received in their PowerTalk Finder mailbox, which opens the letter in<br>
their copy of CollaboDraw and displays it with the attached mailer. Once they were<br>
done reviewing the letter, they could keep the mailer attached if they wanted to reply<br>
to the letter, forward the letter, or keep the additional information the mailer<br>
provides. Or they could select Remove Mailer from the Mail menu, which removes the<br>
mailer from the window, transforming the letter back into adocument. (The Remove<br>
Mailer menu item replaces Add Mailer when there's a mailer in the window.)
</p>
<p>
Much of the power of PowerTalk Standard Mail stems from the fact that all<br>
PowerTalk-aware applications support an additional file type: the letter. In the<br>
Finder, letters can appear in disk windows, in the PowerTalk Finder mailbox window,<br>
and even on the desktop or in the trash. Users can treat these letters like standard<br>
documents, dragging them between folders to copy them, dragging them to the trash to<br>
erase them, and even double-clicking them or dragging them to an application to open<br>
them. When integrating mailer support into an existing application, it's best to think<br>
of letters in much the same way -- simply as an additional document type. Using this<br>
strategy, we'll see that adding a mailer requires little in the way of application<br>
redesign. 
</p>
<p>
<b>UNLOCKING THE POWER OF DIGITAL SIGNATURES</b><br>
Another very powerful PowerTalk feature that can be added to document-based<br>
applications with a small amount of effort is digital signatures. PowerTalk's DigiSign<br>
digital signature technology allows you to apply a personal "signer" to an object or a<br>
file before distribution. Other users can then verify the digital signature, which<br>
guarantees the identity of the person who signed the object as well as ensuring that the<br>
object has not been altered in any way. If the object is modified after being signed, the<br>
signature verification will fail, which will indicate that either the object has changed<br>
or the signature has been tampered with. 
</p>
<p>
Digital signature support also requires adding several menu items. These items are<br>
normally added to an application's Edit menu, but because CollaboDraw has plenty of<br>
space in the menu bar, they were separated into a Signatures menu (see Figure 3). 
</p>
<p>
<img src="img/247.gif" width="288 px"></img>
</p>
<p>
<b>&nbsp;Figure 3</b> The Signatures Menu
</p>
<p>
Within CollaboDraw, digital signature support is provided for the individual shapes<br>
and groups of shapes. To sign a shape, the user simply selects the shape (or group) and<br>
then chooses Sign Selected Shapes from the Signatures menu. A dialog box appears,<br>
prompting for the user's signer identification code. Once the user enters the password<br>
protecting the signer, the selected shape is signed; a dashed rectangle appears around<br>
the shape, with a small icon button (labeled with a pen) in the lower right corner,<br>
indicating that the shape has been signed. (If you were adding digital signature support<br>
to a text-based application, the dashed rectangle would surround the signed text.)<br>
Figure 4 shows a signed shape. 
</p>
<p>
<img src="img/248.gif" width="164 px"></img>
</p>
<p>
<b>&nbsp;Figure 4</b> A Signed Shape
</p>
<p>
To verify the integrity of the signature, a user could either click the pen button in the<br>
corner of the shape or select the shape and choose Verify Selected Shapes from the<br>
Signatures menu. If the signature verification is successful, the dialog box in Figure 5<br>
is displayed, showing the identity of the signer. 
</p>
<p>
<img src="img/249.gif" width="530 px"></img>
</p>
<p>
<b>&nbsp;Figure 5</b> Signature Verification Dialog Box
</p>
<p class="spacer">&nbsp;</p>
<p>
The DigiSign Digital Signature Manager provides routines to display the dialog boxes<br>
described above, as well as standard icons for use in constructing the pen icon button.<br>
This makes adding digital signature support a relatively painless operation. 
</p>
<h2>LETTER FORMATS</h2>
<p>
As was mentioned earlier, you can think of letters as another type of document that<br>
your application needs to support. Before describing how to add support for this new<br>
document type, we'll spend some time discussing the format of PowerTalk letters. 
</p>
<p>
Letters are a special kind of PowerTalk<i>message.&nbsp;&nbsp;</i> A letter is different from a message<br>
in that it is sent from one user to another and is meant to be read by a human, whereas<br>
a standard message is sent from one program to another and is meant to be read by a<br>
program. Both share the same low-level format, consisting of a<i>message header</i> and a<br>
series of<i>message blocks</i> . 
</p>
<p>
The message header describes the message as a whole, including who the message is<br>
from, who the message is to, the subject of the message, the date it was sent, and<br>
whether the message is a letter.&nbsp;&nbsp;&nbsp;The header stores most of the information contained<br>
in the mailer window pane shown in Figure 1, with the exception of enclosures. 
</p>
<p>
Each message also contains message blocks, where the actual message data is stored.<br>
Each block has a type and a creator, as well as message data and a length field.<br>
PowerTalk-defined message blocks store message enclosures, digital signatures, or<br>
message content. In addition, application-specific message blocks can be stored here. 
</p>
<p>
PowerTalk letters have a well-defined content format, which is made up of any<br>
combination of three formats: AppleMail format, Snapshot format, and Native<br>
Application format. Figure 6 shows a letter with all three of these content formats. 
</p>
<p>
<img src="img/250.gif" width="464 px"></img>
</p>
<p>
<b>Figure 6</b> PowerTalk Letter With Content Blocks
</p>
<p>
&nbsp;AppleMail format is one of the most commonly supported content types. It's made up of<br>
runs of text, styled text, PICTs, sounds, and QuickTime movies. In Figure 6, the<br>
AppleMail block contains a small amount of styled text, followed by a picture, followed<br>
by a sound in AIFF format. Using Standard Mail routines, applications can easily get<br>
this content out of a letter and display it to the user. AppleMail format is the native<br>
format for the AppleMail letter application, which ships with PowerTalk. This means<br>
that if you send a letter from your mail-aware application and the recipient doesn't<br>
have a copy of that application, the recipient will still be able to read the letter's<br>
content if you included it in AppleMail format. In addition, PowerTalk Mail Service<br>
Access Modules (MSAMs) will most likely use this format to convert messages to other<br>
external mail systems. 
</p>
<p>
&nbsp;Snapshot format consists simply of PICT snapshots of each page of your letter. It's<br>
similar to AppleMail format in that other letter applications or MSAMs are likely to<br>
be able to read mail sent in this format. Snapshot format is provided for the<br>
convenience of fax gateways, which can easily use it to image letters to fax machines,<br>
and also to offer a WYSIWYG format that preserves the exact look of the original<br>
document.
</p>
<p>
&nbsp;For applications that use QuickDraw GX, the graphics content for each page needs to be<br>
translated into standard QuickDraw before it can be added to the Snapshot content<br>
block. QuickDraw GX provides a set of routines for this purpose, contained in<br>
PicturesAndPICTLibrary (and documented within that library's source code on the<br>
QuickDraw GX CD). These routines allow you to pass in a QuickDraw GX picture and<br>
receive a QuickDraw PICT as a result. On a QuickDraw system, only the QuickDraw<br>
data in this PICT will be drawn. When you pass the PICT into a QuickDraw GX system<br>
and convert it with the GXConvertPICTToShape routine, the routine will use the<br>
QuickDraw GX data rather than the QuickDraw data.&nbsp;&nbsp;Finally, Native Application format<br>
is basically a copy of your original document's disk file put into the letter's content<br>
area. This format, meant mostly for the private use of your application, is useful for<br>
sending documents between two users who both have the same PowerTalk-aware<br>
application. For example, if two users had CollaboDraw, our mail-aware application,<br>
and one user sent the other a CollaboDraw letter that included the document in Native<br>
Application format, the receiving application could simply extract an FSSpec for the<br>
document file to interpret the data in that document. This means you won't lose<br>
information by translating your document into another format, but can instead<br>
preserve your private document format.
</p>
<h2>BUILDING THE FRAMEWORK</h2>
<p>
It's time to look at our sample application. For simplicity, PowerTalk support will be<br>
added to a limited MacDraw&#174;-like application, CollaboDraw, included on this issue's<br>
CD. In this section I briefly describe the basic application framework. Later sections<br>
will show how I added support for the mailer and digital signatures. 
</p>
<p>
The CollaboDraw application is based on a simplified object-oriented message-passing<br>
framework.&nbsp;&nbsp;&nbsp;It's simplified in that only windows are treated as objects, and the code is<br>
actually written in C, not C++. The basis for this object scheme is a block containing<br>
the window content, along with functions, called<i>methods</i> , for processing events that<br>
occur in that window. The block is a handle that's allocated dynamically for each<br>
window and is stored in the window's refCon field. In this way, I can remove all of the<br>
multiwindow complexity from my event loop and simply send a message to the window<br>
receiving the event, letting it take its own action.
</p>
<p>
I won't go into the details of what the CollaboDraw framework does, as I want to<br>
concentrate on the PowerTalk aspect of the sample. It's important to recognize,<br>
however, that CollaboDraw is a fairly typical drawing application. As you'll see, it's<br>
certainly not necessary to redesign an application to add PowerTalk support. 
</p>
<h2>ADDING STANDARD MAIL PACKAGE SUPPORT</h2>
<p>
A large part of the PowerTalk support code in CollaboDraw is for the mailer window<br>
pane and for enabling the mailer to send and receive letters. I've outlined the necessary<br>
code below, with samples interspersed showing proper use of the Standard Mail<br>
Package calls. 
</p>
<p>
<b>INITIALIZING STANDARD MAIL</b><br>
Before using PowerTalk in CollaboDraw, we first need to make sure that PowerTalk<br>
services are available. This is done once when CollaboDraw launches. The following<br>
routine checks whether PowerTalk is installed and available:
</p>
<p>
<code>Boolean HasStandardMail(void)</code><br>
<code>{&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;OSErr&nbsp;&nbsp;&nbsp;err;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;&nbsp;&nbsp;&nbsp;response;</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;err = Gestalt(gestaltSMPMailerVersion, &amp;response);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if ((err!=noErr) || (response==0))</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;return true;</code><br>
<code>}</code>
</p>
<p class="spacer">&nbsp;</p>
<p>
The above routine determines whether PowerTalk and the mailer calls are available by<br>
checking the gestaltSMPMailerVersion attribute. Since PowerTalk may not be installed<br>
or may be disabled, quitting when PowerTalk is unavailable is incorrect behavior.<br>
Instead, like CollaboDraw, the application should just disable or hide its PowerTalk<br>
services, letting the user work with the rest of the application normally. 
</p>
<p>
Once it's known that PowerTalk is available and active, the next step to using Standard<br>
Mail services in CollaboDraw is to initialize the Standard Mail Package.
</p>
<p>
<code>OSErr InitStandardMail(void)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;OSErr err;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;SetCursor(&amp;gWatchCursor);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;err = SMPInitMailer(kSMPVersion);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;SetCursor(&amp;qd.arrow);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;return err;</code><br>
<code>}</code>
</p>
<p class="spacer">&nbsp;</p>
<p>
SMPInitMailer takes the current version number of the Standard Mail Package as<br>
input. Later versions of PowerTalk will continue to support older Standard Mail calls<br>
by identifying the version the application was compiled with and mimicking those<br>
interfaces. 
</p>
<p>
<b>OPENING AND CREATING A LETTER</b><br>
Now that CollaboDraw has checked for and initialized the Standard Mail Package, it can<br>
continue normally, entering its event loop. The next support code we'll cover deals<br>
with opening letters and creating new letters from existing drawings. 
</p>
<p>
Typically, a user opens a letter in CollaboDraw, or any other mail-aware application,<br>
by double- clicking a letter in the Finder. This, in turn, generates an Open Document<br>
core Apple event, which we process in the normal way, with one change: instead of<br>
getting the FSSpec out of the event, mail- aware applications need to check the type of<br>
each item in the event, handling both FSSpecs and LetterSpecs. The LetterSpec is<br>
necessary since PowerTalk letters, in addition to residing in the file system, can be<br>
opened from the PowerTalk mailbox, which is not an HFS volume. A LetterSpec<br>
uniquely identifies a letter inside the mailbox and can be passed via an Apple event to<br>
the mail-aware application to open a letter. The following section of the Apple event<br>
handler shows how to process both LetterSpecs and FSSpecs:
</p>
<p>
<code>AECountItems(&amp;docList, &amp;itemsInList);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;for (index=1; index&lt;=itemsInList; index++) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = AESizeOfNthItem(&amp;docList, index, &amp;returnedType, &amp;size);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (err!=noErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((returnedType == typeLetterSpec) ||</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(returnedType==typeFSS)) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;diskForm = false;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = AEGetNthPtr(&amp;docList, index, typeLetterSpec,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;keywd, &amp;returnedType, (Ptr)&amp;myLetterSpec,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(LetterSpec), &amp;actualSize);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if (returnedType == typeAlias) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;diskForm = true;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = AEGetNthPtr(&amp;docList, index, typeFSS, &amp;keywd,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;returnedType, (Ptr)&amp;myFSS, sizeof(myFSS),</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;actualSize);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (err!=noErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if ((returnedType==typeLetterSpec) || (returnedType==typeAlias) ||</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(returnedType==typeFSS)) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = HandleOpenDoc(diskForm, &amp;myFSS, &amp;myLetterSpec);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (err!=noErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code>}</code>
</p>
<p class="spacer">&nbsp;</p>
<p>
To handle opening either LetterSpecs or FSSpecs as letters, PowerTalk defines a<br>
variant structure called a LetterDescriptor that supports both formats. Once we have a<br>
LetterDescriptor, we can use this information to open the letter. The mailer-window<br>
method CollaboDraw uses to open letters is shown below. 
</p>
<p>
<code>void *DMailerLoadWindow(WindowPtr window, WInfoPtr infoPtr, void</code><br>
<code>*data)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;OSErr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;LetterDescriptor&nbsp;&nbsp;&nbsp;&nbsp;*letterDesc;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Point&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;upLeft = {0, 0};</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;FSSpec&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enclSpec;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Handle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;letterDescHndl;</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;. . .</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;letterDesc = (LetterDescriptor *)data;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;. . .</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;err = SMPOpenLetter(letterDesc, window, upLeft, true,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gPreferences.expandOnOpen, nil, 0L);// Open the letter.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (err!=noErr) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DoError(err);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;err = SMPGetMainEnclosureFSSpec(window, &amp;enclSpec);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (err!=noErr) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DoError(err);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;return DrawLoadWindow(window, infoPtr, &amp;enclSpec);</code><br>
<code>}</code>
</p>
<p>
After some housekeeping, which has been omitted for clarity, the load method given<br>
above calls SMPOpenLetter to open the letter in an existing window. The window was<br>
created earlier and was passed into the load method as input. SMPOpenLetter registers<br>
this window with the Standard Mail Package and associates it with the letter identified<br>
in the LetterDescriptor.&nbsp;&nbsp;&nbsp;SMPGetMainEnclosureFSSpec is then called to extract the<br>
native CollaboDraw document out of the letter, as described earlier in the section<br>
"Letter Formats." Finally, the standard CollaboDraw load method is called, which reads<br>
the shapes from the document and draws them in the window.&nbsp;&nbsp;&nbsp;CollaboDraw supports<br>
opening only letters that contain its native application format, meaning that if the<br>
main enclosure block is not present, CollaboDraw doesn't open the letter. For an<br>
application to support opening letters without native application content, translation<br>
into one of the other content types would be necessary.
</p>
<p>
In addition to opening existing letters, CollaboDraw allows users to add mailers to<br>
existing documents, transforming these documents into letters. When a user chooses<br>
the menu item Add Mailer, the following routine is called:
</p>
<p>
<code>void MakeMailerFromDrawing(WindowPtr window)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;WInfoPtr&nbsp;&nbsp;&nbsp;&nbsp;infoPtr;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hState;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Point&nbsp;&nbsp;&nbsp;topLeft = {0, 0};</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;OSErr&nbsp;&nbsp;&nbsp;err;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;short&nbsp;&nbsp;&nbsp;mWidth, contHeight, expHeight;</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;SetWindowKind(window, kDrawMailerWindow);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;infoPtr = BeginWindowAccess(window, &amp;hState);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;. . .</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;// Add the mailer.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;err = SMPNewMailer(window, topLeft, true,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gPreferences.expandOnCreate, kDefaultIdentity, nil, 0L);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (err!=noErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DoError(err);</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;// Set the window indent fields.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;err = SMPGetDimensions(&amp;mWidth, &amp;contHeight, &amp;expHeight);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (err!=noErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DoError(err);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (infoPtr-&gt;otherFlags[kMailerExpanded])</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;infoPtr-&gt;topIndent = expHeight;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;else</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;infoPtr-&gt;topIndent = contHeight;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;MoveScrollBars(window);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;EndWindowAccess(window, hState);</code><br>
<code>}</code>
</p>
<p>
When a user chooses to turn a document into a letter, the MakeMailerFromDrawing<br>
routine first changes the class of the window. This in turn causes the mailer-window<br>
methods, instead of the draw-window methods, to be called in response to events. Next,<br>
this routine adds a mailer to the window with an SMPNewMailer call. Like<br>
SMPOpenLetter, this routine associates a particular window with a Standard Mail<br>
letter. The kDefaultIdentity parameter to SMPNewMailer is defined as 0 and indicates<br>
that the Standard Mail Package should track identities for the application. Finally, the<br>
content area of the window is lowered to account for the added height of the mailer. This<br>
height can be obtained with an SMPGetDimensions call, which returns both the<br>
expanded and contracted heights of the mailer.
</p>
<p>
<b>HANDLING EVENTS IN MAILER WINDOWS</b><br>
Since letters are a new document type, new methods are needed to handle events in<br>
letter windows.&nbsp;&nbsp;&nbsp;As we'll see, however, we can leverage off of our window class<br>
structure to minimize additional code. 
</p>
<p>
When a window contains a mailer, PowerTalk handles a subset of events for that<br>
window automatically. This includes mouse-down events, key-down events, update<br>
events for the mailer window pane, activate events, deactivate events, and even null<br>
events. The event-handling method for mailer windows is as follows:
</p>
<p>
<code>void *DMailerEventWindow(WindowPtr window, WInfoPtr infoPtr,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *data)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;SMPMailerResult&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;whatHappened;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;EventRecord&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*ev;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;OSErr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err;</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;ev = (EventRecord *)data;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;err = SMPMailerEvent(ev, &amp;whatHappened, nil, 0L);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (err!=noErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DoError(err);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;return (void *)(ProcessPowerTalkWhatHappened(window, infoPtr,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;whatHappened));</code><br>
<code>}</code>
</p>
<p class="spacer">&nbsp;</p>
<p>
So that PowerTalk will get a first look at the events, CollaboDraw calls<br>
SMPMailerEvent with each event received via WaitNextEvent when the frontmost<br>
window is a mailer window. This routine will return a value in the whatHappened field<br>
indicating what action Standard Mail took and whether you still need to process the<br>
event. Here's the postprocessing code for these events:
</p>
<p>
<code>Boolean ProcessPowerTalkWhatHappened(WindowPtr window, WInfoPtr</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;infoPtr, SMPMailerResult mailResult)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;OSErr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;SMPMailerState&nbsp;&nbsp;state;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*lastChanged;</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;// See if mailer has changed since we last changed the mailer</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;// menus.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;err = SMPGetMailerState(window, &amp;state);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (err != noErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DoError(err);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;lastChanged = (long *)&amp;infoPtr-&gt;otherData[kLastChangedData];</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (*lastChanged != state.changeCount) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*lastChanged = state.changeCount;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;infoPtr-&gt;changed = true;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FixMailerMenus(window, infoPtr);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if ((mailResult &amp; kSMPContractedMask) != 0)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HandleContract(window, infoPtr);</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if ((mailResult &amp; kSMPExpandedMask) != 0)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HandleExpand(window, infoPtr);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (((mailResult &amp; kSMPMailerBecomesTargetMask) != 0) ||</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((mailResult &amp; kSMPAppBecomesTargetMask) != 0))</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FixMailerMenus(window, infoPtr);</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;// Check the menus for *every* event that the mailer handles.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;// We may need to update the Undo item in the File menu.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if ((mailResult &amp; kSMPAppShouldIgnoreEventMask) != 0)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FixMailerMenus(window, infoPtr);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if ((mailResult &amp; kSMPAppMustHandleEventMask) != 0)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// App must handle this event.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;else return true;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Mailer handled this event completely.</code><br>
<code>}</code>
</p>
<p class="spacer">&nbsp;</p>
<p>
Most of the postprocessing involves recalculating the menu items, since the mailer<br>
may have affected which items should be active. In addition to this menu handling, if<br>
the kSMPContracted or kSMPExpanded bit is set as a result of the event, CollaboDraw<br>
calls its own private routine HandleExpand or HandleContract. In turn, this routine<br>
calls SMPExpandOrContract to expand the mailer to its full size or contract it to a<br>
single line. 
</p>
<p>
Besides generic event processing, we need to add some minor modifications to the<br>
mouse-click method for mailer windows. This is reasonably straightforward:
</p>
<p>
<code>void *DMailerClickWindow(WindowPtr window, WInfoPtr infoPtr,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *data)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;RgnHandle&nbsp;&nbsp;&nbsp;savedClip;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GrafPtr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;savePort;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*returnVal;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;OSErr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alreadyChanged;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;// Make sure we can change the letter.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;alreadyChanged = infoPtr-&gt;changed;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (!alreadyChanged &amp;&amp; (gCurrentShape!=kSelectShape)) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = SMPPrepareToChange(window);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (err==userCanceledErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;// Since we're drawing a shape, clear any mailer undo buffer.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;err = SMPClearUndo(window);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (err!=noErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DoError(err);</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;// Remove mailer from clipping region.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GetPort(&amp;savePort);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;SetPort(window);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;savedClip = NewRgn();</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GetClip(savedClip);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;ClipToDrawing(window, infoPtr);</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;// Call draw-window click method and maybe mark letter changed.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;returnVal = DrawClickWindow(window, infoPtr, data);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (!alreadyChanged &amp;&amp; infoPtr-&gt;changed) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = SMPContentChanged(window);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (err!=noErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DoError(err);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;// Restore clipping region.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;SetClip(savedClip);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;DisposeRgn(savedClip);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;SetPort(savePort);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;return returnVal;</code><br>
<code>}</code>
</p>
<p>
Before passing the click up to the draw-window method to draw or select shapes, we<br>
need to notify PowerTalk that the letter content will be changing. To do this, we first<br>
call SMPPrepareToChange.&nbsp;&nbsp;&nbsp;If the letter has been digitally signed as a whole, a dialog<br>
box warning the user will appear. If the user cancels the change in response to the<br>
dialog box (the user may not want to invalidate the signature), the routine exits. Next,<br>
the SMPClearUndo routine clears any undo operations from the mailer undo buffer,<br>
since only one undo can be pending for a single window. Then the draw area is removed<br>
from the window's clipping region, and the superclass click method is called. Upon<br>
return, SMPContentChanged is called if the letter has changed. Finally, the clipping<br>
region is restored and the method exits. 
</p>
<p>
As you may have noticed from the above discussion, the mailer keeps its own undo<br>
buffer. This is because Standard Mail supports the Clipboard operations of Cut, Copy,<br>
Paste, Clear, Select All, and Undo for the mailer portion of letters. The code necessary<br>
to support the Clipboard is shown in the mailer-window Cut method:
</p>
<p>
<code>void *DMailerCutWindow(WindowPtr window, WInfoPtr infoPtr,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *data)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;#pragma unused (data)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;OSErr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;SMPMailerResult whatHappened;</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;err = SMPMailerEditCommand(window, kSMPCutCommand,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;whatHappened);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (err!=noErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DoError(err);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;return (void *)(ProcessPowerTalkWhatHappened(window, infoPtr,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;whatHappened));</code><br>
<code>}</code>
</p>
<p>
As you can see, support for Clipboard operations involves just a single call to<br>
SMPMailerEditCommand followed by a call to the CollaboDraw routine<br>
ProcessPowerTalkWhatHappened. Similar methods are used for Copy, Paste, Clear,<br>
Select All, and Undo. 
</p>
<p>
<b>SENDING A LETTER</b><br>
Using the code discussed above, CollaboDraw can open and create letters, as well as<br>
address them via the mailer. However, a mail-aware application needs to be able to<br>
send letters as well. This section extracts the relevant pieces of the CollaboDraw<br>
CommSendLetter routine to explain the process of sending a letter step by step. The<br>
first step in sending a letter is to display the send options dialog box. This dialog is<br>
very similar to the standard print dialog, providing the user with options as to how the<br>
letter should be sent.&nbsp;&nbsp;&nbsp;CollaboDraw uses the following code to display this dialog:
</p>
<p>
<code>GetResString(nativeFormat, kAppNameID, kAppName);</code><br>
<code>GetWTitle(window, docTitle);</code><br>
<code>nativeFormatArray[0] = (StringPtr)nativeFormat;</code><br>
<code>SetCursor(&amp;qd.arrow);</code><br>
<code>err = SMPSendOptionsDialog(window, docTitle, nativeFormatArray, 1,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kSMPNativeMask | kSMPImageMask | kSMPStandardInterchangeMask,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;gPreferences.sendFormat, nil, 0L, &amp;gPreferences.sendFormat,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;gPreferences.sendOptions);</code><br>
<code></code><br>
<code>if (err==userCanceledError)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br>
<code>if (err!=noErr) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;DoError(err);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br>
<code>}</code>
</p>
<p>
The SMPSendOptionsDialog routine is built into the Standard Mail Package and handles<br>
the task of prompting the user for send options. As input, this routine takes the mailer<br>
window, the name of the document being mailed, a list of supported native formats, a<br>
list of which send formats are supported, and several other send option flags. This<br>
routine returns the name of the format that should be used to send the letter, which is<br>
used in the next part of the send process:
</p>
<p>
<code>SetCursor(&amp;gWatchCursor);</code><br>
<code></code><br>
<code>// Use our creator if we have native format, else use AppleMail</code><br>
<code>// creator.</code><br>
<code>if ((gPreferences.sendFormat.whichFormats &amp; kSMPNativeMask)!=0) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;letterCreator = kAppCreator;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;letterType = kCDLtrMsgType;</code><br>
<code>}</code><br>
<code>else {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;letterCreator = 'lap2';</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;letterType = kMailLtrMsgType;</code><br>
<code>}</code><br>
<code>err = SMPBeginSend(window, letterCreator, letterType,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;gPreferences.sendOptions, &amp;mustAddContent);</code><br>
<code>if (err!=noErr) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;SetCursor(&amp;qd.arrow);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;EndWindowAccess(window, hState);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;DoError(err);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br>
<code>}</code><br>
<code>if (mustAddContent) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (err==noErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = AddLetterBlocks(window, infoPtr,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;gPreferences.sendFormat);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (err!=noErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DoError(err);</code><br>
<code>}</code><br>
<code>err = SMPEndSend(window, (err==noErr));</code><br>
<code>if (err!=noErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;DoError(err);</code>
</p>
<p class="spacer">&nbsp;</p>
<p>
The above code first calls SMPBeginSend to start the send process. The send options are<br>
passed as input to this routine, and relevant information is extracted to build the<br>
header for the letter. This call also signals the Standard Mail Package that any<br>
content-adding calls apply to the letter specified in the SMPBeginSend call.&nbsp;&nbsp;Next, the<br>
actual blocks of content are added to the letter with the CollaboDraw AddLetterBlocks<br>
call, described below. Note that the content blocks are added only if mustAddContent,<br>
which is returned from SMPBeginSend, is true. It isn't necessary to add content blocks<br>
if a letter is being forwarded unchanged. 
</p>
<p>
Finally, the SMPEndSend call completes the send process. The second parameter to<br>
SMPEndSend is true if the letter should be sent, false if it should be aborted. 
</p>
<p>
The AddLetterBlocks routine described above adds the content in any combination of the<br>
three formats described earlier in the section "Letter Formats." It simply checks the<br>
sendFormat parameter returned from the SMPSendOptions dialog box to determine<br>
which formats to add. Native Application format is specified by kSMPNativeMask,<br>
AppleMail format by kSMPStandardInterchangeMask, and Snapshot format by<br>
kSMPImageMask. 
</p>
<p>
Routines for adding content in the three formats follow. 
</p>
<p>
<b>Native Application format. </b>The AddNativeContent routine adds content in Native<br>
Application format to a letter. 
</p>
<p>
<code>OSErr AddNativeContent(WindowPtr window, WInfoPtr infoPtr,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringPtr nativeFormatName)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;OSErr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;FSSpec&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fSpec;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;OCECreatorType&nbsp;&nbsp;blockType;</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;// Save file temporarily.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;err = SaveFileToTemp(infoPtr, &amp;fSpec);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (err!=noErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;err = SMPAddMainEnclosure(window, &amp;fSpec);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;FSpDelete(&amp;fSpec);</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;// Add native format name string block.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (err==noErr) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockType.msgCreator = kMailAppleMailCreator;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockType.msgType = kSMPNativeFormatName;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = SMPAddBlock(window, &amp;blockType, false,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nativeFormatName[1], nativeFormatName[0],</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kMailFromStart,0);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;return err;</code><br>
<code>}</code>
</p>
<p>
Native content is stored and accessed via file system FSSpecs, so adding content in this<br>
format requires that the document to be included first be saved in a temporary file.<br>
The SaveFileToTemp routine, not shown here, does this. Once an FSSpec to the<br>
document is available, SMPAddMainEnclosure is called and passed the letter window<br>
and the FSSpec. Finally, once this routine completes, a block is added to indicate the<br>
name of the native format used in the letter. Note that the native content for<br>
CollaboDraw is simply a CollaboDraw drawing document. This document is extracted<br>
when a letter is opened to get the list of shapes present in that letter. 
</p>
<p>
<b>AppleMail format. </b>Content in AppleMail format is added with the following routine:
</p>
<p>
<code>OSErr AddAppleMailLetterContent(WindowPtr window, WInfoPtr infoPtr)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;OSErr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;PicHandle&nbsp;&nbsp;&nbsp;thePicture;</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;thePicture = DrawImageToPicture(window, infoPtr);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (thePicture) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HLock((Handle)thePicture);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = SMPAddContent(window, kMailPictSegmentType, false,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*thePicture, GetHandleSize((Handle)thePicture), nil,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true, smRoman);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KillPicture(thePicture);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;else</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return kInternalError;</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;return err;</code><br>
<code>}</code>
</p>
<p>
Content in AppleMail format consists of a series of blocks containing text, styled text,<br>
pictures, sound, or movies. For CollaboDraw, we simply add a picture block containing<br>
all of the shapes in the current document. To add this block, we first call<br>
DrawImageToPicture, a CollaboDraw routine to allocate a PicHandle containing the<br>
shapes. We then call SMPAddContent with this picture to add the block. 
</p>
<p>
<b>Snapshot format. </b>The final content format supported by CollaboDraw is Snapshot<br>
format, and the routines below add a Snapshot block to a letter.
</p>
<p>
<code>OSErr AddLetterImage(WindowPtr window, WInfoPtr infoPtr)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;return SMPImage(window, DrawImageProc, (long)infoPtr, false);</code><br>
<code>}</code><br>
<code></code><br>
<code>pascal void DrawImageProc(long refCon, Boolean inColor)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;#pragma unused (inColor)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;OpenCPicParams&nbsp;&nbsp;newHeader;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;OSErr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Point&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zeroPt = {0, 0};</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;WInfoPtr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;infoPtr;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;TPrInfo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prInfo;</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;infoPtr = (WInfoPtr)refCon;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;prInfo = (**(infoPtr-&gt;printRecord)).prInfo;</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;newHeader.srcRect = prInfo.rPage;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;newHeader.hRes = FixRatio(prInfo.iHRes, 1);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;newHeader.vRes = FixRatio(prInfo.iVRes, 1);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;newHeader.version = -2;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;newHeader.reserved1 = 0;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;newHeader.reserved2 = 0L;</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;err = SMPNewPage(&amp;newHeader);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (err!=noErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DoError(err);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;DrawAllShapes(infoPtr, zeroPt);</code><br>
<code>}</code>
</p>
<p>
The SMPImage call takes care of including these image blocks for a letter. This routine<br>
is given the letter window and a draw-image routine, as well as a generic data pointer<br>
as input. The draw-image routine for CollaboDraw is called DrawImageProc; it accepts<br>
the window info block in the data pointer field. This callback first sets up the<br>
resolution and size of the page by extracting this information from the print record<br>
for the window. Next, SMPNewPage is called to set up the port into which the shapes<br>
will be imaged. Finally, the shapes are drawn into the page with the CollaboDraw<br>
routine DrawAllShapes, adding the final content blocks to the letter. 
</p>
<p>
<b>REPLYING TO OR FORWARDING A LETTER</b><br>
Once a letter has been opened within CollaboDraw, several options are available. If<br>
additional correspondence is necessary, the letter can be replied to or forwarded. The<br>
mailer can also be removed, which turns the letter back into a document. This<br>
operation is very similar to closing a letter and is described in the next section. The<br>
following code is used to reply to a letter:
</p>
<p>
<code>replyWindow = MakeWindow(kDrawMailerWindow, &amp;newWindRect, newTitle,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;false);</code><br>
<code>err = SMPMailerReply(window, replyWindow, replyToAll, topLeft, true,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true, kDefaultIdentity, nil, 0L);</code><br>
<code>if (err!=noErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;DoError(err);</code><br>
<code>ShowWindow(replyWindow);</code>
</p>
<p>
The first step in replying to a letter is to make a new window in which the reply letter<br>
will be created. The CollaboDraw routine MakeWindow is called to create a new window<br>
of the mailer class. Once this window has been created, SMPMailerReply can be called,<br>
which takes the existing letter window, the new letter window, and several other<br>
parameters as input. As a result of the call, the reply letter is created and<br>
automatically addressed to the originator of the original message. 
</p>
<p>
The mail forwarding process does not involve the creation of a new letter window.<br>
Instead, another mailer is added to the existing letter, and the mailers can be viewed<br>
by clicking a dog-ear in the corner of the mailer window pane. The code to forward a<br>
letter is as follows:
</p>
<p>
<code>void CommForward(WindowPtr window)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;WInfoPtr&nbsp;&nbsp;&nbsp;&nbsp;infoPtr;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hState;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;OSErr&nbsp;&nbsp;&nbsp;err;</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;infoPtr = BeginWindowAccess(window, &amp;hState);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;HandleExpand(window, infoPtr); </code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Expand window before doing forward.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;err = SMPMailerForward(window, kDefaultIdentity);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (err!=noErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DoError(err);</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;infoPtr-&gt;saved = false;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;DMailerActivateWindow(window, infoPtr, nil);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;EndWindowAccess(window, hState);</code><br>
<code>}</code>
</p>
<p>
To forward a letter, the mailer in the window is first expanded. This allows the new<br>
mailer to be fully visible when it's created. The CollaboDraw routine HandleExpand<br>
calls SMPExpandOrContract to expand the mailer. Next, SMPMailerForward actually<br>
adds the mailer to the letter. Once this is done, the state of the document is changed to<br>
indicate that the letter is now an outgoing letter instead of a received letter. Finally,<br>
the activate-event method is called on the window to readjust the menu items that<br>
relate to sending mail. 
</p>
<p>
<b>CLOSING A LETTER</b><br>
When it's time to close a letter window, there's a short process that must be adhered<br>
to. First, the optional close options dialog box can be displayed. This dialog gives the<br>
user the option of deleting the letter or tagging it before it's closed. CollaboDraw uses<br>
the following code to display this dialog:
</p>
<p>
<code>if (gPreferences.closeOptionsDialog) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;SetCursor(&amp;qd.arrow);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;err = SMPCloseOptionsDialog(window, &amp;gPreferences.closeOptions);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (err!=noErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;returnValue = false;</code><br>
<code>}</code>
</p>
<p>
Since the dialog box is optional, CollaboDraw has a preference variable that tracks<br>
whether the dialog should be displayed. If it should be displayed, this is done by calling<br>
SMPCloseOptionsDialog with the letter window and the close options to use when<br>
closing the letter. Note that the close options are also stored in the preferences, to<br>
allow the dialog to default to the close options last used. 
</p>
<p>
The next step in the close process is to make sure that there are no open enclosures and<br>
that there are no Finder copies in progress that would prevent the closure of the<br>
letter. The following code excerpt checks for this:
</p>
<p>
<code>err = SMPPrepareToClose(window);</code><br>
<code>if (err==kSMPHasOpenAttachments) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;SetCursor(&amp;qd.arrow);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;StopAlert(kHasOpenAttachID, nil);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;returnValue = false;</code><br>
<code>}</code><br>
<code>else if (err==kSMPCopyInProgress) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;SetCursor(&amp;qd.arrow);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;StopAlert(kCopyInProgress, nil);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;returnValue = false;</code><br>
<code>}</code>
</p>
<p>
SMPPrepareToClose returns kSMPHasOpenAttachments if there are open enclosures<br>
and kSMPCopyInProgress if the user is in the process of copying a document to or from<br>
the enclosures list. In response, CollaboDraw presents an alert to the user and will not<br>
allow the letter to be closed. 
</p>
<p>
The final steps in closing the letter are to remove the mailer from the window and<br>
close the window.&nbsp;&nbsp;&nbsp;Here's the code to do this removal:
</p>
<p>
<code>err = SMPDisposeMailer(window, closeOptions);</code><br>
<code>if (err!=noErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;DoError(err);</code><br>
<code>return DrawDestroyWindow(window, infoPtr, data);</code>
</p>
<p>
The PowerTalk routine SMPDisposeMailer removes the mailer pane from the window<br>
passed as input and releases all memory associated with the letter window. Once this is<br>
done, CollaboDraw calls the draw-window method for closing a window, which takes<br>
care of disposing of the rest of the window and document structures. 
</p>
<h2>ADDING DIGITAL SIGNATURE PACKAGE SUPPORT</h2>
<p>
Digital signature services can also be incorporated into applications, providing a level<br>
of security not previously possible with personal computers. CollaboDraw allows<br>
signing and verifying within documents at a shape level. Individual shapes can be<br>
selected and signed, and the signatures are carried around with the shapes when the<br>
documents are saved or sent to other users. In addition to this shape-level digital<br>
signature support, the Standard Mail Package provides support for signing letters as a<br>
whole. By supporting the mailer, we automatically get this letter-based digital<br>
signature functionality. 
</p>
<p>
<b>SIGNATURE STORAGE FOR DOCUMENTS</b><br>
Since digital signatures are quite large in size (they can be several kilobytes each), I<br>
elected not to store the signatures in memory with the document shapes. Instead, I<br>
store the signatures in the resource fork of each document file. The signature storage<br>
strategy is not covered in depth in the code below, but you can refer to the digital<br>
signature code within CollaboDraw to see how it's done. 
</p>
<p>
<b>SIGNING A SHAPE</b><br>
To sign a shape or set of shapes within CollaboDraw, the user must select the shapes<br>
and choose the Sign Selected Shapes menu item. In response to this, the following code<br>
is called:
</p>
<p>
<code>void CommSign(WindowPtr window)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;WInfoPtr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;infoPtr;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hState;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;ShapeListPtr&nbsp;&nbsp;&nbsp;&nbsp;shapeList;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;SIGContextPtr&nbsp;&nbsp;&nbsp;sigContext;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sigSize;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;OSErr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err;</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (!IsAppWindow(window))</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;err = SIGNewContext(&amp;sigContext);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (err==noErr) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;infoPtr = BeginWindowAccess(window, &amp;hState);&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = SIGSignPrepare(sigContext, nil, nil, &amp;sigSize);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (shapeList=infoPtr-&gt;data;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(err==noErr) &amp;&amp; (shapeList!=nil);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shapeList=shapeList-&gt;next) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (shapeList-&gt;selected) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = SignShape(infoPtr, sigContext, shapeList,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sigSize);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InvalShapeArea(window, infoPtr, shapeList);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Redraw shape.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SIGDisposeContext(sigContext);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DSIGSetupSignMenu(window, infoPtr);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EndWindowAccess(window, hState);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (err!=noErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DoError(err);</code><br>
<code>}</code>
</p>
<p>
The first important call in the above code is SIGNewContext. This routine creates a<br>
digital signature context, which is required for each signing or verification session.<br>
Creating a context allocates the resources needed to perform signing and verification of<br>
objects. 
</p>
<p>
Next, SIGSignPrepare is called. This routine prompts the user to enter a signer<br>
identification code, allowing the signer to be applied to the selected objects.
</p>
<p>
Now that the signature has been set up, each shape can be signed individually with a<br>
call to the CollaboDraw routine SignShape. Once each shape has been signed,<br>
SIGDisposeContext can be called to end the signing session.
</p>
<p>
The SignShape routine carries out the task of producing and storing a signature for<br>
each shape to be signed, as follows:
</p>
<p>
<code>OSErr SignShape(WInfoPtr infoPtr, SIGContextPtr sigContext,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ShapeListPtr theShape, Size sigSize)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;OSErr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Handle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signature;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resID;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;saveResFile;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;DigSigListPtr&nbsp;&nbsp;&nbsp;theSig;</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;// Allocate storage for the signature.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;signature = NewHandleChk(sigSize);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (MemError()!=noErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return MemError();</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;// Process the data for the signature.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;err = ProcessShapeData(sigContext, theShape);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (err!=noErr) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DisposHandleChk(signature);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;// Create the signature.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;HLock(signature);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;err = SIGSign(sigContext, (SIGSignaturePtr)*signature, nil);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;HUnlock(signature);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (err!=noErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;// Add the signature to the shape.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;saveResFile = CurResFile();</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;UseResFile(gDSTempRefNum);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;resID = Unique1ID(kSignatureResType);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;AddResource(signature, kSignatureResType, resID, "\p");</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;. . .</code><br>
<code>}</code>
</p>
<p class="spacer">&nbsp;</p>
<p>
Before a shape can be signed, memory must first be allocated to hold the signature for<br>
the shape. The size of the block required to hold the signature is returned by<br>
SIGSignPrepare, and this value is passed in as the sigSize parameter to the SignShape<br>
routine. 
</p>
<p>
Once the signature storage has been allocated, all of the data to be signed in the shape<br>
must be handed to the Digital Signature Manager in a byte stream. This process is<br>
required to generate a unique number identifying the contents of the document. The<br>
CollaboDraw routine ProcessShapeData handles this data streaming. Within<br>
ProcessShapeData, the Digital Signature Manager routine SIGProcessData is called to<br>
stream the data. 
</p>
<p>
<code>err = SIGProcessData(sigContext, theShape, kShapeSignLength);</code>
</p>
<p>
Once the unique number, also known as a<i>digest</i> , has been created, the signer is then<br>
applied to that number to create a signature with the call SIGSign. The signature is<br>
stored in the handle allocated at the start of the routine and is then added to the<br>
resource fork of the document file. 
</p>
<p>
<b>VERIFYING A SHAPE</b><br>
Once a shape has been signed, it can later be verified from within CollaboDraw. The<br>
high-level CollaboDraw routine CommVerify is called in response to the Verify<br>
Selected Shapes menu item.&nbsp;&nbsp;&nbsp;This routine is almost identical to the CommSign routine<br>
given earlier, so it isn't included here. It simply calls SIGNewContext and then<br>
repeatedly calls the CollaboDraw routine VerifyShape. Once each shape has been<br>
verified, CommVerify calls SIGDisposeContext. 
</p>
<p>
The VerifyShape routine is analogous to the SignShape routine. Instead of adding a<br>
signature to a shape, this routine retrieves the signature for a shape, verifies the<br>
signature, and displays information about the signer. 
</p>
<p>
<code>signatureSize = SizeResource(sigHandle);</code><br>
<code>HLock(sigHandle);</code><br>
<code>err = SIGVerifyPrepare(sigContext, (SIGSignaturePtr)*sigHandle,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signatureSize, nil);</code><br>
<code>if (err==noErr) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;// Process the data for the signature.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;err = ProcessShapeData(sigContext, theShape);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (err==noErr) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = SIGVerify(sigContext);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (err==noErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = SIGShowSigner(sigContext, nil);&nbsp;&nbsp;&nbsp;// Show signer info.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code>}</code>
</p>
<p>
The section of VerifyShape shown above comes just after the signature is extracted<br>
from the resource fork of the document. Once the signature is in sigHandle,<br>
SIGVerifyPrepare is called. This routine prepares the Digital Signature Manager to<br>
receive data via the SIGProcessData call. Once this data has been streamed to create a<br>
digest, the digest is compared to the one stored in the signature with the SIGVerify<br>
routine. This routine will return noErr if the two digests match. When this occurs, a<br>
SIGShowSigner call will present a dialog box displaying information about the signer<br>
of the shape. 
</p>
<h2>EXPLORING OTHER POWERTALK FEATURES</h2>
<p>
This discussion of the PowerTalk Standard Mail and Digital Signature packages doesn't<br>
even begin to touch on the many features available to developers through PowerTalk.<br>
You can take advantage of InterProgram Messaging for store and forward application<br>
communication, use the Standard Catalog interfaces for picking items out of catalogs,<br>
write custom catalog templates, use PowerTalk authentication services, or build<br>
service access modules to interface to alternate message delivery or directory catalog<br>
services. By adding standard mail and digital signature support to CollaboDraw, we've<br>
enhanced the usefulness of our simple drawing program in many ways. When combined<br>
with other applications that support PowerTalk collaborative services, communication<br>
and productivity within a workgroup can be taken to new levels. 
</p>
<p>
<b>STEVE FALKENBURG </b>has been working in Apple's Developer Technical Support<br>
group ever since he finished his last<i>develop </i> article nearly three years ago. When not<br>
supporting PowerTalk (and Macintosh on PowerPC), Steve can be found hiking around<br>
California everywhere from Mount Tamalpais to Big Basin. Some people think he's just<br>
searching for the perfect mountain vista, but he's also trying his best to keep pace<br>
with his hiking partner, Nancy. *
</p>
<p>
<b>DigiSign's digital signature implementation </b>is based on a public key/private<br>
key standard developed by RSA Technologies, Inc. The technology underlying digital<br>
signatures is beyond the scope of this article; interested readers should refer to the<br>
PowerTalk documentation for more information. *
</p>
<p>
<b>This article hasn't covered </b>a few other PowerTalk features that CollaboDraw<br>
takes advantage of. Among these are printing, tagging letters, and opening the next<br>
letter from the mailbox. Refer to the sample code included on this issue's CD for<br>
implementation details of these features.*
</p>
<p>
<b>THANKS TO OUR TECHNICAL REVIEWERS </b>Godfrey DiGiorgi, John Evans, Steve<br>
Fisher, Martin Minow *
</p>
</body>
</html>
