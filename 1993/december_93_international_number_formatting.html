<html>
<head>
<!-- Article ID: 50 - Extracted from develop-1993 -->
<!-- on 2024-02-03 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by the copyright of its respective owners -->
<title>December 93 - INTERNATIONAL NUMBER FORMATTING</title>
<link href="../common/styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h2>INTERNATIONAL NUMBER FORMATTING</h2>
<h1>NORBERT LINDENBERG</h1>
<p>
<img src="img/252.gif" width="180 px"></img>
</p>
<p>
<i>Have you ever wondered how to get your program to display numbers in a way that</i><br>
<i>satisfies Macintosh users all around the world? This article tells you what users</i><br>
<i>expect and shows you how to use the Macintosh Toolbox to correctly format numbers,</i><br>
<i>taking the needs of both your program and the user into account. It also shows how to</i><br>
<i>interpret numbers entered by the user.</i>
</p>
<p class="spacer">&nbsp;</p>
<p>
When you develop an application, you usually have some opinion about the format in<br>
which numbers should be presented to the user. However, number formatting<br>
standards differ from country to country (and sometimes even within a country), and<br>
users also may have their own ideas on the subject. Macintosh system software<br>
provides support to format numbers in ways that accommodate both the needs of your<br>
application and local standards, and -- starting with System 7.1 -- also lets the user<br>
control some aspects of number formatting using the Numbers control panel. 
</p>
<p>
This article shows two different ways to format numbers: using a default format for<br>
simple number display, and following the user's specification for more sophisticated<br>
number display. It also shows how to interpret numeric input correctly. This issue's<br>
CD contains an application called Numbers Test that lets you try out these two different<br>
methods of formatting numbers and enter numbers for interpretation. The CD also<br>
contains BuildNumbers, an MPW script that builds an MPW tool that's functionally<br>
equivalent to the application.
</p>
<h2>WHAT USERS EXPECT</h2>
<p>
Users expect to see numbers in a format that makes sense to them. This challenges the<br>
programmer to accommodate the variations on number formatting that occur around<br>
the world.
</p>
<p>
The most common system for writing numbers is the decimal system, where numbers<br>
are formed from ten different numerals, with the position of each digit within a<br>
number defining a multiplier for it: 123 = 1*100 + 2*10 + 3*1. However, there<br>
are many local variations on this scheme, and there are some writing systems that<br>
prefer a different style of writing numbers, in which case decimal numbers may or<br>
may not be an acceptable alternative. Systems besides the decimal system that users<br>
may require include Roman numerals (used in many languages to number topics or<br>
title pages) and hexadecimal numbers (familiar to everybody who's ever dropped into<br>
MacsBug), as well as the Japanese and Chinese systems. For details on how these<br>
number formatting systems differ from one another, see "Number Formatting<br>
Variations."
</p>
<p>
Computers may complicate matters even more by providing multiple character codes<br>
for the same digit. For example, the Macintosh Japanese character set provides both<br>
1-byte and 2-byte encodings of the Latin characters (which are called "Romaji" in<br>
Japanese). They can easily be distinguished on the screen: the 1-byte versions are<br>
narrower than the 2-byte versions, which take up the same widthas Kanji characters.<br>
For interpretation as numbers, however, these different encodings should be<br>
considered equivalent. 
</p>
<p>
Another example is the Macintosh Arabic character set, which defines a set of Arabic<br>
digits with right-to-left orientation in addition to the ASCII digits, which have<br>
left-to-right orientation and are usually displayed with Arabic glyphs when an Arabic<br>
font has been chosen. The right-to-left digits are intended only for text that doesn't<br>
have a numeric meaning, such as software version strings and part numbers, and are<br>
needed to obtain proper line layout in these cases. However, users may not be aware of<br>
this intention and may try to enter numbers using these digits. Later we'll discuss how<br>
to deal with this. 
</p>
<h2>WHAT YOUR APPLICATION NEEDS</h2>
<p>
Depending on how sophisticated your application is with regard to numbers, you'll<br>
need to support variations on number formatting in three different situations: simple<br>
number display, number display in a user-specified format, and numeric input. 
</p>
<p>
For simple number display, your application needs to show a given number in a default<br>
format that makes sense to the user. This kind of formatting may suffice for many<br>
applications and is commonly used for dialogs. 
</p>
<p>
For other number-display situations, your application might need to format numbers<br>
according to the user's specification. The user might specify which representation to<br>
use for the number (for example, decimal or traditional Chinese; Thai, Arabic, or<br>
Latin glyphs), the number of digits after the decimal separator, how to indicate<br>
negative numbers, whether to use thousands separators, which currency symbol to<br>
use, and where to place it. This kind of formatting is needed, for example, for<br>
spreadsheets, databases, and page layout applications. 
</p>
<p>
Numeric input is needed in almost any application -- for example, to specify the width<br>
of a page, the number of a page to jump to, or the size of a font. Ideally, your<br>
application should be able to interpret a numeric string in any format that might make<br>
sense to the user, independent of the display formats you use. 
</p>
<h2>NUMBER FORMATTING VARIATIONS</h2>
<p>
Local variations on the decimal system include variations on the shapes of the digits,<br>
representation of negative numbers, the decimal separator, and the thousands<br>
separator.
</p>
<ul>
<li>The shapes of the digits: The glyphs used with the Latin writing system<br>
differ from those used with the Arabic writing system, and several other<br>
writing systems come with their own glyphs.</li>
</ul>
<p>
<img src="img/253.gif" width="600 px"></img>
</p>
<p>
Latin
</p>
<p>
<img src="img/254.gif" width="254 px"></img>
</p>
<p>
Arabic
</p>
<p>
<img src="img/255.gif" width="255 px"></img>
</p>
<p>
Thai
</p>
<ul>
<li>Representation of negative numbers: The minus sign can be used before or<br>
after the number, or the number can be parenthesized.</li>
<li>The decimal separator: Either a period or a comma can be used to mark off<br>
the integer part of the number from the fractional part.</li>
<li>The thousands separator: A space, a comma, a period, or some other<br>
character can be used to mark off the thousands place from the hundreds place,<br>
the millions place from the hundred thousands place, and so on. Sometimes the<br>
thousands separator isn't used&nbsp;&nbsp;at all.</li>
</ul>
<p>
Many other variations exist, especially for noninteger numbers. Here's a sample of<br>
local variations on how one negative number is represented in the decimal system:
</p>
<p>
<img src="img/256.gif" width="525 px"></img>
</p>
<p>
Arabic<br>
French -1 234,56<br>
German -1.234,56 Greek (1 234.56)<br>
Japanese (1,234.56)<br>
Swiss French -1'234.56
</p>
<p>
<img src="img/257.gif" width="413 px"></img>
</p>
<p>
Thai<br>
U.S. -1,234.56
</p>
<p>
In the Roman system, numbers are formed from letter digits representing the<br>
numbers shown below.
</p>
<p><table border="0"><tr><td>M</td><td>1000</td></tr>
<tr><td>D</td><td>500</td></tr>
<tr><td>C</td><td>100</td></tr>
<tr><td>L</td><td>50</td></tr>
<tr><td>X</td><td>10</td></tr>
<tr><td>V</td><td>5</td></tr>
<tr><td>I</td><td>1</td></tr></table></p>
<p class="spacer">&nbsp;</p>
<p class="spacer">&nbsp;</p>
<p>
Originally the digits of the number were simply added up to arrive at the value of the<br>
number, and digits were sorted in decreasing order within the number (so 9 = VIIII).<br>
Later a convention was added that positioning one of the digits C, X, or I before a<br>
higher-valued digit means that its value is to be subtracted instead of added (so 9 =IX).
</p>
<p>
The Japanese and Chinese systems represent numbers in various ways. In horizontal<br>
writing, the decimal system with Latin glyphs is commonly used. Ten thousands<br>
separators were once used instead of thousands separators and are still used in some<br>
very traditional quarters, but accountants in Japan now use thousands separators<br>
instead. In the traditional vertical writing preferred by native speakers, however,<br>
Chinese characters are used without separators. A mapping of decimal numbers to<br>
Chinese digits is acceptable; however, a direct representation of the numbers as they<br>
are spoken is preferred. The number 45000, for example, is represented in the<br>
decimal style on the left and in the traditional style on the right:
</p>
<p>
<img src="img/258.gif" width="75 px"></img>
</p>
<p>
4
</p>
<p>
<img src="img/259.gif" width="15 px"></img>
</p>
<p>
4
</p>
<p>
<img src="img/260.gif" width="17 px"></img>
</p>
<p>
5
</p>
<p>
<img src="img/261.gif" width="17 px"></img>
</p>
<p>
ten thousand
</p>
<p>
<img src="img/262.gif" width="68 px"></img>
</p>
<p>
0
</p>
<p>
<img src="img/263.gif" width="17 px"></img>
</p>
<p>
5
</p>
<p>
<img src="img/264.gif" width="68 px"></img>
</p>
<p>
0
</p>
<p>
<img src="img/265.gif" width="17 px"></img>
</p>
<p>
thousand
</p>
<p>
<img src="img/266.gif" width="68 px"></img>
</p>
<p>
0
</p>
<h2>WHAT MACINTOSH SYSTEM SOFTWARE PROVIDES</h2>
<p>
Macintosh system software supports number formatting with international resources,<br>
the Numbers control panel (in System 7.1), and the Text Utilities routines.<br>
Unfortunately, the functionality provided doesn't cover all the needs just described --<br>
it's limited to decimal numbers and a maximum of two encodings per script. This<br>
means that, for instance, Chinese vertical numbers aren't supported; with the advent<br>
of QuickDraw GX, which supports vertical text, this problem is becoming more urgent.<br>
There are some interesting details you'll have to understand to make the best use of the<br>
functionality provided. 
</p>
<p>
<b>INTERNATIONAL RESOURCES</b><br>
International resources of two types, 'itl0' and 'itl4', provide data that helps in<br>
formatting numbers.
</p>
<ul>
<li>Resources of type 'itl0' contain separator symbols (decimal separator and<br>
thousands separator) and information about a simple default format. These<br>
resources allow for 1-byte characters only and don't support more<br>
sophisticated layout.</li>
<li>Resources of type 'itl4' contain a number parts table used by the Text<br>
Utilities routines to interpret format specification strings entered or selected<br>
by the user.&nbsp;&nbsp;&nbsp;They also contain a table of alternate digits that can be used<br>
instead of the default ASCII digits and that may be 2-byte characters. If there<br>
are no alternate digits for the script, the ASCII digits are repeated in this<br>
table.&nbsp;&nbsp;A system file can contain multiple resources of either type. Each<br>
regional version of system software comes with a default resource of each<br>
type, as well as the U.S. versions of the resources; more resources can be<br>
added. </li>
</ul>
<p>
If multiple scripts are installed on one machine, each script has at least one resource<br>
of each type and designates one resource of each type as the default for the script. The<br>
default resources for the system script (the script that supports the language your<br>
system is localized for) define the systemwide default. If GetIntlResource (IUGetIntl)<br>
is used to access a resource, the script whose resources are returned depends on the<br>
font in the current graphics port and the settings of the international resources<br>
selection flag. To avoid surprises, it's usually better to ask for resources of specific<br>
scripts; the InitializeDefaultNumberSeparators routine, discussed later, does this. 
</p>
<p>
All Macintosh scripts support the use of the ASCII digits ($30-$39), and some<br>
scripts provide an additional set of digits in an alternate numeral table. The Japanese<br>
'itl4' resource contains the 2-byte Romaji digits; the Arabic 'itl4' resource, the<br>
right-to-left digits; and the Thai 'itl4' resource, the Thai digits. Because only one<br>
alternate numeral table is allowed per 'itl4' resource, you won't find in the Japanese<br>
'itl4' resource the Chinese numerals used in the Japanese script. Unfortunately, not<br>
all scripts that have multiple sets of digits define them in the 'itl4' resource; for<br>
instance, the Chinese versions of System 7.1 don't make use of the alternate numeral<br>
table but only support the ASCII digits. 
</p>
<p>
<b>THE NUMBERS CONTROL PANEL</b><br>
The Numbers control panel (in System 7.1) lets users select the default number<br>
format and define customized decimal and thousands separators, as well as the<br>
currency symbol. In earlier systems, the International control panel (which was<br>
shipped only with certain localized versions of system software) allowed the user to<br>
select the default number format but didn't provide for customization.&nbsp;&nbsp;&nbsp;(See Figure<br>
1.)
</p>
<p>
<img src="img/267.gif" width="353 px"></img>
</p>


</p>
<p>
<b>Figure 1</b>The International and Numbers Control Panels
</p>
<p>
To correctly access the international resources and interpret their contents, it helps<br>
to know how the control panels affect the resources. The behavior of the control panels<br>
has changed significantly from system software versions 7.0 and 7.0.1 to version 7.1.<br>
The International control panel in versions 7.0 and 7.0.1 lets the user select only the<br>
language whose number formatting rules apply; it does not allow modification of the<br>
rules. Selecting a language makes the corresponding region's 'itl0' resource the default<br>
resource for its script, so that all its features take effect. The 'itl4' resources are not<br>
affected. 
</p>
<p>
The Numbers control panel in System 7.1 lets the user select a predefined regional<br>
version or define a custom version of the number format. The first time the control<br>
panel is opened after installing System 7.1, it creates a new 'itl0' resource in the<br>
System file based on the predefined default 'itl0' resource of this version of system<br>
software and makes this new resource the default for the system script. From then on<br>
it keeps the user's format definition in this personalized 'itl0' resource, whether it's<br>
selected from predefined formats or defined as a custom format. When the user selects<br>
a different regional version, all items of that region's 'itl0' resource that are<br>
represented in the control panel are copied into the personalized 'itl0' resource; other<br>
features defined in the 'itl0' resource are ignored. This means that the decision, for<br>
example, whether to show negative numbers with a minus sign or in parentheses is not<br>
affected by the selection. The default selection of the 'itl4' resource isn't changed;<br>
however, the default 'itl4' resource is modified to use the personalized 'itl0'<br>
resource's decimal and thousands separators in its number parts table. 
</p>
<p>
There's one problem with the Numbers control panel that you have to be aware of: it<br>
doesn't impose any constraints on the selections for the decimal and thousands<br>
separators, other than not allowing the user to enter 2-byte characters. The user can,<br>
for example, select a digit, the minus sign, no character at all, or a character that<br>
conflicts with the inner workings of the Text Utilities routines for interpreting<br>
format specifications. To make sure that your application functions correctly, you<br>
have to check whether the separators make sense before using them. 
</p>
<p>
The sample code discussed in this article assumes that you don't check for changes of<br>
the resources while your application is running, so it gets all necessary information<br>
at launch time and caches it.&nbsp;&nbsp;&nbsp;This way, changes made with the control panel will not<br>
be immediately reflected in your application, but you also avoid the problem of<br>
inconsistent updates. This problem can arise if you always use the most current<br>
information, and the user changes, say, the decimal separator while your application<br>
is displaying numbers in a window; in this case, it could happen that after redrawing a<br>
part of your window you display one decimal separator in the updated region and<br>
another one in the rest of the window. 
</p>
<p>
<b>THE TEXT UTILITIES ROUTINES</b><br>
The Text Utilities routines format or interpret numbers according to format<br>
specifications that are given by format strings and that can be quite sophisticated so<br>
that context-dependent variations can be taken into account. Format strings are used in<br>
some spreadsheet and database applications and look like this:
</p>
<p>
&nbsp;'###.###,##;(###.###,##);0.##'
</p>
<p>
By default, the Text Utilities routines assume that numbers are encoded by ASCII digits<br>
($30-$39) and displayed using Latin glyphs. However, we'll see that there's a way to<br>
have the routines support the set of digits defined in the alternate numeral table in the<br>
'itl4' resource, in addition to ASCII digits. 
</p>
<p>
The Text Utilities routines assume a localized format string. There's only limited<br>
support for automatically adjusting a generic format string to local customs or the<br>
user's preferences: the routines can replace characters by using a different number<br>
parts table but cannot convert to a different structure of the number format. For<br>
example, the indicator of negative numbers can't be switched automatically from the<br>
minus sign to parentheses. This is a problem if your application isn't localized for all<br>
the regions supported by Macintosh system software. 
</p>
<p>
Now you know what users expect, what your application's needs are, and what support<br>
Macintosh system software offers when it comes to number formatting. You've seen<br>
that the Toolbox doesn't provide a solution for all your needs, so you'll have to extend it<br>
in some cases. We'll now look at how you can make the best use of what<i>is</i>&nbsp;&nbsp;provided to<br>
do simple number display using a default format, to display numbers in a<br>
user-specified format, and to interpret numeric input. The sample code presented<br>
here uses the international resources either directly or in combination with the Text<br>
Utilities routines to make up for at least some of the shortcomings of the Text Utilities<br>
routines. 
</p>
<h2>SIMPLE NUMBER DISPLAY</h2>
<p>
First I'll show you how to use the 'itl0' resources in conjunction with the Text<br>
Utilities or Standard Apple Numerics Environment (SANE) routines to display<br>
numbers in the default number format.&nbsp;&nbsp;&nbsp;This method provides a simple solution for<br>
cases of simple number display. 
</p>
<p>
The following code takes the localized or user-defined decimal and thousands<br>
separators into account. It assumes that numbers are written as integer or fixed-point<br>
decimal numbers in the ASCIIcharacter set and displayed in a font of the system script.<br>
It doesn't support Roman numerals, full- width Romaji, Chinese numbers, Thai digits,<br>
or the like. Negative numbers are written with a leading minus sign; parentheses<br>
aren't supported.
</p>
<p>
In some cases you won't want to use the default number formatting definition but<br>
instead will want to use the definition for a specific language. This case isn't taken into<br>
account in this version. 
</p>
<p>
We start by defining the variables used to cache the default decimal and thousands<br>
separators. They must be initialized by calling InitializeDefaultNumberSeparators<br>
when the application is launched. 
</p>
<p>
<code>PROGRAM Numbers;</code><br>
<code>USES Script, Resources, Memory, Errors, GestaltEqu, Packages, SANE,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;UFailure;</code><br>
<code>VAR gDefaultDecimalSeparator:&nbsp;&nbsp;&nbsp;Char;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;gDefaultThousandsSeparator: Char;</code>
</p>
<p>
We call the procedure InitializeDefaultNumberSeparators in the application's<br>
initialization sequence to initialize both gDefaultDecimalSeparator and<br>
gDefaultThousandsSeparator from the default 'itl0' resource of the system script. If<br>
your application tracks changes in the Script Manager state, you can reinitialize the<br>
variables by calling InitializeDefaultNumberSeparators again. Because the Numbers<br>
control panel lets the user select any characters as the separators, we verify that the<br>
selection doesn't conflict with our use of the separators. If no character was specified<br>
in the control panel, the 'itl0' resource contains Char(0). It's OK not to have a<br>
thousands separator, but you can't display floating- point numbers without a decimal<br>
separator. We don't use GetIntlResource (IUGetIntl), so the outcome of this routine<br>
doesn't depend on the font in the current graphics port or the international resources<br>
selection flag. 
</p>
<p>
<code>PROCEDURE InitializeDefaultNumberSeparators;</code><br>
<code>VAR theItl0Handle: Handle;</code><br>
<code>BEGIN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;theItl0Handle := GetResource('itl0', GetScript(smSystemScript,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;smScriptNumber));</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;FailNILResource(theItl0Handle);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;WITH Intl0Hndl(theItl0Handle)^^ DO BEGIN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF (decimalPt IN ['0'..'9', Char(0), '-']) OR (thousSep IN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;['0'..'9', '-']) OR (decimalPt = thousSep) THEN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FailOSErr(paramErr);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gDefaultDecimalSeparator := decimalPt;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gDefaultThousandsSeparator := thousSep;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;END;</code><br>
<code>END;</code>
</p>
<p>
The FailNILResource, FailNIL, FailOSErr, and FailResError routines check for errors<br>
and initiate error handling if necessary; they were originally introduced in MacApp. In<br>
this sample code, I don't provide complete error handling, but only call these routines<br>
to indicate where a real application would have to be prepared to handle errors. 
</p>
<p>
The procedure LocalizeNumberString takes a string representing a number as it's<br>
produced by a nonlocalizable conversion routine and localizes it by adjusting the<br>
decimal separator (if there is one) and inserting thousands separators. 
</p>
<p>
<code>PROCEDURE LocalizeNumberString(VAR theString: Str255);</code><br>
<code>VAR boundary:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;separatorString:&nbsp;&nbsp;&nbsp;&nbsp;String[1];</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;minusOffset:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer;</code><br>
<code>BEGIN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;separatorString := ',';</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;separatorString[1] := gDefaultThousandsSeparator;</code>
</p>
<p class="spacer">&nbsp;</p>
<p>
First, we find the boundary between the integer and fractional parts. If there's a<br>
period, that's the boundary (and we fix the decimal separator right away); otherwise<br>
it's the end of the string.
</p>
<p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;boundary := Pos('.', theString);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;IF boundary &lt;&gt; 0 THEN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theString[boundary] := gDefaultDecimalSeparator</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;ELSE</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary := Length(theString) + 1;</code>
</p>
<p class="spacer">&nbsp;</p>
<p>
Second, we insert as many thousands separators as necessary, if the user has specified<br>
one. We take into account that we don't want to insert a thousands separator right after<br>
a minus sign. 
</p>
<p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;IF gDefaultThousandsSeparator &lt;&gt; Char(0) THEN BEGIN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF theString[1] = '-' THEN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minusOffset := 1</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELSE</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minusOffset := 0;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHILE boundary &gt; 4 + minusOffset DO BEGIN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theString := Concat(Copy(theString, 1, boundary - 4),</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;separatorString,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copy(theString, boundary - 3,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Length(theString) - boundary + 4));</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary := boundary - 3;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;END;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;END;</code><br>
<code>END;</code>
</p>
<p>
And now we finally come to the two routines that an application will call directly to<br>
format numbers into strings. The first one is intended for integer numbers, the second<br>
one for floating-point numbers. 
</p>
<p>
IntegerToLocalString converts the given integer into a string representation using the<br>
thousands separator specified by localization or by the user. It calls NumToString, a<br>
Text Utilities routine. 
</p>
<p>
<code>PROCEDURE IntegerToLocalString(theNumber: LongInt;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR theString: Str255);</code><br>
<code>BEGIN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;NumToString(theNumber, theString);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;LocalizeNumberString(theString);</code><br>
<code>END;</code>
</p>
<p>
ExtendedToLocalString converts the number into a fixed-point representation using<br>
the decimal separator specified by localization or by the user. The number of digits to<br>
be used after the decimal separator is specified in decimalDigits. DecForm and<br>
Num2Str are defined by SANE. 
</p>
<p>
<code>PROCEDURE ExtendedToLocalString(theNumber: Extended;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decimalDigits: Integer; VAR theString: Str255);</code><br>
<code>VAR theDecForm: DecForm;</code><br>
<code>BEGIN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;WITH theDecForm DO BEGIN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;style := fixedDecimal;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;digits := decimalDigits;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;END;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Num2Str(theDecForm, theNumber, DecStr(theString));</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;LocalizeNumberString(theString);</code><br>
<code>END;</code>
</p>
<p>
That's all there is to the simple case. 
</p>
<h2>NUMBER DISPLAY IN A USER-SPECIFIED FORMAT</h2>
<p>
Now I'll show you how to use the Text Utilities routines and 'itl4' resources to format<br>
numbers according to the user's specification. The idea is that your application comes<br>
with a range of predefined format strings, from which the user can pick one. The<br>
application might also let users enter their own format strings. Of course, these<br>
strings aren't exactly the most user-friendly way to define a number format, so if<br>
your application is intended for novice users you should hide them behind a friendlier<br>
user interface. Before we dive into the code, let's look at a few obstacles that the Text<br>
Utilities routines provide for us and consider how we can work around them. 
</p>
<p>
First of all, the Text Utilities routines expect to work with localized format<br>
specifications. They aren't able to take, for example, the standard number format used<br>
in the United States and translate it into the standard number format used in Greece,<br>
which uses parentheses to indicate negative numbers. This will be a problem if your<br>
application doesn't get localized for all regions for which Macintosh system software is<br>
localized and if some versions of your application get used in regions for which they<br>
aren't localized. To work around this problem, the range of format strings that a given<br>
version of the software offers should include all formats commonly used in any of the<br>
regions in which this version might be used, and your application should also let users<br>
enter their own format strings. 
</p>
<p>
Second, the format strings are interpreted with reference to the characters defined by<br>
the number parts table that you pass into the Text Utilities StringToFormatRec<br>
routine. You have to be sure to use a number parts table whose characters are<br>
compatible with the strings you provide. Currently, only the characters defined by the<br>
U.S. 'itl4' resource are documented. To deal with this situation, we'll take advantage of<br>
the fact that the U.S. 'itl4' resource is always available and will use its characters as a<br>
stable reference point. We'll define all format strings using the U.S. characters, and<br>
use the number parts table in the U.S. 'itl4' resource to interpret them. 
</p>
<p>
Third, if you match a format string against the number parts table of the default 'itl4'<br>
resource, you'll have to make sure that your application doesn't break if the user<br>
defines a custom number format and the Numbers control panel patches the new<br>
decimal and thousands separators into the 'itl4' resource.&nbsp;&nbsp;&nbsp;Therefore, we'll have to<br>
undo all changes that the user may have made with the control panel before we can use<br>
an 'itl4' resource to interpret our format strings.
</p>
<p>
Unfortunately, there's no guarantee that other parts of the number parts table won't<br>
be modified by the Numbers control panel in the future. This means that a format<br>
string that can be converted under the current mechanism may become unconvertible<br>
in the future, just as a valid 7.0 format string may no longer be recognized by the 7.1<br>
StringToFormatRec routine. There's not much you can do about this until you know it's<br>
happened. 
</p>
<p>
An alternative approach that avoids this problem is to store internal representations<br>
of format specifications instead of format strings in the application's resources. The<br>
internal representations are created by a separate tool that's run on unmodified U.S.<br>
system software during the development process. This approach, however, makes it<br>
more difficult for localizers to look at the format strings and to create new ones, and<br>
also makes it slightly more difficult to use an additional feature that we'll discuss<br>
later, in the "Converting Format Strings" section. I therefore prefer to keep format<br>
strings in the application and convert them at run time. 
</p>
<p>
So, to display numbers in a user-specified format, we do the following:
</p>
<ol>
<li>Define all format strings using the characters given by the default U.S.<br>
'itl4' resource and documented in<i>Inside Macintosh: Text,</i> pages 5-39 to 5-43.</li>
<li>Set up two separate number parts tables: one "reference" table that will<br>
be used to interpret the predefined format strings and one "user" table that<br>
reflects the user's formatting needs.</li>
<li>Using the reference number parts table, convert the predefined format<br>
strings into the Text Utilities' internal numeric representation.</li>
<li> Using the user number parts table, convert the internal numeric<br>
representation into format strings that can be displayed to users (to let them<br>
select a preferred format, for example). </li>
<li> Using the user number parts table, convert a format string that the user<br>
has entered into an internal numeric representation. </li>
<li> Format numbers using the user number parts table. </li>
</ol>
<p>
<i>&nbsp;Inside Macintosh: Text</i> , pages 5-35 to 5-44, goes into great detail about how to<br>
format numbers according to the user's specifications. The approach I describe here<br>
differs somewhat from that approach. Instead of assuming that all format strings are<br>
localized for the language supported by the default 'itl4' resource, we prepare the<br>
application to support format strings from two different sources, the application<br>
resources and the user, by using separate number parts tables for them. This is shown<br>
in Figure 2, which essentially replaces the upper left portion of the data flow diagram<br>
on page 5-37 of<i> Inside Macintosh: Text.&nbsp;&nbsp;</i> In all other places where the diagram<br>
in<i>Inside Macintosh: Text</i>&nbsp;&nbsp;shows a number parts table, we use the user number parts<br>
table. 
</p>
<p>
<img src="img/268.gif" width="375 px"></img>
</p>
<p>
<b>Figure 2</b> Number Formatting Using Two Different Number Parts Tables
</p>
<p class="spacer">&nbsp;</p>
<p>
<b>&nbsp;DEFINING FORMAT STRINGS</b><br>
Which format strings you provide with your application depends on the countries you<br>
want to target and the specific needs of your users. Here are some sample strings that<br>
you may want to use: * '###,###.##;-###,###.##;0.##' can be used for<br>
floating-point numbers with an absolute value of less than one million, with a<br>
thousands separator and the minus sign for negative numbers, and without padding.&nbsp;&nbsp;&nbsp;*<br>
'###,###.##;(###,###.##);0.##' is similar, but with parentheses to<br>
represent negative numbers, as is customary in some countries.&nbsp;&nbsp;&nbsp;* '+^^^;-^^^;^^^^'<br>
can be used for integer numbers with an absolute value of less than one thousand, with<br>
signs for both positive and negative numbers, and with padding to four places with a<br>
space character as may be necessary for alignment. 
</p>
<p>
&nbsp;When you define the format strings, there are a few things you have to watch out for.<br>
Most important, the predefined format strings shouldn't include any literal text, as<br>
this text is almost guaranteed to be inappropriate for the regions the application isn't<br>
localized for. (Note that it may be inappropriate even for the target region; for<br>
example, you shouldn't embed currency symbols, because many users deal with<br>
foreign currency.)
</p>
<p>
&nbsp;Also, conversion from U.S. to localized characters really only works for characters<br>
that are listed as separate tokens in<i>Inside Macintosh: Text</i> , page B-56, not for<br>
unquoted characters or other text. For example, parentheses are unquoted characters<br>
and don't get converted to the special right-to-leftparentheses used by the Arabic and<br>
Hebrew script systems. As a result, neither a format string that contains parentheses<br>
nor numbers formatted with it display correctly on Arabic, Persian, or Hebrew<br>
system software. To avoid problems like this, make sure to test your software on the<br>
system software for all countries that you want to target. 
</p>
<p>
Finally, the format string specifies the maximum number of predecimal digits in a<br>
formatted number, and the formatting routine will report an error if the number<br>
doesn't fit into the format. This means that your program has to ensure that the format<br>
strings have enough predecimal digits to accommodate all numbers that may need to be<br>
formatted. If the predefined strings you need get too long, you may want to use a<br>
simplified version that you can show to users without scaring them. 
</p>
<p>
<b>SETTING UP THE NUMBER PARTS TABLES</b><br>
Now we'll set up the number parts tables that we'll use. The reference table is based on<br>
the U.S. 'itl4' resource, but we'll undo all changes that the user may have made with<br>
the control panel. The user table is based on the system's default number parts table<br>
and the user's selections in the Numbers or International control panel. 
</p>
<p>
Again, we assume that your application doesn't check for changes in the Script Manager<br>
state, and therefore we cache the number parts tables that we need at launch time. The<br>
tables are initialized by calling InitializeNumberPartsTables. If the user number<br>
parts table is an unmodified U.S. table, only one table is allocated, and both pointers<br>
reference this table. 
</p>
<p>
<code>VAR gUserNumberPartsTable:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NumberPartsPtr;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;gReferenceNumberPartsTable: NumberPartsPtr;</code><br>
<code>VAR gSystemVersion:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LongInt;</code>
</p>
<p>
The function GetUserItl4 gets the 'itl4' resource that matches the user's selection in<br>
the Numbers or International control panel. This isn't necessarily the default 'itl4'<br>
resource. 
</p>
<p>
<code>FUNCTION GetUserItl4:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Handle;</code><br>
<code>VAR theItl4Handle:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Handle;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;systemScript:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ScriptCode;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;tableOffset, tableLength:&nbsp;&nbsp;&nbsp;LongInt;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;theItl0Handle:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Handle;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;theResID:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;theResType:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ResType;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;theResName:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Str255;</code>
</p>
<p class="spacer">&nbsp;</p>
<p>
System 7 provides a new routine, GetIntlResourceTable (IUGetItlTable), that returns<br>
the number parts table of the default 'itl4' resource. However, the effect of the<br>
International control panel on the default 'itl4' resource differs from that of the<br>
Numbers control panel, as explained earlier, and we take some extra steps to achieve<br>
the behavior that best matches the control panel's behavior. The International control<br>
panel selects an 'itl0' resource but doesn't affect the 'itl4' resource. If we continued<br>
using the default 'itl4' resource, the user wouldn't see any effect from the control<br>
panel selection. To make up for this, we'll try to find an 'itl4' resource that matches<br>
the 'itl0' that the user selected, and use it instead of the default 'itl4'. The Numbers<br>
control panel, on the other hand, updates the decimal and thousands separators in the<br>
'itl4' resource, and changes in the default 'itl0' resource are limited to the features<br>
visible in the control panel. Therefore, the best solution in this case is to use the<br>
default 'itl4' resource. 
</p>
<p>
<code>BEGIN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;IF gSystemVersion &gt;= $0710 THEN BEGIN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;systemScript := GetEnvirons(smSysScript);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IUGetItlTable(systemScript, iuNumberPartsTable, theItl4Handle,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tableOffset, tableLength);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FailNILResource(theItl4Handle);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;END</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;ELSE BEGIN</code>
</p>
<p class="spacer">&nbsp;</p>
<p>
The workaround used here is to ask the system for the 'itl0' resource and then try to<br>
find an 'itl4' resource with a matching number. Some countries, however, have<br>
multiple 'itl0' resources and only one 'itl4' resource, or they don't have any 'itl4'<br>
resource of their own (they use the U.S. version). To cover these cases, we have to go<br>
through an exception table. 
</p>
<p>
<code>theItl0Handle := IUGetIntl(0);</code><br>
<code>FailNILResource(theItl0Handle);</code><br>
<code>GetResInfo(theItl0Handle, theResID, theResType, theResName);</code><br>
<code>theItl4Handle := GetResource('itl4', theResID);</code><br>
<code>IF ResError = resNotFound THEN BEGIN</code>
</p>
<p class="spacer">&nbsp;</p>
<p>
The exceptions in system software versions 7.0 and 7.0.1 are as follows:
</p>
<ul>
<li>the Netherlands: 'itl0' IDs 5 and 6; 'itl4' only ID 5. </li>
<li>Czechoslovakia: 'itl0' IDs 30776, 30777, 56, 57; 'itl4' only ID 30776.</li>
</ul>
<p>
Note that 'itl0' 56 occurs in both the Czechoslovakian and Polish versions. For all<br>
other cases, we try the U.S. resource. 
</p>
<p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CASE theResID OF</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6: theResID := 5;&nbsp;&nbsp;&nbsp;{ Netherlands }</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;30777, 56, 57: theResID := 30776; { Czechoslovakia }</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OTHERWISE theResID := verUS;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;END;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theItl4Handle := GetResource('itl4', theResID);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FailNILResource(theItl4Handle);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;END</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELSE</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FailNILResource(theItl4Handle);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;END;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GetUserItl4 := theItl4Handle;</code><br>
<code>END;</code>
</p>
<p class="spacer">&nbsp;</p>
<p>
In the procedure InitializeDefaultNumberSeparators we've verified that the characters<br>
the user has specified as decimal and thousands separators don't conflict with the use of<br>
these separators for default formatting. Here, we have to take one additional step: the<br>
Text Utilities routines for user- specified formatting don't work if the same character<br>
is used for different purposes in the number parts table. For instance, a character<br>
can't be used both as the decimal separator and to represent digits in a format string. If<br>
the routines find a number parts table they don't like, they return the fBadPartsTable<br>
result. The procedure CheckDefaultNumberSeparators uses this to check for problems<br>
in the user number parts table (which contains the default separators) at application<br>
initialization time. In real life, your application should produce a more meaningful<br>
message explaining to the user what went wrong and then should quit. 
</p>
<p>
<code>PROCEDURE CheckDefaultNumberSeparators(userNumberPartsTable:</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NumberPartsPtr);</code><br>
<code>CONST&nbsp;&nbsp;&nbsp;testString = '0';</code><br>
<code>VAR formatRecord:&nbsp;&nbsp;&nbsp;NumFormatString;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FormatStatus;</code><br>
<code>BEGIN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;result := Str2Format(testString, userNumberPartsTable^,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;formatRecord);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;IF FormatResultType(result) &lt;&gt; fFormatOK THEN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FailOSErr(paramErr);</code><br>
<code>END;</code>
</p>
<p class="spacer">&nbsp;</p>
<p>
The procedure ExtractNumberPartsTable is used by the InitializeNumberPartsTables<br>
routine to extract a number parts table from an 'itl4' resource. 
</p>
<p>
<code>FUNCTION ExtractNumberPartsTable(theItl4Handle: Handle):</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NumberPartsPtr;</code><br>
<code>VAR tableOffset:&nbsp;&nbsp;&nbsp;&nbsp;LongInt;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;tableLength:&nbsp;&nbsp;&nbsp;&nbsp;LongInt;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;theTable:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ptr;</code><br>
<code>BEGIN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;WITH NItl4Handle(theItl4Handle)^^ DO BEGIN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tableOffset := defPartsOffset;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tableLength := defPartsLength;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;END;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;theTable := NewPtr(tableLength);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;FailNIL(theTable);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;LoadResource(theItl4Handle);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;{ Might have been purged since we got hold of it }</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;FailResError;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;BlockMove(Ptr(LongInt(theItl4Handle^) + tableOffset), theTable,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tableLength);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;ExtractNumberPartsTable := NumberPartsPtr(theTable);</code><br>
<code>END;</code>
</p>
<p class="spacer">&nbsp;</p>
<p>
The procedure InitializeNumberPartsTables initializes gUserNumberPartsTable and<br>
gReferenceNumberPartsTable by copying the tables from the respective 'itl4'<br>
resources into nonrelocatable blocks in the heap and cleaning the reference table if<br>
necessary. 
</p>
<p>
<code>PROCEDURE InitializeNumberPartsTables;</code><br>
<code>VAR userItl4, usItl4: Handle;</code><br>
<code>BEGIN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;userItl4 := GetUserItl4;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;usItl4 := GetResource('itl4', verUS);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;FailNILResource(usItl4);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;gUserNumberPartsTable := ExtractNumberPartsTable(userItl4);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;CheckDefaultNumberSeparators(gUserNumberPartsTable);</code>
</p>
<p class="spacer">&nbsp;</p>
<p>
We check whether the user number parts table is an unmodified U.S. table, so we can<br>
use it as the reference table as well. 
</p>
<p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;IF (usItl4 = userItl4) AND ((gSystemVersion &lt; $0710) OR</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((gDefaultDecimalSeparator = '.') AND</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(gDefaultThousandsSeparator = ','))) THEN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gReferenceNumberPartsTable := gUserNumberPartsTable</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;ELSE BEGIN</code>
</p>
<p class="spacer">&nbsp;</p>
<p>
We need to get the U.S. number parts table and undo any changes that the user may have<br>
made with the Numbers control panel.
</p>
<p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gReferenceNumberPartsTable := ExtractNumberPartsTable(usItl4);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gReferenceNumberPartsTable^.data[tokDecPoint].a[1] := '.';</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gReferenceNumberPartsTable^.data[tokThousands].a[1] := ',';</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;END;</code><br>
<code>END;</code>
</p>
<p>
The procedure DisposeNumberPartsTables disposes of the global number parts tables. 
</p>
<p>
<code>PROCEDURE DisposeNumberPartsTables;</code><br>
<code>BEGIN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;IF gReferenceNumberPartsTable &lt;&gt; gUserNumberPartsTable THEN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DisposPtr(Ptr(gReferenceNumberPartsTable));</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;DisposPtr(Ptr(gUserNumberPartsTable));</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;gReferenceNumberPartsTable := NIL;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;gUserNumberPartsTable := NIL;</code><br>
<code>END;</code>
</p>
<p>
<b>CONVERTING FORMAT STRINGS</b><br>
Now that we have the two number parts tables, we're going to use them to do some<br>
conversions.&nbsp;&nbsp;&nbsp;We're going to convert our predefined format strings into the Text<br>
Utilities' internal numeric representation, convert this representation into format<br>
strings that can be displayed to the user, and convert format strings entered by the<br>
user into internal representations.
</p>
<p>
But first, remember the alternate numerals table mentioned earlier? It's time now to<br>
reveal a previously undocumented feature: if a number parts table used for converting<br>
a format string to its internal numeric representation contains a character other than<br>
"#" as the no-leader format marker, the resulting internal numeric representation<br>
will specify using the alternate numerals. 
</p>
<p>
We can use this knowledge to write a wrapper around the StringToFormatRec<br>
(Str2Format) routine that temporarily replaces the no-leader format marker,<br>
adjusts the format string to use the replacement character as well, calls<br>
StringToFormatRec, and reverts the number parts table to its original state. A<br>
convenient replacement character is "1," because digits are very unlikely to be used<br>
for any other purpose in any version of the number parts table. As the character code<br>
for "#" is in a range that isn't used for the bytes of 2-byte characters, we don't have<br>
to check for 2-byte characters here. 
</p>
<p>
Here's what the wrapper routine looks like:
</p>
<p>
<code>PROCEDURE StringToFormatRecord(formatString: Str255;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;useAlternateNumerals: Boolean;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theNumberPartsTable: NumberPartsPtr;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR formatRecord: NumFormatString);</code><br>
<code>VAR result: FormatStatus;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oldChar:&nbsp;&nbsp;&nbsp;&nbsp;WideChar;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer;</code><br>
<code>BEGIN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;IF useAlternateNumerals THEN BEGIN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oldChar := theNumberPartsTable^.data[tokNonLeader];</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theNumberPartsTable^.data[tokNonLeader].b := Ord('1');</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FOR i := 1 TO Length(formatString) DO</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF formatString[i] = '#' THEN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;formatString[i] := '1';</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;END;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;result := Str2Format(formatString, theNumberPartsTable^,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;formatRecord);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;IF useAlternateNumerals THEN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theNumberPartsTable^.data[tokNonLeader] := oldChar;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;IF FormatResultType(result) &lt;&gt; fFormatOK THEN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FailOSErr(paramErr);</code><br>
<code>END;</code>
</p>
<p class="spacer">&nbsp;</p>
<p>
When do you use alternate numerals? First you have to find out whether the user 'itl4'<br>
resource you're using supports alternate numerals. You can use the following routine<br>
to do this. If it returns TRUE, you should let the user make the final decision whether<br>
to use the alternate numerals for output -- you can't take for granted that they're<br>
always preferred over the ASCII digits. For input, it probably makes sense to accept<br>
them without bothering the user first. An exception is the alternate numerals in<br>
bidirectional scripts, where the internal representation of the number won't match<br>
what the user sees on the screen. You probably shouldn't accept these digits. 
</p>
<p>
<code>FUNCTION HasAlternateNumerals</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(aNumberPartsTable: NumberPartsPtr): Boolean;</code><br>
<code>BEGIN</code><br>
<code>HasAlternateNumerals :=</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aNumberPartsTable^.altNumTable.data[0].b &lt;&gt; Ord('0');</code><br>
<code>END;</code>
</p>
<p>
Obviously, the decision whether to use alternate numerals has to be made at run time.<br>
This is the second reason I recommended storing format strings and not internal<br>
representations in the&nbsp;&nbsp;application: with internal representations, you would have to<br>
store both versions and select the right one at run time; with format strings, you only<br>
store one version and decide at run time how to convert it. 
</p>
<p>
Given this preparation and the two number parts tables, the remaining steps are<br>
straightforward. The following routines do no more than call StringToFormatRecord<br>
and FormatRecToString with the appropriate number parts table and check for errors<br>
that might occur. 
</p>
<p>
PredefinedStringToFormatRecord converts a predefined format string using the<br>
standard U.S.&nbsp;&nbsp;&nbsp;number parts table into an internal numeric representation. 
</p>
<p>
<code>PROCEDURE PredefinedStringToFormatRecord</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(predefinedFormatString: Str255;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;useAlternateNumerals: Boolean;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR formatRecord: NumFormatString);</code><br>
<code>BEGIN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;StringToFormatRecord(predefinedFormatString,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;useAlternateNumerals,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gReferenceNumberPartsTable, formatRecord);</code><br>
<code>END;</code>
</p>
<p>
FormatRecordToUserString converts an internal numeric representation into a format<br>
string that can be displayed to the user. 
</p>
<p>
<code>PROCEDURE FormatRecordToUserString(formatRecord: NumFormatString;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR userFormatString: Str255);</code><br>
<code>VAR result: FormatStatus;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;positions: TripleInt;</code><br>
<code>BEGIN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;result := Format2Str(formatRecord, gUserNumberPartsTable^,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;userFormatString, positions);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;IF FormatResultType(result) &lt;&gt; fFormatOK THEN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FailOSErr(paramErr);</code><br>
<code>END;</code>
</p>
<p>
UserStringToFormatRecord converts a format string entered by the user into an<br>
internal numeric representation. 
</p>
<p>
<code>PROCEDURE UserStringToFormatRecord(userFormatString: Str255;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;useAlternateNumerals: Boolean;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR formatRecord: NumFormatString);</code><br>
<code>BEGIN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;StringToFormatRecord(userFormatString, useAlternateNumerals,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;gUserNumberPartsTable, formatRecord);</code><br>
<code>END;</code>
</p>
<p>
<b>FORMATTING NUMBERS</b><br>
After all the preparations, the formatting itself is trivial. FormatNumber formats<br>
theNumber into a string, using the internal numeric representation given and the user<br>
number parts table.
</p>
<p>
<code>PROCEDURE FormatNumber(theNumber: Extended;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theFormatRecord: NumFormatString;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR theString: Str255);</code><br>
<code>VAR result: FormatStatus;</code><br>
<code>BEGIN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;result := FormatX2Str(theNumber, theFormatRecord,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;gUserNumberPartsTable^, theString);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;IF FormatResultType(result) &lt;&gt; fFormatOK THEN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FailOSErr(paramErr);</code><br>
<code>END;</code>
</p>
<p class="spacer">&nbsp;</p>
<h2>NUMERIC INPUT</h2>
<p>
Now let's look at conversions in the opposite direction. When the user enters a<br>
number, your application receives a numeric string that it has to convert into a<br>
number. This could be quite a difficult task, given that a user may pick a rather<br>
arbitrary format (and remember, Macintosh users are generally inclined to do things<br>
their own way). Unfortunately, the Toolbox doesn't provide a routine that simply<br>
converts an arbitrary numeric string to a number; your application always has to<br>
specify the acceptable format. 
</p>
<p>
We can reasonably make some simplifying assumptions: If your application doesn't<br>
support output in formats other than ASCII digits, it's probably acceptable to apply the<br>
same restriction to the input formats that can be used. And if your application uses<br>
only the default format for display, you can also get away with allowing input in this<br>
format only, although it would be nicer to accept input in any format the user prefers.<br>
If your application supports user-specified number formats, however, it should be<br>
prepared to accept input in any currently defined format, and probably in some<br>
variations of them, plus the default format. 
</p>
<p>
The Toolbox provides three routines that convert numeric strings into numbers.<br>
StringToNum can parse integer numbers but can't deal with anything that goes beyond<br>
a sequence of decimal digits that's possibly preceded by a sign. The SANE routine<br>
Str2Num can parse floating-point numbers and does detect erroneous input, but it<br>
assumes the period as the decimal separator and doesn't support thousands separators.<br>
Finally, StringToExtended is supposed to support input of numeric strings in a<br>
localized format, but it can deal with only one format at a time and has several other<br>
shortcomings that we'll look at later.
</p>
<p>
We'll take the same approach as with number display and provide separate routines<br>
that can deal with the default number format and with user-specified formats. 
</p>
<p>
<b>INTERPRETING NUMBERS IN THE DEFAULT NUMBER FORMAT</b><br>
This solution restricts user input to something that's very close to the default number<br>
format. Then we can simply reverse the "localization" process done for the default<br>
format -- that is, strip thousands separators and modify the decimal separator -- and<br>
call the StringToNum routine or SANE directly to interpret the number. 
</p>
<p>
The procedure UnlocalizeNumberString checks whether theString is a legal number<br>
string, strips all thousands separators, and replaces the default decimal separator<br>
with a period. As the default number format consists only of ASCII digits, the minus<br>
sign, and thousands and decimal separators (which are limited to one byte by the 'itl0'<br>
resource), we don't have to worry about 2-byte characters here if we walk the string<br>
and check each character (we would have to worry if we used a string search routine).
</p>
<p class="spacer">&nbsp;</p>
<p>
<code>PROCEDURE UnlocalizeNumberString(VAR theString: Str255;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allowDecimal: Boolean);</code><br>
<code>VAR delta:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;i:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;theChar:&nbsp;&nbsp;&nbsp;&nbsp;Char;</code><br>
<code>BEGIN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;delta := 0;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;FOR i := 1 TO Length(theString) DO BEGIN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theChar := theString[i];</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF (theChar &gt;= '0') &amp; (theChar &lt;= '9') THEN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theString[i - delta] := theChar</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELSE IF (theChar = '-') &amp; (i = 1) THEN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theString[i - delta] := theChar</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELSE IF theChar = gDefaultThousandsSeparator THEN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delta := delta + 1</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELSE IF theChar = gDefaultDecimalSeparator THEN BEGIN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF allowDecimal THEN BEGIN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allowDecimal := FALSE; { one is enough }</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theString[i - delta] := '.';</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;END</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELSE</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FailOSErr(paramErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;END</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELSE</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FailOSErr(paramErr);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;END;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;theString[0] := Char(Length(theString) - delta);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;IF Length(theString) = 0 THEN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FailOSErr(paramErr);</code><br>
<code>END;</code>
</p>
<p class="spacer">&nbsp;</p>
<p>
And here we finally come to the two routines that your application will call directly to<br>
interpret numeric strings. The first one is intended for integer numbers, the other<br>
one for floating-point numbers. 
</p>
<p>
LocalStringToInteger converts to an integer a numeric string that we're hoping<br>
represents an integer. The string may contain localized thousands separators. 
</p>
<p>
<code>PROCEDURE LocalStringToInteger(theString: Str255;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR theNumber: LongInt);</code><br>
<code>BEGIN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;UnlocalizeNumberString(theString, FALSE);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;StringToNum(theString, theNumber);</code><br>
<code>END;</code>
</p>
<p>
LocalStringToExtended converts to an equivalent floating-point number a numeric<br>
string that we're hoping represents a fixed-point number. The string may contain<br>
localized thousands and decimal separators. 
</p>
<p>
<code>PROCEDURE LocalStringToExtended(theString: Str255;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR theNumber: Extended);</code><br>
<code>BEGIN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;UnlocalizeNumberString(theString, TRUE);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;theNumber := Str2Num(theString);</code><br>
<code>END;</code>
</p>
<p>
<b>INTERPRETING NUMBERS IN USER-SPECIFIED NUMBER FORMATS</b><br>
Now we can benefit from some of the work that we did to display a number in a<br>
user-specified number format: we use the same number parts tables and the same<br>
format conversion routines.&nbsp;&nbsp;&nbsp;However, because we can't really constrain users to any<br>
given format for input, we have to allow them at least to use any currently defined<br>
format, including the default format. To do this, your application should try the default<br>
format and all currently defined format strings until it finds one for which the<br>
conversion is successful. 
</p>
<p>
The core of this conversion is the StringToExtended (FormatStr2X) routine, and it<br>
helps to understand how this routine works. You get the most reliable results from<br>
StringToExtended if users enter numbers exactly in one of the three possible formats<br>
given by a format string (for positive and negative numbers and 0). In this case it<br>
returns fFormatOK. If the input string doesn't conform to any of the three formats,<br>
StringToExtended tries to guess: it replaces the default decimal separator in the string<br>
with a period, moves the minus sign to the beginning of the string, and strips some<br>
other punctuation. If the resulting string can be interpreted by SANE,<br>
StringToExtended returns fBestGuess and the number found by SANE; otherwise<br>
StringToExtended returns one of several other values that indicate why the string<br>
cannot be interpreted. 
</p>
<p>
You can control how liberal your application is by either allowing fBestGuess as a<br>
result of StringToExtended or treating it as an error. If you don't allow fBestGuess, the<br>
input string can deviate from the specified format in only the following two ways:
</p>
<ul>
<li> If you specify parentheses to indicate negative numbers,<br>
StringToExtended recognizes parenthesized numbers as negative but still also<br>
accepts numbers with a minus sign. This helps in many countries where<br>
negative numbers can be written with either a minus sign or parentheses. </li>
<li> If you set useAlternateNumerals to TRUE when you converted your format<br>
string, StringToExtended accepts ASCII digits in addition to the alternate<br>
numerals. </li>
</ul>
<p>
If you allow fBestGuess, the following deviations (and more) are also allowed:
</p>
<ul>
<li>The minus sign for negative numbers can occur anywhere in the number.<br>
That may be nice for some people who prefer to write the minus at the end, but<br>
interpreting "12-3" as -123 doesn't make sense. </li>
<li>Thousands separators can be missing or in the wrong place. </li>
<li>A fractional part can be present while the format string doesn't provide<br>
for it. </li>
<li>A decimal separator and fractional part specified in the format string can<br>
be missing. </li>
<li>More predecimal digits than specified by the format can be present. </li>
</ul>
<p>
Because the guessing process ignores some of the information entered by the user, it<br>
may behave inconsistently with the behavior shown when the format is OK. For<br>
example, if your format string uses parentheses to indicate negative numbers and also<br>
specifies thousands separators, "(123)" will be read as -123 (with fFormatOK), but<br>
"(1234)" will be read as 1234 (with fBestGuess). The missing thousands separator<br>
causes StringToExtended to go into the guessing pass, and there the parentheses are<br>
stripped instead of being interpreted as the indicator for "negative."
</p>
<p>
This situation is somewhat unfortunate. On one hand, checking for fFormatOK alone<br>
doesn't give users much freedom to type numbers in their preferred format -- for<br>
instance, where a fractional part is specified, they must at least enter the decimal<br>
separator. On the other hand, allowing fBestGuess may mean that some pretty bizarre<br>
strings are accepted and may lead to inconsistent interpretation of parentheses. It<br>
seems that for integer strings allowing fBestGuess is never a good solution, while for<br>
real values it might be OK as long as you don't support expressing negative numbers<br>
with parentheses. To play it safe, I don't allow fBestGuess in the code that follows. 
</p>
<p>
To provide the appropriate handling and return the desired type of number, here are<br>
two different routines that interpret numeric strings representing floating-point and<br>
integer numbers. They both return Booleans to tell the caller whether theString was<br>
successfully converted. 
</p>
<p>
InterpretExtended interprets a numeric string and converts it to an Extended number.
</p>
<p class="spacer">&nbsp;</p>
<p>
<code>FUNCTION InterpretExtended(theString: Str255;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theFormatRecord: NumFormatString;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR theNumber: Extended): Boolean;</code><br>
<code>VAR result: FormatStatus;</code><br>
<code>BEGIN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;result := FormatStr2X(theString, theFormatRecord,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gUserNumberPartsTable^, theNumber);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;InterpretExtended := FormatResultType(result) = fFormatOK;</code><br>
<code>END;</code>
</p>
<p>
InterpretInteger interprets a numeric string that (we hope) represents an integer and<br>
converts it to the equivalent LongInt. 
</p>
<p>
<code>FUNCTION InterpretInteger(theString: Str255;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theFormatRecord: NumFormatString;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR theNumber: LongInt): Boolean;</code><br>
<code>VAR result:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FormatStatus;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theExtended:&nbsp;&nbsp;&nbsp;&nbsp;Extended;</code><br>
<code>CONST</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minLongInt = -2147483648;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxLongInt = 2147483647;</code><br>
<code>BEGIN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;result := FormatStr2X(theString, theFormatRecord,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gUserNumberPartsTable^, theExtended);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;IF (FormatResultType(result) = fFormatOK) &amp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(theExtended &gt;= minLongInt) &amp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(theExtended &lt;= maxLongint) THEN BEGIN</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theNumber := Num2LongInt(theExtended);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InterpretInteger := TRUE;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;END</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;ELSE</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InterpretInteger := FALSE;</code><br>
<code>END;</code>
</p>
<h2>TESTING THE CODE</h2>
<p>
The Numbers Test application on this issue's CD tests all the routines that we've seen<br>
so far. It's a simple, text-based application that spits out a few numbers in the default<br>
format, converts a few format strings and displays them in the localized version, and<br>
then runs a test that reads in numbers and formats them according to format strings.<br>
In a real program, you would of course get the format strings and the messages from<br>
resources. In case you prefer to play with an MPW tool, you can use the BuildNumbers<br>
script on the CD to build a tool that's equivalent to the application.
</p>
<p>
One final warning in case you don't check out the source code: Before using the routines<br>
described in this article, your application has to check that it runs on system software<br>
version 7.0 or higher, because the section "Setting Up the Number Parts Tables"<br>
makes some assumptions about this. 
</p>
<h2>OFF YOU GO</h2>
<p>
If you compare the user expectations described at the beginning of this article and what<br>
we've actually achieved with the Toolbox, you'll find that we've been only partially<br>
successful. The code handles the default number format and some user-specified<br>
customizations, but it's still limited to decimal numbers expressed in ASCII digits and<br>
to additional characters supported by the 'itl4' resource. 
</p>
<p>
You may consider adding code of your own to make your number handling more<br>
flexible. There's an obvious need for support for nondecimal numbers. Many<br>
specialized applications already support Roman numerals or hexadecimal numbers;<br>
your application could similarly support traditional Chinese numbers or decimal<br>
numbers using Chinese digits. 
</p>
<p>
When you add your own number support, you should always design it as an extension to<br>
the facilities provided by system software, not as a replacement. The Macintosh is<br>
being localized into ever more languages to reach ever more customers, and you'll be<br>
more successful if your application is at least as good as system software worldwide. 
</p>
<p>
<b>REFERENCES</b>
</p>
<ul>
<li><i>Apple Numerics Manual</i> , 2nd ed. (Addison-Wesley, 1988).</li>
<li><i>Inside Macintosh: Text </i> (Addison-Wesley, 1993). See Chapter 1,<br>
"Introduction to Text on the Macintosh"; Chapter 5, "Text Utilities"; Chapter<br>
6, "Script Manager"; and Appendix B, "International Resources."</li>
</ul>
<p>
<b>NORBERT LINDENBERG </b>is an import from Germany who still wonders why there<br>
are offices in California that don't have windows and need artificial light while the sun<br>
is shining outside, and how Americans can survive on 12 days of vacation a year<br>
instead of the normal six weeks. While a student at the University of Karlsruhe,<br>
Norbert developed the Literate Programming Workshop, which he claims is the best<br>
environment for doing literate programming. (Literate programming is similar to a<br>
<i>develop</i>&nbsp;&nbsp;article in that you combine source code and documentation in one document,<br>
but different because you compile the source code right out of this integrated source<br>
document.) Now he actually gets paid for writing literate programs for Apple's<br>
International Software Support Group. *<b>For background information on</b><br>
<b>number formatting, </b> see Chapter 5, "Text Utilities," in <i> Inside Macintosh: Text</i> .<br>
For definitions of basic terms used in this article, see Chapter 1, "Introduction to Text<br>
on the Macintosh," in the same volume. *
</p>
<p>
<b>The number in international resource types </b>isn't related to functionality.<br>
Resources of type 'itl1' contain long date strings; resources of type 'itl2' deal with text<br>
handling (sorting, uppercase and lowercase, word boundaries); and resources of type<br>
'itl5' define rendering and character encoding. There are no resources of type 'itl3'. *
</p>
<p>
<b>GetIntlResource or IUGetIntl? </b>With the new edition of <i>Inside Macintosh</i> , many<br>
Toolbox routines have been renamed. However, interface files defining the new names<br>
are not yet available for all Macintosh programming environments. Therefore, I use<br>
the new names in the documentation, followed by the old names in parentheses, and I<br>
use the old names in the source code.*
</p>
<p>
<b>GetIntlResource (IUGetIntl) </b>is described in <i>Inside Macintosh: Text</i> , pages 6-90<br>
to 6-91. The international resources selection flag is described in <i>Inside Macintosh:</i><br>
<i>Text</i> , pages 6-21 to 6-26.*
</p>
<p>
<b>SANE </b>is the set of routines for floating-point calculations in Apple computers. It's<br>
documented in the <i> Apple Numerics Manual</i> .*
</p>
<p>
<b>NumToString </b>is described in <i>Inside Macintosh: Text</i> , page 5-92.*
</p>
<p>
<b>DecForm and Num2Str </b>are described in the <i> Apple Numerics Manual</i> , second<br>
edition, pages 26 to 27. *
</p>
<p>
<b>Number parts tables </b>are described in more detail in <i>Inside Macintosh: Text</i> , pages<br>
B-55 to&nbsp;&nbsp;B-57.*
</p>
<p>
<b>GetIntlResourceTable (IUGetItlTable) </b>is described in <i>Inside Macintosh: Text</i> ,<br>
pages 6-91 to 6-92.*
</p>
<p>
<b>StringToFormatRec (Str2Format) </b>is described in <i>Inside Macintosh: Text</i> , pages<br>
5-95 to 5-96.*
</p>
<p>
<b>FormatRecToString (Format2Str) </b>is described in <i>Inside Macintosh: Text</i> , pages<br>
5-96 to 5-98.*
</p>
<p>
<b>StringToNum and StringToExtended (FormatStr2X) </b>are described in <i>Inside</i><br>
<i>Macintosh: Text</i> . See pages 5-93 to 5-94 for StringToNum, and pages 5-98 to 5-99<br>
for StringToExtended.*
</p>
<p>
<b>Str2Num </b>is described in the <i>Apple Numerics Manual</i> , second edition, pages 25 to 26.<br>
*
</p>
<p>
<b>Result values for StringToExtended </b>are described in <i> Inside Macintosh: Text</i> ,<br>
page 5-38.*
</p>
<p>
<b>Num2LongInt </b>is described in the <i>Apple Numerics Manual,</i>&nbsp;&nbsp;second edition, page 22.*
</p>
<p>
<b>THANKS TO OUR TECHNICAL REVIEWERS </b>Jeannette Cheng, Peter Edberg, Bryan<br>
K. ("Beaker") Ressler, Kenny Tung *
</p>
</body>
</html>
