<html>
<head>
<!-- Article ID: 35 - Extracted from develop-1993 -->
<!-- on 2024-02-03 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by the copyright of its respective owners -->
<title>September 93 - WORKING IN THE THIRD DIMENSION</title>
<link href="../common/styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h2>WORKING IN THE THIRD DIMENSION</h2>
<h1>JAMIE OSBORNE AND DEANNA THOMAS</h1>
<p>
<img src="img/221.gif" width="216 px"></img>
</p>
<p>
<i>Macintosh users have a lifetime of experience seeing and manipulating objects in three</i><br>
<i>dimensions. Many developers are taking advantage of this experience by adding</i><br>
<i>three-dimensional elements to their human interfaces. 3-D effects can heighten the</i><br>
<i>ease of use, realism, and visual appeal of your application. This article discusses why</i><br>
<i>3-D effects add value to Macintosh applications and describes an easy way to add 3- D</i><br>
<i>effects to applications created with MacApp.</i>
</p>
<p class="spacer">&nbsp;</p>
<p>
Three-dimensional effects can add life to any user interface. A 3-D interface is<br>
inviting to users. It offers them tactility and can make the user interface elements<br>
they work with stand out. When implemented correctly, the 3-D interface helps users<br>
differentiate between the important contents of a window and the background. The<br>
result is a friendlier, more accessible interface to your application. 
</p>
<p>
This article tells you about some basic 3-D design principles that you can use and<br>
describes one way to implement them. The accompanying code on this issue's CD<br>
contains a set of adorners and classes that make it easy to bring your MacApp<br>
applications into the third dimension. 
</p>
<h2>WHY A 3-D LOOK?</h2>
<p>
Developers have been adding color and 3-D buttons to their products for a couple of<br>
years now.&nbsp;&nbsp;&nbsp;Users like 3-D effects not only because they're nicer to look at but also<br>
because they help define user interface elements within the workspace. There's a clear<br>
message that both users and developers want 3-D effects, and developers aren't holding<br>
off until Apple provides guidelines and tools to implement them. 
</p>
<p>
We've seen many developers come up with their own implementations of gray windows<br>
and 3-D buttons. Even within Apple there are several ideas about what a 3 - D user<br>
interface should look like.&nbsp;&nbsp;&nbsp;Although this article doesn't present an official Apple 3-D<br>
interface, it does describe designs and approaches that we developed while<br>
implementing a 3-D interface and that we think can help you with your own 3-D<br>
interface design. 
</p>
<h2>THE 3-D LOOK</h2>
<p>
In our three-dimensional look, windows have a light gray background instead of the<br>
standard white background. Darker shades of gray and white on the edges of user<br>
interface elements give the illusion that some elements are chiseled into the<br>
background while others appear in bas-relief.&nbsp;&nbsp;&nbsp;There are two special cases: Modal<br>
dialog boxes (windows with the definition ID of dBoxProc) have a gray background, but<br>
do not have the chiseled effect because the color version of the window already has a<br>
3-D border. Scrollable document windows (definition ID of documentProc) do not have<br>
a gray background at all. 
</p>
<p>
The 3-D look offers the user two advantages. First, it creates a clearer work<br>
environment. White interface elements, such as text fields, checkboxes, and pop-up<br>
menus, stand out from the light gray background and call attention to themselves. The<br>
chiseled appearance, though subtle and unobtrusive, effectively communicates the<br>
division of elements within the window. 
</p>
<p>
The second advantage to the 3-D look is that it lets the user work on a more tangible,<br>
tactile surface.&nbsp;&nbsp;&nbsp;The chiseled look gives strong clues that invite interaction. The slight<br>
depression of text fields, for example, invites the user "into" the field to edit text. The<br>
shading around buttons makes them look as if they project slightly from the gray<br>
background. This makes buttons appear pressable, and they react appropriately when<br>
the user clicks them. Our implementation of these elements strives to maintain the<br>
crisp, clean graphical elegance that the Macintosh is known for. 
</p>
<p>
The background gray we use for windows is the lightest gray in the Macintosh palette.<br>
Its RGB value is 61166, 61166, 61166 (hex 0xEEEE). In small areas, this gray is<br>
subtle; it appears to be darker in large areas that have only a few text fields or other<br>
graphical elements. 
</p>
<p>
Chiseled lines define the edges of windows, text fields, and checkboxes. They also help<br>
group related items within a window. To create a chiseled effect on the light gray<br>
background, use white and the fourth gray value from the Macintosh palette. The RGB<br>
value of this medium light gray is 43690, 43690, 43690 (hex 0xAAAA). The way<br>
you use these colors determines whether an object comes toward the user or recedes<br>
into the background. 
</p>
<p>
To chisel an object into the gray background, use gray shading on the object's top and<br>
left edges and white on its bottom and right edges. To make an object project from the<br>
gray background, reverse the order: use white on the top and left edges and gray on the<br>
bottom and right edges. Note that the color of the top and left edges, whether white or<br>
gray, always extends to the far corner pixels. Figure 1 shows both kinds of shading. 
</p>
<p>
<img src="img/222.gif" width="255 px"></img>
</p>
<p>
<b>&nbsp;Figure 1</b> Shading Items for 3-D Effects
</p>
<p>
If you keep in mind that the imaginary light source on the desktop comes from the<br>
upper left corner of the screen, you can always determine where to place the highlight<br>
and shadow colors. 
</p>
<p>
In windows, the background itself should appear to come forward by one pixel. To<br>
create this effect, draw a white line on the top and left edges of the window and a gray<br>
line on the bottom and right edges. Figure 2 shows a window with the background<br>
drawn this way and a scrolling list chiseled into the background. 
</p>
<p>
<img src="img/223.gif" width="576 px"></img>
</p>
<p>
<b>&nbsp;Figure 2</b> A Window With 3-D Effects
</p>
<p>
Though these chiseled effects are subtle, they do give a sense of depth, even if it's<br>
almost subliminal in some cases. Remember, we don't want to hit anyone over the head<br>
with these graphical enhancements. The goal is to add elegance and ease of use to the<br>
work environment, not to scream out "Look at me!"
</p>
<h2>ICON BUTTONS</h2>
<p>
Icon buttons are buttons that use graphics to describe what they do. The page<br>
orientation controls in the standard Page Setup dialog box are good examples of early<br>
icon buttons. One of the great things about icon buttons is that they give pictorial clues<br>
at a glance. The user can usually understand what the buttons do from the way they're<br>
clustered and from their surrounding context. Another advantage of icon buttons is that<br>
they're more accessible and easier to see than menu commands.&nbsp;&nbsp;&nbsp;This makes icon<br>
buttons ideal for frequently used commands. 
</p>
<p>
It's very easy to create poorly designed icons. If you decide to use icon buttons in your<br>
application, take the extra time to do plenty of user testing to make sure your users<br>
think your icons mean what you think they mean. This is especially important if you<br>
decide not to use text labels for your buttons. 
</p>
<p>
Our icon buttons are square or rectangular, and the button is a slightly darker shade of<br>
gray so that it's easily distinguished from the light gray background. The illusion of<br>
height invites the user to press a button. Figure 3 shows a few examples of icon<br>
buttons. 
</p>
<p>
Because icon buttons are dynamic elements with specific characteristics, they need to<br>
maintain a distinct appearance even in black and white , just as checkboxes and radio<br>
buttons do. On a black-and- white screen, we use a 50% dither pattern along the<br>
bottom and right edges of an icon button to give the button height (see Figure 3). When<br>
the user clicks the button, the entire button inverts, maintaining a subtle 3-D look. 
</p>
<p>
<img src="img/224.gif" width="522 px"></img>
</p>
<p>
<b>&nbsp;Figure 3</b> Some Icon Buttons
</p>
<p>
To achieve a consistent 3-D effect, our icon buttons follow certain guidelines. We<br>
always use a 2- to 3-pixel margin between the icon boundaries and the edge of the<br>
surface of a button. The frame and shading that give the icon button its 3-D appearance<br>
extend four pixels in each direction. Figure 4 shows a closeup of an icon button's<br>
shading.&nbsp;&nbsp;When you design your icon buttons, don't forget the additional pixels that<br>
you'll need for the shading. If you want to use a 32 x 32 icon in a button, the minimum<br>
button size is 40 x 40. If you want the entire button, including its shading, to fit in a<br>
32 x 32 space, the icon should fit in roughly a 22 x 22 area so that it sits comfortably<br>
within the button. 
</p>
<p>
<img src="img/225.gif" width="267 px"></img>
</p>
<p>
<b>&nbsp;Figure 4</b> Icon Button Detail
</p>
<p>
As you design your icons, try to keep the image as free form as possible. In general,<br>
the image shouldn't follow the outline of the button. A square icon can hide the<br>
appearance of a square button and diminish the 3-D effect when the user presses the<br>
button. The more free form the image, the clearer it is within the button. The icon<br>
buttons in Figure 3 are good examples of free-form images. 
</p>
<p>
Our icon buttons can appear in one of three states: available, selected, and unavailable.<br>
Figure 5 shows what these states look like.&nbsp;&nbsp;
</p>
<ul>
<li>In the available state, the button shows the full 3-D shading, and its icon<br>
is displayed in the normal way. When the user clicks the button, it goes into<br>
the selected state. </li>
<li>In the selected state, the button and its icon darken, similar to a selected<br>
icon in the Finder. Since it's a 3-D image, the shading changes to make the icon<br>
recede into the surface, giving the impression that it's pushed in. If the button<br>
behaves like a radio button, it stays in this state until the user selects a<br>
different button. If the button behaves like a push button, it pops back out<br>
when the user releases the mouse button. </li>
<li>In the unavailable state, meaning the operation that the button represents<br>
is not available, the entire button is dimmed to make it appear flat against the<br>
surface.&nbsp;&nbsp;&nbsp;When the user takes some action that makes the button's operation<br>
available, it changes to the available state. </li>
</ul>
<p>
<img src="img/226.gif" width="269 px"></img>
</p>
<p>
<b>&nbsp;Figure 5</b> Icon Button States
</p>
<p>
You can change the icon in the button depending on context. Dynamic buttons give the<br>
user visual information about what effect the operation will have. For instance,<br>
suppose you have a list that can show user names, folders, and documents at the same<br>
time. When the user selects a folder or a document from the list, the icon button for<br>
the Open operation displays a folder icon or a document icon; the folder case is shown<br>
in the window on the left in Figure 6. When the user selects a user name from the list,<br>
the button changes to display the standard user face icon, as shown on the right in<br>
Figure 6.&nbsp;&nbsp;You need to be especially careful when designing dynamic icon buttons.<br>
While the image in the icon may change to specialize the button, you don't want to<br>
change the meaning of the button. Changing the icon from open folder to open document<br>
is useful, but changing the meaning of the button from "open item" to "quit<br>
application" would confuse the user. 
</p>
<p>
<img src="img/227.gif" width="531 px"></img>
</p>
<p>
<b>&nbsp;Figure 6</b> A Window Containing a Dynamic Button
</p>
<h2>THE NAUGHTY BITS</h2>
<p>
This issue's CD includes code that makes it easy for you to add these 3-D effects to your<br>
MacApp application, and includes a sample application, with source code, that shows<br>
you how to use the code.&nbsp;&nbsp;&nbsp;There are some adorners for drawing gray backgrounds and<br>
chisels in windows and around text and list boxes, 3-D versions of TControls such as<br>
T3DCheckBox and T3DRadio, and two C++ stack- based objects to help with drawing.<br>
The code requires MacApp 3.0.x and the resulting application requires System 7. 
</p>
<p>
The 3-D adorner classes on the CD are TGrayBackgroundAdorner,<br>
T3DGrayBackgroundAdorner, TWhiteBackgroundAdorner, T3DFrameAdorner,<br>
T3DLineTopAdorner, T3DLineBottomAdorner, T3DLineLeftAdorner, and<br>
T3DLineRightAdorner. The 3-D TControl classes are T3DButton, T3DCheckBox,<br>
T3DRadio, and T3DIconButton. 
</p>
<p>
The easiest way to incorporate the 3-D adorners and classes into your application is to<br>
use a view editor, such as AdLib or ViewEdit. Attach the adorners to your views the<br>
same way you would attach any other adorner. For best performance, insert the line<br>
adorners after the Draw adorner in the view's adorner list. One of the background<br>
adorners should replace the Erase adorner (before the Draw adorner) in your<br>
window's adorner list. 
</p>
<p>
For the classes, create a control 'View' resource of the type you want, and insert "3D"<br>
into the name.&nbsp;&nbsp;&nbsp;For instance, TCheckBox becomes T3DCheckBox, TRadio becomes<br>
T3DRadio, and so on.&nbsp;&nbsp;&nbsp;T3DIconButton is an exception because there is no TIconButton<br>
class. To create a T3DIconButton, you'll need an icon suite ('ICN#' resource). Next,<br>
create a TControl and change the class name to T3DIconButton. Then, set the user value<br>
of the T3DIconButton to the ID of the icon suite. If you install the adorners or classes<br>
this way, be sure to call InitU3DDrawing in your initialization code so that the linker<br>
doesn't dead-strip any adorners that you don't explicitly reference in your code. 
</p>
<p>
Another way to use the adorners is to create them procedurally and use the AddAdorner<br>
method to add them to a view. If you do it this way, you can create a single global<br>
instance of each adorner you intend to use and pass a pointer to the global adorner when<br>
you call AddAdorner. MacApp uses this technique for the common adorners such as<br>
TDrawAdorner and TEraseAdorner. You may still want to call InitU3DDrawing in your<br>
initialization function in case you decide to use the first method for some of your<br>
views. 
</p>
<p>
You can create the 3-D classes (such as T3DCheckBox and T3DRadio) procedurally as<br>
you would any other MacApp view. 
</p>
<h2>STACKING THE DECK IN YOUR FAVOR</h2>
<p>
The MacApp classes on the CD use two C++ stack-based objects to help you draw the<br>
3-D effects.&nbsp;&nbsp;&nbsp;CGraphicsState objects save and restore the drawing state, and<br>
CDrawPerDevice objects let you customize your drawing routines for different pixel<br>
depths. For more information on stack-based objects, see "Stack-Based Objects."
</p>
<p>
When a drawing routine changes the graphics state, as most of the 3-D adorners and<br>
classes do, it's a common courtesy to restore the state to the way you found it when<br>
your routine is done. CGraphicsState saves important characteristics of the graphics<br>
state, such as the foreground color, the background color, the pen state, and the text<br>
style. All you have to do is declare an instance of a CGraphicsState in your function's<br>
local variable list, and forget it. C++ takes care of everything else, as in the following<br>
example. 
</p>
<p>
<code>MyClass::DrawIt() {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aLocal;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;CGraphicsState&nbsp;&nbsp;theGState;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;. . .</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;// Do some drawing.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;. . .</code><br>
<code>}</code>
</p>
<p>
When the function ends, CGraphicsState's destructor restores the graphics state. 
</p>
<p>
Sometimes you want your drawing routine to behave differently depending on the pixel<br>
depth of a monitor. Our stack-based object, CDrawPerDevice, lets you specify how<br>
your drawing routine should react to monitors with different pixel depths.<br>
CDrawPerDevice performs the same function as the DeviceLoop routine (see the<br>
article "DeviceLoop Meets the Interface Designer" in<i>develop</i> Issue 13), but<br>
CDrawPerDevice is easier to use with MacApp. To use the DeviceLoop routine with<br>
C++ or with Object Pascal, you need to create a static drawing routine that you can<br>
pass to DeviceLoop.&nbsp;&nbsp;&nbsp;Since you can't make the Draw method of a TView subclass static,<br>
you need to create a second drawing function. If you had to do this for all your drawing<br>
classes, it would get messy and wasteful.&nbsp;&nbsp;&nbsp;CDrawPerDevice doesn't require static draw<br>
routines.
</p>
<p>
To use CDrawPerDevice, declare an instance of it and initialize it with a CRect that<br>
specifies the QuickDraw drawing area. Then do your drawing in a while loop that calls<br>
CDrawPerDevice::NextDevice, like this:
</p>
<p>
<code>MyClass::DrawIt(VRect area) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;CGraphicsState&nbsp;&nbsp;theGState;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;CRect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aQDArea;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pixelSize;</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;ViewToQDRect(area, aQDArea);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;CDrawPerDevice device(aQDArea);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;while (device.NextDevice(pixelSize)) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pixelSize &gt; 2) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Do some color drawing.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;DrawColor();</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Do some black-and-white drawing.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;DrawBW();</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code>}</code>
</p>
<p>
Note that you create actual instances of CGraphicsState and CDrawPerDevice on the<br>
stack (that is, as local variables in the function). Don't instantiate pointers to these<br>
objects.
</p>
<p><table border="0"><tr><td><b>Correct</b></td><td></td><td><b></b><b>Incorrect</b></td><td></td></tr>
<tr><td><code>CGraphicsState</code></td><td><code></code><code>myState;</code></td><td><code></code><code>CGraphicsState</code></td><td><code></code><code>*myState;</code></td></tr>
<tr><td><code>CDrawPerDevice</code></td><td><code></code><code>drawing(aQDArea);</code></td><td><code></code><code>CDrawPerDevice</code></td><td><code>*drawing;</code></td></tr>

<tr><td></td><td></td><td><code>new drawing(aQDArea);</code></td><td></td></tr></table></p>
<p class="spacer">&nbsp;</p>
<p class="spacer">&nbsp;</p>
<h2>DECORATING YOUR WINDOWS WITH ADORNERS</h2>
<p>
An adorner is a handy class that MacApp uses to draw views. Instead of putting special<br>
drawing code in the Draw method of a class, you can use an adorner to do the drawing<br>
for you. For example, a line adorner might draw a single black line along the top edge<br>
of a view. You can create an adorner to draw something, like a line, and then add it to<br>
any view you want. 
</p>
<p>
The basic 3-D adorner is TGrayBackgroundAdorner. As you might have guessed, it<br>
colors the background of its view gray. This adorner calls EraseRect on the viewRect<br>
with kLightGray. Using EraseRect instead of PaintRect in gray has a useful side effect:<br>
because any view without an explicit TDrawingEnvironment inherits the foreground<br>
color and the background color from its superview, all subviews of a view with a<br>
TGrayBackgroundAdorner will erase with gray by default. This is especially important<br>
when you have TStaticText items. Without the gray TDrawingEnvironment they<br>
inherit, they would draw ugly white boxes around the text. 
</p>
<p>
T3DGrayBackgroundAdorner is a subclass of TGrayBackgroundAdorner that adds the<br>
chiseled effect described earlier in this article. Its Draw routine first calls the<br>
inherited method, which fills the viewRect with kLightGray. Then it draws the gray<br>
and white lines around the edges. These lines are not drawn if the monitor is in<br>
black-and-white mode. To draw a chiseled gray line that appears as a black line in<br>
black-and-white mode, use T3DLineTopAdorner, T3DLineLeftAdorner,<br>
T3DLineBottomAdorner, or T3DLineRightAdorner. 
</p>
<p>
The T3DFrameAdorner, used for TEditText and list views, is an interesting case.<br>
Unlike the other frame adorners, which tend to draw a one-pixel-wide line around<br>
your view or portions of your view, T3DFrameAdorner draws two-pixel-wide lines to<br>
achieve its 3-D effect. This isn't a problem for TEditText, but it means that you need to<br>
inset your TListView two pixels from the TView or TControl that encloses the<br>
TListView. Then add the T3DListFrameAdorner to the<i>enclosing</i> TView instead of the<br>
TListView. You should also add a TWhiteBackgroundAdorner to your list view or edit<br>
text (before the Draw adorner) so that the text appears on a white background.<br>
Another way to get the same effect is to set the drawing environment background for<br>
the list view or edit text to white. 
</p>
<p>
Note that the 3-D adorners draw the chiseled effect only on devices whose pixel depth<br>
is 2 or more.&nbsp;&nbsp;&nbsp;None of the 3-D adorners described here, except the line adorners<br>
described above, show up in black and white. This decision to hide 3-D effects in black<br>
and white follows the Macintosh Human Interface Guidelines recommendation that<br>
applications not try to simulate 3-D effects in black and white. 
</p>
<h2>TO STAY IN CONTROL YOU HAVE TO HAVE CLASS</h2>
<p>
It would be nice if you could give 3-D effects to controls simply by adding adorners. To<br>
do it that way, you would need to draw over the CDEF. This is not a recommended<br>
programming practice, since CDEFs may change, or a user might have installed a<br>
special CDEF such as Greg's Buttons.&nbsp;&nbsp;&nbsp;Any assumptions your adorner makes about the<br>
way a control looks may turn out to be false. That's why we use MacApp classes instead<br>
of adorners to handle the drawing of 3-D controls. 
</p>
<p>
The 3-D control classes are still easy to use because they inherit from their 2-D<br>
ancestors. On 1-bit devices, the 3-D classes simulate the standard two-dimensional<br>
CDEF drawing. Since icon buttons need to maintain a distinct button appearance even in<br>
black and white, T3DIconButton does simulate a 3-D effect even on 1-bit devices.&nbsp;&nbsp;The<br>
text for checkboxes, radio buttons, and regular push buttons is normally drawn on a<br>
white background because that's the way the System CDEF works. The TControl<br>
subclasses change the effect to draw on a gray background and, where appropriate, to<br>
add a 3-D effect. T3DCheckBox, for example, draws black text on a gray background<br>
and adds the chiseled effect to the checkbox itself.&nbsp;&nbsp;&nbsp;You can customize the drawing<br>
colors by setting the fForegroundColor and fBackgroundColor fields. 
</p>
<p>
You can use two different kinds of 3-D buttons: T3DButton, descended from MacApp's<br>
TButton, and T3DIconButton from our code. Class T3DButton just inherits from<br>
TButton to draw in 3-D. 
</p>
<p>
Class T3DIconButton uses the TIconSuite class and icon suites ('ICN#' and 'ics#'<br>
resources) to draw icon buttons. T3DIconButton uses CDrawPerDevice to draw buttons<br>
differently on monitors set to different pixel depths. For example, if you're drawing on<br>
a 4-bit monitor, T3DIconButton uses the 'icl4' or 'ics4' resource for your icon, but if<br>
you're drawing on an 8-bit monitor, it uses 'icl8' or 'ics8'.&nbsp;&nbsp;&nbsp;Also, instead of inverting<br>
the icon when the button is hit, T3DIconButton masks the icon with the kSelected mask<br>
just as the Finder does. 
</p>
<h2>ADDING THE 3-D CLASSES TO YOUR MACAPP APPLICATION</h2>
<p>
Here's how you add the 3-D adorners and 3-D control classes to your MacApp<br>
application:
</p>
<ol>
<li>Drag the files in the 3D Drawing folder on the this issue's CD to your<br>
project folder. </li>
<li>Edit your M<i>YourApp</i> .cp file as follows: In main, add "extern<br>
InitU3DDrawing();" after your includes, and add "InitU3DDrawing();" where<br>
the other initialization routines are. </li>
<li>Edit your<i>YourApp</i> .MAMake file to include the files you added from the CD.<br>
The Demo3D.MAMake file is a good example of how to do this. </li>
</ol>
<h2>WHY BOTHER WITH A THIRD DIMENSION WHEN WE HAVE TWO<br>
PERFECTLY GOOD ONES?</h2>
<p>
"So," you ask, "why should I bother with all this stuff? Does it really make my<br>
application any easier to use?" The answer is: probably. There have been no studies<br>
that definitively prove a 3-D interface is better than a 2-D interface. What we hear is<br>
a cry for more 3-D elements in the Macintosh interface. The subtle effects described<br>
in this article are enough to add depth and tactility to the workspace. This results in<br>
ease of use and clarity of view for the user. It's also a lot more fun without being<br>
distracting. 
</p>
<p>
"Why not just use a custom CDEF like Greg's Buttons?" The 3-D effects from this<br>
article weren't created arbitrarily. They reflect a lot of work done to date by some of<br>
Apple's visual designers.&nbsp;&nbsp;&nbsp;CDEFs are also more difficult to write than adorners and<br>
TControl subclasses. Furthermore, CDEFs define only the way controls are drawn. You<br>
can't use a CDEF to create a chiseled effect and a gray background for your windows,<br>
for example. 
</p>
<p>
"This all looks great with MacApp, but what if I'm using something else?" There's<br>
nothing intrinsic about the 3-D effects that makes them difficult to implement in any<br>
application framework. We chose to use MacApp because it made sense for our work.<br>
You could easily adapt these techniques to fit the framework you're using. 
</p>
<p>
We hope that someday 3-D will become the rule, and that it will be just as easy to<br>
make a window three dimensional as it is now to make it colorized. Until then, the<br>
methods we've described in this article should save you time and frustration when<br>
making your applications 3 - D. And we're confident that those who use your<br>
applications will appreciate and benefit from your effort. 
</p>
<h2>STACK-BASED OBJECTS</h2>
<p>
Stack-based objects are a powerful feature of C++ that lets you use function scope to<br>
perform routine actions in your code. They work because of constructors and<br>
destructors.To create a stack-based object, create&nbsp;&nbsp;a C++ class with a constructor and<br>
a destructor. In the constructor, add the code that you want to execute when an instance<br>
of the object is created. For example, the constructor can save the graphics state, set<br>
the cursor to a watch, or lock down handles. In the destructor, reverse the process:<br>
restore the state, reset the cursor, or unlock the handles.
</p>
<p>
Since the object is created on the stack as a local variable, C++ frees the memory it<br>
occupies when the function ends. But before the object is freed, its destructor<br>
executes.
</p>
<p>
The CGraphicsState class is a simple illustration of this technique. When you declare<br>
an object of type CGraphicsState, the constructor saves the graphics state in the<br>
object's data members. When the function ends, and the destructor is called, it<br>
restores the graphics state from its saved data.
</p>
<p>
In theory, you can use the constructors and destructors of stack-based objects to do<br>
anything you want; in practice, you have to be careful. Obviously, your destructor<br>
should reset any changes that your constructor made, so it's important that they're in<br>
sync. If your constructor allocates memory, you should be prepared to handle a<br>
failure. Since constructors can't return a value, you'll need to provide some way to<br>
find out whether the operation was successful.<b>Greg's Buttons </b>is a shareware<br>
extension that adds 3-D effects to the standard controls. *
</p>
<p>
<b>JAMIE OSBORNE </b>(AppleLink JWO) is a best-selling novelist stuck inside a software<br>
engineer's body. When he isn't working on secret decoder rings in Apple's Enterprise<br>
Systems Division, he can be found watching <i> Star Trek</i>&nbsp;&nbsp;with his friends Darmok and<br>
Jilad, and his kitten. Before coming to Apple, he was an undergraduate at Dartmouth<br>
College, where he discovered and was subsequently sucked into the world of Macintosh<br>
programming. He has yet to escape. *
</p>
<p>
<b>DEANNA THOMAS, </b>semiotician savant, has been at Apple for over five years, and<br>
loves to work in all dimensions (second, third, and fourth), experience music,<br>
meditate in the garden, and taste wonderful foods. A visual designer in the Human<br>
Interface Group of the Enterprise Systems Division, Deanna paints in tiny pixels<br>
instead of on the large canvases she knew at the University of North Texas, where she<br>
got her MFA in Painting and Photography. Before joining Apple, she taught<br>
college-level studio arts and managed her own design business, Gorilla Graphics. *
</p>
<p>
<b>AdLib </b>is a view editor sold by MADA. You may purchase a copy by calling MADA at<br>
(408)253-2765 or by sending an AppleLink to MADA.*
</p>
<p>
<b>The 3-D code was written by </b>Jamie Osborne, Robin Mair, Faulkner White, and<br>
Henri Lamiraux. *
</p>
<p>
<b>THANKS TO OUR TECHNICAL REVIEWERS </b>Robin Mair, Ed Navarett, Cordell<br>
Ratzlaff, Dean Yu*
</p>
</body>
</html>
