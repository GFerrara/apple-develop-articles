<!DOCTYPE html>
<html>
<head>
<!-- Article ID: 39 - Extracted from develop-1993 -->
<!-- on 2024-02-03 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by the copyright of its respective owners -->
<title>September 93 - GETTING STARTED WITH QUICKDRAW GX</title>
<link href="../common/styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h2>GETTING STARTED WITH QUICKDRAW GX</h2>
<h1>PETE ("LUKE") ALEXANDER</h1>
<p>
<img src="img/230.gif" width="180 px"></img>
</p>
<p>
<i>A beta version of QuickDraw GX comes to you on this issue's CD. As you contemplate the</i><br>
<i>vast scope of it all, you may wonder how you're ever going to get your arms around</i><br>
<i>this new imaging technology. Not to worry -- this article will get you started. It walks</i><br>
<i>you through the steps to getting QuickDraw GX up and drawing and presents a simple</i><br>
<i>"GX-hip" application shell that incorporates the basics for you to experiment with.</i>
</p>
<p class="spacer">&nbsp;</p>
<p>
QuickDraw GX offers developers a totally new and markedly improved way of imaging<br>
on the Macintosh. Yes, you'll have to learn the new system, but look at what you get:<br>
The API is simpler and the human interface is better. The amount of control your<br>
application can exercise over text and graphics has been greatly increased. Your<br>
application will be able to produce consistent output no matter what the output device.<br>
And extensive support for color is built in throughout the system. 
</p>
<p>
With the beta version of QuickDraw GX in hand, you're no doubt eager to create a<br>
QuickDraw GX application and start drawing. This article covers just about everything<br>
you need to know to get started: initializing QuickDraw GX, using windows, creating and<br>
manipulating QuickDraw GX shapes, printing, and debugging. By way of illustration,<br>
we discuss the QuickDraw GX shell that you'll find on this issue's CD. But before we do<br>
that, let's take a quick look under the hood at the major features of QuickDraw GX and<br>
how it fits into the Macintosh architecture. 
</p>
<h2>QUICKDRAW GX: A QUICK LOOK UNDER THE HOOD</h2>
<p>
QuickDraw GX coexists happily with QuickDraw, thank goodness. It doesn't replace<br>
QuickDraw, but instead "moves in next door," so you still live with a Macintosh<br>
Toolbox based on QuickDraw.&nbsp;&nbsp;&nbsp;You can run QuickDraw-based applications on a<br>
QuickDraw GX system. These applications won't even notice that QuickDraw GX is<br>
installed, but they'll be able to take advantage of some of the QuickDraw GX printing<br>
features, including improved background printing to all devices, desktop printers,<br>
print job queuing, and better type management.
</p>
<p>
QuickDraw GX has three major pieces: graphics, typography, and printing. You can<br>
visualize the relationship of these three different pieces to each other and to<br>
QuickDraw as shown in Figure 1. 
</p>
<p>
<img src="img/231.gif" width="555 px"></img>
</p>
<p>
<b>Figure 1</b> QuickDraw and the Pieces of QuickDraw GX
</p>
<p>
<b>GRAPHICS</b>The basic building block of QuickDraw GX graphics is the<i>shape</i>. A shape is<br>
an object that contains, among other things, a geometry of some type and a fill<br>
property that specifies how the geometry should be interpreted when drawn (such as<br>
framed or filled).
</p>
<p>
There are four basic types of shapes, classified by the nature of the geometry they<br>
contain: geometric shapes, typographic shapes, bitmap shapes, and pictures.
</p>
<ul>
<li>A<i> geometric shape</i> contains a primitive geometry: a point, a line, a curve,<br>
a rectangle, a polygon (a series of points connected by straight lines), or a<br>
path (a series of points connected by straight or curved lines). In addition,<br>
there are two other special geometric shape types: empty (no geometry at all)<br>
and full (covers the entire coordinate system).</li>
<li>A<i> typographic shape</i> contains text, glyphs (renditions of individual<br>
characters or character combinations over which your application has direct<br>
control), or layouts (pieces of text for which QuickDraw GX automatically<br>
chooses and positions glyphs, given certain information by the application).</li>
<li>A<i> bitmap shape</i> contains a reference to a block of memory containing a bit<br>
image, as well as information on how to interpret the bits: the pixel size,<br>
color space, color set, and color profile. </li>
<li>A<i> picture</i> contains a list of other shapes. The shapes in the list can be<br>
other pictures, so that a picture is actually a hierarchical database of shapes. </li>
</ul>
<p>
Besides containing a geometry, a shape contains references to three other objects that<br>
describe how it should be rendered. These objects are the style, the transform, and the<br>
ink. 
</p>
<ul>
<li>The<i> style</i>defines the pen thickness, the place where the pen draws (inside,<br>
outside, or on the geometry), the kind of start and end cap (such as round,<br>
pointy, or square), and ways to dash, join, and pattern shapes. For a text<br>
shape, the style also defines the font, size, variation, and text face. </li>
<li>The<i> transform</i>controls the skew, scale, perspective, and clipping of the<br>
geometry.&nbsp;&nbsp;&nbsp;It also specifies where to draw it and how to hit-test it. </li>
<li>The<i> ink</i>tells the system which color to draw the geometry in. Ink also<br>
includes information about the color matching and transfer mode. </li>
</ul>
<p>
Some of these objects in turn contain references to other objects. For example, a<br>
transform points to a list of <i>view port</i> objects that describe where to draw the<br>
geometry. A view port is like a QuickDraw grafPort in that it defines an area of local<br>
space as a drawing environment. Unlike a grafPort, though, a view port doesn't contain<br>
state information about the drawing environment (pen, color, transfermode, and so<br>
on).&nbsp;&nbsp;A view port contains the mapping used to convert from the view port's local space<br>
to a global space described by a<i>view group</i>. A view port object points in turn to a list <br>
of <i>view device</i> objects, which describe the clip shape, mapping, and bitmap associated<br>
with a physical device such as a monitor. 
</p>
<p>
A shape can also have one or more<i>attributes</i>, which modify the shape's behavior. These<br>
attributes enable your application to specify how a shape is edited or how QuickDraw<br>
GX stores the shape. For example, if you set the shape attribute<br>
gxMapTransformShape, this tells QuickDraw GX that you want it to manipulate the<br>
transform referenced by the shape, instead of directly manipulating the data contained<br>
within the geometry of the shape. 
</p>
<p>
Figure 2 depicts the shape object and what it references. The owner count is the<br>
number of other objects within the application that reference that object. The tag list<br>
is a list of tag objects, which are simply containers for any data the application<br>
associates with the owning object. 
</p>
<p>
<img src="img/232.gif" width="600 px"></img>
</p>
<p>
<b>&nbsp;Figure 2</b> The Shape Object and What It References
</p>
<p>
<b>TYPOGRAPHY</b><br>
QuickDraw GX has a sophisticated typographic model that's fully integrated with<br>
graphics. The ability to do kerning, tracking, and justification, as well as ligatures and<br>
ornamental forms of various characters, is provided by the line layout routines,<br>
supported by the QuickDraw GX smart font format. The line layout routines work with<br>
the typographic information contained in the TrueType GX and Type 1 GX fonts to give<br>
you a ton of control over how text is placed on a page.
</p>
<p>
Because QuickDraw GX typography is fully integrated with graphics, you can rotate,<br>
skew, and change the perspective of typographic shapes the same way you can<br>
geometric shapes. You can use the text shape to draw a line of text with one style. The<br>
glyph shape enables you to draw text in several styles and graphically manipulate each<br>
glyph. The layout shape uses the information contained in a TrueType GX or Type 1 GX<br>
font to automatically kern, justify, and track, and to support ligatures, final forms<br>
(special forms found at the ends of words), and ornamental forms of the various<br>
glyphs contained within the layout shape. 
</p>
<p>
Note that although QuickDraw GX supports all existing Macintosh font formats (Type<br>
1, bitmap, and TrueType), to take full advantage of its extensive line layout<br>
capabilities you must use TrueType GX or Type 1 GX fonts. 
</p>
<p>
<b>PRINTING</b><br>
QuickDraw GX improves printing for both users and developers. Users get an improved<br>
human interface, and developers get much more control and functionality. From the<br>
application's point of view, QuickDraw GX offers true device independence: you can<br>
send the same data to all supported devices and the output will be rendered<br>
appropriately on each device.
</p>
<p>
QuickDraw GX introduces three new printing concepts: desktop printers, portable<br>
digital documents, and printing extensions.
</p>
<p>
Users can create<i>desktop printers</i>with the Chooser. These are represented as icons on<br>
the desktop and are full Finder citizens; users can drag and drop print files and<br>
documents to them. Users can also manage the print queue and redirect print files and<br>
documents by dragging them to and from desktop printers, and can share desktop<br>
printers with other users via PrinterShare GX. 
</p>
<p>
A<i> portable digital document</i>(PDD) file contains all the objects required to render a<br>
document on a screen or printer, so you can open, review, and print the file on any<br>
system running QuickDraw GX without the application or fonts used to create the<br>
document. When a PDD file is created, only the glyphs used in the document are saved<br>
along with it; since the document can't very well be edited, the PDD is secure for<br>
transporting fonts. When you print, you can save the print job as a PDD with or<br>
without the fonts required. If you know that the person you're sending the PDD file to<br>
has the fonts you used, you can choose not to save the fonts with the PDD. 
</p>
<p>
<i>Printing extensions</i>are small standalone pieces of code that modify the behavior of<br>
printing and give users vastly increased control, at a system rather than a program<br>
level, over how a printed page looks.&nbsp;&nbsp;&nbsp;For example, through a printing extension the<br>
user can direct a printer to print "Confidential" diagonally across each page, no matter<br>
what program is doing the printing. The user selects a printing extension from a list<br>
displayed in the expanded Print, By Page Setup, and Document Setup dialogs (which<br>
appear when More Choices is clicked in the regular dialogs).
</p>
<p>
The API for QuickDraw GX printing gives you easy access to information about the page<br>
size and orientation of a print job and enables you to keep the user from changing these<br>
settings.
</p>
<p>
QuickDraw GX supports raster, vector, and PostScriptTM devices. The bad news is that<br>
if your system is running QuickDraw GX, you won't be able to use any non-QuickDraw<br>
GX printer drivers. The good news is that because QuickDraw GX provides<br>
system-level support for developing printer drivers, it's a whole lot easier to develop<br>
printer drivers for QuickDraw GX than it is for the old QuickDraw-based printing<br>
architecture -- you can plan on months of development time as opposed to years. And<br>
in many cases you may find that a printing extension, which is easier yet to develop,<br>
will suffice to implement the desired functionality; for more information, see the<br>
article "Developing QuickDraw GX Printing Extensions" later in this issue. 
</p>
<h2>PROGRAMMING AMENITIES</h2>
<p>
QuickDraw GX offers you some truly useful programming goodies: libraries of handy<br>
high-level routines, extensive error-handling capabilities, and a powerful new<br>
debugging tool called GraphicsBug. 
</p>
<p>
<b>THE QUICKDRAW GX LIBRARIES</b><br>
As you cruise around the QuickDraw GX folder on this issue's CD, you'll notice a folder<br>
named Libraries. Open it and you'll find libraries of code for many common graphics,<br>
line layout, and printing tasks. These provide sample code that most applications will<br>
need in order to create a QuickDraw GX application. But unlike Macintosh Toolbox code,<br>
this library code can be modified or extended by you to meet your own particular<br>
needs. All the library code is based on core QuickDraw GX calls.
</p>
<p>
<b>ERROR HANDLING IN QUICKDRAW GX</b><br>
The goal of QuickDraw GX's error-handling capabilities is to never allow QuickDraw<br>
GX to crash your Macintosh, and to inform you anytime QuickDraw GX can't complete<br>
an operation.&nbsp;&nbsp;&nbsp;QuickDraw GX uses two different models for handling errors: one for<br>
graphics and layout errors and another for printing errors. We'll discuss graphics and<br>
layout errors here. Printing errors are described later in this article, under "Basic<br>
Printing in QuickDraw GX."
</p>
<p>
There's both a debugging and a nondebugging version of the combined graphics and<br>
layout portions of QuickDraw GX. The debugging version provides extensive<br>
error-handling capabilities to help you debug your applications under development.<br>
The nondebugging version is lean and mean; it has fewer error-handling capabilities<br>
and is faster than the debugging version. You can differentiate between the two<br>
versions by their sizes and version strings: the nondebugging version is smaller, and<br>
the version string for the debugging version has the word "debug" in it. When you're<br>
developing your QuickDraw GX application, you should be using the debugging version.
</p>
<p class="spacer">&nbsp;</p>
<p>
In the debugging version, information about internal data and drawing problems comes<br>
in three flavors: notices, warnings, and errors. Only a few selected errors and<br>
warnings are issued in the nondebugging version. 
</p>
<p>
<b>Notices. </b>A notice informs you that the operation you're performing isn't really<br>
needed. Notices aren't necessarily bad things; they're just information to help you<br>
improve the efficiency of your application.&nbsp;&nbsp;&nbsp;For example, if you've already colored a<br>
shape and you try to color it again, you'll receive the following notice in the installed<br>
debugger:
</p>
<p>
<code>GRAPHICS NOTICE: color already set</code>
</p>
<p>
<b>Warnings. </b>A warning informs you that QuickDraw GX doesn't allow the operation<br>
you're trying to perform. While this might not cause any problems, you also might not<br>
get the result you expected.&nbsp;&nbsp;&nbsp;For example, if you try to use a font that isn't available,<br>
QuickDraw GX will substitute the default font and give you the following warning:
</p>
<p>
<code>GRAPHICS WARNING: font substitution took place</code>
</p>
<p>
<b>Errors.</b> An error means that QuickDraw GX couldn't draw your shape or complete a<br>
routine. For example, if you try to draw an empty shape or one that hasn't been<br>
defined, you'll receive the following error:
</p>
<p>
<code>GRAPHICS ERROR: shape is nil</code>
</p>
<p>
<b>Checking for drawing errors. </b>Once you've finished developing your application,<br>
you'll still want to be able to check for drawing errors. The QuickDraw GX routine<br>
GXGetShapeDrawError lets you do this and, in case of an error, fail in a graceful<br>
manner. For example, this code fragment checks that drawing was successful and fails<br>
if it wasn't:
</p>
<p>
<code>GXDrawShape(gthePage);</code><br>
<code>if (drawingError = GXGetShapeDrawError(gthePage) != noDrawError)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;// Your error-handling code here!</code>
</p>
<p>
<b>Ignoring notices and warnings. </b>Sometimes you might want to ignore a particular<br>
notice or warning because you know what you're doing. Use these routines to ignore a<br>
notice or warning:
</p>
<p>
<code>void GXIgnoreGraphicsNotice(gxGraphicsNotice notice);</code><br>
<code>void GXIgnoreGraphicsWarning(gxGraphicsWarning warning);</code>
</p>
<p>
For example, if you wanted to ignore a notice about recoloring a shape, you would make<br>
this call:
</p>
<p>
<code>void GXIgnoreGraphicsNotice(color_already_set);</code>
</p>
<p>
When you call GXIgnoreGraphicsNotice or GXIgnoreGraphicsWarning, the notice or<br>
warning is added to the top of the notice stack or warning stack, respectively. (It's<br>
added to the stack even when not ignored, but the stack handling is taken care of behind<br>
the scenes for you in that case.) So you must balance this with a call to one of the<br>
following routines to ensure that you don't overflow the notice or warning stack:
</p>
<p>
<code>void GXPopGraphicsNotice(void);</code><br>
<code>void GXPopGraphicsWarning(void);</code>
</p>
<p>
In the nondebugging version, where notices and most warnings aren't available, calling<br>
the GXIgnoreGraphicsXXX and GXPopGraphicsXXX routines still results in a trap call<br>
and dispatch even though they just return immediately. There may be a small<br>
performance penalty for this, so you should remember to remove the unnecessary<br>
calls for a shipping application. 
</p>
<p>
<b>Grabbing errors, notices, and warnings. </b>In the nondebugging version, you<br>
receive only a few selected errors and warnings. If you've tested your application<br>
thoroughly, these should be the only errors you see:
</p>
<p>
<code>out_of_memory</code><br>
<code>not_enough_memory_for_graphics_client_heap</code><br>
<code>graphics_client_memory_too_small</code><br>
<code>could_not_create_backing_store</code>
</p>
<p>
These should be the only warnings you see:
</p>
<p>
<code><<font or character>>_substitution_occurred</code><br>
<code><<map, move, scale, rotate, or skew>>_shape_out_of_range</code><br>
<code><<map, move, scale, rotate, or skew>>_transform_out_of_range</code>
</p>
<p>
You probably don't want your user to end up in a debugger or with a system bomb, so<br>
you should catch errors by calling the GXGetGraphicsError routine; you can then<br>
handle the error appropriately within your application or present it to the user.
</p>
<p>
<code>gxGraphicsError GXGetGraphicsError(gxGraphicsError *stickyError);</code>
</p>
<p>
You can also grab notices (in the debugging version only) and warnings with these<br>
calls:
</p>
<p>
<code>gxGraphicsNotice GXGetGraphicsNotice(gxGraphicsNotice *stickyNotice);</code><br>
<code>gxGraphicsWarning GXGetGraphicsWarning(gxGraphicsWarning</code><br>
<code>*stickyWarning);</code>
</p>
<p>
<b>GRAPHICSBUG: A POWERFUL NEW DEBUGGING TOOL</b><br>
The only way to create and modify shapes in QuickDraw GX is through the public API;<br>
you can't operate on any data directly. This is a very good thing because it lets Apple<br>
expand the system in the future with minimal compatibility risk. But if you can't see<br>
the data you're working with, won't debugging be a nightmare? Here's where<br>
GraphicsBug comes to the rescue. GraphicsBug is an application that enables you to<br>
inspect the contents of any QuickDraw GX graphics or layout object to make sure it<br>
contains the correct information. The command set is very similar to that of MacsBug;<br>
just type "?" to get a list of the commands available. GraphicsBug works only in the<br>
debugging version of QuickDraw GX 1.0b1 but in both versions of later QuickDraw GX<br>
releases. 
</p>
<h2>INITIALIZING QUICKDRAW GX</h2>
<p>
Now that we've checked out the horsepower under the hood and the amenities built in<br>
for programmers, we're ready to get QuickDraw GX up and drawing. The first step is to<br>
initialize QuickDraw GX, but before you do, you need to make sure the user has<br>
installed it. Use the Gestalt selector 'grfx' to determine whether the graphics and<br>
typography portions of QuickDraw GX have been installed, and the Gestalt selector<br>
'pmgr' to determine whether QuickDraw GX printing has been installed. 
</p>
<p>
In the case of our QuickDraw GX shell, the following routine finds out which parts of<br>
QuickDraw GX have been installed:
</p>
<p>
<code>Boolean QuickDrawGXAvailable()</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;long theFeatureInQuestion;</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (Gestalt('grfx', &amp;theFeatureInQuestion) == noErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Gestalt('pmgr', &amp;theFeatureInQuestion) == noErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gQDGXPrintingInstalled = true;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (true);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;return (false);</code><br>
<code>}</code>
</p>
<p>
The QuickDraw GX shell uses the global variable gQDGXPrintingInstalled to determine<br>
if QuickDraw GX printing has been installed. If it has, the printing menu items in the<br>
File menu are enabled. Otherwise, an alert tells the user that QuickDraw GX printing<br>
hasn't been installed, and the application works without printing. 
</p>
<p>
Once you know that the user has QuickDraw GX, you're ready to initialize it. After the<br>
generic Macintosh Toolbox initialization, you create a new graphics client to allocate<br>
memory. Then you can set up error handling and validation as an aid to tracking down<br>
problems, although if you're eager to get on with drawing, you don't have to do this<br>
right now. Finally, you can initialize the common color library to get quick and easy<br>
color. In the QuickDraw GX shell, the routine QuickDrawGXInit does all of this<br>
initialization. 
</p>
<p>
<b>CREATING A NEW GRAPHICS CLIENT</b><br>
A graphics client is a reference to the block of MultiFinder memory used by<br>
QuickDraw GX graphics and layout called the<i>QuickDraw GX heap</i>. When your<br>
application creates a new graphics client, QuickDraw GX usually allocates this block of<br>
memory. The QuickDraw GX heap contains all the graphics and layout objects your<br>
application creates while running QuickDraw GX, as well as a few objects QuickDraw<br>
GX uses to manage the heap. (See "Managing Memory in the QuickDraw GX Heap" for<br>
more details.)
</p>
<p>
The simplest way to create a graphics client is to call EnterGraphics, which defines a<br>
client for you based on some fundamental assumptions. If you want to have more<br>
control over the graphics client you create, call GXNewGraphicsClient:
</p>
<p>
<code>gGraphicsClient = GXNewGraphicsClient(nil,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;gGraphicsHeapSize * 1024, 0L);</code>
</p>
<p>
The variable gGraphicsClient holds the new graphics client. You can use this variable<br>
anytime you need to access this graphics client. In our shell, we only need this<br>
variable when the application shuts down. The first parameter tells the Memory<br>
Manager where we want to create the QuickDraw GXheap.&nbsp;&nbsp;A nil value tells the Memory<br>
Manager to create the heap within MultiFinder memory. That's usually where you want<br>
it, but you can also specify a pointer to a block of memory in your application heap or<br>
even the system heap. The second parameter defines the size of the heap in bytes.&nbsp;&nbsp;&nbsp;Our<br>
shell uses a 115K heap (gGraphicsHeapSize = 115); if you pass 0, you get the default<br>
heap size of 600K. The last parameter, named separateStack, tells QuickDraw GX to<br>
allocate a stack for the graphics client, which is necessary if that client is going to run<br>
at interrupt time. To get a separate stack, just pass any nonzero value that defines the<br>
stack size. 
</p>
<p>
<b>SETTING UP ERROR HANDLING AND VALIDATION</b><br>
After setting up the graphics client, you should enable the error, warning, and notice<br>
capabilities if you want to make debugging easier for yourself down the line. In our<br>
QuickDraw GX shell we enable all three with the routines SetGraphicsLibraryErrors<br>
(which enables errors and warnings) and SetGraphicsLibraryNotices (which enables<br>
notices). 
</p>
<p>
The debugging version of QuickDraw GX graphics and layout provides extensive<br>
validation facilities that let you determine whether you're passing valid data to the<br>
QuickDraw GX API and whether anything's gone awry internally. (See "Tracking Down<br>
a Memory Trashing Problem" for details on how to use validation to find out how<br>
damage is being caused in the QuickDraw GX heap.) In general, you should always run<br>
with gxPublicValidation + gxTypeValidation while you're developing a QuickDraw GX<br>
application. To set this level of validation, make this call:
</p>
<p>
<code>GXSetValidation(gxPublicValidation + gxTypeValidation);</code>
</p>
<p>
This setting ensures that for all calls, QuickDraw GX checks the routines on entry and<br>
makes sure that the types are correct. For example, if you call GXDrawShape with this<br>
validation setting, QuickDraw GX makes sure that the shape being passed in is a valid<br>
shape and that it's an object of the correct type. This will result in a slight decrease in<br>
performance but will help you catch bad data earlier. 
</p>
<p>
Your application can validate various QuickDraw GX graphics and layout objects --<br>
shape, style, transform, ink, view port, view device, view group, color profile, color<br>
set, tag, or graphics client, or any combination -- with a GXValidate call before<br>
they're passed to a routine. For example, if you wanted to validate the inks in the heap,<br>
you would make the following call:
</p>
<p>
<code>GXValidateInk(gxInk);</code>
</p>
<p>
If you're interested in using only these validation calls, set the validation level to<br>
gxPublicValidation. 
</p>
<p>
<b>SETTING UP THE COMMON COLOR LIBRARY</b><br>
The common color library provided by QuickDraw GX gives you a quick way to color<br>
the shapes you create. This library contains 103 common colors, including maroon,<br>
teal, fluorescent blue, apple green, Mars orange, and Venetian red. To initialize this<br>
library, make this call:
</p>
<p>
<code>InitCommonColors();</code>
</p>
<p>
With the color library set up, you can call SetShapeCommonColor to color a shape.<br>
We'll do this later with the shapes we draw in the QuickDraw GX shell window.
</p>
<h2>USING WINDOWS WITH QUICKDRAW GX</h2>
<p>
Now that you've initialized QuickDraw GX, you need to set it up to work within a<br>
window. The first step is to create a view port and attach it to a window. Then you need<br>
to provide routines to zoom and resize the view port and to scroll its contents. 
</p>
<p>
Recall that QuickDraw GX draws all shapes in a view port, which contains the mapping<br>
used to convert from the view port's local space to the global space (described by a<br>
view group). The view group determines whether the contents of the view port are<br>
drawn on the screen in a window or to an off-screen area. A view port also contains its<br>
clip shape, describing the area in which drawing can take place.
</p>
<p>
<b>ATTACHING A VIEW PORT TO A WINDOW</b><br>
By attaching a view port to a window, you guarantee that all the shapes you draw to the<br>
view port will be drawn in the correct location even after the user moves the window.<br>
You attach a view port to your window with this call:
</p>
<p>
<code>gxViewPort windowParentViewPort;</code>
</p>
<p>
<code>windowParentViewPort = GXNewWindowViewPort(theWindow);</code>
</p>
<p>
If all goes well, windowParentViewPort contains a reference to the view port attached<br>
to the window (the parent view port). You can't change the clip shape or mapping of<br>
this particular view port, because QuickDraw GX automatically maintains all the<br>
characteristics of the parent view port. This is a problem if you don't want your scroll<br>
bars to be overwritten. However, you can attach a view port to the parent view port<br>
(see Figure 3) and then adjust this newest view port (the child view port) to reflect<br>
changes due to scrolling or resizing the window.
</p>
<p>
<img src="img/233.gif" width="393 px"></img>
</p>
<p>
<b>Figure 3</b> The View Port Hierarchy
</p>
<p>
<b>Defining the new view port's bounds. </b>Before we create a new view port we need<br>
to determine its bounds. We can find the bounds of the window by converting the<br>
window's QuickDraw portRect into a fixed-point QuickDraw GX rectangle. The<br>
following utility routine does this. 
</p>
<p>
<code>void GetFixedWindowBounds(WindowPtr myWindow,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;gxRectangle *boundingBoxPtr)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GrafPtr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oldPort;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Rect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qdBounds;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;gxRectangle gxBounds;</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GetPort(&amp;oldPort);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;SetPort(myWindow);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;qdBounds = myWindow-&gt;portRect;</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;// Convert the QuickDraw rectangle into a GX fixed-point</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;// rectangle.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXQDGlobalToFixedLocal((Point *) &amp;qdBounds.top,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(gxPoint *) &amp;gxBounds.left);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXQDGlobalToFixedLocal((Point *) &amp;qdBounds.bottom,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(gxPoint *) &amp;gxBounds.right);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;*boundingBoxPtr = gxBounds;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;SetPort(oldPort);</code><br>
<code>}</code>
</p>
<p>
Now we can create a QuickDraw GX rectangle that represents the portRect of the<br>
window. The rectangle will reside in the variable viewRect. 
</p>
<p>
<code>GetFixedWindowBounds(theWindow, &amp;viewRect);</code>
</p>
<p>
We need to adjust viewRect for the scroll bars attached to the window.
</p>
<p>
<code>viewRect.right -= ff(kScrollBarWidth - 1);</code><br>
<code>viewRect.bottom -= ff(kScrollBarWidth - 1);</code>
</p>
<p>
<b>Creating and activating the child view port. </b>Now we're ready to create a child<br>
view port that's attached to the parent view port. We want to create a new view port<br>
within the same view group (that is, sharing the same global space) as the window's<br>
view port:
</p>
<p>
<code>gxViewPort gcontentViewPort;</code>
</p>
<p>
<code>gcontentViewPort =</code><br>
<code>GXNewViewPort(GXGetViewPortViewGroup(windowParentViewPort));</code>
</p>
<p>
The gcontentViewPort variable now contains a valid view port that we can work with.<br>
Now we're ready to set the clip shape of this view port. The clip shape can be any<br>
geometry-based shape like a rectangle, a polygon, or a path. The clip shape for<br>
gcontentViewPort will simply be defined by the rectangle contained in viewRect, which<br>
is the portRect of the window, minus the scroll bar areas.&nbsp;&nbsp;&nbsp;After we set the clip shape,<br>
we dispose of the shape because it's no longer needed, thereby freeing up space within<br>
the QuickDraw GX heap:
</p>
<p>
<code>gxRectangle contentViewPortShape;</code>
</p>
<p>
<code>contentViewPortShape = GXNewRectangle(&amp;viewRect);</code><br>
<code>GXSetViewPortClip(gcontentViewPort, contentViewPortShape);</code><br>
<code>GXDisposeShape(contentViewPortShape);</code>
</p>
<p>
Next, we need to set the mapping of gcontentViewPort to be the default mapping and<br>
attach gcontentViewPort to the parent view port:
</p>
<p>
<code>GXSetViewPortMapping(gcontentViewPort, nil);</code><br>
<code>GXSetViewPortParent(gcontentViewPort, windowParentViewPort);</code>
</p>
<p>
Now we need to tell QuickDraw GX which view port we want the shapes to be drawn in.<br>
We could have all shapes drawn to both view ports, but that wouldn't be especially<br>
efficient. So we make the following call, which tells QuickDraw GX to draw all the<br>
shapes we make from now on in gcontentViewPort:
</p>
<p>
<code>SetDefaultViewPort(gcontentViewPort);</code>
</p>
<p>
<b>ZOOMING AND RESIZING THE CHILD VIEW PORT</b><br>
Anytime the user zooms or resizes the window, we must update the clip shape of the<br>
child view port we attached to the window's parent view port. To do this, we get the<br>
portRect of the window in a fixed-point rectangle, adjust it for the scroll bars, create<br>
a new clip shape from this rectangle, and reset the clip shape of the view port to this<br>
new clip shape. The following routine does the work:
</p>
<p>
<code>void ResetContentViewPortClip(WindowPtr theWindow)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;gxRectangle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;viewRect;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;gxShape&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contentViewPortClipShape;</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;// Get the window's portRect into the fixed-point viewRect.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GetFixedWindowBounds(theWindow, &amp;viewRect);</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;// Adjust the viewRect to accommodate the scroll bars.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;viewRect.right -= ff(kScrollBarWidth - 1);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;viewRect.bottom -= ff(kScrollBarWidth - 1);</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;// Create and set the new clip shape.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;contentViewPortClipShape = GXNewRectangle(&amp;viewRect);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXSetViewPortClip(gcontentViewPort, contentViewPortClipShape);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXDisposeShape(contentViewPortClipShape);</code><br>
<code>}</code>
</p>
<p>
<b>SCROLLING THE CHILD VIEW PORT'S CONTENTS</b><br>
When the user scrolls in the window, we need to reset the mapping of the child view<br>
port before we call ScrollRect to scroll the bits in the window. That will ensure that<br>
when we redraw the contents of the window on the next update event, all the shapes<br>
will be located in the correct window-relative position. Otherwise they would be<br>
redrawn in their old position, because the geometry of the shapes -- which includes<br>
their position in the view port -- doesn't change. 
</p>
<p>
This remapping approach gives us an advantage at print time. If we didn't adjust the<br>
mapping of the child view port, we would need to adjust the mapping of each shape.<br>
While it's possible to do that, we would have to do it again at print time to ensure that<br>
the shapes printed on the right page. If the page contained a lot of shapes, that could be<br>
a very time-consuming operation. 
</p>
<p>
To update the mapping of gcontentViewPort (the child view port) to reflect the<br>
scrolling of the window, we get its current mapping, adjust it to translate the view<br>
port by the scroll amount, and set the mapping to the changed one.
</p>
<p>
<code>gxMapping viewPortMapping;</code>
</p>
<p>
<code>GXGetViewPortMapping(gcontentViewPort, &amp;viewPortMapping);</code><br>
<code>GXMoveMapping(&amp;viewPortMapping, ff(hScroll), ff(vScroll));</code><br>
<code>GXSetViewPortMapping(gcontentViewPort, &amp;viewPortMapping);</code>
</p>
<h2>CREATING, MANIPULATING, AND DRAWING QUICKDRAW GX<br>
SHAPES</h2>
<p>
At this point, you've learned how to initialize QuickDraw GX and deal with view ports.<br>
It's finally time to talk about creating, manipulating, and drawing shapes. 
</p>
<p>
A shape contains all the information required to draw it. To create a shape with<br>
QuickDraw GX, you simply define its geometry. Then you can draw it by calling<br>
GXDrawShape(myShape). If you haven't specified otherwise, your shape will use the<br>
default style, transform, and ink supplied by QuickDraw GX for the particular type of<br>
shape. When you change a shape's style, transform, or ink, QuickDraw GX copies a<br>
reference to the new style, transform, or ink into your shape. 
</p>
<p>
To illustrate the process of creating, manipulating, and drawing shapes, in our<br>
QuickDraw GX shell we'll create a typographic shape containing text. We'll outline the<br>
text in some color and fill the inside of each letter with a pattern composed of stars.<br>
Then we'll create a typographic shape containing a line layout of some text, which we'll<br>
render in a combination of different fonts and scripts. 
</p>
<p>
In the QuickDraw GX shell we'll use a picture, which we'll store in the global variable<br>
gthePage, to collect all the shapes we draw to the window. Using a picture enables us to<br>
make just one call to GXDrawShape to draw the contents of the window. We also need to<br>
set the gxUniqueItemsShape shape attribute so that each time we add a shape to the<br>
picture, QuickDraw GX will make a copy of the shape and add the copy, rather than just<br>
adding a reference to the shape. These calls create our picture and set the shape<br>
attribute:
</p>
<p>
<code>gxShape gthePage</code>
</p>
<p>
<code>gthePage = GXNewShape(gxPictureType);</code><br>
<code>GXSetShapeAttributes(gthePage, gxUniqueItemsShape);</code>
</p>
<p>
The variable gthePage now holds an empty picture, ready to have shapes added to it. 
</p>
<p>
<b>EXAMPLE 1: A SHAPE CONTAINING TEXT</b><br>
First we'll create a shape containing text, which we'll store in the variable<br>
tempTextShape. We want the text to read "GX." We set the text shape's position, create<br>
the new shape, set the text size, and set the font to New York:
</p>
<p class="spacer">&nbsp;</p>
<p>
<code>gxPoint textPosition = {ff(10), ff(205)};</code><br>
<code>gxShape tempTextShape;</code><br>
<code></code><br>
<code>tempTextShape = GXNewText (2, (unsigned char *) "GX", &amp;textPosition);</code><br>
<code>GXSetShapeTextSize(tempTextShape, ff(250));</code><br>
<code></code><br>
<code>// This next call comes from the Font Library.</code><br>
<code>SetShapeCommonFont(tempTextShape, newyorkFont);</code>
</p>
<p>
The variable tempTextShape now holds the text shape. 
</p>
<p>
<b>Outlining the text. </b>We said that we want to outline the text with some color and fill<br>
the text shape with stars. The approach we'll take to outlining our text shape is to first<br>
convert it into a path shape, which requires only the GXSetShapeType call. 
</p>
<p>
After the conversion to a path shape, each character in the text shape becomes a path.<br>
Thus, the converted shape will contain two different paths, one for each character. To<br>
draw the outline of each path, we set the fill type to gxClosedFrameFill. Then we set the<br>
pen to draw on the outside of each contour, set the pen thickness, set the color of our<br>
path to a color from the common color library, and scale it 125% on the x-axis and<br>
65% on the y-axis so that it will come out looking short and fat. 
</p>
<p>
<code>GXSetShapeType(tempTextShape, gxPathType);</code><br>
<code>GXSetShapeFill(tempTextShape, gxClosedFrameFill);</code><br>
<code>GXSetShapeStyleAttributes(tempTextShape, gxOutsideFrameStyle);</code><br>
<code>GXSetShapePen(tempTextShape, ff(3));</code><br>
<code>SetShapeCommonColor(tempTextShape, blue);</code><br>
<code>GXScaleShape(tempTextShape, fl(1.25), fl(0.65), 0, 0);</code>
</p>
<p>
Now we add our path shape to the picture we've stored in gthePage:
</p>
<p>
<code>GXSetPictureParts(gthePage, 0, 0, 1, &amp;tempTextShape, nil, nil, nil);</code>
</p>
<p>
From now on, whenever we draw gthePage, our path shape stored in tempTextShape<br>
will be drawn as well. (See Figure 4.)
</p>
<p>
<img src="img/234.gif" width="600 px"></img>
</p>
<p>
<b>Figure 4 </b>The Path Shape Outlining Our Text
</p>
<p>
<b>Filling with stars. </b>To fill our shape with stars, we start by changing the fill type<br>
and color of our path.&nbsp;&nbsp;&nbsp;Then we define the star shape and the pattern record that will<br>
replace the style of our shape, add our new patterned path to our picture, and dispose<br>
of all the unneeded shapes. 
</p>
<p>
We need to change the fill type of tempTextShape to solid fill because at this point we<br>
want to fill the contents rather than draw the outline of each path. We also want our<br>
stars to be gray, so we need to reset the color. 
</p>
<p>
<code>GXSetShapeFill(tempTextShape, gxSolidFill);</code><br>
<code>SetShapeCommonColor(tempTextShape, cold_grey);</code>
</p>
<p>
We define the star as a polygon shape containing one contour and five points, with the<br>
default fill of evenOdd (which results in a star with a hollow pentagon inside), and we<br>
scale it by 15% to make it tiny:
</p>
<p>
<code>gxShape starShape;</code><br>
<code>long&nbsp;&nbsp;starGeometry[] = {1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// One contour.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Five points defining the polygon.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ff(60), 0, ff(90), ff(90), 0, ff(30),</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ff(120), ff(30), 0, ff(90)};</code><br>
<code></code><br>
<code>starShape = GXNewPolygons((gxPolygons *) starGeometry);</code><br>
<code>GXScaleShape(starShape, fl(0.15), fl(0.15), 0, 0);</code>
</p>
<p>
The pattern record contains the shape to be used as the pattern, two vectors (u and v)<br>
that describe how to tile the pattern, and the pattern attribute. (See Figure 5.) We'll<br>
attach this record to the style of our path shape, replacing the default style.
</p>
<p>
<img src="img/235.gif" width="116 px"></img>
</p>
<p>
<b>Figure 5</b> Making the Star Pattern
</p>
<p>
&nbsp;The bounding box of our star shape will be a fixed-point rectangle contained in the<br>
variable starShapeBounds. This information is used to define the u and v vectors of our<br>
pattern record.
</p>
<p>
<code>gxRectangle&nbsp;&nbsp;starShapeBounds;</code>
</p>
<p>
<code>GXGetShapeBounds(starShape, 0L, &amp;starShapeBounds);</code>
</p>
<p>
We define u and v to place the stars side by side without overlapping:
</p>
<p>
<code>gxPatternRecord starPattern;</code>
</p>
<p>
<code>starPattern.u.x = 0;</code><br>
<code>starPattern.u.y = starShapeBounds.bottom;</code><br>
<code>starPattern.v.x = starShapeBounds.right + fix1;</code><br>
<code>starPattern.v.y = 0;</code>
</p>
<p>
We set the attributes of the pattern record to gxNoAttributes and then add our star<br>
polygon shape to the pattern record:
</p>
<p>
<code>starPattern.attributes = gxNoAttributes;</code><br>
<code>starPattern.pattern = starShape;</code>
</p>
<p>
Finally, we add the starPattern to tempTextShape. QuickDraw GX copies a new style to<br>
the converted tempTextShape with the pattern record, replacing the default style<br>
currently referenced by tempTextShape. Anytime this shape is drawn, it will be drawn<br>
patterned with stars. We add our updated tempTextShape to the picture stored in the<br>
variable gthePage:
</p>
<p>
<code>GXSetShapePattern(tempTextShape, &amp;starPattern);</code><br>
<code>GXSetPictureParts(gthePage, 0, 0, 1, &amp;tempTextShape, nil, nil, nil);</code>
</p>
<p>
Now we can dispose of our star polygon shape because it's contained in our pattern<br>
record, which has been encapsulated into the style of our shape. We also dispose of<br>
tempTextShape because there's now a unique reference to it in our picture. 
</p>
<p>
<code>GXDisposeShape(starShape);</code><br>
<code>GXDisposeShape(tempTextShape);</code>
</p>
<p>
<b>The results. </b>Our picture, gthePage, now contains two shapes. The first shape is a<br>
colored path that outlines the text "GX." The second shape is the same path filled with<br>
gray stars. When we call GXDrawShape(gthePage), all the shapes contained in our<br>
picture are drawn. The results are shown in Figure 6. 
</p>
<p>
<img src="img/236.gif" width="600 px"></img>
</p>
<p>
<b>&nbsp;Figure 6</b> Our Text Outlined With Color and Filled With Stars
</p>
<p>
<b>EXAMPLE 2: A SHAPE CONTAINING A LINE LAYOUT</b><br>
In a text shape, all the text can be rendered in only one font and size. In a layout shape,<br>
on the other hand, the text can be rendered in a combination of different fonts and sizes<br>
by applying multiple style runs. A layout shape can contain as many style runs as you<br>
like. A style controls the font, the size, the script (such as Roman or Arabic), run<br>
features (which pertain to swashes, ligatures, and final forms available with the<br>
specified font), justification overrides, and kerning adjustments.
</p>
<p>
To illustrate QuickDraw GX's line layout features, we'll create a layout shape<br>
containing the text "Catch the Nasty WAVE, Dude." We'll start by creating the styles to<br>
be applied in three different style runs, and then we'll define the layout shape. Finally,<br>
we'll make the whole line of text slant backward, to demonstrate that you can perform<br>
any graphical operation on typographic shapes in QuickDraw GX.
</p>
<p>
<b>Creating the styles. </b>We're going to apply styles to our layout shape in three<br>
different runs. The first run of text, "Catch the Nasty," will use the Hoefler Italic font;<br>
the second run, "WAVE," will use the Times Roman font; and the third run, "Dude,"<br>
will use Hoefler Italic again. In the first and third runs, we'll enable a total of three of<br>
the run features available with Hoefler Italic. But before we create the styles, we need<br>
to initialize the run controls used to regulate the run features. We specify the number<br>
of run features and styles we'll use.
</p>
<p>
<code>gxRunControls runControls;</code><br>
<code>gxRunFeature runFeatures[3];</code><br>
<code>gxStyle styles[3];</code>
</p>
<p>
<code>InitializeRunControls(&amp;runControls);</code>
</p>
<p>
Here's how we specify the style used for our first text run:
</p>
<p>
<code>styles[0] = NewLayoutStyle((char *)"\pHoefler Italic", ff(36), 0,</code><br>
<code>&amp;runControls, nil, 0, nil);</code>
</p>
<p>
We want to enable two run features in our first text run: an "as" ligature in "Nasty"<br>
and swashes on the "C" and "N."
</p>
<p>
<code>runFeatures[0].featureType = gxLigatureType;</code><br>
<code>runFeatures[0].featureSelector = gxLigatureRareOnSelector;</code><br>
<code>runFeatures[1].featureType = gxAlternateDesignsType;</code><br>
<code>runFeatures[1].featureSelector =</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;gxAlternateDesignsChanceryOnSelector;</code>
</p>
<p>
Now we add the two run features to the style used by this run of text:
</p>
<p>
<code>GXSetStyleRunFeatures(styles[0], 2, runFeatures);</code>
</p>
<p>
We create the styles for the second and third text runs:
</p>
<p>
<code>styles[1] = NewLayoutStyle((char *)"\pTimes Roman", ff(38), 0,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;runControls, nil, 0, nil);</code><br>
<code>styles[2] = NewLayoutStyle((char *)"\pHoefler Italic", ff(40), 0,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;runControls, nil, 0, nil);</code>
</p>
<p>
The run feature used by the last run of text will enable the final form of the "e" in<br>
"Dude" and will update the style:
</p>
<p>
<code>runFeatures[2].featureType = gxSmartSwashType;</code><br>
<code>runFeatures[2].featureSelector = gxSmartSwashLineFinalsOnSelector;</code><br>
<code>GXSetStyleRunFeatures(styles[2], 3, runFeatures);</code>
</p>
<p>
We'll also get the swash on "D" in "Dude" because we enabled the swash capabilities in<br>
the second run feature. When we call GXSetStyleRunFeatures, we tell QuickDraw GX<br>
line layout to use all three entries in the array. 
</p>
<p>
<b>Defining the layout shape. </b>We need to define the length of our layout (in bytes)<br>
and initialize the lengths array used to tell QuickDraw GX line layout the length of each<br>
run of text:
</p>
<p>
<code>short totalLengthOfLayout, lengthsArray[3];</code>
</p>
<p>
<code>lengthsArray[0] = 15; lengthsArray[1] = 6; lengthsArray[2] = 5;</code><br>
<code>totalLengthOfLayout = 26;</code>
</p>
<p>
We now have all the information required to define our layout shape and add it to our<br>
picture stored in the variable gthePage. Our layout shape will contain three runs of<br>
text using three different styles.&nbsp;&nbsp;&nbsp;Each style will use a different text size. Two<br>
different fonts will be used, and three run features will be enabled. The definition<br>
looks like this:
</p>
<p>
<code>char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*sampleText = "Catch the Nasty WAVE, Dude";</code><br>
<code>gxPoint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;layoutPosition = {ff(10), ff(65)};</code><br>
<code></code><br>
<code></code><br>
<code>tempLayoutShape =&nbsp;&nbsp;GXNewLayout(1, &amp;totalLengthOfLayout,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;(void *) &amp;sampleText, 3, lengthsArray, styles, 0, nil, nil,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;nil, &amp;layoutPosition);</code><br>
<code></code><br>
<code>GXSetPictureParts(gthePage, 0, 0, 1, &amp;tempLayoutShape, nil,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;nil, nil);</code>
</p>
<p>
We draw tempLayoutShape by calling GXDrawShape(tempLayoutShape). The result is<br>
shown in Figure 7. Note that "WAVE" has been kerned automatically. 
</p>
<p>
<img src="img/237.gif" width="600 px"></img>
</p>
<p>
<b>&nbsp;Figure 7</b> Our Line Layout Shape
</p>
<p>
<b>&nbsp;Skewing the shape and cleaning up. </b>Because QuickDraw GX treats all<br>
typographic shapes as graphics, we can perform any graphical operation on our layout<br>
shape, now stored in tempLayoutShape. We'll skew it by 125% in the x direction about<br>
its origin, move the shape 15 pixels in the x direction to put it back into the window<br>
after the skew, and move it 75 pixels in the y direction to move it away from the<br>
beginning position. Finally, we'll add the shape to our picture stored in the variable<br>
gthePage.&nbsp;&nbsp;&nbsp;When drawn, it will look like Figure 8. 
</p>
<p>
<code>&nbsp;GXSkewShape(tempLayoutShape, fl(1.25), 0, shapePosition.x,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;shapePosition.y);</code><br>
<code>GXMoveShape(tempLayoutShape, ff(15), ff(75));</code><br>
<code>GXSetPictureParts(gthePage, 0, 0, 1, &amp;tempLayoutShape, nil, nil,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;nil);</code>
</p><img src="img/237-b.gif" width="700 px"></img>






<p>
<b>&nbsp;Figure 8</b> Our Line Layout Shape, Skewed
</p>
<p>
&nbsp;We no longer need tempLayoutShape because it's now part of our picture, so we can<br>
dispose of tempLayoutShape and our array of styles:
</p>
<p>
<code>short&nbsp;&nbsp;&nbsp;loop;</code><br>
<code></code><br>
<code>GXDisposeShape(tempLayoutShape);</code><br>
<code>for (loop = 0; loop &lt;= 2; loop++)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXDisposeStyle(styles[loop]);</code>
</p>
<p>
&nbsp;Now gthePage contains three shapes. The first shape is a colored path that outlines the<br>
text "GX," the second shape is the same path filled with stars, and the third shape is a<br>
typographically cool and skewed rendition of "Catch the Nasty WAVE, Dude." When we<br>
call GXDrawShape(gthePage), all these shapes are drawn. In the QuickDraw GX shell,<br>
gthePage is set up in the CreateThePageOfGXShapes function. 
</p>
<h2>BASIC PRINTING IN QUICKDRAW GX</h2>
<p>
QuickDraw GX adds quite a few new printing features, as mentioned earlier in this<br>
article. We'll briefly explore printing here by discussing methods for printing<br>
shapes, how to initialize QuickDraw GX printing, how to handle printing errors, how<br>
to implement three new print items added to the File menu, and how to finish up<br>
printing. 
</p>
<p>
<b>METHODS FOR PRINTING SHAPES</b><br>
Three approaches to printing shapes are available to your application: you can send<br>
shapes to QuickDraw GX printing one by one, you can send a picture that contains all<br>
the shapes used to represent a page, or you can send a picture that contains other<br>
pictures. 
</p>
<p>
Depending on your application, sending an entire picture full of information may be<br>
simplest, but if the picture contains quite a few shapes, say 20,000 to 25,000, you<br>
might suffer a performance penalty.&nbsp;&nbsp;&nbsp;On the other hand, sending shapes one by one is<br>
more complicated for some applications, but it may be the most efficient in terms of<br>
performance when you have lots of shapes -- more than 20,000.&nbsp;&nbsp;If you have lots of<br>
shapes in one big picture but you don't want to send them one by one, you should<br>
consider breaking the big picture into smaller pictures. (Recall that a QuickDraw GX<br>
picture is a shape that can contain other pictures.) This approach would enable you to<br>
group similar items in the same way as in MacDraw&#174;. 
</p>
<p>
You need to decide which method works best for your application. In the case of our<br>
shell, we'll send a picture for each page of our document (which conveniently consists<br>
of only one page). 
</p>
<p>
<b>INITIALIZING QUICKDRAW GX PRINTING</b><br>
To initialize QuickDraw GX printing, we call InitPrinting after we create the graphics<br>
client. We then create a job, which is an extensible data structure containing all the<br>
information required to print a document. For example, a job specifies the formatting<br>
printer driver, the printer for which the job has been targeted, when the document<br>
should be printed, and the number of pages in the document. 
</p>
<p>
<code>OSErr&nbsp;&nbsp;&nbsp;myQDGXPrintError;</code><br>
<code>gxJob&nbsp;&nbsp;&nbsp;gDocumentJob;</code><br>
<code></code><br>
<code>myQDGXPrintError = GXInitPrinting();</code><br>
<code></code><br>
<code>if (myQDGXPrintError == noErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;myQDGXPrintError = GXNewJob(&amp;gDocumentJob);</code><br>
<code>else</code><br>
<code>// Your error-handling code here!</code>
</p>
<p>
<b>HANDLING PRINTING ERRORS</b><br>
QuickDraw GX printing handles printing errors differently from the Printing<br>
Manager. The Printing Manager requires you to check for an error after each call. If<br>
you receive an error, you must match all your open calls with the appropriate close<br>
calls, close up the Printing Manager, and report the error to the user.
</p>
<p>
In QuickDraw GX printing, printing errors are local to the job. This gives you the<br>
ability to poll for errors after a group of routines, making your code smaller and<br>
cleaner. If you do receive an error within a group of routines, the routine that caused<br>
the error will prevent the remaining calls from executing until the error is cleared<br>
by calling GXGetJobError. You can then alert the user to the problem. All the<br>
QuickDraw GX printing errors are listed in PrintingErrors.h.
</p>
<p>
<b>IMPLEMENTING THE NEW MENU ITEMS</b><br>
Your application should implement three new items in the File menu: Print One Copy,<br>
Document Setup, and By Page Setup.
</p>
<ul>
<li>Print One Copy should print one copy of the document without presenting<br>
the user with any dialog other than a status dialog.</li>
<li> Document Setup should present a dialog that lets the user format the<br>
entire document, similar to the old Page Setup dialog.</li>
<li> By Page Setup should present a dialog that enables page-by-page<br>
formatting of a document (for instance, the user should be able to choose a<br>
different page size for each page in the document). </li>
</ul>
<p>
We won't take the space to reprint the code to implement Document Setup or By Page<br>
Setup here; check it out in our QuickDraw GX shell. 
</p>
<p>
When the user chooses Print One Copy from the File menu, we want to print the<br>
application's document. In our QuickDraw GX shell, that means printing the contents of<br>
gthePage:
</p>
<p>
<code>OSErr DoPrintOneCopy(WindowPtr window)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Str255&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windowTitle;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;OSErr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printError;</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;if (window)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GetWTitle(window, windowTitle);</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Start sending the job. The job has the same name as our</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// window, and it contains one page. The name appears in the</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// status dialog.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GXStartJob(gDocumentJob, windowTitle, 1);</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Send the entire page down to the printer. (All the shapes</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// that are being printed have been collected into gthePage.)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GXPrintPage(gDocumentJob, 1, GXGetJobFormat(gDocumentJob, 1),</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gthePage);</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// This call tells QuickDraw GX printing we've finished</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// sending the job, so terminate the transmission (that is,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the connection to the printer).</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GXFinishJob(gDocumentJob);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (GXGetJobError(gDocumentJob) != noErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Your error-handling code here!</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code>}</code>
</p>
<p>
<b>FINISHING UP</b><br>
Once we've finished printing, we leave the printing system open. This isn't a problem,<br>
because the QuickDraw GX printing system has a very small memory requirement<br>
when not in use -- approximately 35K. The main reason we leave it open is that we<br>
want to keep the job around, ready to be used the next time the user prints. If we were<br>
to close the printing system, we would need to recreate the job.
</p>
<h2>CLOSING UP THE QUICKDRAW GX WORLD</h2>
<p>
Closing up the QuickDraw GX world is as straightforward as initializing it. You should<br>
dispose of all the QuickDraw GX objects you created while your application was<br>
running. For example, if you called the GXNewShape routine to create a shape, you<br>
should call the GXDisposeShape routine to dispose of it. 
</p>
<p>
In our QuickDraw GX shell's shutdown, we need to dispose of the QuickDraw GX picture<br>
we created to contain all the shapes drawn to our window, the common color library,<br>
our window, and the graphics client. To dispose of the picture we created, we first test<br>
to make sure it contains something. If it does, we call GXDisposeShape on it:
</p>
<p>
<code>if (gthePage != nil) GXDisposeShape(gthePage);</code>
</p>
<p>
The QuickDraw GX shell has also been using the common color library, which we<br>
dispose of by calling
</p>
<p>
<code>DisposeCommonColors();</code>
</p>
<p>
Now we can dispose of the window; this also disposes of the view ports. In our shell, we<br>
created our own pointer to the window record, so we need to dispose of it with the<br>
appropriate call. 
</p>
<p>
To close up the QuickDraw GX printing system, we dispose of the job and then call<br>
GXExitPrinting before we dispose of the graphics client. If we were going to save our<br>
picture to disk, we would want to flatten the job to disk as well. 
</p>
<p>
<code>if (GXDisposeJob(gDocumentJob))</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;// Your error-handling code here!</code><br>
<code></code><br>
<code>if (GXExitPrinting())</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;// Your error-handling code here!</code>
</p>
<p>
Finally, we need to call GXDisposeGraphicsClient to dispose of the graphics client we<br>
created earlier:
</p>
<p>
<code>GXDisposeGraphicsClient(gGraphicsClient);</code>
</p>
<p>
If for some reason you haven't yet disposed of all the QuickDraw GX objects you've<br>
created while your application has been running, GXDisposeGraphicsClient disposes of<br>
them. If you enabled graphics notices earlier in your application, you'll receive a<br>
graphics notice for the first QuickDraw GX object you didn't dispose of. For example, if<br>
you didn't dispose of a shape, you'll receive this notice:
</p>
<p>
<code>GRAPHICS NOTICE: shape not disposed</code>
</p>
<p>
This isn't a problem when you're shutting down your application, because the<br>
QuickDraw GX heap is cleaned up when GXDisposeGraphicsClient is called. But getting a<br>
notice like this when your application ends means that you've been leaving unused<br>
items in the QuickDraw GX heap. That could mean reduced performance, since the<br>
QuickDraw GX Memory Manager has to page these unused objects into and out of the<br>
heap in a low-memory situation. 
</p>
<p>
If you do receive a graphics notice about something you didn't dispose of, you should<br>
track down the object to improve your runtime memory management. Prevent your<br>
application from calling GXDisposeGraphicsClient so that the QuickDraw GX heap<br>
doesn't disappear before you can analyze it. In GraphicsBug, use the Heap menu to<br>
choose your application's heap; then type "hd" to get a dump of your QuickDraw GX<br>
heap, or "hd shape" to get a list of all the shapes you forgot to throw away. 
</p>
<p>
In our QuickDraw GX shell, the routine ShutDownProgram closes up the QuickDraw GX<br>
world. 
</p>
<h2>WHERE TO GO FROM HERE</h2>
<p>
We've taken a look at what you need to do to begin making use of the new QuickDraw GX<br>
technology. Now you're ready to tackle that huge pile of QuickDraw GX material.
</p>
<p>
I suggest starting with the sample code that comes with QuickDraw GX. There are<br>
sample applications ranging from very simple to relatively complex, and some tools to<br>
play with. Try out the samples that interest you. For an illustration of the minimum<br>
number of lines of code needed to draw GX shapes, take a look at the "One Rectangle"<br>
sample. It initializes the QuickDraw GX world, attaches a view port to a window,<br>
creates a rectangle, and draws the shape to the window.&nbsp;&nbsp;Then take a look at the<br>
QuickDraw GX documentation. You should start with the "QuickDraw GX Objects"<br>
chapter, which describes all the objects illustrated in Figure 2. From there, proceed<br>
to the parts of the documentation that make the most sense for your application.
</p>
<p>
I hope you've enjoyed this overview of QuickDraw GX. We haven't covered all the<br>
exciting parts of the technology, by any means. This is only the beginning! 
</p>
<h2>MANAGING MEMORY IN THE QUICKDRAW GX HEAP</h2>
<p>
The graphics and layout portions of QuickDraw GX use their own heap format and their<br>
own relocating Memory Manager to improve efficiency. Why is this necessary? The GX<br>
system is object based, so it needs the ability to quickly move graphics and layout<br>
objects from the heap onto disk when they aren't needed and additional memory is<br>
required, and to move these objects back into memory when they're needed. This isn't<br>
possible with the current Memory Manager.
</p>
<p>
Your application has quite a bit of control over the objects it creates in the QuickDraw<br>
GX heap. The QuickDraw GX API provides calls to unload objects from the heap, and<br>
shape attributes that indicate when a shape should be paged out of the heap to the<br>
backing store on disk. If you don't unload the objects or set any of the shape attributes<br>
yourself, QuickDraw GX unloads the oldest objects first.
</p>
<p>
You can use a GXUnload call to tell QuickDraw GX to page a graphics or layout object --<br>
specifically, a shape, style, transform, ink, color profile, color set, or tag -- from<br>
the heap to the backing store on disk when the next memory management call occurs.<br>
For example, to unload a particular shape from the heap, you would use the following<br>
call:
</p>
<p>
<code>GXUnloadShape(gxShape target);</code>
</p>
<p>
QuickDraw GX maintains a reference to the objects, so it can read them from disk back<br>
into the heap if your application needs them. It does this automatically, but if you want<br>
to improve the performance of your application, you can explicitly load graphics and<br>
layout objects with a GXLoad call. For example, to load a particular shape into the<br>
heap, you would use the following call:
</p>
<p>
<code>GXLoadShape(gxShape target);</code>
</p>
<p>
There are two shape attributes that you can set to indicate when to page a shape out to<br>
disk when memory is needed:
</p>
<ul>
<li>When gxDiskShape is set, this shape will be the first shape to be paged out<br>
of memory to disk when memory is needed.</li>
<li>When gxMemoryShape is set, this shape will be the last to be paged out to<br>
disk.</li>
</ul>
<p>
It's generally a good idea to dispose of an object as soon as you've finished with it. If<br>
you leave a bunch of unused objects lying around in the heap, QuickDraw GX will<br>
maintain them and page them out to disk when memory becomes tight. This wasted<br>
operation will cause your application to take a performance hit.
</p>
<p>
If you have a collection of shapes, say a picture, that you won't need for a while, you<br>
should consider flattening them to disk and then disposing of them. When you flatten a<br>
shape to disk, each object is compressed and sent to the file as a stream of data. When<br>
you dispose of the objects you just flattened, you free up some heap space.
</p>
<h2>TRACKING DOWN A MEMORY TRASHING PROBLEM</h2>
<p>
Validation is a good way to track down a memory trashing problem. If the QuickDraw<br>
GX heap gets trashed, you need to know if it's your application that's doing the damage<br>
or if it's QuickDraw GX. These validation levels can help you find this out:
</p>
<p>
<code>gxNoMemoryManagerValidation = 0x0000</code><br>
<code>gxApBlockValidation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0x0100</code><br>
<code>gxFontBlockValidation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0x0200</code><br>
<code>gxApHeapValidation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0x0400</code><br>
<code>gxFontHeapValidation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0x0800</code><br>
<code>gxCheckApHeapValidation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0x1000</code><br>
<code>gxCheckFontHeapValidation&nbsp;&nbsp;&nbsp;= 0x2000</code>
</p>
<p>
To see if the problem is caused by your application, add gxApHeapValidation or<br>
gxFontHeapValidation to the types of validation you set. The one you choose depends on<br>
whether you believe the problem lies in a general API call or within the font heap (the<br>
heap separate from the QuickDraw GX heap where all the font information is cached).<br>
This type of validation checks the public API calls when they make a memory request.
</p>
<p>
If your application doesn't trash memory after adding this validation, it means that the<br>
problem is probably caused by an internal call within QuickDraw GX. In that case, add<br>
the validation level gxCheckApHeapValidation or gxCheckFontHeapValidation. This<br>
additional validation checks the memory allocation for the internal core calls. If you<br>
die at this point, you know that the internal call is causing the problem.
</p>
<p class="spacer">&nbsp;</p>
<p>
<b>PETE ("LUKE") ALEXANDER </b>started out as a meteorology major in college and to<br>
this day is great at forecasting the weather. He'd be happy to see nothing but blue<br>
skies, and in all kinds of weather he strives to incorporate something blue in his<br>
attire. He loves raw carrots, despises cooked ones. He hates waiting in lines and<br>
wearing a wristwatch. Sometimes when he's driving down the street and spots someone<br>
sitting at a bus stop, he'll honk his horn to wake them from their dazed stupor. And<br>
when he sees bicyclists sitting in their bike seats while riding up hills, he's been<br>
known to yell out the window, "Stand up, you weenie!"*
</p>
<p>
<b>If you're a PostScript language whiz </b>making the transition to QuickDraw GX,<br>
you'll find the article "QuickDraw GX for PostScript Programmers" in this issue<br>
helpful.*
</p>
<p>
<b>Shapes are completely resolution independent, </b>which enables accurate<br>
representation at any size to the screen or printer. *
</p>
<p>
<b>The By Page Setup and Document Setup dialogs </b> are new in QuickDraw GX.<br>
They're described later in this article under "Basic Printing in QuickDraw GX."*
</p>
<p>
<b>For a complete list </b>of all the errors, warnings, and notices provided by the<br>
graphics and layout portions of QuickDraw GX, take a look at the graphics errors.h<br>
header file.&nbsp;&nbsp;*
</p>
<p>
<b>Routine naming in QuickDraw GX </b> is very predictable and logical. All calls<br>
preceded by "GX" are from the core API, while ones without "GX" are from the library<br>
or application code. In addition, all calls pertaining to the same object are very<br>
similar, and once you grasp how to operate on one object, you pretty much know how to<br>
operate on all objects. *
</p>
<p>
<b>If you're looking for a shortcut,</b> you can skip the InitCommonColors call,<br>
because your first call to SetShapeCommonColor will initialize the library.&nbsp;&nbsp;*
</p>
<p>
<b>The number of view ports </b>that can be attached to another view port is limited<br>
only by the amount of memory you make available in the QuickDraw GX heap. *
</p>
<p>
<b>QuickDraw GX uses fixed-point numbers, </b>offering the advantage of speed,<br>
instead of the floating-point numbers used by QuickDraw. The <b>ff</b> macro uses<br>
IntToFixed to convert an integer into a fixed-point number; another handy macro, <b> fl</b>,<br>
converts a floating-point number into a fixed-point number.*
</p>
<p>
<b>Another approach to outlining text,</b> described in the article "QuickDraw GX for<br>
PostScript Programmers" in this issue, involves using text faces.&nbsp;&nbsp;*
</p>
<p>
<b>THANKS TO OUR TECHNICAL REVIEWERS </b>Hugo Ayala, Cary Clark, Tom Dowdy,<br>
Dave Hersey, Daniel Lipton, Dave Opstad*
</p>
</body>
</html>
