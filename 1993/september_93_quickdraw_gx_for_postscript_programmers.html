<!DOCTYPE html>
<html>
<head>
<!-- Article ID: 30 - Extracted from develop-1993 -->
<!-- on 2024-02-03 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by the copyright of its respective owners -->
<title>September 93 - QUICKDRAW GX FOR POSTSCRIPT PROGRAMMERS</title>
<link href="../common/styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h2>QUICKDRAW GX FOR POSTSCRIPT PROGRAMMERS</h2>
<h1>DANIEL LIPTON</h1>
<p>
<img src="img/204.gif" width="180 px"></img>
</p>
<p>
<i>With QuickDraw GX, the Macintosh gets a brand new, powerful, and totally different</i><br>
<i>model for text and graphics. Programmers of graphics and page layout applications</i><br>
<i>accustomed to using custom PostScript code during the printing process will have to</i><br>
<i>learn new techniques for imaging on the Macintosh, but the reward is a robust feature</i><br>
<i>set, an easier API, and consistent output whether to a screen (of any resolution or</i><br>
<i>color depth) or a printer (PostScript, raster, or vector). This article should help</i><br>
<i>those programmers make the transition.</i>
</p>
<p class="spacer">&nbsp;</p>
<p>
QuickDraw, while a powerful imaging model for its time and well suited for<br>
interactive graphics on the screen, lacks many features demanded by today's users. To<br>
provide features such as transformation (rotation, skewing, and so on) and B&#233;zier<br>
curves (ubiquitous in most modern graphics applications), applications in a<br>
QuickDraw world must do much of the work of drawing to the screen themselves.<br>
However, when printing to PostScript devices such as the Apple LaserWriter, these<br>
applications can offload much of this work to the printer by simply using the<br>
PostScript language to draw most, if not all, of their graphics and text. For this<br>
reason, many Macintosh application programmers have also become PostScript<br>
programmers and know how to get things done with the PostScript language. 
</p>
<h2>WHAT IS POSTSCRIPT?</h2>
<p>
Before getting into the details of how to make the transition from the PostScript<br>
language to QuickDraw GX, you need to understand the two models. The article "Getting<br>
Started With QuickDraw GX" in this issue of <i>develop</i> provides an introduction to<br>
QuickDraw GX. For an overview of the features of the PostScript language, read on. 
</p>
<p>
The PostScript language is probably best known as a robust graphics model with many<br>
capabilities.&nbsp;&nbsp;&nbsp;These capabilities include the ability to fill or frame paths made up of<br>
line and cubic B&#233;zier segments, render continuous tone images in both color and<br>
grayscale, transform graphics with a matrix, and clip to a path made up of line and<br>
cubic B&#233;zier segments. PostScript code can also draw text in a variety of different<br>
typefaces and manipulate this text as a graphic. 
</p>
<p>
To a limited extent the PostScript language is also a printing model. Certain operators<br>
in the PostScript language are related to printing. These include operators for page<br>
control&nbsp;&nbsp;(<b>showpage</b> and <b>copypage</b>), for controlling paper selection, and for<br>
controlling device-specific features (<b>setpagedevice </b>in PostScript Level 2). 
</p>
<p>
In addition, the PostScript language serves as a document interchange format. Since<br>
it's so widely available on so many different platforms and printers, a PostScript file<br>
can be treated as a device-independent&nbsp;&nbsp;document interchange. (However, it's not<br>
easily edited except by an expert.) Similarly, it's also used to export clip art.<br>
Encapsulated PostScript (EPS) files are widely used for exporting and importing<br>
artwork into documents. 
</p>
<p>
But the most important attribute of the PostScript language is that, more than a<br>
graphics model, it's a programming language with most of the constructs of modern<br>
high-level languages. The PostScript language is really a wrapper for the PostScript<br>
graphics model. The graphics are invoked by operators in the language. This full<br>
programmability makes it easy for programmers to extend the PostScript model to<br>
meet their needs. If a desired feature isn't in the PostScript graphics model, it can<br>
frequently be programmed in the PostScript language. For example, PostScript Level<br>
1 doesn't contain patterns, but a PostScript procedure can be written to fill a<br>
PostScript path with a pattern.
</p>
<p>
Due to this programmability, it's possible to emulate directly on PostScript printers<br>
many of the QuickDraw GX features that aren't present in the PostScript graphics<br>
model. When QuickDraw GX generates a PostScript stream, it includes a complex set of<br>
PostScript procedures to do so. 
</p>
<h2>COMPARING QUICKDRAW GX AND POSTSCRIPT</h2>
<p>
This section compares QuickDraw GX and the PostScript language in terms of their<br>
graphics, text- drawing, printing, and programming models. 
</p>
<p>
<b>THE GRAPHICS MODEL</b><br>
Some differences between the QuickDraw GX and PostScript graphics models include<br>
math types, B&#233;zier curves, matrix transformation, and orientation of the y-axis. 
</p>
<p>
<b>Math types. </b>Before entering the world of QuickDraw GX programming, a PostScript<br>
programmer must understand the basic differences in how numbers are represented<br>
by QuickDraw GX and the PostScript language. 
</p>
<p>
The PostScript language uses floating-point numbers and QuickDraw GX uses<br>
fixed-point numbers.&nbsp;&nbsp;&nbsp;The advantage to floating-point numbers is numeric range; the<br>
advantage to fixed-point numbers is speed. With fixed-point numbers, addition and<br>
subtraction are no slower than with regular integers.&nbsp;&nbsp;&nbsp;QuickDraw GX uses 16.16<br>
fixed-point numbers (32-bit numbers with the high 16 bits representing the integer<br>
portion and the low 16 bits representing the fractional portion).
</p>
<p>
In the PostScript language, color component values are represented by floating-point<br>
numbers between 0.0 and 1.0. In QuickDraw GX, color component values are<br>
represented by a type called colorValue, which is really a short such that 0x0000 is<br>
0.0 and 0xFFFF is 1.0. QuickDraw GX also uses a type called fract. The fract type is<br>
like the fixed type except that only the high two bits are the integer portion and the<br>
low 30 bits are the fractional portion. This is generally used for numbers between -1<br>
and 1 where fractional precision is important. 
</p>
<p>
<b>Curves. </b>Both QuickDraw GX and the PostScript language support B&#233;zier curves.<br>
However, each supports a different kind (see Figure 1). While the PostScript language<br>
uses cubics, GX uses quadratics. A cubic B&#233;zier curve segment is defined by four<br>
control points: a starting point on the curve, two points off the curve, and an ending<br>
point on the curve. A quadratic B&#233;zier curve is defined by three control points: a<br>
starting point on the curve, a control point off the curve, and an ending point on the<br>
curve. 
</p>
<p>
<img src="img/205.gif" width="497 px"></img>
</p>
<p>
<b>&nbsp;Figure 1</b> Comparing Control Points on B&#233;zier Curves
</p>
<p>
&nbsp;Figure 2 illustrates two similarly shaped paths. The one on the left is defined by two<br>
quadratic segments, requiring five control points. The one on the right is defined by a<br>
single cubic segment, requiring four control points. This seems to imply that in<br>
drawing similar shapes, more points are required using quadratics than using cubics<br>
and that, therefore, quadratics are at a disadvantage.&nbsp;&nbsp;&nbsp;However, to reduce data size, the<br>
data structure for a QuickDraw GX path allows implied points.&nbsp;&nbsp;&nbsp;Each point in the<br>
QuickDraw GX path has a control bit, indicating whether the point is on or off the<br>
curve. If two consecutive points in the path are off the curve, there's an implied point<br>
halfway between the two explicitly specified points. So, as shown in Figure 2, it's only<br>
necessary to supply four points for the quadratic path, as the point between point 2<br>
and point 3 is implicit. 
</p>
<p>
<img src="img/206.gif" width="600 px"></img>
</p>
<p>
<b>Figure 2</b> Control Points for Paths
</p>
<p>
<b>&nbsp;Matrix transformations.&nbsp;&nbsp;</b>Both QuickDraw GX and the PostScript language allow<br>
anything to be transformed through a matrix before being drawn. Both use a 3 x 3<br>
transformation matrix. However, in the PostScript language the matrix has implicit<br>
constant values in the last column, so there are only six degrees of freedom rather<br>
than nine. QuickDraw GX allows you to specify all nine elements of the matrix. 
</p>
<p>
&nbsp;To modify the current transformation matrix (CTM) by a given transformation, an<br>
application may use the following PostScript code:
</p>
<p>
<code>[ 4.17 0.0 0.0 -4.17 -1280.0 1650.5 ] concat</code>
</p>
<p>
This code concatenates the following matrix with the CTM in the graphics state:
</p>
<p><table border="0"><tr><td><code>4.17</code></td><td><code>0.0</code></td><td><code>0.0</code></td></tr>
<tr><td><code>0.0</code></td><td><code>-4.17</code></td><td><code>0.0</code></td></tr>
<tr><td><code>-1280.0</code></td><td><code>1650.5</code></td><td><code>1.0</code></td></tr></table></p>
<p class="spacer">&nbsp;</p>
<p class="spacer">&nbsp;</p>
<p>
QuickDraw GX has a data structure called gxMapping, which is a structure containing<br>
one field. The field is a 3 x 3 array. The first two columns contain fixed-point<br>
numbers and specify the skewing, scaling, rotation, and translation of the<br>
transformation. The third column is made up of fractional numbers (numbers of type<br>
fract) and specifies the perspective portion of the transformation. The following code<br>
generates a mapping that's equivalent to the matrix in the PostScript code:
</p>
<p>
<code>/* Declare a mapping structure (fract1 is a constant for 1.0 in</code><br>
<code>&nbsp;&nbsp;&nbsp;mathtypes.h). */</code><br>
<code>gxMapping&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aMapping =</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ { fl(4.17),&nbsp;&nbsp;&nbsp;&nbsp;fl(0.0),&nbsp;&nbsp;&nbsp;&nbsp;fl(0.0) }</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ fl(0.0),&nbsp;&nbsp;&nbsp;&nbsp;-fl(4.17),&nbsp;&nbsp;&nbsp;fl(0.0) }</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ -fl(1280.0), fl(1650.5), fract1&nbsp;&nbsp;} };</code>
</p>
<p>
<img src="img/207.gif" width="543 px"></img>
</p>
<p>
<b>Figure 3</b> Coordinate Systems
</p>
<p>
<b>The y-axis. </b>The y-axis orientation differs in the PostScript graphics model and<br>
QuickDraw GX. In the PostScript model, the y-axis increases from the bottom of the<br>
page or window to the top and in QuickDraw GX, as in QuickDraw, it increases from top<br>
to bottom (see Figure 3). 
</p>
<p>
<b>OBJECT-BASED MODEL VERSUS STREAM-BASED PROTOCOL</b><br>
A fundamental difference between graphics code for QuickDraw GX and PostScript code<br>
is that QuickDraw GX is object-based and PostScript code is essentially a<br>
stream-based protocol. Although the PostScript language is a programming language,<br>
documents usually consist of a set of PostScript procedures followed by a stream that<br>
invokes those procedures. Each model has advantages: With a stream-based protocol<br>
the graphic content of any given page is virtually infinite. As long as PostScript code is<br>
continuously streamed to the printer, it renders into the frame buffer until<b>showpage</b><br>
is issued -- which essentially says, "This page is done; start the next one." With an<br>
object model it's relatively easy to share data between objects. A quick summary of<br>
objects in QuickDraw GX illustrates this advantage. 
</p>
<p>
<b>QuickDraw GX objects. </b>The shape object is the basic element of the QuickDraw GX<br>
graphics model. A shape contains a geometry of any primitive type and points to three<br>
other objects that describe how to render that geometry: the ink object, which<br>
describes how to apply color to the geometry (as well as transfer mode); the style<br>
object, which describes how to affect the geometry before rendering (pattern, dash,<br>
and so on); and the transform object, which describes how to map and clip the<br>
geometry before rendering. These objects can, in turn, point to other objects. For<br>
example, a transform object points to a list of view port objects that describe where to<br>
draw the geometry (such as in which window). An ink object points to a color profile<br>
object that describes the colors in the ink in a device-independent manner. All the<br>
previously described objects could also have lists of tag objects. A tag object is simply<br>
a container for any data the application associates with the owning object. 
</p>
<p>
Data sharing is extremely easy in this object model. If I have a picture made up of 100<br>
different shapes and 30 of them have the same color, these 30 shapes can all point to<br>
the same ink object. The color for these 30 shapes is stored only once. In a<br>
stream-based protocol, it's only convenient to share data between consecutive items in<br>
the stream. (You can write PostScript code that shares data between nonconsecutive<br>
objects, but it's not easy.)
</p>
<p>
<b>PostScript procedures and dictionaries versus QuickDraw GX objects. </b><br>
Emulating the object model in PostScript code is possible because it's a programming<br>
language. You could use PostScript dictionaries as containers for shapes and then have<br>
a PostScript procedure that draws one of these dictionaries. The following is a simple<br>
example of how this could work. (Warning: Serious PostScript code ahead.)
</p>
<p class="spacer">&nbsp;</p>
<p>
<code>/aShape 7 dict def&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Make a dictionary for the shape.</code><br>
<code>aShape begin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Put it on the dictionary stack.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;/geometryProcedure {&nbsp;&nbsp;&nbsp;&nbsp;% Define a procedure for the geometry</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newpath&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;&nbsp;to draw a rectangle.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;100 100 moveto</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 100 rlineto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;100 0 rlineto</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 -100 rlineto</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;closepath</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;} bind def&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;% Dictionary entries for transform.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;/Transform [ 10 0 0 10 0 0 ] def</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;% Dictionary entries for the color.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;/redComponent 1.0 def</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;/greenComponent 0.0 def</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;/blueComponent&nbsp;&nbsp;1.0 def</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;/penWidth 5.0 def</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;/fillType (framed) def</code><br>
<code>end&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Dictionary definition.</code><br>
<code></code><br>
<code>% The following procedure takes a shape dictionary and draws it.</code><br>
<code>/DrawShapeDict {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;begin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Put the shape dictionary on the stack.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;gsave&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Shape shouldn't affect graphics state.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Transform concat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Apply transform.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;redComponent greenComponent blueComponent setrgbcolor</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Set the color.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;geometryProcedure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Execute the geometry procedure.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;fillType (framed) eq {&nbsp;&nbsp;&nbsp;% If the shape is framed,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;penWidth setlinewidth&nbsp;&nbsp;&nbsp;%&nbsp;&nbsp;set the pen width and</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stroke&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;&nbsp;stroke the path.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;} {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Else, fill the shape.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eofill</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;} ifelse</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;grestore</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;end</code><br>
<code>} bind def</code><br>
<code></code><br>
<code>% The following would be in the stream to draw the shape stored in</code><br>
<code>% the dictionary.</code><br>
<code>aShape DrawShapeDict</code>
</p>
<p>
You could use PostScript code in this manner, but most printers have limited memory,<br>
and memory management in PostScript printers is difficult (a subject for another<br>
article), so it's usually not done. 
</p>
<p>
<b>Graphics state versus shape attributes. </b>In a stream-based graphics model, a<br>
graphics state determines how a particular item is drawn. In the PostScript language,<br>
the graphics state attributes include the color, pen thickness, transformation matrix,<br>
clip, miter limit, end caps, and joins that will be used to fill or stroke the current<br>
path, bitmap, or text to be drawn. Applications using PostScript code must efficiently<br>
manage the graphics state -- you never want to send more information to the printer<br>
than necessary, but sending too little is fatal to the fidelity of the graphics. So, an<br>
application emitting PostScript code must send the color for the item to be drawn only<br>
if it's different from that of the last item drawn, and do similarly for pen thickness,<br>
transformation matrix, and so on. 
</p>
<p>
In the QuickDraw GX object-based model, every shape points to all the information<br>
necessary to draw itself. An application merely needs to call GXDrawShape to draw the<br>
shape properly with the designated color and pen thickness and other designated<br>
characteristics. The application no longer has to keep track of the graphics state.<br>
However, there's a different burden (though less cumbersome): making sure shape<br>
objects share other objects when possible to reduce the memory used by the picture. 
</p>
<p>
The following code samples effectively illustrate the difference between the two<br>
models. Each sample draws two rectangles, one red and one blue, and offsets the second<br>
one by (100, 100). First, here's the PostScript code:
</p>
<p>
<code>/DrawRect {100 100 moveto 25 0 rlineto 0 25 rlineto -25 0 rlineto</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;closepath fill} bind def</code><br>
<code>gsave</code><br>
<code>1.0 0.0 0.0 setrgbcolor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Set the color red.</code><br>
<code>DrawRect</code><br>
<code>100 100 translate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Move the coordinate system by</code><br>
<code>100,100.</code><br>
<code>0.0 0.0 1.0 setrgbcolor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Set the color blue.</code><br>
<code>DrawRect</code><br>
<code>grestore</code>
</p>
<p>
Now compare the QuickDraw GX code:
</p>
<p>
<code>void GXDraw2Rectangles()</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;gxRectangle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aRectangle =</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ ff(100), ff(100), ff(125), ff(125) };</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;gxShape&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rectShape;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;gxInk&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redInk, blueInk;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;gxColor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aColor;</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;aColor.space = rgbSpace;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Color will be RGB. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;aColor.profile = nil;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* No color profile. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;aColor.element.rgb.red = 0xFFFF;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;aColor.element.rgb.green = 0x0000;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;aColor.element.rgb.blue = 0x0000;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;redInk = NewInk();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Make red ink. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXSetInkColor(redInk, &amp;aColor);</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;aColor.element.rgb.red = 0x0000;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;aColor.element.rgb.green = 0x0000;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;aColor.element.rgb.blue = 0xFFFF;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;blueInk = NewInk();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Make blue ink. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXSetInkColor(blueInk, &amp;aColor);</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;rectShape = GXNewRectangle(&amp;aRectangle);/* Create a shape. */</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXSetShapeInk(rectShape, redInk);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Use red ink. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXDrawShape(rectShape);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Draw it. */</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;/* Move it over and draw it in blue. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXMoveShape(rectShape, ff(100), ff(100));</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXSetShapeInk(rectShape, blueInk);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Use blue ink. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXDrawShape(rectShape);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Draw it. */</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;/* Clean up. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXDisposeShape(rectShape);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXDisposeInk(blueInk);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXDisposeInk(redInk);</code><br>
<code>}</code>
</p>
<p>
The PostScript code uses a procedure to draw the rectangle. The procedure is analogous<br>
to the shape object. However, each time the rectangle is drawn, the graphics state must<br>
be modified to change the color and the transformation. At the end, the graphics state<br>
for subsequently drawn items is blue and the origin is shifted by (100, 100) from the<br>
original rectangle. The<b>grestore</b>operator is needed to set the graphics state back to<br>
what it was to begin with.
</p>
<p>
The QuickDraw GX code created a shape, made it red, drew it, moved it, made it blue,<br>
and drew it again. No global state was affected, only the shape itself. Moving the<br>
rectangle with PostScript code necessitated modifying the graphics state's CTM. With<br>
QuickDraw GX code, moving the rectangle involved only translating the shape's own<br>
geometry with the GXMoveShape routine. 
</p>
<p>
<b>QuickDraw GX database versus PostScript container. </b> In QuickDraw GX a<br>
picture is a type of shape object whose geometry is a list of other shapes. Those shapes<br>
in the list can also be picture shapes.&nbsp;&nbsp;&nbsp;Therefore, a QuickDraw GX picture shape is a<br>
hierarchical database of shapes. This database can be queried and modified with<br>
QuickDraw GX routines such as GXSetPictureParts, which inserts or replaces shapes<br>
in a picture shape, and GXGetPictureParts, which retrieves shapes from a picture.&nbsp;&nbsp;<br>
Since a picture can have objects that refer to each other, QuickDraw GX must have the<br>
whole picture shape available at one time (although not actually in memory, but<br>
rather in the disk-based backing store in low-memory conditions). 
</p>
<p>
A PostScript file describing a picture is essentially a container for graphics. The file<br>
contains all the data needed to draw the picture, but it can't be readily edited or queried<br>
without having an interpreter for the PostScript language built into your application.<br>
The PostScript stream-based protocol lets the device draw the stream on the fly. 
</p>
<p>
Again, each model has its advantages. The object model is best suited for interactive<br>
applications and the stream-based protocol is best suited for printers with limited<br>
memory and no disk drives. 
</p>
<p>
<b>TEXT-DRAWING MODELS</b><br>
QuickDraw GX contains three different types of shape objects for drawing text: the text<br>
type, the glyph type, and the layout type. The text type is the simplest of the three,<br>
although it's not the mostprimitive form.&nbsp;&nbsp;Drawing a text shape is similar to using the<br>
PostScript<b>show</b> operator, as illustrated by the following code samples. First, here's a<br>
PostScript "Hello World" program:
</p>
<p>
<code>24 scalefont&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Scale it to 24 points.</code><br>
<code>setfont&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Make it the current font.</code><br>
<code>100 100 moveto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Move to location 100, 100.</code><br>
<code>(Hello World) show&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Draw the text.</code>
</p>
<p>
Now here's the QuickDraw GX "Hello World" program:
</p>
<p>
<code>void GXHelloWorld(void)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;gxShape&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;helloShape;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;gxFont&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aFont;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;gxPoint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location = {ff(100), ff(100)};</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;/* Find the font object for Times. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;aFont = FindPNameFont(fullFontName, "\pTimes Roman");</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;/* Make a text shape. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;helloShape = NewText(11, "Hello world", &amp;location);</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXSetShapeFont(helloShape, aFont);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXSetShapeTextSize(helloShape, ff(24));</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXDrawShape(helloShape);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXDisposeShape(helloShape);</code><br>
<code>}</code>
</p>
<p>
You can use these examples to help you get started with drawing text in QuickDraw GX.<br>
They also show some similarities between the PostScript model and the QuickDraw GX<br>
model. Both have font entities: in PostScript code it's a dictionary and in QuickDraw GX<br>
code it's an object. In PostScript code, the font matrix entry in the dictionary itself is<br>
scaled by the<b>scalefont</b>operator to set the point size; in QuickDraw GX code, the point<br>
size is contained in the shape's style and can be set by a call to GXSetShapeTextSize. For<br>
the most part, that's it for similarities. 
</p>
<p>
<img src="img/208.gif" width="380 px"></img>
</p>
<p>
<b>&nbsp;Figure 4</b> Different Glyphs From a Roman Font
</p>
<p>
<b>Characters and glyphs. </b>To understand the full capabilities of QuickDraw GX<br>
typography, you must first understand the difference between characters and glyphs.<br>
Characters are symbols that havelinguistic meaning, usually a letter from an alphabet.<br>
Glyphs are renditions of those characters or combinations of them. For example, for<br>
any given character from an alphabet, there may be various forms of this character<br>
that are appropriate to draw at different times (see Figure 4). 
</p>
<p>
The most complex text drawing in QuickDraw GX comes from the layout shape. With a<br>
layout shape, the application specifies which characters in the language make up the<br>
piece of text to be displayed. Given the language and script system specified in the<br>
layout shape's style object, QuickDraw GX can then figure out which glyphs to use for<br>
those characters. 
</p>
<p>
The top line of Figure 4 shows three glyphs from a particular Roman font. They're the<br>
glyphs for lowercase<i>f</i> , lowercase<i>i,</i>&nbsp;&nbsp;and a lowercase<i> fi</i>&nbsp;&nbsp;ligature. The ligature is an<br>
example of a glyph that represents two characters. With a layout shape, QuickDraw GX<br>
can detect when the<i>i</i>&nbsp;&nbsp;follows the<i>f</i> and automatically choose the<i>fi</i>&nbsp;&nbsp;ligature glyph when<br>
drawing. This allows the user to type<i>f</i>&nbsp;&nbsp;followed by<i> i</i>&nbsp;&nbsp;rather than having to figure out<br>
what key combination to type and what font to select to get the<i>fi</i> ligature. 
</p>
<p>
The bottom line of Figure 4 illustrates another example of different glyphs for the<br>
same character.&nbsp;&nbsp;&nbsp;The glyph on the left is the normal capital<i>A</i>&nbsp;&nbsp;for that font. The glyph<br>
on the right is a glyph to use at the beginning of the line. With a layout shape,<br>
QuickDraw GX detects when the character is at the beginning of the line and<br>
automatically chooses the correct glyph. 
</p>
<p>
<b>Platforms and encodings. </b>In most versions of the PostScript language, any given<br>
encoding of a font has access to only 256 glyphs at a time. If a font contains more than<br>
256 glyphs, you must use different font dictionaries, each with a different encoding. In<br>
effect, the application generating the PostScript code must select from different font<br>
dictionaries to create all the glyphs in a given typeface.&nbsp;&nbsp;&nbsp;QuickDraw GX can take<br>
advantage of fonts that contain up to 65535 glyphs, all of which are available to any<br>
shape object. 
</p>
<p>
The bytes contained in the geometry of a text, layout, or glyph shape can have different<br>
meanings depending on the gxFontPlatform and gxFontScript attributes set in the style<br>
object. When gxFontPlatform is set to gxMacintoshPlatform and gxFontScript is set to<br>
gxRomanScript, the stream of bytes means the same thing it does on a Roman<br>
Macintosh system today. If gxFontPlatform is set to gxGlyphPlatform, the bytes are<br>
taken two at a time as a short and are treated as glyph indices in the font; a shape<br>
object then has direct access to all the glyphs in a font. Each font indicates which<br>
platforms, languages, and scripts it supports. 
</p>
<p>
<b>Positioning glyphs in a line of text. </b>The PostScript language provides several<br>
methods for allowing your application to explicitly position glyphs on a page. The<br>
simplest is the<b>show</b> operator. This operator simply draws each glyph specified by the<br>
string and moves the current point by the advance width of that glyph. The<b> ashow</b> and<br>
<b>awidthshow</b> operators allow the application to modify the advance width for all<br>
glyphs or a particular glyph. With the<b> kshow</b> operator you can call a general<br>
procedure between the drawing of each pair of glyphs specified by the string and the<br>
procedure can modify the graphics state before drawing the next glyph. This process is<br>
generally used for kerning. In kerning the procedure is passed the two character codes,<br>
uses those two codes to look in a kerning table, and modifies the current point<br>
appropriately. This method, while totally flexible, is difficult to use because the<br>
application must parse font metric files to derive kerning tables to use with<br>
the<b>kshow</b>procedure. 
</p>
<p>
PostScript Level 2 provides a way to position characters without executing a<br>
procedure for each glyph drawn -- the<b> xshow</b>,<b> yshow</b>, and<b> xyshow</b> operators. With<br>
these operators the application can specify an array of advance widths to use in place<br>
of the built-in advance widths of the font. This is faster than using the<b>kshow</b>operator.<br>
Again, the application must generate the advance widths to use, usually by parsing font<br>
metric tables and deriving kerning information. 
</p>
<p>
It's possible for applications to generate PostScript code that uses the<b> kshow</b> operator<br>
or the <b>xshow</b>, <b>yshow</b>, and <b>xyshow</b> operators to justify, kern, and track text. In<br>
QuickDraw GX, a layout shape does this automatically, as specified by metrics in the<br>
QuickDraw GX font. Each font contains tables that specify kerning pairs with kerning<br>
amounts, optimal tracking values, and optimal choices for how justification should<br>
occur. Your application can override these values if you choose, but the values&nbsp;&nbsp;in the<br>
font are written by the font designer and therefore cause QuickDraw GX to position the<br>
glyphs as the font designer intended. Your application need not parse the font metric<br>
tables and position glyphs directly. 
</p>
<p>
&nbsp;When you use layout or glyph shapes, text can have multiple style runs. This allows a<br>
single shape object to switch between fonts, sizes, text faces, and languages as many<br>
times as desired (see Figure 5). 
</p>
<p>
<img src="img/209.gif" width="600 px"></img>
</p>
<p>
<b>&nbsp;Figure 5</b> A Shape Object With Multiple Style Runs
</p>
<p>
&nbsp;If you want the application to have direct control over positioning glyphs, use a glyph<br>
shape object rather than a layout shape object. Glyph shapes bypass the automatic<br>
positioning information. This approach is similar to using PostScript operators. When<br>
using a glyph shape, you specify exactly which glyphs are to be drawn in what styles<br>
and at what positions and angles. Then, when GXDrawShape is called, it uses this<br>
information for rendering.
</p>
<p>
&nbsp;Using the positions and advance bits in a glyph shape, your application can draw the<br>
glyphs anywhere on the page. Figure 6 illustrates some of the data in a glyph shape<br>
with various values in the positions and advance bits. Where the advance bit is 1, the<br>
value in the positions array is that glyph's absolute position on the page (before being<br>
mapped through the shape's transform). Where the advance bit is 0, the value in the<br>
positions array is an amount to add to the normal advance vector of the glyph. Not<br>
shown in Figure 6 is the tangents array. Each glyph in a glyph shape object also has a<br>
tangent vector that specifies an orientation for the glyph in addition to the position. 
</p>
<p>
<img src="img/210.gif" width="600 px"></img>
</p>
<p>
<b>&nbsp;Figure 6</b> Some of the Data in a Glyph Shape
</p>
<p>
&nbsp;Given the tangent (Tx, Ty), the glyph is transformed through the following 2 x 2<br>
matrix:
</p>
<p><table border="0"><tr><td><code>Tx</code></td><td><code>Ty</code></td></tr>
<tr><td><code>-Ty</code></td><td><code>Tx</code></td></tr></table></p>
<p class="spacer">&nbsp;</p>
<p class="spacer">&nbsp;</p>
<p>
It's important to note that glyph shapes don't do any character-to-glyph mapping, as<br>
do layout shapes. They map character codes to glyph codes as specified by the<br>
gxFontPlatform attribute in the style object, but they don't automatically pick<br>
alternate forms of characters (ligatures, for example). If you use glyph shapes in<br>
your application, you have to do nearly everything; however, glyph shapes provide the<br>
most flexibility. 
</p>
<p>
<b>QuickDraw GX is language aware. </b>When you use the layout type of shape objects,<br>
QuickDraw GX is aware of the language and script as specified by the style object. This<br>
allows QuickDraw GX to automatically run text, for example, from left to right for<br>
English, right to left for Hebrew, and vertically for Chinese. Each font/language<br>
combination has a set preference for which way to run text. Because the layout shape<br>
can automatically determine where to position the glyphs based on the language, your<br>
application can maintain the text for the shape in its linguistic order rather than the<br>
display order. 
</p>
<p>
QuickDraw GX also uses script-dependent information when justifying text. For<br>
example, in English, justification involves adding or removing white space between<br>
glyphs. In Arabic, glyphs are joined by horizontal lines called Kashidas. When<br>
justifying Arabic text, QuickDraw GX automatically varies the length of the Kashida to<br>
compensate for added or removed space in the text. 
</p>
<p>
<b>PRINTING MODELS</b><br>
The printing models for QuickDraw GX and the PostScript language differ in much the<br>
same ways as the graphics models do. PostScript code uses a stream-based protocol<br>
while QuickDraw GX uses an object model. 
</p>
<p>
<b>PostScript stream-based printing. </b>PostScript language elements invoke<br>
various printing commands such as commands for choosing a particular type of paper<br>
or a particular page orientation. With PostScript Level 1, some implementations added<br>
operators for bin selection and other device-dependent features. PostScript Level 2<br>
has the<b>setpagedevice</b>operator, which is a generalization of this idea. 
</p>
<p>
A PostScript stream that represents an actual document rather than a particular<br>
encapsulated graphic has those various operators embedded between the pages to<br>
instruct the printer page by page. In addition to operators, there's a defined protocol<br>
for including comments in a PostScript stream to identify the document elements.<br>
Some of these occur at the beginning of the stream and some of them occur between the<br>
pages. They're called document structuring conventions (DSCs) and are described in<br>
detail in the<i>PostScript Language Reference Manual,</i> Second Edition<i>. </i>
</p>
<p>
<b>QuickDraw GX object-based printing. </b>For each element of a printed document,<br>
there's a corresponding QuickDraw GX object. Your application simply associates the<br>
appropriate objects when spooling the document's pages and QuickDraw GX does the<br>
rest. Your application need not worry about the details of paper trays and<br>
transformation matrices to reorient the page. 
</p>
<p>
Global document properties, such as the device information and the number of pages or<br>
copies, are stored in the job object. Properties associated with a particular page are<br>
stored in the format object.&nbsp;&nbsp;&nbsp;Each format object owns a paper type object. 
</p>
<p>
The job object can be thought of as a context for the document that your application is<br>
spooling.&nbsp;&nbsp;&nbsp;The format object contains information such as the page orientation<br>
(portrait or landscape) and paper type (US Letter, Envelope, and so on). Each page<br>
your application generates can have a different format associated with it. The job<br>
object contains a default format that's used if a specific format isn't specified for a<br>
page. All your application needs to do to set up the contents of these objects is call the<br>
QuickDraw GX printing dialog boxes. The following code example shows how five pages<br>
in one job can be printed with four different formats. (The contents of each page are<br>
stored in a picture shape object.)
</p>
<p>
<code>OSErr Print5Pages(shape page1, shape page2, shape page3, shape page4,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shape page5)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OSErr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EditMenuRecord&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myEditMenu;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gxFormat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;format1, format2, format3;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gxJob&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myJob;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DialogResult&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result;</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status = GXNewJob(&amp;myJob);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (status != noErr) return (status);</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Add code here to set up the Edit menu record. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;. . .</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Use dialog box to set up default format for the job. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = GXJobDefaultFormatDialog(myJob, &amp;myEditMenu);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (result == okSelected) {</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Create three separate formats for the first three</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pages. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;format1 = GXNewFormat(myJob);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;format2 = GXNewFormat(myJob);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;format3 = GXNewFormat(myJob);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Bring up dialog box to set up page 1's format. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = GXFormatDialog(format1,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"\pPage Setup for Page 1", &amp;myEditMenu);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (result != okSelected) goto canceled;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Bring up dialog box to set up page 2's format. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = GXFormatDialog(format2,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"\pPage Setup for Page 2", &amp;myEditMenu);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (result != okSelected) goto canceled;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Bring up dialog box to set up page 3's format. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = GXFormatDialog(format3,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"\pPage Setup for Page 3", &amp;myEditMenu);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (result != okSelected) goto canceled;</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Bring up the Job dialog box. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = GXJobPrintDialog(myJob, &amp;myEditMenu);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (result != okSelected) goto canceled;</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Now spool the document. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GXStartJob(myJob, "\pdevelop Article", 5);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GXPrintPage(myJob, format1, page1, 1);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GXPrintPage(myJob, format2, page2, 2);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GXPrintPage(myJob, format3, page3, 3);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GXPrintPage(myJob, nil, page4, 4);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Page 4 uses job's default format. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GXPrintPage(myJob, nil, page5, 5);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* So does page 5. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GXFinishJob(myJob);</code><br>
<code></code><br>
<code>canceled:</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GXDisposeFormat(format1);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GXDisposeFormat(format2);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GXDisposeFormat(format3);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status = GXGetJobError(myJob);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GXDisposeJob(myJob);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (status);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;}</code>
</p>
<p>
This example calls the QuickDraw GX routines that present dialog boxes, allowing the<br>
user to configure all the job and format properties. However, the QuickDraw GX<br>
printing API allows the programmer to control these properties directly, if desired.<br>
Using this API, your application can exert total control of all aspects of printing<br>
without ever bringing up a dialog box! 
</p>
<h2>IF YOU CAN DO IT IN POSTSCRIPT . . .</h2>
<p>
This section shows you how to use QuickDraw GX to do some of those tricky things<br>
you've figured out how to do with PostScript code.
</p>
<p>
<b>FRAMING SOMETHING WITH A NONSQUARE PEN</b><br>
QuickDraw has the concept of a nonsquare pen. You can set the width and height of the<br>
pen independently. Both the PostScript language and QuickDraw GX have only one pen<br>
dimension; however, you can simulate the framing of a path with a nonsquare pen.<br>
Here's the PostScript code:
</p>
<p>
<code>% Assuming there exists a path ready for drawing in the graphics</code><br>
<code>% state:</code><br>
<code>gsave&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Save the current graphics state to muck with later.</code><br>
<code>1 setlinewidth&nbsp;&nbsp;% Set the current line width to 1.</code><br>
<code>xPen yPen scale % Scale the CTM by the pen width and pen height.</code><br>
<code>stroke&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Stroke the path. The scaled matrix will scale the</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% 1-unit line width by xPen in the x-axis and yPen in</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% the y-axis when stroking. This produces the desired</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% effect.</code><br>
<code>grestore&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Put back the CTM and line width.</code><br>
<code>newpath&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Clear the path since we did grestore after stroke.</code>
</p>
<p>
Now, here's how to do it with QuickDraw GX:
</p>
<p>
<code>void FrameNonSquare(gxShape theShape, fixed xPen, fixed yPen)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;gxShape&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tempShape;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;gxMapping&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aMapping;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;gxTransform&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aTransform;</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;/* Make a copy of the shape to operate on. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;tempShape = GXCopyToShape(nil, theShape);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;/* Make a new transform for the shape so it's scaled by the */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pen. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;aTransform = GXCopyToTransform(nil,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GXGetShapeTransform(tempShape));</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXScaleTransform(aTransform, xPen, yPen, 0, 0);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXSetShapeTransform(tempShape, aTransform);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;/* Make an inverse mapping to premap the shape so that when it's</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scaled by the pen it will return to its original self. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXResetMapping(&amp;aMapping);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Set to identity. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXScaleMapping(&amp;aMapping, FixedDivide(ff(1), xPen),</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FixedDivide(ff(1), yPen), 0, 0);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXMapShape(tempShape, &amp;aMapping);</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXSetShapePen(tempShape, ff(1));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Set pen width to 1. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXDrawShape(tempShape);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Draw it. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXDisposeShape(tempShape);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXDisposeTransform(aTransform);</code><br>
<code>}</code>
</p>
<p>
<b>MODIFYING GLYPHS IN A FONT</b><br>
The PostScript language allows you to modify the behavior of glyphs by changing<br>
entries in the font dictionary, either directly or with the<b>makefont</b>operator. 
</p>
<p>
<b>Oblique text. </b>This PostScript code creates oblique text:
</p>
<p>
<code>/Helvetica findfont 24 scalefont&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Put 24-point Helvetica</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% dictionary on the stack.</code><br>
<code>[1.0 0.0 -0.25 1.0 0.0 0.0] makefont&nbsp;&nbsp;&nbsp;&nbsp;% Skew the font dictionary.</code><br>
<code>setfont&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Make it the current font.</code>
</p>
<p>
This is how to do it with QuickDraw GX:
</p>
<p>
<code>/* Modify the style object to do oblique text. */</code><br>
<code>void ObliqueText(gxStyle aStyle)&nbsp;&nbsp;&nbsp;</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;gxTextFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theFace;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;gxTransform&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aTransform;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;aTransform = GXNewTransform();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Make a transform. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXSkewTransform(aTransform, fix1/4, 0, 0, 0);&nbsp;&nbsp;&nbsp;/* Skew it. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;theFace.faceLayers = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Set text face to 1 layer. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXResetMapping(&amp;theFace.advanceMapping);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Make advance mapping the identity mapping. */</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;theFace.faceLayer[0].outlineTransform = aTransform;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;theFace.faceLayer[0].outlineStyle = nil;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;theFace.faceLayer[0].boldOutset.x = 0;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;theFace.faceLayer[0].boldOutset.y = 0;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;theFace.faceLayer[0].outlineFill = gxSolidFill;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;theFace.faceLayer[0].flags = 0;</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXSetStyleFace(aStyle, &amp;theFace);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXDisposeTransform(aTransform);</code><br>
<code>}</code>
</p>
<p>
The text face data structure is used to modify the way glyphs are drawn. A text face can<br>
have multiple layers and each layer can have a style (for patterns and so on), a<br>
transform, a boldness, and a fill type.&nbsp;&nbsp;&nbsp;By using all of the fields and layers in the text<br>
face, you can affect the drawing of text in all sorts of nasty ways. The next example<br>
uses the fill type to simulate outline text. 
</p>
<p>
<b>Outline text. </b>This code creates outline text in QuickDraw GX:
</p>
<p>
<code>/* Modify the style object to do outline text. */</code><br>
<code>void OutlineText(gxStyle aStyle)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;gxTextFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theFace;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;gxStyle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;layerStyle;</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;theFace.faceLayers = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Set text face to 1 layer. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXResetMapping(&amp;theFace.advanceMapping);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Make advance mapping the identity mapping. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;layerStyle = GXNewStyle();</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXSetStylePen(layerStyle, fix1/16);&nbsp;&nbsp;&nbsp;&nbsp;/* Make pen 1/16 point. */</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;theFace.faceLayer[0].outlineTransform = nil;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;theFace.faceLayer[0].outlineStyle = layerStyle;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;theFace.faceLayer[0].boldOutset.x = 0;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;theFace.faceLayer[0].boldOutset.y = 0;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;theFace.faceLayer[0].outlineFill = gxClosedFrameFill;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;theFace.faceLayer[0].flags = 0;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXSetStyleFace(aStyle, &amp;theFace);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;GXDisposeStyle(layerStyle);</code><br>
<code>}</code>
</p>
<p>
To do the same thing with PostScript code, modify the font dictionary:
</p>
<p class="spacer">&nbsp;</p>
<p>
<code>/Helvetica findfont&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Put Helvetica's dictionary on the stack.</code><br>
<code>dup length 1 add dict begin</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Make a copy of the font dictionary and put it on the stack.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;1 index /FID eq {pop pop} {def} if else</code><br>
<code>} forall</code><br>
<code></code><br>
<code>/PaintType 2 def&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Make the font PaintType 2. This means stroked.</code><br>
<code>/StrokeWidth 1.0 16.0 div def&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Make the stroke width 1/16.</code><br>
<code>currentdict</code><br>
<code>end</code><br>
<code></code><br>
<code>/HelveticaFramed exch definefont pop&nbsp;&nbsp;&nbsp;&nbsp;% Define the outlined font.</code><br>
<code>/HelveticaFramed findfont 24 scalefont setfont&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Make it current.</code>
</p>
<p>
<b>CONVERTING FRAMED OBJECTS INTO FILLED OBJECTS</b><br>
Sometimes you want a shape that, if filled, is the same as the result of stroking the<br>
original shape. In PostScript code, calling<b> strokepath</b> on the current path applies the<br>
current pen width to the path, and the resulting path is one that can be filled to<br>
produce the result that calling<b> stroke</b> would have produced. 
</p>
<p>
In QuickDraw GX, the GXPrimitiveShape routine applies the fill and style to any shape<br>
to produce a primitive shape. A primitive shape is one that's completely described by<br>
its geometry and fill and doesn't need a style object to be drawn properly. For example,<br>
a path that's framed with a pen width of 10 becomes a solidFilled shape. 
</p>
<p>
<b>CONVERTING TEXT INTO A PATH</b><br>
In the PostScript language, the<b> charpath</b> operator takes a string and converts it into<br>
a path using the current font in the graphics state. The following code converts the<br>
word<i>Hello</i>&nbsp;&nbsp;into a path using the font and font size of the current graphics state:
</p>
<p>
<code>(Hello) false charpath</code>
</p>
<p>
Any QuickDraw GX text, glyph, or layout shape object can be turned into a path shape<br>
object by calling GXSetShapeType as follows:
</p>
<p>
<code>GXSetShapeType(myTextShape, pathType);</code>
</p>
<p>
This converts the shape object myTextShape into a path shape object by applying the<br>
font, font size, and text face in the shape object's style object. 
</p>
<h2>NOW YOU'RE READY FOR QUICKDRAW GX</h2>
<p>
Whether or not you're familiar with the PostScript language, the preceding samples<br>
and comparisons should help you get going on your QuickDraw GX application. In the<br>
days of QuickDraw, you frequently had to resort to generating PostScript code from<br>
your application because the graphics constructs simply didn't exist in QuickDraw.<br>
However, QuickDraw GX is a robust graphics, text, and printing architecture that does<br>
all the things that current drawing applications do and then some.&nbsp;&nbsp;&nbsp;There should be no<br>
need to generate your own PostScript code from your application in the world of<br>
QuickDraw GX. Using QuickDraw GX as the medium for all drawing also gives your<br>
application the added benefit of being able to produce application-independent portable<br>
digital documents. You can view portable digital documents with TeachText and print<br>
them on any printer, PostScript or not.&nbsp;&nbsp;&nbsp;Enjoy! 
</p>
<p>
<b>DANIEL LIPTON, </b>in addition to being an accomplished PostScript programmer, is an<br>
avid animal lover. He lives with a variety of pets, most notably his dog SpotFunction.<br>
As a result of many hours of training, SpotFunction can perform some impressive<br>
tricks, including both "roll" and "loop." Dan's affinity for animals extends beyond the<br>
canine domain to include his pet iguana, who can neither roll nor loop. Although<br>
warm-blooded himself, Dan can often be found sunning himself on a rock outside his<br>
office at Apple. "I find myself mysteriously drawn to the reptilian lifestyle," he<br>
confesses, his eyes intently tracking a fly buzzing about his office. Dan is known to<br>
break into fits of uncontrollable laughter whenever he's shown a picture of a gorilla, a<br>
fact that his coworkers often use to their advantage during meetings. *
</p>
<p>
<b>The definitive reference on the PostScript language </b> is <i>PostScript Language</i><br>
<i>Reference Manual, </i> Second Edition (Addison- Wesley, 1990).*
</p>
<p>
<b>There's more information on QuickDraw GX objects </b> in the article "Getting<br>
Started With QuickDraw GX" in this issue of<i>develop</i> .*
</p>
<p>
<b>THANKS TO OUR TECHNICAL REVIEWERS </b>Pete ("Luke") Alexander, Tracey<br>
Davis, Herb Derby, Dave Williams *
</p>
</body>
</html>
