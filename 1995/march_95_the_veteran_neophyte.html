<!DOCTYPE html>
<html>
<head>
<!-- Article ID: 8 - Extracted from develop-1995 -->
<!-- on 2024-08-30 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by the copyright of its respective owners -->
<title>March 95 - THE VETERAN NEOPHYTE</title>
<link href="../common/styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h2>THE VETERAN NEOPHYTE</h2>
<h2>The Downside</h2>
<h1>DAVE JOHNSON</h1>
<p>
<img src="img/140.gif" width="233 px"></img>
</p>
<p>
According to the menu bar clock on my computer screen, it was 1:38A.&nbsp;&nbsp;M. My eyes<br>
were raw and stinging, my neck was stiff, and my mind was jittery and frazzled. I had<br>
to get some sleep soon, because the alarm clock, glowing weakly red in the dark in the<br>
next room, right there next to my soundly sleeping wife and animals, was set to go off<br>
at 5:30. I'd been ready to stop two hours ago, having lost yet another entire evening to<br>
the computer, but I found that there was some obscure system structure that wasn't<br>
being disposed of when my program quit, even though I never directly created or used<br>
that structure in my code. Dang. I hate that. 
</p>
<p>
The program I was writing is a kind of "magic graph paper" that can help me figure out<br>
multiperson juggling patterns. It was originally intended to be the topic of this<br>
column, but it took a lot longer to write than I thought it would, and it still isn't done;<br>
it will have to wait for some future column. So there I was, deadline approaching,<br>
without a topic. I was whining about my foiled plans to my friend Ned (a tolerant<br>
listener), complaining loudly about the amount of time and trouble it takes to write<br>
the simplest piece of code, bitching and moaning about the trials and tribulations of<br>
programming, and wondering out loud what I was going to write about. 
</p>
<p>
Then it dawned on me -- write about the downside! Write about the parts of<br>
programming that frustrate you so much! Get those nasty feelings out on paper! Purge!<br>
Catharse! I could even do another little electronic survey, sort of the opposite of the<br>
"Why We Do It" column in Issue 17. Hot dawg. 
</p>
<p>
So that's what this column is about: "What do people hate about programming?" I<br>
posted this question to various news groups on the Internet, and sent it out via e-mail<br>
to a bunch of programmers I know, and got some good responses. But before I tell you<br>
what other people hate about programming, first it's<i>my</i>&nbsp;&nbsp;turn, and I'm ready to gripe. 
</p>
<p>
Once upon a time, I loved programming. It was ahobby, something I did for the sheer<br>
joy of it, somethingthat was<i>fun</i> . I welcomed the chance to learn all the arcane and<br>
grungy details of the internal workings of the computer. I binged, ignoring the demands<br>
of my home life and my body. I dove willingly into the thick, impenetrable books,<br>
joyfully grappling with myriad problems that had nothing whatever to do with the<br>
program I was writing. The program itself was in many ways incidental: it was that<br>
continual solving of difficult problems that was both the fuel and the reward, the stick<br>
and the carrot combined.
</p>
<p>
Well, I still go on binges now and then, small ones, but it's much rarer. Before, I<br>
would pursue just about any harebrained idea that crossed my feverish mind (and<br>
abandon most of them later, half constructed, often after I'd enthusiastically<br>
programmed myself into a corner). Nowadays I abandon most ideas much sooner,<br>
usually long before I even hit the keyboard. Now, every time I think of a fun<br>
programming project (which still happens often), I immediately quail at the thought<br>
of sitting down and beginning. Knowing up front how much time and effort is required<br>
to accomplish even the simplest things just makes me want to go to sleep. Call me a<br>
burnout, call me a wimp, call it growing older, or call it growing up: you'll be right on<br>
every count. 
</p>
<p>
But why? What changed? It used to be so different. It used to be that I would dive in<br>
immediately at the first glimmer of an idea, hacking and slashing my way through the<br>
Toolbox with gleeful abandon, forgetting to eat, forgetting to sleep, forgetting to check<br>
errors, sitting in the same position for hours on end, staring, typing, staring, typing,<br>
staring . . . 
</p>
<p>
Wait a second. <i>That's</i>&nbsp;&nbsp;something that bugs me about programming. Even though the<br>
action in my head is fast, furious, and fascinating, physically I just sit, stare, and<br>
type. Maybe someday I'll get enough RAM in my Duo to actually do some coding<br>
outdoors, but I'll<i>still</i>&nbsp;&nbsp;be sitting, staring, and typing; I'll just have a better view on<br>
the rare occasions I remember to look up from my lap. (Come to think of it, it might<br>
be even worse, since I'll be forced to use electronic references as well: I won't even get<br>
the small breaks that I normally get while flipping pages in some weighty tome of<br>
wisdom.) So even though programming is fundamentally acreative thing, teeming with<br>
meaning and craftsmanshipand beautiful logic, there's a tradeoff. To partake of that<br>
sweet creation, you have to be willing to mostly sit still, stare at glowing humming<br>
boxes that make your face look green, and type cryptic symbols in a very strict,<br>
"filling out forms" kind of way. For hours. And hours. And<i>hours</i> . I can almost feel my<br>
muscles turning to liquid, my blood slowing and thickening, gravity slowly pulling my<br>
withered flesh from my bones. 
</p>
<p>
That's something else annoying about programming, and about computers in general:<br>
the amount of time they require. They are infinite time sinks, no doubt about it. Maybe<br>
time is just more precious to me now than it was before, and I'm less and less willing<br>
to spend it sitting at a computer. Writing software, in particular,<i>always</i> takes too<br>
long. It takes much longer than it reasonably ought to, and it takes much longer than<br>
you think it possibly can. Every time. There's a common rule of thumb for estimating<br>
how long it will take to complete a software project: come up with a reasonable<br>
estimate of the time required; then double it. Amazingly, even that doesn't do it. I've<br>
heard another, more tongue-in-cheek formula that says to take your best estimate,<br>
double it, and then jump to the next larger time unit. For example, if you think a<br>
project will take 8 weeks, first double it to 16 weeks, then change the time unit from<br>
weeks to months: 16 months is reasonable. Now<i>that</i>&nbsp;&nbsp;might actually be accurate. 
</p>
<p>
(I remember some time ago there was a seminar here at Apple given by someone who<br>
had a system that was carefully worked out to produce accurate estimates of software<br>
projects. The system was entirely history based; that is, the estimates weren't based<br>
on the details of the project or the estimates of the engineers involved or the<br>
marketing plans for the product, but instead were based on how long it had taken to<br>
complete past, similar projects. It sounded very promising to me, but you know what?<br>
The estimates thus produced were so much longer than those arrived at by conventional<br>
means that real adoption of that sort of system would require a fundamental change in<br>
the way the software business is run. I haven't heard about it since.)
</p>
<p>
Part of the reason programming takes so long, of course, is that much of the time is<br>
spent on tasks that really have nothing to do with the program you're trying to write,<br>
but instead are about bookkeeping, working around the limitations of the machine,<br>
trying to figure out how to express your very clear ideas in the hobbled, awkward<br>
prose of "modern" computer languages, and so on.&nbsp;&nbsp;&nbsp;That's <i>another</i>&nbsp;&nbsp;thing I hate about<br>
programming: the mountains of mind-numbing and irrelevant detail you have to wade<br>
through and deal with to accomplish the simplest tasks. I don't really give a hoot about<br>
the details of the operation of the file system, I just want to get some information onto<br>
the disk; I don't really want to know how scroll bars work, I just want the user to be<br>
able to navigate an area larger than the window. This is, naturally, a good argument for<br>
using frameworks (among many other good arguments), but the promise is still<br>
beyond the reality, and even with a good framework there are still mountains of<br>
irrelevant detail. They're different mountains, and they might be a little smaller, but<br>
they're still mountains, and they're still irrelevant. 
</p>
<p>
Another thing: software is never really done, just shipped. That's another aspect of the<br>
"infinite time sink" thing. There's always something more that can be done to make a<br>
program better, and there are always bugs that can be fixed. I've heard some artists<br>
and writers say that they never actually finish a piece, they just stop working on it<br>
(and, incidentally, that knowing when to stop is where a lot of the art is). Software is<br>
often the same way. 
</p>
<p>
Programming is also addictive, and I hate that, too. (I'm starting to feel like Andy<br>
Rooney here.) It positively <i>consumes</i> me. There I'll be in the umpteenth hour, my eyes<br>
burning, my head aching, my neck stiff, everyone else fast asleep, warm and cozy in<br>
their nice, soft, analog beds. But I can't stop, because there's just one more little<br>
wrinkle to iron out, one more small problem to solve. And the solution to that problem<br>
leads to another problem, and the solution to that one leads to another, and . . . 
</p>
<p>
Know what else I hate? Bugs. Not the plain old easy to find kind of bugs, but the nasty,<br>
subtle, elusive, intermittent kind that just don't seem to have a deterministic cause.<br>
They're an unavoidable part of programming, but I hate 'em anyway. (Seymour<br>
Papert, in his book<i>Mindstorms,</i> made the excellent point that programming is one of<br>
the few disciplines where you're<i> expected</i> to make mistakes, every time, and an<br>
integral part of the process is going back over your work, finding the inevitable<br>
mistakes, and fixing them. This is in sharp and healthy contrast to most academic<br>
subjects, where mistakes are thought of as unwelcome anomalies rather than an<br>
inevitable part of the process. An excellent reason, says Papert, to teach programming<br>
to children: it introduces them to the fact that mistakes are an integral part of<br>
real-world processes.) Knowing that there really<i>is</i>&nbsp;&nbsp;a solution to the bug (and<br>
probably an easy one) just pisses me off even more. If there's an answer, why can't I<br>
find it? And after spending days and nights sleuthing my way to an eventual answer, do<br>
I rejoice when I arrive? No, I'm just angry that I had to waste so much time on<br>
something that didn't really move me further forward. Hope starts to fade; ennui<br>
begins its inexorable descent. 
</p>
<p>
And finally, well, programming<i>hurts. </i> It hurts my body, and it also hurts my brain.<br>
It's unnatural to think like that, composing long strings of imperatives, with no<br>
subtlety or nuance or fuzziness of meaning allowed, especially for long, uninterrupted<br>
periods of time. It's somehow dehumanizing, because to program well you have to<br>
assume the characteristics of the machine, you have to think like one, you have to<br>
make your thoughts linear and ordered. It's just not normal. 
</p>
<p>
All right, that's probably enough personal griping. I<i>do</i> feel a little better having gotten<br>
that off my chest, here in public. Now let's see what other people had to say. 
</p>
<p>
In general I was surprised at the paucity of responses, at least compared to the<br>
veritable flood of replies I got when I asked what people<i>liked</i> about programming.&nbsp;&nbsp;Of<br>
course, I was asking programmers, and since they do it for a living they presumably<br>
don't hate it too much. 
</p>
<p>
Of the responses I got, the most commonly hated thing by far was bad or broken tools.<br>
This wasn't surprising; programmers<i>love</i> to complain about their tools. In particular,<br>
buggy compilers were soundly thrashed from all sides as the worst time wasters<br>
around. Dealing with your own bugs is one thing; that's a normal part of the<br>
programming process. Dealing with bugs in your tools, though, and having to work<br>
around them, is something else entirely:
</p>
<p>
<i>&nbsp;I LIKE programming. The only things that bother me are things that are not under my</i><br>
<i>control, like compiler bugs. I hate that.&nbsp;&nbsp;</i>&nbsp;&nbsp;-- Matt DiMeo
</p>
<p>
<i>&nbsp;After a while, the tools got to me. Tools with bugs and bad interfaces made the</i><br>
<i>day-to-day work more like digging a ditch than the artistic expression it maybe could</i><br>
<i>be. I don't like to dig ditches, I like it to be interesting.&nbsp;&nbsp;</i>&nbsp;&nbsp;-- Bo3b Johnson,<br>
semiretired programmer (the "3" is silent)
</p>
<p>
This is one of the things that came up over and over: the primitive state of the tools<br>
available.&nbsp;&nbsp;&nbsp;Programmers in particular, since they know intimately what the machine<br>
is capable of, are appalled at the state of the tools available for programming. Memory<br>
management was cited often as a needless hassle -- many C and C++ programmers<br>
actually mentioned dynamic languages in a positive light,mostly because of the<br>
automatic memory management and the banishing of the compile-link-debug cycle. 
</p>
<p>
Lots of folks also complained about the job of programming, and most of those<br>
complaints fell into the realm of "the nonprogrammers just don't get it."
</p>
<p>
<i>&nbsp;The interactions with the management. You know, these silly men with ties that say,</i><br>
<i>"Well, you should change that program to act THIS way, and not in the way we agreed</i><br>
<i>last week," when you have the job half done.&nbsp;&nbsp;</i>&nbsp;&nbsp;-- Maurizio Loreti
</p>
<p>
Maybe that's why geeks seem to congregate in groups: only other geeks really get it. 
</p>
<p>
Interestingly (from my Macintosh perspective), a number of people mentioned<br>
interface programming as something they hated:
</p>
<p>
<i>&nbsp;I have a special hate mode for doing GUI programming.&nbsp;&nbsp;It's boring, it's arcane, and it's</i><br>
<i>ill behaved. Give me systems, give me new real terrain to learn and think about, but</i><br>
<i>leave the GUI programming to robots!&nbsp;&nbsp;</i>&nbsp;&nbsp;-- Jeffrey Greenberg
</p>
<p>
This surprised me a little, I must admit, partly because I really<i>like</i> that part of<br>
programming. Almost all of my little toy projects involve lots of clicking and dragging<br>
of widgets on the screen, and now that I think of it, programming didn't really begin to<br>
interest me until I discovered the Macintosh and user interaction. But hey, everyone's<br>
entitled to an opinion. 
</p>
<p>
Another frequently mentioned offender was lousy APIs:
</p>
<p>
<i>&nbsp;Number two: Poorly designed OS and peripheral interfaces, where I have to keep track</i><br>
<i>of a lot of "moving parts" to do something that should be straightforward.&nbsp;&nbsp;</i>&nbsp;&nbsp;-- Tom<br>
Breton
</p>
<p>
That's another example of something that seems pervasive: complaints about the<br>
software layers that surround most programs these days. It's pretty much unavoidable<br>
now; you can't write a program without depending heavily on the software<br>
environment you're programming for. Your software is controlled from the outside by<br>
other software (typically a GUI these days), and in turn your software isn't directly<br>
controlling the machine like in the good old days, but is instead calling<i>other</i>&nbsp;&nbsp;pieces of<br>
software (like the Toolbox or a framework) to accomplish its tasks. So naturally it's<br>
annoying when the software you depend on is badly designed or buggy. Unfortunately,<br>
it's all too common an occurrence. 
</p>
<p>
A few also mentioned a lack of programming quality or a lack of professionalism as a<br>
big downside:
</p>
<p>
<i>&nbsp;I get really livid when I find a reckless patch or hack in products, specifically those</i><br>
<i>that make a nightmare for future development and integration. They demonstrate a</i><br>
<i>selfish and irresponsible form of engineering.&nbsp;&nbsp;</i>&nbsp;&nbsp;-- Dave Evans
</p>
<p>
<i>&nbsp;Unfortunately, most of the programmers I've been around are immature and not well</i><br>
<i>managed, so you end up with these massive schedule and quality problems. I claim it's</i><br>
<i>immaturity, because if we are still stuck in low gear trying to impress our friends</i><br>
<i>with our tricky code, that's high school behavior. That's mostly what I saw. "Ooh, I can</i><br>
<i>save 12 bytes if I write this in a stupid way. Aren't I clever?" Too bad no one can read</i><br>
<i>it. Or, "Ooh, I can make this faster if I write it obscurely. I'm so cool." Never mind</i><br>
<i>that it never gets used. That sort of lack of professionalism is what put me over the</i><br>
<i>edge.&nbsp;&nbsp;</i>&nbsp;&nbsp;-- Bo3b Johnson
</p>
<p>
Finally, and near and dear to my heart, is the issue of being forced to interact with the<br>
machine:<i> I hate the actual typing in of all the stuff. After a pleasant period of roaming</i><br>
<i>around, scribbling down nice little try-outs and possible solutions, just using old</i><br>
<i>pieces of paper, lying down on the couch, thinking a bit, reading a bit, talking things</i><br>
<i>over with a couple of colleagues, there comes a long, boring period when I'm almost</i><br>
<i>chained to that silly desk, sitting in front of that silly machine, banging that silly</i><br>
<i>keyboard, trying to express my illuminated thoughts in some sort of silly</i><br>
<i>programming language . . . I want my couch, I want my can of beer, I want my</i><br>
<i>cigarettes and my books; THAT'S how I want to program.&nbsp;&nbsp;</i>&nbsp;&nbsp;-- Jos Horsmeier
</p>
<p>
<i>&nbsp;. . . spending the greater part of my life at a !#@!$* keyboard, staring at a !$&amp;*!#</i><br>
<i>monitor.&nbsp;&nbsp;</i>&nbsp;&nbsp;-- Anonymous
</p>
<p>
Yep, that's the part that I hate the most, too; in order to program I have to spend huge<br>
amounts of my time sitting at the computer. You know, digging ditches is starting to<br>
sound better and better. It's tactile, it's immediate, it's outdoors, it uses muscles<br>
beyond those in your forearms, it doesn't consume or pollute your mind, there's no<br>
irrelevant detail to deal with, and when you're done you're done. Though I could be<br>
wrong, I don't<i>think</i>&nbsp;&nbsp;ditch digging is addictive, and I'm quite sure that there's no<br>
possibility of subtle and elusive bugs. Sounds good. 
</p>
<p>
Hey, that gives me an idea! With QuickDraw GX's great hit testing and picture<br>
hierarchies, I could write a really cool ditch-digging simulator . . . 
</p>
<p><b>RECOMMENDED READING</b></p>
<ul>
<li><i>Snow Crash </i> by Neal Stephenson (Bantam Books, 1992).</li>
<li><i>Chicken Soup, Boots </i> by Maira Kalman (Viking, 1993).</li>
</ul>
<p>
<b>DAVE JOHNSON </b>has an inordinate (some say irrational) love of playground swings.<br>
He's been a lover of swings and swinging as long as he can remember, and still does<br>
backflips out of them from maximum height, impressing mightily any kids who might<br>
be watching. He's also been known to suddenly stop the car and leap out at the sight of a<br>
swing set he hasn't visited before. No swing shall be left unswung.*
</p>
<p>
<b>Thanks </b>to Jeff Barbose, Brian Hamlin, Bo3b Johnson, Lisa Jongewaard, and Ned van<br>
Alstyne for their always enlightening review comments.*
</p>
<p>
<b>Dave welcomes feedback </b>on his musings. He can be reached at JOHNSON.DK on<br>
AppleLink, dkj@apple.com on the Internet, or 75300,715 on CompuServe.*
</p>
</body>
</html>
