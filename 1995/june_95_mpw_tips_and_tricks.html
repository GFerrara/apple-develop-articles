<!DOCTYPE html>
<html>
<head>
<!-- Article ID: 19 - Extracted from develop-1995 -->
<!-- on 2024-08-30 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by the copyright of its respective owners -->
<title>June 95 - MPW TIPS AND TRICKS</title>
<link href="../common/styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h2>MPW TIPS AND TRICKS</h2>
<h2>Building a Better (Development) Environment</h2>
<h1>TIM MARONEY</h1>
<p>
<img src="img/159.gif" width="180 px"></img>
</p>
<p>
The days of the solitary hacker are long past. While this reclusive species is still<br>
spotted in the wildernesses of academia and shareware, today's commercial engineers<br>
roam the virtual plains in herds, overcoming the incessant problems of bloated<br>
software projects by sheer force of numbers. 
</p>
<p>
Like all human groups, software teams are tied together by a shared language and<br>
environment. On the Macintosh, this common ground often contains a set of MPW<br>
scripts and tools. While most developers prefer the faster compilers offered by<br>
third-party vendors, the scripting and source control capabilities of MPW make it an<br>
indispensable workhorse in team software projects. It even serves as the cornerstone<br>
of many cross-platform efforts involving both the Mac OS and that other operating<br>
system. 
</p>
<p>
Following a few simple principles will greatly reduce headaches resulting from<br>
maintaining a team's MPW configuration. These guidelines may seem obvious, but I<br>
have yet to see a project that followed all of them. 
</p>
<p>
<b>ENGINEERS ARE USERS, TOO</b><br>
While we may be accustomed these days to thinking of a user interface as a sequence of<br>
pictures, a build environment in MPW is as much a user interface as any other<br>
software system. Like all such projects, designing it naively invites the wrath of your<br>
users -- in this case, the engineers on your team. And unlike most users, they have<br>
your direct telephone number and know where you park your car! 
</p>
<p>
The primary principle of user interface design is to stop thinking "I want to make the<br>
best X ever," whether X is a text engine, file system, image processor, build<br>
environment, or gorgonzola sandwich.&nbsp;&nbsp;&nbsp;That narrow form of thinking leads to excellent<br>
solutions to technical problems but systems that are difficult to use, because the model<br>
of the problem adopted by an engineer is likely to be different from that applied by an<br>
end user. For instance, to an image processing expert, rotating an image is a problem<br>
of accurate and rapid approximation across a grid, but to a scanner operator, the<br>
problem is one of deciding when to rotate, whether to do it automatically, whether to do<br>
it before or after other operations, and so forth. A technically superb rotation<br>
algorithm may completely fail to meet the requirements of the operator in a print shop<br>
if it wasn't originally designed with that environment in mind. 
</p>
<p>
Balance technical problem solving by thinking through in detail how the system will<br>
be used to accomplish specific tasks. Spell out particular scenarios and make sure<br>
your solutions work in them.&nbsp;&nbsp;&nbsp;Otherwise, they probably won't.&nbsp;&nbsp;So, to keep the needs<br>
of your various users in mind, you need to consider not only a normal build, but<br>
auxiliary tasks such as the following:
</p>
<ul>
<li>installing and updating the system</li>
<li>incorporating scripts from other sources</li>
<li>giving MPW commands by hand</li>
<li>personalizing the configuration</li>
<li>maintaining a synchronized environment among all users</li>
<li>archiving the environment for reproducing builds</li>
<li>working from home over Apple Remote Access, and other ways of working<br>
remotely</li>
<li>troubleshooting scripts and tools</li>
</ul>
<p>
Never assume that smart people make fewer errors.&nbsp;&nbsp;A rule of thumb is that the<br>
number of errors made is proportional to the number of possible errors, not to the<br>
skill of the user. Error prevention should be one of your guiding principles in any<br>
system design. For instance, don't require three commands in a particular order to<br>
complete a build; a single build should be a single command. If you have user interface<br>
design staff, get them involved with the development environment; their familiarity<br>
with principles such as error prevention and nonmodality could be very helpful. 
</p>
<p>
Most of all, talk to your users. Ask them what they need and what their problems are.<br>
Sometimes their suggestions will be ones you can use directly; more often they won't<br>
hold up to scrutiny as actual designs, but they always indicate a legitimate area of<br>
concern that you'll need to address. Design your system on paper first, and have your<br>
users review your drafts. This time will pay off later in increased productivity. 
</p>
<p>
<b>&nbsp;Many of the principles </b> of modern software design were originally developed for<br>
traditional command-line systems. See<i> The Elements of Friendly Software Design: The</i><br>
<i>New Edition </i>&nbsp;&nbsp;by Paul Heckel (Alameda: Sybex, 1991). *
</p>
<p>
<b>CHECK IN THE SYSTEM</b><br>
An obvious, but flawed, approach to organizing a system of tools and scripts is to put<br>
them all on a server where everyone can reach them. Each engineer is responsible for<br>
synchronizing his or her local configuration with the latest files on the server, and<br>
anyone can improve the scripts in their copious free time. In addition, everyone can<br>
customize their own system as much as they like. 
</p>
<p>
In practice this simple scheme wastes the time of everyone on the team, because no one<br>
ever has the same configuration as anyone else. A typical frustrating conversation<br>
under this system would be:
</p>
<p>
<i>I can't build the SuperWidgets library. Does it build for you? </i>
</p>
<p>
<i>Sure! Maybe you didn't get the new SourceGrinder script? </i>
</p>
<p>
<i>No, I got that yesterday, after I couldn't build Pat's latest brilliant changes to</i><br>
<i>WhizzySnork. Let's take a look at your copy of the MungePrefix tool. </i>
</p>
<p>
<i>Hmmm. It seems to match yours. Gee, I don't know what the problem could be. Let's</i><br>
<i>both do a complete reinstall and try again. </i>
</p>
<p>
(Repeat until hysteria ensues.)
</p>
<p>
The solution to the problem of synchronization is to keep the build system itself under<br>
source control. When people run into problems, they'll make sure that they've checked<br>
out the current scripts and tools as well as the current source files,<i>before</i> they bother<br>
you about it. If they don't, they'll look silly. Since that will probably bring back<br>
unpleasant memories from the playground, they'll try harder next time. 
</p>
<p>
For complex projects, you'll probably want to institute a regular build process with<br>
versioning and source archiving. When you archive the sources for a build, don't<br>
forget to archive a matchingrevision of the development environment! You may need to<br>
reproduce that build in the future, for which you'll need the source code and the exact<br>
build system. 
</p>
<p>
In some larger projects, the development environment may be maintained by a group<br>
separate from the programmers who use the system. In that case, it may not be<br>
practical to archive the environment as part of a project build. The environment group<br>
needs to archive the system with named versions, and the project team needs to always<br>
build with respect to a named version of the environment. The project team also needs<br>
to record in its release notes which version of the development environment was used<br>
for each archived build. This allows the build to be reproduced from the two archives. 
</p>
<p>
<b>HAVE AN INSTALLED COPY HANDY</b><br>
Bootstrapping an MPW configuration for a new engineer can be painful. There is a<br>
chicken-and-egg problem with any script-based installation of an MPW build system.<br>
The scripts you want to use for installation are checked in, but how does the<br>
first-timer get to them? You can write out careful step-by-step instructions, but few<br>
engineers can resist the temptation to improvise. You'll wind up doing it for them after<br>
all when they fail. 
</p>
<p>
Instead, keep an up-to-date copy of a preconfigured MPW on a convenient server. The<br>
new user simply copies the entire MPW folder from the server to the local disk<br>
(remember those licensing restrictions,though!), edits the configuration file, and is<br>
ready to run. 
</p>
<p>
<b>THE DREADED USERSTARTUP*PERSONAL FILE</b><br>
It's perfectly clear to the development environment designer that the user needs to<br>
type his or her name where it says
</p>
<pre>Set MyName "Your Name Here"</pre>
<p>
but no one ever seems to fill in the blanks correctly without hand-holding. 
</p>
<p>
It may be worth your while to write a mini-application that sets up the personal<br>
configuration file in the MPW folder. An hour or two creating a setup application witha<br>
nice, clear modeless dialog will pay for itself a few newhires down the road. More<br>
simply, you can use MPW's Request, GetFileName, and GetListItem commands in a<br>
setup script -- but a single dialog is friendlier. 
</p>
<p>
This application or script should also be stored on the server where you have the<br>
preconfigured MPW folder. With a little clever scripting, you can easily arrange for<br>
the application to be run automagically if the personal configuration file hasn't yet<br>
been set up. 
</p>
<p>
There are a few kinds of setup that can be done programmatically. For instance, if a<br>
script needs to know the monitor size, don't ask users to type it in themselves; an<br>
MPW tool can look at the graphics device list and figure it out by itself. 
</p>
<p>
<b>ESCHEW CLEVERNESS</b><br>
One of the best programming tips I ever got was from an introductory LISP text I read<br>
a few centuries ago as an undergraduate. It warned against cleverness in coding. On the<br>
surface this would appear to be stupidadvice. Isn't cleverness a requirement for<br>
programming?&nbsp;&nbsp;The problem is that when our own code strikes us as clever, it usually<br>
involves some trick or back door that's both fragile and hard to understand, not only<br>
for the next poor sap who inherits the code, but maybe for ourselves a month or three<br>
from now. Yet these clever tricks are rewarding. Not only does a trick resolve a sticky<br>
problem in one swell foop, but it reinforces our belief in our own intelligence and<br>
resourcefulness. 
</p>
<p>
LISP, being inherently weird, lends itself to clever solutions. So does object-oriented<br>
programming.&nbsp;&nbsp;(I'll spare you the name of a program that buries its resolution of<br>
conflicting filenames -- dialogs and all -- deep in the bowels of a general-purpose<br>
string class.) Scripting languages such as those of MPW and<b>csh</b> also encourage<br>
cleverness.&nbsp;&nbsp;Remember the scripts to accelerate launching in last issue's MPW Tips<br>
and Tricks? The form in which they were passed to me used a very clever method of<br>
signaling a cold boot: it aliased the built- in End command to Quit, bypassing the<br>
state-saving code in the Quit script. Needless to say, the potential for side effects was<br>
enormous, but no doubt someone enjoyed thinking of it! I changed the cold boot sequence<br>
to write an empty file called DontSaveState in the MPW folder, and the Quit script to<br>
detect and remove this file. It takes perhaps a tenth of a second longer, but it's<br>
comprehensible and free from harmful side effects. 
</p>
<p>
<b>KEEP IT SIMPLE, STUPID</b><br>
Another common class of difficulties results from redesigning the basis of MPW. It can<br>
be tempting to make big changes to the system, such as by changing the default value of<br>
a built-in variable like Exit, or permanently blanking variables like CIncludes and<br>
RIncludes to prevent conflicts with local headers. 
</p>
<p>
The problem is that this turns a multifunction system into a single-function system,<br>
making MPW useful solely for the build tasks you've planned. Scripts from other<br>
sources won't work anymore, and the existing techniques and skills of people on the<br>
team may become hard for them to apply in the oddly mutated environment. Getting rid<br>
of RIncludes might make some part of your build sequence easier to manage, but what<br>
happens when an engineer wants to DeRez something by hand? 
</p>
<p>
The solution is to avoid changing the underpinnings of the MPW Shell. If you need to add<br>
variables, add them as new variables -- don't mess with the old ones. Don't install<br>
patches that let you add whizzy graphical menus and floating windows if they interfere<br>
with the ordinary AddMenu and Open commands. When you do need to change something,<br>
change it only in the scope of the script where it's needed. 
</p>
<p>
Among other reasons, you may someday need to have more than one build system<br>
installed. Suppose your company is acquired by the Gizmonics Institute and they have<br>
their own MPW configuration.&nbsp;&nbsp;&nbsp;Would you rather throw away yours and try to figure<br>
out how to shoehorn your source code into their system, or be able to run them both in<br>
the same MPW Shell? Or suppose (and I admit this is pretty unlikely) you start<br>
talking with the weirdos down the hall instead of just snickering about them behind<br>
their backs.&nbsp;&nbsp;&nbsp;Before you know it, you'll be drinking beer together and trying to<br>
integrate your build systems. Don't laugh; it happens. 
</p>
<p>
<b>THE JOY OF THEFT -- SHARE AND ENJOY</b><br>
There are various sources for useful MPW scripts. Instead of trying to do it all<br>
yourself, you can impress your manager by ripping off scripts from CDs, computer<br>
networks, friends, and so forth.&nbsp;&nbsp;&nbsp;Sometimes even magazines have good stuff. 
</p>
<p>
Apple already distributes quite a few useful scripts, such as those in the folder called<br>
DTS MPW Goodies on this issue's CD. Posting a note on a Usenet newsgroup may get you<br>
just the script you wanted in a matter of hours or days (even though you could have<br>
done it better yourself, of course). 
</p>
<p>
Remember to share a little of your own work to balance the karmic load. This is the<br>
philosophy of UNIX&#174;, and unfortunately it's better developed in that culture than in<br>
ours. Don't forget the others in the virtual herd! 
</p>
<p class="spacer">&nbsp;</p>
<p>
<b>TIM MARONEY </b>has been tempered in the forge of computer networks, acquiring a<br>
rough, cast-iron finish that's often mistaken for obnoxiousness. His favorite animal<br>
name is "Kittens," his favorite food is anything dead, and his favorite new game<br>
involves building globe-spanning conspiracies out of overpriced trading cards. Tim<br>
supplements his seven-figure earnings from writing for magazines by developing<br>
software for Apple. *
</p>
<p>
<b>Thanks </b>to Shad Ahmad, Dave Evans, Arnaud Gourdol, and Eleanor the Wonder Gerbil<br>
for reviewing this column. *
</p>
</body>
</html>
