<!DOCTYPE html>
<html>
<head>
<!-- Article ID: 30 - Extracted from develop-1995 -->
<!-- on 2024-08-30 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by the copyright of its respective owners -->
<title>June 95 - QuickDraw 3D: A New Dimension for Macintosh Graphics</title>
<link href="../common/styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h2>QuickDraw 3D: A New Dimension for Macintosh Graphics</h2>
<h1>Pablo Fernicola and Nick Thompson</h1>
<p>
<img src="img/189.gif" width="96 px"></img>
</p>
<p>
<i>QuickDraw 3D is a new technology that helps developers bring 3D capabilities to their</i><br>
<i>applications. It runs on all Power Macintosh computers and offers high-performance</i><br>
<i>3D rendering and other features that make working with 3D data easier. This article</i><br>
<i>gives the basics you'll need to use QuickDraw 3D in your application, whether you're a</i><br>
<i>consummate 3D developer, a classic 2D application developer, or a game developer.</i>
</p>
<p>
QuickDraw 3D is the newest enhancement to the Macintosh graphics architecture.<br>
Developers have been requesting a 3D library, supported at the system level, since the<br>
Macintosh was introduced. Although a number of Macintosh developers have produced<br>
some amazing 3D applications, 3D graphics capabilities were relegated to niche<br>
applications due to the lack of support at the core operating system level. QuickDraw<br>
3D, which is expected to ship in mid-1995, brings the ability to deal with 3D<br>
graphics to all Power Macintosh applications: not only can traditional 3D applications<br>
take advantage of it, but it provides base functionality for general-purpose<br>
applications as well.
</p>
<p>
QuickDraw 3D is a Code Fragment Manager-based shared library, with a C-based API.<br>
Here we'll cover some concepts you need to know to get basic QuickDraw 3D support<br>
into your application. This issue's CD contains a prerelease version of the QuickDraw<br>
3D shared library, the 3D Viewer shared library, programming interfaces,<br>
preliminary Inside Macintosh: QuickDraw 3D documentation, sample code, utility<br>
libraries, and other goodies. Two of the sample programs are discussed in this article.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>The API described in the article </b>is based on a beta version of QuickDraw<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3D; although nearly final, the API may change before the final release of the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;software.
</p>
<p>
In addition, we'll talk about reading and writing data in QuickDraw 3D metafile format,<br>
which is a way of representing 3D data in a consistent, transferable manner. But first<br>
we'll set the stage with some background information.
</p>
<h2>QUICKDRAW 3D -- SO, WHAT'S THE BIG DEAL?</h2>
<p>
As we'll explain further in this article, QuickDraw 3D provides developers with a<br>
number of benefits:
</p>
<ul>
<li>    a rich set of high-level geometries</li>
<li> built-in renderers that cover the base functionality needed by developers</li>
<li> immediate and retained graphics</li>
<li> a common 3D file format</li>
<li> human interface guidelines and widgets</li>
<li> a 3D pointing-device manager that provides support for input devices<br>
with more than two degrees of freedom</li>
<li> pointing and picking support that enables user selection of 3D data</li>
<li> transparent access to graphics accelerators</li>
<li> an extensible, plug-in shading and rendering architecture</li>
<li> implementation advantages over other 3D libraries</li>
</ul>
<p>
We've made dealing with 3D data in applications easier with QuickDraw 3D. By<br>
creating a standard for data interchange, with a well-rounded metafile definition,<br>
we're enabling applications to read and write 3D data in a consistent format. The<br>
metafile specification addresses requests from both end users (who couldn't exchange<br>
data between applications in a common format) and developers (who had to write<br>
special-case code to deal with several different file formats).
</p>
<p>
QuickDraw 3D comes with a set of human interface guidelines to foster the adoption of<br>
a consistent look and feel between applications (see "The QuickDraw 3D Human<br>
Interface"). 3D applications today are geared toward the trained 3D expert; what you<br>
learn in one application is generally not transferable to another application. By<br>
following the QuickDraw 3D human interface guidelines, however, developers can help<br>
make 3D graphics an integral part of the user experience within their applications.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______________________________
</p>
<p>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;THE QUICKDRAW 3D HUMAN INTERFACE</b>
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BY DAN VENOLIA
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;QuickDraw 3D provides human interface guidelines (in version 1.0) and a<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toolkit for implementing the guidelines (to come in the second major release).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A sample application on this issue's CD illustrates our current ideas for a 3D<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;human interface. By getting a preview of our plans, you can start taking your<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;applications along the common path.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Our main goal is to provide integration into the Macintosh experience. We feel<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;that 3D graphics will be the next popular multimedia data type -- in the way<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;that 2D graphics, sound, and movies have been in the past -- and users will<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;want to incorporate 3D data into their documents in the same way that they can<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;now incorporate other multimedia data types. To do this they'll need an<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interaction model built on the 2D principles that they're familiar with.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Our guidelines offer suggestions and examples of how things can be done. If<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;your applications are targeted for a very specific audience, and you know that<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;audience well, you may decide to communicate with them in a different way,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and that's perfectly OK.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;One of our guidelines, about direct manipulation through the use of a widget, is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;illustrated in Figure 1. Here we've appropriated the 2D grab handles that are<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;popular in many "draw" programs and extended them to 3D. A widget is a set of<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handles for control of spatial parameters. Some widgets, such as the scale tool<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shown in Figure 1, indicate selection of a shape, while others make an<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invisible object, such as a light or a camera, visible.
</p>
<p>
<img style="margin-left: 44px" src="img/190.gif" width="180 px"></img>
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Figure 1. </b>A scaling widget
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Figure 2 shows what a full-featured 3D application might look like. The<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;emphasis here is on what's the same as in 2D applications rather than on<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;what's unique. The illustration shows a shape selected with a rotation widget, a<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;material selection palette, a room metaphor, and a document containing<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;multiple views of a scene.
</p>
<p>
<img style="margin-left: 44px" src="img/191.gif" width="573 px"></img>
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Figure 2. </b>Conceptual sketch of a 3D application&gt;
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______________________________
</p>
<p>
QuickDraw 3D technology has been made possible in part by the dramatic performance<br>
improvements in the Power Macintosh line of computers. The performance of<br>
QuickDraw 3D is scalable across the Power Macintosh line; we've put in a lot of effort<br>
to ensure that the performance on even entry-level computers is excellent. With<br>
hardware acceleration, these computers can easily compete (and win) against<br>
mid-range workstations costing a lot more money.
</p>
<p>
<b>HOW QUICKDRAW 3D COMPARES WITH OTHER LIBRARIES</b>
</p>
<p>
QuickDraw 3D offers many advantages over other 3D libraries. When using other<br>
graphics libraries, you're on your own if, for instance, you want to change the way a<br>
scene is rendered (say, by doing ray tracing or applying procedural shading): you have<br>
to reimplement all of the 3D architecture. With QuickDraw 3D, you only have to write<br>
code to deal with the specific area that you want to change. And, even better, the code<br>
you write can be used as a plug-in by other applications.
</p>
<p>
Unlike some libraries, QuickDraw 3D will be able to take advantage of a number of 3D<br>
hardware acceleration solutions, since acceleration was one of its design criteria.<br>
Another important criterion was cross-platform support. For example, a renderer<br>
could be written to take advantage of low-level 3D libraries, such as the Silicon<br>
Graphics OpenGL graphics library.
</p>
<h2>WHAT YOU CAN DO WITH QUICKDRAW 3D</h2>
<p>
The 3D application development process can be broken down into four areas: creation<br>
of 3D data into a set of data structures, manipulation of that data in the human<br>
interface of the application, presentation of the data by displaying it, and<br>
transportation of the data (saving to and reading from files). QuickDraw 3D provides<br>
support in each of these areas. You can implement one or more of them in your<br>
application:
</p>
<ul>
<li>    QuickDraw 3D geometries -- If you're planning to write an application<br>
to deal with the creation of models, QuickDraw 3D lets you define the<br>
representation of the objects to be modeled in 3D form.</li>
<li> QuickDraw 3D human interface -- Maybe you want to allow users to<br>
visualize 3D data and models in a standalone application or as part of an<br>
existing application. QuickDraw 3D's human interface guidelines and built-in<br>
widgets provide a consistent way of manipulating 3D objects.</li>
<li> QuickDraw 3D rendering and shading -- Rendering turns the 3D<br>
geometries into pixels; shading determines what color those pixels should be.<br>
Realism can be added by applying textures to objects:<i> texture mapping </i>takes a<br>
texture (usually from a picture source, such as a picture of a brick wall) and<br>
wraps it around an object. For example, Figure 3 shows a dinosaur mesh<br>
rendered with a skin texture picture as a texture map. In its second major<br>
release, QuickDraw 3D will enable you to write plug-in renderers and<br>
shaders and license them to other developers.</li>
</ul>
<p>
<img src="img/192.gif" width="600 px"></img>
</p>
<p>
<b>Figure 3. </b>Dinosaur mesh mapped with a skin-like texture
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>The dinosaur model </b>was supplied in QuickDraw 3D metafile format<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;courtesy of Viewpoint DataLabs Intl.
</p>
<ul>
<li style="margin-left: 17px">    QuickDraw 3D metafile format -- If you want to provide 3D clip art in<br>
the form of models, you'll really be pleased with QuickDraw 3D's metafile<br>
format. One of the common problems encountered by users when working with<br>
several 3D applications is that of data interchange, where one application's<br>
file is not readable by another due to the multitude of 3D data formats.<br>
QuickDraw 3D addresses this problem by providing a standard for the<br>
interchange of 3D data. This device- and platform-independent representation<br>
of 3D data is extensible, so your custom data gets preserved. And all of the<br>
elements for a scene can be stored in the metafile, including lighting, camera<br>
objects, texture maps, and shaders.</li>
</ul>
<h2>ROAD MAP FOR ADOPTION</h2>
<p>
Based on our experience working with developers, we've created a road map for<br>
adoption of QuickDraw 3D. Here we'll look at how different application developers<br>
might begin to adopt QuickDraw 3D, in order from the least to the greatest amount of<br>
support. These categories provide you with a general strategy for bringing QuickDraw<br>
3D into your applications.
</p>
<ul>
<li>    Developers of general-purpose 2D applications should add support for<br>
the metafile format, enabling users to read and save 3D data within an<br>
application. This can be achieved by using the 3D Viewer, which allows 3D<br>
objects derived from metafile data to be viewed and manipulated by the user.</li>
<li> Developers who use other 3D libraries and may not be ready to move to<br>
QuickDraw 3D just yet should at least add support for the metafile format and<br>
additionally consider adopting the QuickDraw 3D human interface guidelines.<br>
Obviously, support for the metafile format requires writing a parser to<br>
convert metafile data to another internal representation (Apple will be<br>
supplying parser code). Implementing the human interface guidelines will<br>
make the application be compatible with and look consistent with other 3D<br>
applications available on the Macintosh. Note that an application that uses a 3D<br>
library other than QuickDraw 3D will have a harder time using the 3D<br>
Viewer.</li>
<li> Developers of existing 3D applications who want to take the first step<br>
toward creating a QuickDraw 3D-savvy application should take advantage of<br>
QuickDraw 3D's rendering capabilities through the use of immediate-mode<br>
rendering (more on this later). This method provides not only fast rendering<br>
in software but also transparent access to hardware, while allowing the<br>
application to preserve its own data structures. In addition, these developers<br>
should plan to add support for the metafile format and the human interface<br>
guidelines.</li>
<li> Developers who want to leave the low-level work to QuickDraw 3D, and<br>
concentrate on creating differentiating features within their applications,<br>
should make their applications as QuickDraw 3D-savvy as possible. This<br>
means taking advantage of the full API, including QuickDraw 3D's data<br>
structures and geometries (which provide metafile support virtually for<br>
free), rendering (both immediate and retained modes), and the human<br>
interface guidelines.</li>
</ul>
<h2>QUICKDRAW 3D ARCHITECTURE</h2>
<p>
The QuickDraw 3D architecture isolates in a layer within the system software those<br>
things that all developers have to do, leaving them to concentrate on the code that will<br>
allow their application to stand out. This architecture can be thought of as a sandwich<br>
filling that sits between your application and the hardware it's running on, isolating<br>
you from having to deal with operating system and hardware issues directly. Like any<br>
good sandwich filling, if you examine it closely, you'll see that it's divided into a<br>
number of appetizing chunks. Figure 4 shows some of the functional blocks that make<br>
up QuickDraw 3D, with an emphasis on those areas that can be customized by<br>
developers.
</p>
<p>
<img src="img/193.gif" width="504 px"></img>
</p>
<p>
<b>Figure 4. </b>QuickDraw 3D architecture
</p>
<p>
&nbsp;&nbsp;&nbsp;Let's take a quick look at each of these functional areas, which we'll expand on later.<br>
Here we'll use the word scene to describe not only the objects being modeled, but also<br>
the lighting, camera settings, shaders, and other entities that affect the final<br>
appearance on output devices.
</p>
<p>
<i>Widgets</i> are used to enhance the user experience for 3D applications. For example, to<br>
allow the user to interact with an object, the application can draw grab handles, in the<br>
form of a translation widget, to allow the object to be manipulated.
</p>
<p>
<i>Geometries </i>are the encapsulation of data used to describe an object. Some geometries<br>
are provided as part of QuickDraw 3D, resulting in a very concise representation; for<br>
more information, see "QuickDraw 3D Geometries." (QuickDraw 3D uses geometries to<br>
draw widgets.)
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______________________________
</p>
<p>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;QUICKDRAW 3D GEOMETRIES</b>
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The QuickDraw 3D geometries that are currently available are as follows:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line, polyline, triangle, point, simple polygon, general polygon, trigrid,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mesh, box, marker, NURB curve, and patch.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In addition, the following geometries are planned for the second major release<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;of QuickDraw 3D: torus, ellipse, ellipsoid, disk, cylinder, cone, and triangle<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strip. (In version 1.0, you can create any of these geometries by representing<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;them as meshes.)
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Where applicable, the geometries are parameterized so that they're ready for<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;texture mapping or other shading effects.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______________________________
</p>
<p>
The <i>I/O layer </i>provides support for metafiles. There are routines for reading and<br>
writing 3D data to Storage objects, which may be disk or memory based and are useful<br>
for providing Clipboard or drag and drop support in your application.
</p>
<p>
<i>Picking </i>is used to determine which object a user chose. QuickDraw 3D's picking<br>
facilities are more extensive than in other 3D libraries, not only providing several<br>
different types but also returning quite a bit of information to the application beyond<br>
whether a hit took place.
</p>
<p>
<i>Light objects</i> supply the lighting for a scene. QuickDraw 3D provides four types of<br>
light sources: ambient, directional, point, and spot. Based on the light sources for a<br>
given scene and the illumination shader, the renderer makes intensity calculations for<br>
each object's surface and vertex contained in the scene.
</p>
<p>
<i>Camera objects </i>define a point of view into a particular scene. QuickDraw 3D provides<br>
three different camera types: view angle, orthographic, and view plane.
</p>
<p>
<i>Attributes </i>are used to specify different characteristics for each object (or parts of an<br>
object, such as its vertices or faces), and also to attach custom data to an object.
</p>
<p>
<i>Shaders </i>are used to modify or add data, on either a per vertex or a per pixel basis, as<br>
geometries are being processed by the renderer -- for example, illumination and<br>
texturing shaders.
</p>
<p>
<i>Renderers </i>are the business end of QuickDraw 3D. A renderer is a set of routines used<br>
to create a shaded synthetic model of the scene, based on the information stored in the<br>
geometry and taking into account the lighting, surface attributes, and camera location.<br>
QuickDraw 3D provides two basic renderers: a wireframe and an interactive renderer.<br>
You can extend QuickDraw 3D by writing a plug-in renderer, developing an<br>
accelerator card, or implementing a combination of both -- a renderer tied to a<br>
particular hardware setup.
</p>
<h2>IMPLEMENTING SUPPORT FOR THE 3D VIEWER</h2>
<p>
Now, on to the coding details. We realized that some application developers wouldn't<br>
want to get involved with the low-level details of a new API. We looked at the<br>
QuickTime model and saw that a lot of developers implemented support for viewing<br>
movie data by using movie controllers in their existing nonmultimedia applications.<br>
We likewise wanted to allow applications to support the viewing of QuickDraw 3D<br>
metafiles with minimal effort, so we've provided an additional shared library that<br>
implements a 3D Viewer. The Viewer allows users to view and have a basic level of<br>
interaction with 3D data without your having to make any QuickDraw 3D calls. Figure<br>
5 shows a Viewer implementation in a modified version of the Scrapbook. (We used a<br>
preliminary version, so the Viewer interface may change.)
</p>
<p>
<img src="img/194.gif" width="438 px"></img>
</p>
<p>
<b>Figure 5. </b>Viewer implementation in the Scrapbook
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>The car model </b>was supplied in QuickDraw 3D metafile format courtesy of<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Viewpoint DataLabs Intl.
</p>
<p>
Adding Viewer support is simple -- it requires only about five function calls. Your<br>
application can check to see if the Viewer is available by calling Gestalt with the<br>
constant gestaltQuickDraw3DViewer.
</p>
<p>
We'll now look at how your application can create and use a QuickDraw 3D Viewer<br>
object. In the application named Simple 3D Viewer on this issue's CD, we create a<br>
window in which the only object is a Viewer.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>As you read through the code samples, </b>you'll notice that function names<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;have a "Q3" prefix, data types have a "TQ3" prefix, and constants have a "kQ3"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prefix. The part of a function name before the underscore indicates the object<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;being operated on (the class), while the part after the underscore indicates<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the operation (the method). For example, to set the origin of a Box object,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;you'd call the function Q3Box_SetOrigin.
</p>
<p>
<b>CREATING AND DISPOSING OF A VIEWER OBJECT</b>
</p>
<p>
Creating and disposing of a Viewer object is very easy to do. You attach a Viewer to a<br>
window with the Q3ViewerNew function:
</p>
<pre>viewerObj = Q3ViewerNew((CGrafPtr)theWindow, &amp;theRect, 0L);</pre>
<p>
This function takes a WindowPtr, a pointer to a Rect that describes the window area<br>
where you want the 3D scene to appear, and a long word containing flags for modifying<br>
the behavior of the Viewer. When you're finished with the Viewer, you need to dispose<br>
of it with the Q3ViewerDispose function:
</p>
<pre>Q3ViewerDispose(viewerObj);</pre>
<p>
<b>ATTACHING DATA TO THE VIEWER</b>
</p>
<p>
To display the contents of a metafile in your Viewer, you can use the Q3ViewerUseFile<br>
function:
</p>
<pre>Q3ViewerUseFile(viewerObj, fileRefNum);</pre>
<p>
Q3ViewerUseFile takes a reference to the Viewer object and a file reference to a<br>
previously opened QuickDraw 3D metafile. You can also display data from the<br>
Clipboard or data you created yourself, with the Q3ViewerUseData function:
</p>
<pre>Q3ViewerUseData(viewerObj, myDataPtr, myDataSize);</pre>
<p>
This function takes a reference to a Viewer object, a pointer to the data, and the size of<br>
the data in bytes. The data must be in metafile format.
</p>
<p>
<b>HANDLING EVENTS</b>
</p>
<p>
You need to modify your event loop slightly to give the Viewer the opportunity to<br>
handle events, as follows:
</p>
<pre>wasViewerEvent = Q3ViewerEvent(viewerObj, theEvent);</pre>
<p>
Q3ViewerEvent takes a reference to a Viewer object and a pointer to an event record<br>
(usually obtained from WaitNextEvent). This function allows the Viewer to respond to<br>
events, such as a mouse-down event in one of its controls. It returns a value of type<br>
Boolean that indicates whether the event was handled.
</p>
<p>
If the area occupied by the Viewer needs to be updated, you need to redraw the data in<br>
your update event handler by calling Q3ViewerDraw:
</p>
<pre>theErr = Q3ViewerDraw(viewerObj);</pre>
<p>
<b>OTHER VIEWER FUNCTIONALITY</b>
</p>
<p>
The Viewer allows access to the View object for the scene, which enables you to<br>
customize the Viewer's behavior by changing the renderer or lighting for the scene<br>
(more on Views later). Also, the Viewer provides support for cut, copy, and paste; see<br>
the Simple 3D Viewer sample on the CD for an example.
</p>
<h2>PROGRAMMING WITH THE QUICKDRAW 3D API: ERROR<br>
CHECKING AND INITIALIZATION</h2>
<p>
Now let's look at programming with the QuickDraw 3D API, starting with error<br>
checking and initialization. First, the QuickDraw 3D shared library needs to be<br>
installed in the Extensions folder or in the same folder as your project. During your<br>
development cycle you should use the debugging version of the library for extensive<br>
error checking.
</p>
<p>
Error checking may seem like a weird place to start, but checking and responding to<br>
what QuickDraw 3D is trying to tell you will save a great deal of trouble and strife<br>
during development. The QuickDraw 3D error manager provides several levels of<br>
error checking along with functions for checking the last error that occurred. The<br>
error checking, which is similar to that in QuickDraw GX, has three levels: errors,<br>
warnings, and notices.
</p>
<ul>
<li><i>Errors</i> are the most severe indication of a problem and can be divided into<br>
two kinds, fatal and nonfatal. You can determine whether an error is fatal with<br>
the call

<pre>TQ3Boolean Q3Error_IsFatalError(TQ3Error theError);</pre>
<p>
For a complete list of errors provided by QuickDraw 3D, look in the<br>
QuickDraw 3D header files.
</p></li></ul>
<ul>
<li><i>Warnings</i> are less severe than errors, but you should be prepared to<br>
handle them. If the system generates a warning based on a recoverable<br>
situation that you ignore, often an unrecoverable error may occur later.</li>
<li><i>Notices</i> indicate problems that may exist with the way you're using the<br>
QuickDraw 3D library. Although they're less severe than warnings, you<br>
should take note of what notices are telling you, to prevent problems from<br>
occurring later in your application's execution. Notices are generated only in<br>
the debugging version.</li>
</ul>
<p>
You can install your own error, warning, and notice handlers, which can write the<br>
error information to a window or file or present a dialog or alert. Presenting too many<br>
alerts can be annoying to the user, so you should probably log errors, warnings, and<br>
notices to a file or a status window, and present a dialog or an alert only for fatal<br>
errors from which no recovery is possible.
</p>
<p>
<b>DEFINING AND INSTALLING AN ERROR HANDLER</b>
</p>
<p>
Handlers for errors, warnings, and notices are all similar -- they're functions that<br>
take an error code of type TQ3Error and have no return value. Listing 1 shows a<br>
definition of an error handler.
</p>
<p>
<b>Listing 1. </b>Error handler
</p>
<pre>static void MyErrorHandler(TQ3Error firstError, TQ3Error lastError,
                           long refCon)
{
   char   buf[512];

   sprintf(buf, "ERROR %d - %s\n", lastError,
         getErrorString(lastError));  // Get the error as a C string.
   if (gErrorFile == NULL)
      gErrorFile = fopen("error.output", "w+");
   if (gErrorFile != NULL)
      fputs(buf, gErrorFile);
}</pre>
<p>
Once handlers have been defined, it's a snap to install them. For example, you would<br>
install the error handler defined in Listing 1 as follows:
</p>
<pre>Q3Error_Register(MyErrorHandler, 0L);</pre>
<p>
<b>INITIALIZING QUICKDRAW 3D</b>
</p>
<p>
Before you can use QuickDraw 3D, you need to call Gestalt to see if the library is<br>
installed, using the constant gestaltQuickDraw3D. You then need to initialize the<br>
library as shown in Listing 2. You call the Q3Initialize function to ensure that the<br>
QuickDraw 3D library gets a chance to allocate its internal data structures and to<br>
initialize any subcomponents (such as plug-in shaders) that it needs to call. You then<br>
do other initialization as needed, such as installing an error handler. The return value<br>
indicates whether the call was successful.
</p>
<p>
<b>Listing 2. </b>Initializing and closing the connection to the library
</p>
<pre>void Initialize3DStuff(void)
{  
   if (Q3Initialize() == kQ3Failure) {
      // Handle the error.
      StopAlert(kQD3DInitFailed);
      ExitToShell();
   }
   MyErrorInit();
}
void Exit3DStuff(void)
{  
   if (Q3Exit() == kQ3Failure) {
      // Handle the error.
      StopAlert(kQD3DExitFailed);
      ExitToShell();
   }
}</pre>
<p>
When your application is about to quit, you should shut down your connection to the<br>
QuickDraw 3D library by calling Q3Exit, also shown in Listing 2. (Obviously a real<br>
application would have more sophisticated error handling here.)
</p>
<h2>CREATING AND DRAWING A SIMPLE 3D OBJECT: THE BOX<br>
APPLICATION</h2>
<p>
The Box application on this issue's CD is a simple QuickDraw 3D program that opens a<br>
window, displays 3D boxes in the window, and rotates the boxes (see Figure 6). While<br>
this isn't a useful application as such, it covers all the basics needed to create and<br>
display objects using QuickDraw 3D. It also illustrates double buffering support,<br>
which helps an application provide flicker-free drawing when animating geometries;<br>
QuickDraw 3D's double buffering takes advantage of hardware double buffering when<br>
available.
</p>
<p>
<img src="img/195.gif" width="342 px"></img>
</p>
<p>
<b>Figure 6. </b>A window from the Box sample program
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>For a more complex example, </b>see the Modeller program on the CD, which<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shows most of the things a QuickDraw 3D application needs to do, such as<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reading and writing metafiles, texture mapping, and using interpolation<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;styles.
</p>
<p>
We define the following data structure to store the information that QuickDraw 3D<br>
needs to model and render our scene:
</p>
<pre>struct _documentRecord {

    TQ3ViewObject   fView;          // The view for the scene
    TQ3GroupObject  fModel;         // Object in scene being modeled
    TQ3StyleObject  fInterpolation; // Style used when rendering
    TQ3StyleObject  fBackFacing;    // Whether to draw shapes that
                                    // face away from the camera
    TQ3StyleObject  fFillStyle;     // Drawn as solid filled objects
                                    // or decomposed to components
    TQ3Matrix4x4    fRotation;      // The transform for the model
};
typedef struct _documentRecord DocumentRec, *DocumentPtr,
     **DocumentHdl;</pre>
<p>
We can create a new instance of this type, initialize it with the required values, and<br>
store a reference to it in each window's refCon field.
</p>
<p>
<b>OBJECT CREATION</b>
</p>
<p>
Creating a simple object -- like a box -- is straightforward. We'll make four copies<br>
of the box, each with its own transform. The code to create these boxes is shown in<br>
Listing 3. We can store the boxes in our document simply by storing the value<br>
returned by this function in our document's fModel field.
</p>
<p>
<b>Listing 3. </b>Creating four boxes
</p>
<pre>TQ3GroupObject MyNewModel()
{
   TQ3GroupObject       myGroup;
   TQ3GeometryObject    myBox;
   TQ3BoxData           myBoxData;
   TQ3GroupPosition     myGroupPosition;
   TQ3ShaderObject      myIlluminationShader;
   TQ3Vector3D          translation;
   TQ3SetObject         faces[6];
   short                face;

   // Create a group for the complete model.
   if ((myGroup = Q3DisplayGroup_New()) != NULL) {
      // Define a shading type for the group and add the shader to
      // the group.
      myIlluminationShader = Q3PhongIllumination_New();
      Q3Group_AddObject(myGroup, myIlluminationShader);  

      // Set up the colored faces for the box data.
      myBoxData.faceAttributeSet = faces;  
      myBoxData.boxAttributeSet = nil;
      MyColorBoxFaces(&amp;myBoxData);

      // Create the box itself.
      Q3Point3D_Set(&amp;myBoxData.origin, 0, 0, 0)
      Q3Vector3D_Set(&amp;myBoxData.orientation, 0, 1, 0);
      Q3Vector3D_Set(&amp;myBoxData.majorAxis, 0, 0, 1);  
      Q3Vector3D_Set(&amp;myBoxData.minorAxis, 1, 0, 0);  
      myBox = Q3Box_New(&amp;myBoxData);
     
      // Put four references to the box into the group, each one with
      // its own translation.
      translation.x = 0; translation.y = 0; translation.z = 0;
      MyAddTransformedObjectToGroup(myGroup, myBox, &amp;translation);
      translation.x = 2; translation.y = 0; translation.z = 0;
      MyAddTransformedObjectToGroup(myGroup, myBox, &amp;translation);
      translation.x = 0; translation.y = 0; translation.z = -2;
      MyAddTransformedObjectToGroup(myGroup, myBox, &amp;translation);
      translation.x = -2; translation.y = 0; translation.z = 0;
      MyAddTransformedObjectToGroup(myGroup, myBox, &amp;translation);
   }

   // Dispose of the objects we created here.
   if (myIlluminationShader != NULL)
      Q3Object_Dispose(myIlluminationShader);
   for (face = 0; face &lt; 6; face++) {
      if (myBoxData.faceAttributeSet[face] != NULL)
         Q3Object_Dispose(myBoxData.faceAttributeSet[face]);
   }
   if (myBox != NULL)
      Q3Object_Dispose(myBox);
   return myGroup;
}</pre>
<p>
Notice that we dispose of the boxes after adding them to the document group. QuickDraw<br>
3D will create references to the boxes in the document group, so we can safely dispose<br>
of them. To be good QuickDraw 3D citizens and to make more effective use of memory,<br>
we need to dispose of each QuickDraw 3D object as soon as we're done with it.<br>
QuickDraw 3D keeps track of the reference count of each object to help detect memory<br>
leaks. If you're using the debugging version of QuickDraw 3D, it will tell you when you<br>
call Q3Exit if there are any objects remaining that need to be disposed of.
</p>
<p>
<b>RETAINED AND IMMEDIATE MODE RENDERING</b>
</p>
<p>
We talked earlier about retained and immediate modes. Which mode to use is the<br>
subject of big philosophical arguments in the world of 3D graphics. Some developers<br>
prefer one over the other as a matter of principle; other developers make a choice<br>
based on the type of application being developed. QuickDraw 3D offers the best of both<br>
worlds: not only does it support both ways of rendering geometric data, it also allows<br>
you to mix these types in the same rendering loop.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Retained and immediate modes are</b> simply methods of rendering, without<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the usual connotation of the term "mode" (a state that you must exclusively<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remain in once you get into it). Although this terminology has become common<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in the field of 3D graphics, retained rendering and immediate rendering calls<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;can in fact be freely mixed.
</p>
<p>
In<i> retained mode, </i>the definition and storage of the geometries are kept internal to<br>
QuickDraw 3D (as an abstract object). This mode provides convenient features for<br>
caching, rejection of entire objects based on clipping and culling, preservation of<br>
tessellated surfaces, multiple instantiation of objects (drawing multiple versions of<br>
an object but storing its definition only once), and conversion between geometry types.<br>
Retained mode is useful when the geometry has to be passed around to different modules<br>
within the application or to plug-in renderers. Extensive geometry editing functions<br>
are provided as part of the QuickDraw 3D API, which makes it easy to alter the data<br>
associated with each geometric object.
</p>
<p>
In <i>immediate mode,</i> the application keeps the only copy of the geometry. This is<br>
particularly useful when your application needs to reference data that's in a format<br>
different from the one used by QuickDraw 3D or when a large number of vertices that<br>
make up the geometry are being edited continuously -- for example, in the animation<br>
of a stress analysis for mechanical design.
</p>
<p>
The code in Listing 3 creates the boxes in retained mode, by creating objects that<br>
encapsulate the box data; QuickDraw 3D then manages the box data for us. If you want<br>
to add QuickDraw 3D rendering and drawing to an existing application with its own 3D<br>
data structures, you can draw in immediate mode instead. To draw a box in immediate<br>
mode, you simply initialize the values in the TQ3BoxData structure to the appropriate<br>
values and then draw the data directly in a rendering loop (described later) by calling<br>
the following function:
</p>
<pre>myStatus = Q3Box_Submit(&amp;myBoxData);</pre>
<p>
Because you never create a QuickDraw 3D object, there's no need to call<br>
Q3Object_Dispose.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Notice that in Listing 3 </b>we initialize an object using a data structure of<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type TQ3BoxData. This structure contains all of the information required to<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw a Box geometry, but is not an object in itself. Because of this we don't<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call Q3Object_Dispose on the box data structure, but we do call it on the Box<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;object.
</p>
<p>
<b>THE DRAW CONTEXT</b>
</p>
<p>
All window system dependencies are isolated to a layer we call the draw context. This<br>
makes porting your application easier (and it also makes it easier for us to port<br>
QuickDraw 3D to other platforms). Although QuickDraw 3D is platform independent,<br>
of course at some point you'll need to deal with the realities of a particular platform's<br>
window system, in this case the Mac OS.
</p>
<p>
&nbsp;&nbsp;This is where the concept of a draw context comes in. It's a means for QuickDraw 3D<br>
to interface with the host environment. There's a special draw context for the Mac OS,<br>
called a Macintosh draw context; information describing this context is stored in a<br>
TQ3MacDrawContext object, which contains the information necessary for QuickDraw<br>
3D to image the data on a computer running the Mac OS.
</p>
<p>
Listing 4 is a routine from the Box application that creates a Macintosh draw context<br>
the size of a window that we pass in. We're telling QuickDraw 3D to create a buffer in<br>
which to image the data; this is referred to as the back buffer. If we're using double<br>
buffering (that is, we set the doubleBufferState field of the Macintosh draw context to<br>
true), the front buffer will be the window associated with the draw context. The data is<br>
copied from the back buffer to the front buffer when Q3View_EndRendering is called.<br>
This helps provide flicker-free animation if you're animating the object being viewed.
</p>
<p>
<b>Listing 4. </b>Creating a Macintosh draw context
</p>
<pre>TQ3DrawContextObject MyNewDrawContext(WindowPtr theWindow)
{
   TQ3DrawContextData      myDrawContextData;
   TQ3MacDrawContextData   myMacDrawContextData;
   TQ3DrawContextObject    myDrawContext;
   TQ3ColorRGB             clearColor;

   Q3ColorRGB_Set(&amp;clearColor, 1, 1, 1);
   myDrawContextData.clearImageState = kQ3True;
   myDrawContextData.clearImageMethod = kQ3ClearMethodWithColor;
   myDrawContextData.clearImageColor = clearColor;
   myDrawContextData.paneState = kQ3False;
   myDrawContextData.maskState = kQ3False;
   myDrawContextData.doubleBufferState = kQ3True;
   myMacDrawContextData.drawContextData = myDrawContextData;
   myMacDrawContextData.window = (CGrafPtr) theWindow;
                              // The window associated with the view
   myMacDrawContextData.library = kQ3Mac2DLibraryNone;
   myMacDrawContextData.viewPort = nil;
   myMacDrawContextData.grafPort = nil;
  
   // Create draw context and return it; if nil, caller must handle
   // it.
   myDrawContext = Q3MacDrawContext_New(&amp;myMacDrawContextData);
   return myDrawContext;
}</pre>
<p>
Sometimes you might want to be able to get at the back buffer yourself; for example,<br>
you might want to create a picture preview of some metafile data to place on the<br>
Clipboard along with the metafile data, so that applications that don't support metafiles<br>
can display the picture. QuickDraw 3D makes this possible by providing a different<br>
type of draw context, called a pixmap draw context, which can be based on a GWorld.<br>
First you need to create a GWorld the size of the window area; then you can create a<br>
pixmap draw context as shown in Listing 5.
</p>
<p>
<b>Listing 5. </b>Creating a pixmap draw context
</p>
<pre>TQ3DrawContextObject MyNewPixmapDrawContext(GWorldPtr theGWorld)
{
   TQ3PixmapDrawContextData    myPixmapDCData;
   TQ3ColorRGB                 clearColor;
   PixMapHandle                hPixMap;
   Rect                        srcRect;
  
   Q3ColorRGB_Set(&amp;clearColor, 1, 1, 1);

   // Fill in the draw context data.
   myPixmapDCData.drawContextData.clearImageState = kQ3True;
   myPixmapDCData.drawContextData.clearImageMethod =
      kQ3ClearMethodWithColor;
   myPixmapDCData.drawContextData.clearImageColor = clearColor;
   myPixmapDCData.drawContextData.paneState = kQ3False;
   myPixmapDCData.drawContextData.maskState = kQ3False;
   myPixmapDCData.drawContextData.doubleBufferState = kQ3False;
   hPixMap = GetGWorldPixMap(theGWorld);
   LockPixels(hPixMap);
   srcRect = theGWorld-&gt;portRect;
   myPixmapDCData.pixmap.width     = srcRect.right  - srcRect.left;
   myPixmapDCData.pixmap.height    = srcRect.bottom - srcRect.top;
   myPixmapDCData.pixmap.rowBytes  = (**hPixMap).rowBytes &amp; 0x7FFF;
   myPixmapDCData.pixmap.pixelType = kQ3PixelTypeRGB32;
   myPixmapDCData.pixmap.pixelSize = 32;
   myPixmapDCData.pixmap.bitOrder  = kQ3EndianBig;
   myPixmapDCData.pixmap.byteOrder = kQ3EndianBig;
   myPixmapDCData.pixmap.image     = (**hPixMap).baseAddr;

   return Q3PixmapDrawContext_New(&amp;myPixmapDCData);
}</pre>
<p>
When using a pixmap draw context, you must keep the GWorld's PixMap locked all the<br>
time (which implies that you need to call LockPixels on it, to help avoid heap<br>
fragmentation). Also, the PixMap must be 32 bits deep -- other depths are not<br>
supported.
</p>
<p>
<b>THE CAMERA</b>
</p>
<p>
A camera is a QuickDraw 3D object used to project a 3D scene onto a 2D plane. It<br>
defines a point of view on the scene and a method of projection onto the viewing plane.<br>
QuickDraw 3D provides three types of camera:
</p>
<ul>
<li>    View angle or perspective -- This type of camera is defined in terms of<br>
a viewing angle and horizontal-to-vertical aspect ratio. It's the most common<br>
camera type because it provides a natural-looking perspective.</li>
<li> Orthographic -- This is a parallel projection, where the direction of<br>
projection is perpendicular to the projection plane. Orthographic projections<br>
are generally less realistic than perspective projections; however, they're<br>
popular for engineering drawings because parallel lines remain parallel in<br>
the projection, rather than converging to a single point on the horizon.</li>
<li> View plane -- This is a perspective projection defined in terms of an<br>
arbitrary viewing plane. This type of camera is useful for providing an<br>
off-axis view, which is used for scrolling.</li>
</ul>
<p>
We use a view angle camera for the Box application, creating the camera with the<br>
routine in Listing 6.
</p>
<p>
<b>Listing 6. </b>Creating the camera
</p>
<pre>TQ3CameraObject MyNewCamera(WindowPtr theWindow)
{
   TQ3ViewAngleAspectCameraData   perspectiveData;
   TQ3CameraObject               camera;
  
   TQ3Point3D       from = { 0.0, 0.0, 13.0 };
   TQ3Point3D       to   = { 0.5, 0.5, -1.5 };
   TQ3Vector3D    up   = { 0.0, 1.0, 0.0 };
   float          fieldOfView = 0.523593333;
   float          hither      = 0.001;
   float          yon         = 1000;

   perspectiveData.cameraData.placement.cameraLocation = from;
   perspectiveData.cameraData.placement.pointOfInterest = to;
   perspectiveData.cameraData.placement.upVector = up;
   perspectiveData.cameraData.range.hither = hither;
   perspectiveData.cameraData.range.yon = yon;
   perspectiveData.cameraData.viewPort.origin.x = -1.0;
   perspectiveData.cameraData.viewPort.origin.y = 1.0;
   perspectiveData.cameraData.viewPort.width  = 2.0;
   perspectiveData.cameraData.viewPort.height = 2.0;
   perspectiveData.fov = fieldOfView;
   perspectiveData.aspectRatioXToY =
      (float)(theWindow-&gt;portRect.right - theWindow-&gt;portRect.left) /
      (float)(theWindow-&gt;portRect.bottom - theWindow-&gt;portRect.top);
   camera = Q3ViewAngleAspectCamera_New(&amp;perspectiveData);

   return camera;
}</pre>
<p>
<b>LIGHTING</b>
</p>
<p>
QuickDraw 3D includes a number of different light objects that can be used to provide<br>
illumination to the surfaces in a scene. Lighting is additive, meaning that the amount of<br>
lighting applied to a particular surface will be the sum of the lighting from all<br>
sources. There are four light types:
</p>
<ul>
<li>    Ambient -- This is the amount of light added to all surfaces in a scene.<br>
Since this light type has no location, it doesn't cast shadows.</li>
<li> Directional -- Sometimes referred to as an "infinite" light, this light<br>
source emits parallel rays of light in a specific direction. The intensity of this<br>
light source doesn't change as the distance from the light changes.</li>
<li> Point -- This light source emits rays of light in all directions from a<br>
particular point location. A point light is attenuated, meaning that the<br>
intensity of the light decreases as the distance from the light increases;<br>
QuickDraw 3D provides a set of constants to control this behavior.</li>
<li> Spot -- This type of light emits a circular cone of light from a point<br>
source in a particular direction. A spot light is attenuated both by the distance<br>
from the source and by the position across the cone; the intensity of light at<br>
the center of the cone is greater than the intensity at the edge of the cone.</li>
</ul>
<p>
Listing 7 shows an extract from our sample's MyNewLights routine; here we create a<br>
point light and add it to a light group.
</p>
<p>
<b>Listing 7. </b>Creating a point light in a light group
</p>
<pre>lightGroup = Q3LightGroup_New();

pointData.lightData.isOn = kQ3True;
pointData.lightData.brightness = 0.80;
pointData.lightData.color.r = 1.0;
pointData.lightData.color.g = 1.0;
pointData.lightData.color.b = 1.0;
pointData.location.x = -10.0;
pointData.location.y = 0.0;
pointData.location.z = 10.0;
pointData.castsShadows = kQ3False;
pointData.attenuation = kQ3AttenuationTypeNone;
light = Q3PointLight_New(&amp;pointData);

Q3Group_AddObject(lightGroup, light);</pre>
<p>
Q3Object_Dispose(light);
</p>
<p>
<b>THE VIEW</b>
</p>
<p>
Once you've added the light to a group, you can associate the group with the View object<br>
for your scene. A View object keeps track of the information necessary to render an<br>
entire scene, tying together the different parts of QuickDraw 3D. In our simple<br>
example it ties together the draw context, camera, lights, and renderer. Listing 8<br>
shows the code we use to create the View object for the Box program.
</p>
<p>
<b>Listing 8. </b>Creating the View object
</p>
<pre>TQ3ViewObject MyNewView(WindowPtr theWindow)
{
   TQ3Status               myStatus;
   TQ3ViewObject           myView;
   TQ3DrawContextObject    myDrawContext;
   TQ3RendererObject       myRenderer;
   TQ3CameraObject         myCamera;
   TQ3GroupObject          myLights;
  
   myView = Q3View_New();
  
   // Create and set the draw context.
   myDrawContext = MyNewDrawContext(theWindow);
   myStatus = Q3View_SetDrawContext(myView, myDrawContext);
   Q3Object_Dispose(myDrawContext);
  
   // Create and set the renderer. Use the interactive software
   // renderer.
   myRenderer = Q3Renderer_NewFromType(kQ3RendererTypeInteractive);
   myStatus = Q3View_SetRenderer(myView, myRenderer);
   Q3Object_Dispose(myRenderer);
  
   // Create and set the camera.
   myCamera = MyNewCamera(theWindow);
   myStatus = Q3View_SetCamera(myView, myCamera);
   Q3Object_Dispose(myCamera);
  
   // Create and set the lights.
   myLights = MyNewLights();
   myStatus = Q3View_SetLightGroup(myView, myLights);
   Q3Object_Dispose(myLights);

   return myView;
}</pre>
<p>
<b>THE RENDERING LOOP</b>
</p>
<p>
All drawing must be done in a rendering loop. This is necessary because we don't know<br>
in advance how much memory is required to render a complex model. The loop should<br>
fit neatly into your application, because most Macintosh applications will localize<br>
drawing in the update event-handling code, which is where you'll call your rendering<br>
loop for QuickDraw 3D. A simple rendering loop will look like Listing 9.
</p>
<p>
<b>Listing 9. </b>The rendering loop
</p>
<pre>TQ3Status DocumentDraw3DData(DocumentPtr theDocument)
{  
   Q3View_StartRendering(theDocument-&gt;fView);
   do {
      Q3Style_Submit(theDocument-&gt;fInterpolation,
         theDocument-&gt;fView);
      Q3Style_Submit(theDocument-&gt;fBackFacing, theDocument-&gt;fView);
      Q3Style_Submit(theDocument-&gt;fFillStyle, theDocument-&gt;fView);
      Q3MatrixTransform_Submit(&amp;theDocument-&gt;fRotation,
           theDocument-&gt;fView);
      Q3DisplayGroup_Submit(theDocument-&gt;fModel, theDocument-&gt;fView);
   } while (Q3View_EndRendering(theDocument-&gt;fView)
                     == kQ3ViewStatusRetraverse);
   return kQ3Success;
}</pre>
<p>
Recall that earlier we set up our Macintosh draw context to use double buffering; this<br>
causes all drawing to take place in the back buffer. The calls in the rendering loop<br>
draw into the active buffer, which we have set up to be the back buffer. The image data<br>
is copied from the back buffer to the front buffer (in this case the window) when<br>
Q3View_EndRendering is called.
</p>
<p>
A rendering loop for a pixmap draw context would be similar to the routine in Listing<br>
9, except you would need to copy the data from your PixMap to the screen yourself,<br>
generally with CopyBits.
</p>
<h2>THE QUICKDRAW 3D METAFILE</h2>
<p>
Here we'll take a brief look at the architecture of QuickDraw 3D's metafile format<br>
(file type '3DMF') and at how you can provide metafile support in your application.
</p>
<p>
The QuickDraw 3D metafile comes in two forms: plain-text (ASCII) and binary. Table<br>
1 shows the differences between these two forms. The plain-text form is more useful<br>
for debugging purposes; once your application is debugged, it's more efficient to use<br>
the binary form, which may be read and written much faster and may require less<br>
storage space on disk.
</p>
<p>
<img src="img/196.gif" width="600 px"></img>
</p>
<p>
The metafile format supports a wide range of primitive data types, including 1-, 2-,<br>
4-, and 8-byte signed and unsigned integers and 4- and 8-byte IEEE floating-point<br>
numbers, together with a range of types for describing 3D data. In addition, metafiles<br>
may contain big- or little-endian numbers, making them ideal for storing data that<br>
may be used in a cross-platform manner.
</p>
<p>
<b>METAFILE ORGANIZATION</b>
</p>
<p>
There are three distinct types of metafile organization: normal, stream, and database.<br>
The organization of the file can affect both the size of the file and the time it takes to<br>
access the data in the file. Let's look at a simple example in which a single Box object<br>
is drawn four times at different positions by means of four different Transform<br>
objects, as was shown in Figure 6. The three types of organization are illustrated in<br>
Figure 7. (Note that # marks the beginning of a comment.) These types are as follows:
</p>
<ul>
<li>    Normal -- This is the most compact representation. Referenced objects<br>
are listed in a Table of Contents (TOC). In our example, only the Box object is<br>
listed in the TOC. The Transform objects don't appear in the TOC because they<br>
were referenced only once. Note that random access to the file is needed to<br>
resolve references, since after reading a reference, the metafile parser needs<br>
to skip forward to the TOC, and back to resolve the references.</li>
<li> Stream -- There is no TOC, and references to objects are written as<br>
copies of the objects themselves. This may result in a larger file if a lot of<br>
object references were used, but it allows for a sequential search. A sequential<br>
search is very useful for reading from the file and imaging to a printer, since<br>
each object can be read, imaged, and disposed of. This organization is also<br>
useful as a wire protocol for imaging on remote machines.</li>
<li> Database -- Every object is logged into the TOC, even if it's not<br>
referenced. Each TOC entry contains the type of the object. Accessing the TOC<br>
lets you see all the information contained in the file without having to read in<br>
all of the file and create objects. This would be useful for creating a catalog of<br>
textures, for example.</li>
</ul>
<p>
<img src="img/197.gif" width="692 px"></img>
</p>
<p>
<b>Figure 7. </b>Three types of metafile organization (representing Figure 6)
</p>
<p>
<b>USING METAFILES</b>
</p>
<p>
The simplest way to access data in metafiles is to use the QuickDraw 3D API. First,<br>
there are two types of objects you need to understand:
</p>
<ul>
<li>    TQ3FileObject -- Objects of this type maintain state information and<br>
provide an interface between a given file format and a Storage object. File<br>
objects are used to read and write data in metafile format from and to Storage<br>
objects.</li>
<li> TQ3StorageObject -- Objects of this type act as an interface to a type of<br>
physical stream-based storage (for example, memory and files). Storage<br>
objects are used to represent a piece of physical storage.</li>
</ul>
<p>
Why have this two-stage approach? The answer is that all the machine dependencies<br>
are localized in the Storage object, which allows files to be used to read and write data<br>
from differing types of physical storage with the same set of routines. For example,<br>
you can use the same File object to write to a Storage object that represents a file on<br>
your hard disk and to write to another Storage object that represents a block of<br>
memory that will be passed to the Scrap Manager.
</p>
<p>
The usual method for using File and Storage objects is to create a new instance of a<br>
Storage object and attach it to a newly created File object using Q3File_SetStorage, as<br>
shown in Listing 10.
</p>
<p>
<b>Listing 10. </b>Attaching a Storage object to a file
</p>
<pre>TQ3FileObject MyGetNewFile(FSSpec *myFSSpec, TQ3Boolean *isText)
{
   TQ3FileObject      myFileObj;
   TQ3StorageObject   myStorageObj;
   OSType            myFileType;
   FInfo               fndrInfo;

   // We assume the FSSpec passed in was valid and get the file
   // information. We need to know the file type; this routine may
   // get called by an Apple-event handler, so we can't assume a
   // type -- we need to get it from the FSSpec.
   FSpGetFInfo(myFSSpec, &amp;fndrInfo);
   myFileType = fndrInfo.fdType;

   if (myFileType == '3DMF')
      *isText = kQ3False;
   else if (myFileType == 'TEXT')
      *isText = kQ3True;
   else
      return NULL;
  
   // Create a new Storage object and new File object.
   if (((myStorageObj = Q3FSSpecStorage_New(myFSSpec)) == NULL)
         || ((myFileObj = Q3File_New()) == NULL)) {
      if (myStorageObj != NULL)
         Q3Object_Dispose(myStorageObj);
      return NULL;
   }

   // Set the storage for the File object.
   Q3File_SetStorage(myFileObj, myStorageObj);
   Q3Object_Dispose(myStorageObj);

   return myFileObj;
}</pre>
<p>
<b>Reading data from metafiles. </b>There are three routines that you can use to help<br>
with reading the data: Q3File_GetNextObjectType, Q3File_ReadObject, and<br>
Q3File_SkipObject. Listing11 illustrates the technique used to read drawable data<br>
from a metafile. The code loops through the file, getting each object and checking to see<br>
if the object is drawable; if so, it adds the object to a group object. <b>Listing 11.</b><br>
Reading from a metafile
</p>
<pre>TQ3Status MyReadModelFromFile(TQ3FileObject theFile, TQ3GroupObject
        myGroup)
{  
   if (theFile != NULL) {
      TQ3Object       myTempObj;
      TQ3Boolean      isEOF;
  
      // Read objects from the file.
      do {
         Q3File_ReadObject(theFile, &amp;myTempObj);
         if (myTempObj != NULL) {
            // We want the object in our main group only if we can
            // draw it.
            if (Q3Object_IsDrawable(myTempObj))
               Q3Group_AddObject(myGroup, myTempObj);
            // We either added the object to the main group, or we
            // don't care, so we can safely dispose of it.
            Q3Object_Dispose(myTempObj);
         }
         // Check to see if we've reached the end of the file yet.
         Q3File_IsEndOfFile(theFile, &amp;isEOF);
      } while (isEOF == kQ3False);  
   }
   if (myGroup != NULL)
      return kQ3Success;
   else
      return kQ3Failure;
}</pre>
<p>
Because we're isolating the implementation details of how the metafile data is stored in<br>
the Storage object that we associated with the File object at its creation time, we don't<br>
care how the metafile data we're reading is physically stored. What this means is that<br>
we could use the routine above to read data from the scrap, from a handle supplied by<br>
the Drag Manager, or from a file, as long as the storage object attached to the file is set<br>
up properly.
</p>
<p>
<b>Writing data to metafiles.</b> Data is written to files similarly to the way it's drawn<br>
in a rendering loop. Depending on the available memory and the complexity of the<br>
model, QuickDraw 3D may need to traverse the model in the group more than once in<br>
order to write all the data out (this is the same reason that the rendering needs to be<br>
done in a loop). As shown below, you need to preface your file-writing loop with a call<br>
to Q3File_BeginWrite, and test the value returned by Q3File_EndWrite to see if<br>
there's a need to traverse the data again.
</p>
<pre>Q3File_OpenWrite(file, kQ3FileModeNormal);</pre>
<pre>Q3File_BeginWrite(file);
do {
    Q3Object_Write(group, file);
} while (Q3File_EndWrite(file) == kQ3FileStatusRetraverse);
Q3File_Close(file);</pre>
<h2>GO TO IT!</h2>
<p>
QuickDraw 3D lowers the bar for application developers who want to put support for<br>
3D data into their applications. By providing support for the features that all<br>
developers need to have in applications -- geometries, metafile support, rendering,<br>
and human interface -- QuickDraw 3D allows you to concentrate on the features and<br>
facilities that set your application apart.
</p>
<p>
<b>PABLO FERNICOLA</b> (AppleLink PFF, eWorld EscherDude)&nbsp;&nbsp;After spending many<br>
years working in 3D graphics under operating systems named **IX, in a faraway land<br>
called Alabama, Pablo made the transition to real computers. After moving to Silicon<br>
Valley, he learned to beat the traffic jams by getting to work before 8 A.M. and going<br>
home after 10 P.M. Now he can be found staring out the window and wondering how he's<br>
going to get home on Interstate 280 after the next earthquake.
</p>
<p>
<b>NICK THOMPSON </b>(AppleLink NICKT) is currently establishing himself as the<br>
Mountain Dew-guzzling fat fool of Developer Technical Support. Unable to work the<br>
winter blubber off due to killer waves that are preventing him from surfing on the<br>
California coast, Nick has been consoling himself with learning the wonder that is<br>
QuickDraw 3D. He was last seen wandering down one of the corridors at Apple<br>
mumbling to himself.
</p>
<p>
Thanks to our technical reviewers Kent Davidson, Eiichiro Mikami, Don Moccia, and<br>
Dan Venolia, and to all the members of the QuickDraw 3D team. Special thanks to Kent<br>
and Dan for supplying information used in this article and to David Vasquez for his<br>
Viewer sample. Thanks also to the Shawn and John team (Shawn Hopwood, Apple's 3D<br>
evangelist, and our marketing weenie, John Alfano) for their input.
</p>
</body>
</html>
