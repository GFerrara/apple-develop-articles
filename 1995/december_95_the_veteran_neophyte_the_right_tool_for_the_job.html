<!DOCTYPE html>
<html>
<head>
<!-- Article ID: 62 - Extracted from develop-1995 -->
<!-- on 2024-08-30 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by the copyright of its respective owners -->
<title>December 95 - The Veteran Neophyte: The Right Tool for the Job</title>
<link href="../common/styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h1>The Veteran Neophyte: The Right Tool for the Job</h1>
<h2>Dave Johnson</h2>
<p>
<img src="img/271.gif" width="144 px"></img>
</p>
<p>
Dynamic programming languages are cool. Once you've tasted dynamic programming,<br>
it's hard to go back to the old, crusty, static way of doing things. But the fact remains<br>
that almost all commercial software is still written with static languages. Why?
</p>
<p>
Recently I took a class in Newton programming. For me personally the Newton isn't a<br>
very useful device, only because I never carry around a notepad or calendar or address<br>
book or to-do list and I don't have a need to collect any sort of data out in the field. But<br>
even though it's not terribly useful to me, it is very useful to a lot of people -- and<br>
useful or not, it's a really cool device. Programming the Newton, for those of you who<br>
haven't had the pleasure, is very, very different from programming the Macintosh in<br>
C or C++ or Pascal, and is incredibly attractive in a lot of ways.
</p>
<p>
The language that you use to program the Newton, NewtonScript, is an example of an<br>
object-oriented dynamic language, or OODL. (See? Even the acronym is cool.) This<br>
means a number of things, but the upshot is that it's very programmer-friendly and<br>
very flexible. Now, I don't pretend to be an expert in languages, not by a long shot, so I<br>
can't offer any incisive comparisons with other "modern" languages, but I <i>can</i> tell you<br>
what it feels like for a dyed-in-the-wool C programmer to leap into this new and<br>
different world. It feels great.
</p>
<p>
One well-known feature of dynamic languages is garbage collection, the automatic<br>
management of memory. Objects in memory that are no longer needed are<br>
automatically freed, and in fact there is no way to explicitly free them other than<br>
making sure that there are no references to them any more, so that the garbage<br>
collector can do its thing. I didn't fully realize how much time and effort and code it<br>
takes to deal with memory management until I didn't have to do it anymore. There's<br>
something almost naughty about it, going around cavalierly creating objects in<br>
memory without worrying about what to do with them later. After a lifetime of living<br>
in mortal fear of memory leaks, it feels deliciously irresponsible. I like it. I like it a<br>
lot.
</p>
<p>
NewtonScript's object model is refreshingly simple and consistent. There are the usual<br>
"simple" data types -- integers, real numbers, Booleans, strings, and so on -- and<br>
only two kinds of compound objects: <i>arrays</i> and <i>frames</i>. An array, as you might expect,<br>
is simply a linear, ordered group of objects, and the individual objects are referenced<br>
by their index (their position in the array). Frames are an unordered collection of<br>
items in named slots; you refer to a particular item by the name of its slot. Frames are<br>
also the only NewtonScript objects that can be sent messages, and the message is<br>
simply the name of a slot that contains a function.
</p>
<p>
Because NewtonScript is dynamic, variables or frame slots or array members can hold<br>
any kind of data, including other arrays or frames, or even functions, and the kind of<br>
data can be changed at any time. The size of the array or frame can be changed anytime,<br>
too; you can add or delete items as needed, without worrying about managing the<br>
changing memory requirements. This kind of flexibility is a big chunk of what makes<br>
dynamic languages so, well, dynamic. Such a thing is of course unimaginable in a static<br>
language, where each byte must be explicitly allocated <i>before</i> it's needed, carefully<br>
tracked while used, and explicitly deallocated when you're done with it.
</p>
<p>
NewtonScript is also <i>introspective</i>, meaning that all objects "know" all about<br>
themselves. (Isn't that a nice term? I like the idea of a language being introspective --<br>
sitting there, chin in hand, pondering itself.) The type of a piece of data is stored with<br>
the data, and named items keep their names. In fact, everything in memory is<br>
coherent, with a well-defined identity; there is no possibility of undifferentiated bits<br>
getting schlepped around, no possibility of a dangling pointer or a string being<br>
interpreted as a real number. In static languages, of course, all that design-level<br>
information is thrown out at compile time, and doesn't exist in the running program at<br>
all. There's nothing <i>but</i> undifferentiated bits, really. What a mess.
</p>
<p>
And that means that debugging, for the most part, has to take place at the machine<br>
level. By the time the program is running, it's just a maze of pointers and bytes and<br>
instructions, fine for a machine but nasty for humans. Of course, to combat this we<br>
have elaborate, complex programs called source-level debuggers. They give you the<br>
sense that the names still exist, thank goodness, but it's just a trick, and depends on an<br>
external file that correlates symbols with locations in memory. If you don't have the<br>
symbol file, you're out of luck. (Confession time: In my regular C programming I avoid<br>
low-level debugging like the plague. Usually I'd rather spend an hour in a source-level<br>
debugger than spend five minutes in MacsBug -- I know, I know, I'm a wimp --<br>
precisely because all the information that helps me to think about my program, the<br>
names and so on, still "exist" in the source-level debugger. In NewtonScript, there<br>
isn't even such a thing as low-level debugging! All that design information is right<br>
there in the guts of the running program. Hallelujah!)
</p>
<p>
With dynamic languages like NewtonScript, you can let go of the details of the<br>
machine's operation, and deal with your program's operation instead -- you can think<br>
at the design level, not the machine level. And it's an incredible relief to float free of<br>
the bits and bytes and pointers and handles and memory leaks and messy bookkeeping.<br>
Most of the ponderous baggage that comes along with writing a computer program goes<br>
away. I mean really, how much longer must we approach the machine on its terms<br>
when we want to build something on it? Users were released from that kind of bondage<br>
to the machine's way of doing things long ago. So what are we waiting for? Obviously<br>
we can't program the Macintosh in NewtonScript (more's the pity) but why aren't we<br>
all chucking our C++ compilers in exchange for Prograph or Lisp or Smalltalk or<br>
Dylan? Well, some of us are. But I think there are two major hurdles to overcome<br>
before dynamic languages become mainstream: the need for speed, and inertia.
</p>
<p>
Dynamic languages carry their own baggage, of course. In the same way that making<br>
the Macintosh easier for people to use made it harder to program because the<br>
complexity and bookkeeping were shunted behind the scenes, making programming<br>
languages easier to use also requires new behind-the-scenes infrastructure and<br>
complexity. (<i>Somebody</i> has to do the memory management, after all.) This usually<br>
results in a bigger memory footprint and slower execution. For "normal" operations,<br>
we're long past the point where that mattered: the hardware is beefy enough to handle<br>
it without blinking. But software always pushes the limits of the hardware.<br>
Consequently, there are still times when it's important to squeeze every drop of<br>
performance out of the machine. And dynamic languages are just not very good at that.<br>
(I don't think you'd want to write your QuickDraw 3D renderer in Lisp.) So any<br>
dynamic language that hopes for mainstream commercial acceptance had better have a<br>
facility for running hunks of "external" code. That way you could write the bulk of<br>
your program in a dynamic language, but still be able to write any time-critical parts<br>
in your favorite static language and plug them in. You'd lose the protection of the<br>
dynamic language when running the external code, but that's a reasonable tradeoff.
</p>
<p>
Inertia is the other big problem. People, once they know one way to do something, are<br>
often loath to change it, especially if they've been doing it that way for a long time. I'm<br>
guilty of this in my own small way: every time I learn a spiffy, liberating new way to<br>
program I think I'll never go back to the "old" way. But the next time I set off to write<br>
some code I automatically reach for the <i>familiar</i> tools, not the new ones. (Lucky for<br>
me, the <i>only</i> way to program the Newton is in NewtonScript.) Fortunately, neither one<br>
of these hurdles will stop the evolution of our tools. It's unstoppable, if perhaps<br>
slower than we might like. There's already a whole spectrum of tools available. From<br>
Assembler to AppleScript, Pascal to Prograph, there are tools that allow anyone with<br>
enough interest to teach their computers to do new things. The line between users and<br>
programmers continues to blur, and dynamic languages can only help that process. I<br>
love the thought of putting programming tools into the hands of "nonprogrammers" --<br>
kids, artists, hobbyists -- and seeing what they come up with. You can bet it will be<br>
something new, something that people tied to the machine would never have thought of.<br>
I can't wait.
</p>



<p>
<b>RECOMMENDED READING</b>
</p>
<ul>
<li><i>Unleashed: Poems by Writers' Dogs</i>, edited by Amy Hempel and<br>
Jim Shepard (Crown, 1995).</li>
</ul>
<p>
<b>DAVE JOHNSON</b> recently enrolled his smallest dog -- named Io (eye-oh) but<br>
affectionately called The Stinklet -- in an agility class. Dog agility is a sort of<br>
obstacle course for dogs, with ramps and jumps and tunnels and poles to climb<br>
and leap over and crawl and weave through. Dave got so involved that he started<br>
building agility courses in the living room. He came to his senses, thankfully,<br>
before creating any permanent installations.
</p>
<p>
Dave is easing up on his working life: beginning with the next issue, he'll be<br>
working 3/4 time. He had to give up some things, and it was decided<br>
(reasonably enough) that helping to edit the rest of develop was more<br>
important than writing this column. Look for guest Neophytes in coming<br>
issues, with perhaps the occasional installment from Dave.
</p>
<p>
Thanks to Lorraine Anderson, Jeff Barbose, Paul Dreyfus, Bo3b Johnson, Lisa<br>
Jongewaard, and Ned van Alstyne for their always enlightening review<br>
comments.
</p>
<p>
Dave welcomes feedback on his musings. He can be reached at JOHNSON.DK on<br>
AppleLink or eWorld, or dkj@apple.com on the Internet.
</p>
</body>
</html>
