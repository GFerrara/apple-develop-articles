<!DOCTYPE html>
<html>
<head>
<!-- Article ID: 27 - Extracted from develop-1995 -->
<!-- on 2024-08-30 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by the copyright of its respective owners -->
<title>June 95 - Copland: The Mac OS Moves Into the Future</title>
<link href="../common/styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h1>Copland: The Mac OS Moves Into the Future</h1>
<h2>Tim Dierks</h2>
<p>
<img src="img/175.gif" width="96 px"></img>
</p>
<p>
<i>The Macintosh operating system has continually evolved since the days when the</i><br>
<i>Macintosh was a home appliance with 128K of RAM and a floppy disk drive -- but now</i><br>
<i>the time has come for radical change. The next generation of the Mac OS, code-named</i><br>
<i>Copland, was designed specifically to serve computers with a fast processor running</i><br>
<i>several tasks and processing large quantities of data. This preview describes Copland's</i><br>
<i>major features and suggests how you might get ready for it.</i>
</p>
<p>
Since the first Macintosh operating system and Toolbox were developed in the early<br>
1980s, the needs of users and developers alike have evolved significantly. Newer<br>
technologies, such as MultiFinder and the PowerPC(TM) processor, have appeared on<br>
the scene. Users have come to expect greater ease of use, more capabilities, and<br>
enhanced productivity. Although the Mac OS has evolved along with the times, a more<br>
radical advance is now required to take advantage of the great increases in power<br>
afforded by the PowerPC processor.
</p>
<p>
Enter Copland, a new generation of the Mac OS to be released by Apple in mid-1996.<br>
Copland will provide a radically new architecture that includes technologies such as<br>
preemptive multitasking and protected memory. For one thing, it's based on a<br>
microkernel that moderates between individual tasks and arbitrates access to the<br>
machine's resources. A number of other services have been updated and improved, both<br>
to fulfill the requirements this change implies and to take advantage of the new<br>
capabilities it provides. For example, the file system has been updated to be accessible<br>
from several processes running simultaneously in several address spaces. Similarly,<br>
the networking system has been enhanced, as have a number of the auxiliary operating<br>
system managers such as the Process Manager.
</p>
<p>
With Copland will also come a number of enhancements to the user experience,<br>
including a Finder that can perform several tasks simultaneously, changes to the<br>
appearance and feel of the interface, and advances that will make it easier to locate and<br>
access information. (See "Moving the Mac OS Interface Into the Future" for more<br>
details.) All of this new functionality is glued together in a runtime model based on the<br>
Code Fragment Manager, the dynamically linked library mechanism introduced with<br>
the first Power Macintosh computers.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______________________________
</p>
<p>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOVING THE MAC OS INTERFACE INTO THE FUTURE</b>
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BY B. WINSTON HENDRICKSON
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copland will not only radically change the foundation of the Mac OS, it will also<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;introduce some of the most significant changes to the user experience since<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1984. For the user, this means new personalization capabilities, built-in<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assistance with tasks, and improved access to information. For the developer,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it means a robust foundation for constructing consistent and compelling<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interfaces that are easier to use.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The new managers in Copland directly concerned with enhancing the user<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;experience are the Appearance Manager, the Assistance Manager, and<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Navigation Services. The following brief descriptions of these will give you an<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inkling of things to come.
</p>
<p>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;THE APPEARANCE MANAGER</b>
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Appearance Manager defines how standard user interface elements should<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;be presented and enables users to personalize the appearance of these elements<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;by choosing one of a number of graphical designs called themes. Applications<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;can use the Appearance Manager's capabilities to draw custom interface<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elements in the style of the current theme.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Appearance Manager provides you with
</p>
<ul>
<li style="margin-left: 35px">a Pattern Manager that returns the appropriate PixPats<br>
for use as dialog backgrounds, control colors, and other aspects of the<br>
interface</li>
<li style="margin-left: 35px">a set of drawing primitives for rendering common<br>
interface elements such as window title bars and dialog separator<br>
lines</li>
<li style="margin-left: 35px">new standard interface elements, including sliders,<br>
progress indicators, and icon buttons</li>
<li style="margin-left: 35px">event notification when the current theme is changed,<br>
allowing you to resync any cached appearance data</li>
</ul>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To prepare now for Copland's dynamic system appearance, be sure not to make<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assumptions about interface specifics (such as assuming that the dialog or<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;menu background is white). Also, don't hard-code the appearance of your<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;application's interface elements; for instance, avoid the use of custom<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;definition procedures wherever possible.
</p>
<p>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;THE ASSISTANCE MANAGER</b>
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Assistance Manager supports the implementation of active user assistance,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enabling the computer to accomplish specific tasks with little or no direction<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from the user. The Assistance Manager provides support for the following:
</p>
<ul>
<li style="margin-left: 35px">task delegation, allowing the creation and management of<br>
automated activity controlled by a condition or event, such as time or<br>
mail delivery</li>
<li style="margin-left: 35px">the ability to create templates from which tasks are<br>
created and executed</li>
<li style="margin-left: 35px">user "interviews" for task configuration, based on Apple<br>
Guide's interaction engine</li>
</ul>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Since this active assistance is built on existing technologies, you can start to<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prepare for it today. The first and most important step is to make your<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;application scriptable, so that it can be automated. Second, you should provide<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;task-based assistance using Apple Guide. Finally, if your application provides<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;any task delegation, you should factor out the related code now so that you can<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;take advantage of the Assistance Manager under Copland.
</p>
<p>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NAVIGATION SERVICES</b>
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Navigation Services replaces System 7's Standard File Package, providing a<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set of tools for opening, saving, and naming documents as well as for<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;navigating a hierarchical information space containing such documents. These<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tools will increase consistency between applications and the Finder and will<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enable integration with the Finder's new and improved searching mechanism.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The new capabilities provided by Navigation Services include these:
</p>
<ul>
<li style="margin-left: 35px">support for a favorite items list, file list position recall<br>
(rebound), and a more intuitive browser</li>
<li style="margin-left: 35px">the ability to browse diverse containers such as a mailbox<br>
and return a general-purpose reference value to documents in those<br>
containers</li>
<li style="margin-left: 35px">one-step calls for common operations such as selecting a<br>
file or directory</li>
<li style="margin-left: 35px">support for easy customization, including an extensible<br>
list of information "panels" (based on Copland's new dialog panels)</li>
<li style="margin-left: 35px">automatic dialog layout adjustment for active script<br>
systems</li>
</ul>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;You can do a few things now to get ready for Navigation Services. First, when<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;customizing the Standard File dialog, render only inside your dialog items, as<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;they may be rearranged. Second, don't assume you're drawing into the desktop<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;port, because you won't be. And finally, don't try to control Standard File by<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;posting events to dialog items; use the documented interface instead. Because of<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the large number of advances and changes in Copland, some software will be<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;incompatible. For instance, applications that have inappropriately incestuous<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;relationships with the operating system might run into problems. But there<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;are some things you can do now to prepare yourself for this release and ensure<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;that your applications will be as compatible as possible. I'll tell you about<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;those things as I give you a tour of Copland's microkernel, runtime model, File<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Manager, and I/O architecture.
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______________________________</p>
<h2>THE MICROKERNEL: A NEW FOUNDATION</h2>
<p>
The present Macintosh operating system is somewhat too trusting: it doesn't take<br>
charge of restricting software's actions or balancing the use of the machine's<br>
resources. Any piece of code can write all over memory, retain control forever, and<br>
even turn off interrupts for any period of time. This model, while once appropriate,<br>
has shortcomings in a computer with a fast processor running several tasks and<br>
processing large quantities of data.
</p>
<p>
&nbsp;&nbsp;That's where Copland's microkernel, developed by Apple specifically for use in the<br>
Mac OS, comes in. The microkernel serves as a referee for the system. It moderates<br>
between many individual tasks so that none can hog the processor and so that special<br>
code need not be implemented to share it. It also arbitrates access to the machine's<br>
resources, including memory, preventing software from being able to see or change<br>
data unrelated to its task.
</p>
<p>
The microkernel provides a number of services -- most of them familiar to those<br>
conversant with kernel-based systems -- including task control, address space<br>
management, virtual memory management, interrupt control, synchronization<br>
primitives, and intertask messaging. These services, which we'll look at in more detail<br>
in the following pages, serve as the basic building blocks of the system. In most cases,<br>
your software won't use any of these kernel services directly but will instead take<br>
advantage of them through other APIs -- APIs that are part of System 7 but that have<br>
been reimplemented in Copland.
</p>
<p>
<b>TASK CONTROL</b>
</p>
<p>
The Copland kernel provides full support for a variety of tasking services. While<br>
applications will normally be cooperatively scheduled by the Process Manager (just as<br>
in System 7), applications will also be able to create tasks that are preemptively<br>
scheduled. Preemptive tasks are scheduled in the order of their assigned priority and<br>
according to kernel scheduling rules; the Process Manager doesn't manage them in the<br>
way it does applications. Such tasks behave as threads behave in other systems. At any<br>
time, almost anything in the system -- including the currently running application<br>
-- can be preempted to run such a task. Interrupt handlers can't be preempted,<br>
however.
</p>
<p>
You'll be able to set the priority of preemptive tasks that you create; higher priority<br>
tasks will run in preference to lower priority ones. By giving an I/O-intensive task<br>
higher priority than your main application thread, you'll gain performance very<br>
similar to that made possible today by chained completion routines. During the<br>
relatively long I/O delays when your task is blocked, your main application thread<br>
will execute freely. Whenever its I/O requests do complete, the task will regain<br>
control immediately so that it can issue its next I/O request, resulting in maximum<br>
throughput without unnecessary blocking of other computing tasks. Similarly, you'll<br>
be able to assign a higher priority to general application tasks than to background<br>
tasks that can afford to wait or proceed slowly while the machine is in use (such as a<br>
background renderer for a network-distributed 3D software package). This will<br>
ensure responsiveness in your application and allow you to use otherwise idle CPU<br>
time.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Chained completion routines </b>are discussed in the article "Asynchronous<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Routines on the Macintosh" in develop Issue 13.
</p>
<p>
To prepare for this opportunity, you can work to make your application easier to<br>
factor. If you remove dependencies between different portions of your application, it'll<br>
be easier to take full advantage of Copland's multitasking capabilities. When a Copland<br>
preemptive thread runs, the file system, networking, and device I/O will be available,<br>
similar to the environment when a Time Manager or Deferred Task Manager task runs<br>
in System 7. One addition is that synchronous calls can be made; your thread will just<br>
block until the I/O has completed.
</p>
<p>
<b>ADDRESS SPACE AND VIRTUAL MEMORY MANAGEMENT</b>
</p>
<p>
In System 7.5, there's only one address space. A particular address always refers to<br>
the same part of memory, and data located there can be accessed by every part of the<br>
operating system. In Copland, by contrast, multiple address spaces can be created,<br>
allowing code and data to be hidden from some processes. For compatibility reasons,<br>
Macintosh applications will continue in this release to share a single address space,<br>
while components of the operating system and third-party software can create fully<br>
protected memory areas in which code that's not dependent on the Macintosh Toolbox<br>
can execute. The kernel, the file system, and several other components will create<br>
such areas to protect their private data structures.
</p>
<p>
Each address space is divided into areas. An area can be either private (accessible only<br>
to tasks executing in that address space) or global (accessible at the same location in<br>
all address spaces). In addition, an area can be either read/write to all tasks (most<br>
global areas fit into this category) or read-only in user mode and read/write in<br>
supervisor mode. (Most code runs in user mode; only code that needs special abilities,<br>
such as drivers and parts of the operating system, runs in supervisor mode.) This<br>
latter protection is used for most kernel and file system data structures; they're<br>
located in global memory for fast and easy access (without the need to switch to<br>
another address space) but can't be damaged by code executing in user mode. Only the<br>
privileged clients of the system can change these structures.
</p>
<p>
In addition to having the ability to map RAM into a variety of address spaces, Copland<br>
also uses virtual memory to provide more room than is available in physical RAM,<br>
moving data between RAM and disk as needed. In fact, virtual memory is always on. It's<br>
dramatically better than System 7's virtual memory in these ways:
</p>
<ul>
<li>The new file system and better integration between the file system<br>
and virtual memory will improve performance.</li>
<li>Your application will be able to provide hints to the operating<br>
system to allow it to tune for best performance. For example, you'll be able to<br>
tell it that you're about to access a significant portion of a large array, and it<br>
will asynchronously begin to bring in the pages that the array resides on.</li>
<li>Fewer limitations on what can be paged will increase the available<br>
RAM for the system. In System 7, the system heap is always held in memory<br>
and can't be paged onto disk. In Copland, virtually all of the system -- aside<br>
from the kernel, the file system, and the disk driver -- will be pageable.</li>
<li>The disk cache will be integrated with the virtual memory system,<br>
and the size of the disk cache will dynamically adjust based on current<br>
operations in order to optimize performance.</li>
<li>Best of all, Copland's virtual memory will dynamically expand the<br>
amount of address space in the system as needed, giving users much more<br>
flexibility than in System 7, where they must decide beforehand how much<br>
memory they'll need, adjust the Memory control panel accordingly, and<br>
reboot. In Copland, if they need to open additional applications, they can do so<br>
without going through any rigmarole; space will be created on the fly to<br>
support their needs, provided that sufficient disk space is available for use as<br>
a backing store.</li>
</ul>
<p>
Because Copland will make available a full gigabyte of address space in which to run<br>
applications (subject, of course, to the limits imposed by the amount of disk space<br>
available for paging), two other limitations of the System 7 memory allocation system<br>
should be alleviated. First, Copland will reduce (though not entirely eliminate) the<br>
need for the user to configure and reconfigure the application's memory partition to<br>
accommodate changing needs. Also, problems with applications fragmenting the<br>
available memory for launching more applications should be eliminated. Thus, no<br>
longer will users always have to deal with the complex issues of memory allocation and<br>
organization to make best use of their machines.
</p>
<p>
In addition to swapping space, Copland will support memory-mapped files. This<br>
technology allows an application to map a file against an area of address space;<br>
accessing locations in the address space causes the appropriate portions of the file to<br>
be read into RAM. In system software version 7.1.2, this technology is used by the<br>
system for paging PowerPC code when virtual memory is on, but it's not available to<br>
applications. In Copland, it will be available to applications; data files can be mapped<br>
for read-only or read/write access. An application will be able to read a document just<br>
by walking through the address space without having to manually stream it into<br>
buffers.
</p>
<p>
To be prepared for Copland's use of virtual memory, applications today should be able<br>
to operate well in a virtual memory environment. For purposes of performance, this<br>
means keeping a tight locality of reference; code that uses contiguous data structures<br>
rather than structures spread all over memory will require fewer pages to be resident<br>
for any operation. Also, take care when allocating variable-sized buffers. Don't always<br>
attempt to allocate the largest possible buffer, sizing it down till it fits -- a popular<br>
but potentially wasteful habit; instead, cap buffers at points beyond which they won't<br>
gain from more RAM. For example, if reading a file, you might cap the size of a data<br>
buffer at 64K, because there's little to gain by reading the file in larger chunks.
</p>
<p>
<b>INTERRUPT CONTROL</b>
</p>
<p>
On Power Macintosh computers running System 7.5, interrupts are handled by the<br>
680x0 instruction emulator, incurring a large overhead. Even if the overhead of the<br>
actual interrupt handler is small, a significant price is paid in invoking the emulator,<br>
especially if a mostly native application is executing (in which case the emulator has<br>
to be pulled into the cache on each interrupt, then flushed out as native code is reloaded<br>
after the interrupt returns). Since a Macintosh can easily take several hundred<br>
interrupts per second (thanks to interrupts caused by video retrace, the old-style VBL<br>
Manager, ADB, and the like), this can have a significant performance impact.
</p>
<p>
&nbsp;&nbsp;By contrast, Copland's I/O system, including interrupt handlers, is entirely native;<br>
this, along with an improved architecture, should mean significantly lower interrupt<br>
latency and better overall performance. Because of the flexibility of the execution<br>
control available to the kernel, it will be easy for an interrupt handler to do the<br>
absolute minimum to deal with an interrupt (often all that's required is to<br>
acknowledge it). After control is returned from the interrupt, another piece of code<br>
called a secondary interrupt handler can be invoked; although under the same<br>
constraints as a hardware interrupt handler, this handler results in the best system<br>
performance by enabling the soonest possible exit from the hardware handler. If<br>
significant processing needs to be done right away, this secondary handler can wake a<br>
high-priority task to do that work, thus keeping the system from being bottlenecked<br>
by any individual set of handlers.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Some native interrupt functionality</b> will be delivered before Copland;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;see the article "Creating PCI Device Drivers" in this issue of develop for more<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;information.
</p>
<p>
<b>SYNCHRONIZATION AND INTERTASK MESSAGING</b>
</p>
<p>
As mentioned earlier, applications under Copland will be able to create tasks that are<br>
preemptively scheduled. You'll be able to assign priorities to your preemptive tasks,<br>
but this in itself won't prevent the tasks from preempting each other at inopportune<br>
times. What you'll need in order to ensure correct behavior from your tasks is a<br>
mechanism to synchronize access to shared resources.
</p>
<p>
&nbsp;&nbsp;Copland provides several synchronization mechanisms, each useful in a different<br>
situation. Any operating systems textbook includes a variety of them, and most can be<br>
implemented in combination with others. The ones implemented in Copland -- atomic<br>
operations, simple locks (mutual exclusions, or mutexes), read/write locks, event<br>
flags, and event queues -- are meant to efficiently solve problems common in<br>
Macintosh applications and the Mac OS and to provide building blocks to implement<br>
other synchronization mechanisms if necessary.
</p>
<p>
The kernel also has an intertask message system that provides data transfer as well as<br>
synchronization, although for basic synchronization of shared data it's probably more<br>
than you'll need. It can move arbitrary amounts of data across address spaces<br>
synchronously or asynchronously, by value or by reference. In cases in which the<br>
system uses messages to implement functionality, the message will be hidden inside an<br>
API library, so you generally won't have to deal with the details of how the message<br>
system works.
</p>
<h2>THE RUNTIME MODEL</h2>
<p>
Copland's runtime model is based on the Code Fragment Manager (CFM). Instead of a<br>
monolithic binary file, the operating system consists of a number of individual<br>
libraries that combine to provide the API and system functionality. This mechanism<br>
allows software to be built in a much more modular fashion. In addition, the CFM<br>
provides a much more consistent context and activation model than does the statically<br>
linked, trap-dispatched runtime model used in 680x0-based computers. Rather than<br>
having to be concerned with setting up and restoring the A5 register to provide access<br>
to data when executing in an interrupt task, the CFM provides a standardized transition<br>
to make sure the data appropriate to the executing code is always available.
</p>
<p>
Although applications under Copland will continue to be cooperatively scheduled within<br>
a single address space, developers can, as already mentioned, use kernel services to<br>
create tasks that take advantage of preemptive multitasking and protected memory.<br>
Tasks running in address spaces outside the Toolbox will have a limited number of<br>
services available to them, similar to those available to background-only applications<br>
in System 7: they'll be able to allocate memory, communicate with other processes,<br>
and use the kernel services, the file system, and the network, but they won't be able to<br>
draw on the screen or interact directly with the user. Tasks that are I/O or<br>
computation intensive running in separate address spaces will get the benefits of<br>
preemptive multitasking, and protected memory will separate these tasks from<br>
applications, providing an increased level of stability and reliability.
</p>
<p>
For example, Copland will include an implementation of the personal file sharing<br>
server that runs in a separate address space. This allows the server -- which takes<br>
networking traffic and converts it to file system calls, serving files from the local<br>
drive to remote clients -- to share the system with the user and foreground processes<br>
as efficiently as possible. It will use concurrent I/O to interleave its requests with<br>
those of foreground processes, and it will get compute time at any moment when the<br>
processor is otherwise idle, even if the foreground process is waiting for a page fault<br>
to be completed.
</p>
<p>
Figure 1 illustrates Copland's architecture, showing the separation between the<br>
Toolbox environment, other tasks, and the operating system. Core portions of the<br>
operating system such as the kernel and the file system run in an address space that's<br>
protected from the Toolbox environment and other processes; similarly, the Toolbox<br>
environment is protected from other applications running in their own address spaces.<br>
Each of these areas, including the kernel and other services, can have one or several<br>
threads of execution; the kernel preemptively switches between them. Some services,<br>
such as the file system, can have several active threads of control, each responsible<br>
for a single outstanding file system request. All applications running in the Toolbox<br>
environment, including the Finder, run as a single task, inside a single address space.<br>
However, Copland-aware applications can use preemptive threads to best handle CPU-<br>
and I/O-intensive tasks.
</p>
<p>
<img src="img/176.gif" width="600 px"></img>
</p>
<p>
<b>Figure 1.</b> The Copland architecture
</p>
<p>
With the new runtime model will come a number of new ways to monitor and modify<br>
system operations without patching, which is clunky and difficult to maintain.<br>
Currently, extensions have no formal presence in the system; they live in the cracks<br>
between the system and applications. By providing a better-defined environment for<br>
extensions, Copland will make them easier to write and more stable. For example,<br>
extensions currently must patch the file system -- or use the inefficient alternative<br>
of polling -- if they need to track file usage; the new File Manager will let software<br>
install notification procedures that can be called whenever a particular event, such as<br>
creating or renaming a file, occurs. Patching will still be available; a new Patch<br>
Manager will allow software to patch CFM entry points and will give much more<br>
control over the installation and removal of patches, including where they fall in the<br>
chain of execution.
</p>
<p>
To run under Copland, extensions you've developed will need to be revised. You'll make<br>
the transition easier for users if your applications that ship with extensions are able<br>
to run without these extensions installed. Also, desk accessories will no longer be<br>
supported in Copland; if you depend on any desk accessories, you should rewrite them<br>
as small applications.
</p>
<h2>THE FILE MANAGER</h2>
<p>
When the Macintosh was first introduced, it had a flat file system that was appropriate<br>
only for floppy disks. Since then, a number of advances have been made, including the<br>
introduction of the hierarchical file system (HFS) in 1986. But the System 7 File<br>
Manager has these limitations:
</p>
<ul>
<li>The File Manager implementation is closely tied to the HFS volume<br>
format, making it difficult to support other volume formats.</li>
<li>As HFS volumes grow in size, they become less efficient due to<br>
HFS's limitation of 216 (65536) allocation blocks, making it difficult to<br>
extend the HFS volume format.</li>
<li>The File Manager can process only one operation at a time,<br>
restricting performance when several tasks are contending for file I/O.</li>
<li>The File Manager is implemented entirely in 680x0 assembly<br>
code, limiting performance on the Power Macintosh platform.</li>
</ul>
<p>
Copland will introduce a new File Manager that addresses these limitations, directly or<br>
indirectly. For instance, the new File Manager has been divorced from HFS<br>
implementation details and thus imposes no limitations on volume formats; arbitrary<br>
volume formats can be developed and plugged in. This will allow the Macintosh to<br>
properly support any file system, including ones that feature larger volumes, more<br>
files, or larger files than the HFS disk format. It will even be possible to create<br>
components that provide access to distributed network file systems or other data<br>
stores that don't easily map onto the HFS block storage model. In fact, HFS itself will<br>
be implemented as one of these plug-in modules.
</p>
<p>
The new File Manager will also support concurrent data transfer, so that several file<br>
system requests can be in progress at any one time. This will dramatically increase<br>
throughput in a number of cases. For example, copying files from a fast file server to<br>
a hard drive now involves an entirely serialized read over the network followed by a<br>
write to the hard drive; in Copland, the read and write operations can be overlapped,<br>
so the copy can be completed in as little as half the time. Throughput will even be<br>
increased in cases where two accesses share a communications channel, such as<br>
transfers involving several devices on the local SCSI bus or several file servers,<br>
because most communications channels won't be filled by a single device. A significant<br>
portion of the time it takes to read or write data to a SCSI disk is spent waiting for the<br>
disk, not actually transferring data; in the new model, that time can be used to<br>
transfer data to or from a different device.
</p>
<p>
Another real enhancement to the file system is the introduction of a new API, designed<br>
to be easy to learn and use. A new API was necessary because the new file system<br>
supports files and volumes larger than 231 bytes, meaning that more than 32 bits are<br>
needed to store various values. The System 7 File Manager API has already been<br>
through several stages of evolution, from the original file system calls through the<br>
HFS calls to the calls taking FSSpecs in System 7; the new API is in lieu of reworking<br>
it one more time. In addition, the HFS API is composed of a number of calls that take<br>
huge parameter blocks where it isn't obvious which fields need to be set to what at any<br>
moment; wherever possible in the new API, parameter blocks have few fields and can<br>
easily be reused.
</p>
<h2>THE I/O ARCHITECTURE</h2>
<p>
With Copland comes a new I/O architecture designed with the following objectives in<br>
mind:
</p>
<ul>
<li>improved performance</li>
<li> ability to support concurrent data transfer</li>
<li>sufficient abstraction to enable Apple to license the Mac OS to<br>
manufacturers who build a variety of hardware configurations</li>
<li>increased ease of configuration</li>
<li>independence from the 68000 microprocessor and its runtime<br>
model</li>
</ul>
<p>
The I/O architecture is organized around a number of services, each of which can be<br>
associated with a set of drivers in a unit known as a family. For example, the SCSI<br>
Manager can be associated with a number of SCSI interface modules (SIMs), each of<br>
which describes a single SCSI bus. Similarly, each of the drivers in the block storage<br>
family can provide block storage functionality to a file system agent. Drivers in the<br>
volume format family (through the File Manager) will manage a number of volume<br>
format agents, including the HFS agent.
</p>
<p>
Thus, the I/O architecture is structured in a hierarchy of layered components, which<br>
pass control and data among themselves. For example, an application might make a file<br>
system call, which would be passed to the HFS file system agent, which would then<br>
make a request of the appropriate block device driver. That driver could then use the<br>
SCSI Manager to transfer data to a SIM, over a SCSI bus, to a specific SCSI device. This<br>
modularity means that other data flows are easily constructed. For example, the file<br>
system request might be passed to an AFP file system agent, which would result in data<br>
being transferred over the network using Open Transport. (AFP stands for AppleTalk<br>
Filing Protocol -- the protocol used to talk to AppleShare file servers.) These<br>
relationships are diagrammed in Figure 2.
</p>
<p>
<img src="img/177.gif" width="600 px"></img>
</p>
<p>
<b>Figure 2. </b>An example of relationships and control flow in the new driver model
</p>
<p>
This layered architecture permits a flexible dependency chain, where no component<br>
has too much knowledge about the implementation details of its dependencies or its<br>
clients. A block storage driver, for instance, doesn't need to know the details of the<br>
SIM's SCSI bus implementation or which volume format it's being used for; it just<br>
passes requests up and down the chain. This modular architecture should make it<br>
easier for Apple and developers to introduce new ways of solving problems.
</p>
<p>
The driver model for PCI cards, described in this issue of <i>develop</i> in the article<br>
"Creating PCI Device Drivers," was designed with this new I/O architecture in mind.<br>
Copland will support drivers developed for PCI cards in accordance with the guidelines<br>
presented in that article, so you would do well to familiarize yourself with them. Old<br>
drivers will need to be revised because they read and write to hardware locations<br>
directly; protection in the new kernel requires that this ability be reserved to<br>
specially privileged software. But this doesn't mean that everything packaged into<br>
Device Manager drivers will break. The Device Manager will continue to support code<br>
packaged as a driver that doesn't actually touch hardware and that isn't otherwise<br>
incompatible with Copland, such as drivers that some programs use for<br>
interapplication communication.
</p>
<p>
Note also that Open Transport, which is now available for development on System 7.5,<br>
will be the native networking protocol in Copland. Applications that use it will make<br>
best use of the native networking stack and will be prepared to run in a separate<br>
address space.
</p>
<h2>WHERE DOES THIS LEAVE YOU?</h2>
<p>
The transition to Copland will be the most significant operating system transition in<br>
the history of the Macintosh. You can make this transition easier for yourself and<br>
users if you do these things:
</p>
<ul>
<li>Begin factoring your applications now.</li>
<li>Make sure your applications can operate well in a virtual memory<br>
environment.</li>
<li>Avoid reading or modifying low-memory globals and system data<br>
structures if at all possible in your applications.</li>
<li>Avoid patching.</li>
<li>Ensure that any of your applications that ship with extensions can<br>
run without these extensions installed.</li>
<li>Rewrite as small applications any desk accessories you depend on.</li>
<li>Familiarize yourself with the new driver model for PCI cards.</li>
<li>Make use of Open Transport for networking.</li>
</ul>
<p>
With its vastly expanded functionality, Copland will offer an unprecedented number of<br>
new opportunities for developers. In providing a stronger foundation for third-party<br>
products and future Mac OS releases, Copland will lay the groundwork for years of<br>
advances on the Macintosh platform.
</p>
<p>
<b>TIM DIERKS, </b>who is known for having the messiest office on the Apple R&amp;D campus,<br>
has been bumming around Apple for several years, including stints working with the<br>
Macintosh Developer Technical Support group as well as on the Copland project.<br>
Currently, he's hard at work on Apple's interactive television solution, which gives<br>
him an excuse for watching Rocco's Modern Life at work. He shares his office with two<br>
lizards, a corn snake, and a pinball machine -- which helps explain at least some of<br>
the mess.
</p>
<p>
Thanks to our technical reviewers Jeff Cobb, Dave Evans, John Iarocci, Wayne<br>
Meretsky, Mike Neil, Steve Szymanski, and Russell Williams. Special thanks to<br>
Russell Williams for information on synchronization services for preemptively<br>
scheduled tasks.
</p>
</body>
</html>
