<!DOCTYPE html>
<html>
<head>
<!-- Article ID: 3 - Extracted from develop-1997 -->
<!-- on 2025-03-30 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by the copyright of its respective owners -->
<title>March 97 - Gearing Up for Asia With the Text Services Manager and TSMTE</title>
<link href="../common/styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h1>Gearing Up for Asia With the Text Services<br>
Manager and TSMTE</h1>
<h2>Tague Griffith</h2>
<p>
<img src="img/129.gif" width="198 px"></img>
</p>
<p>
<i style="font-size:125%;">Are you eyeing Asian markets for your application? If so, the</i>
<br>

<i style="font-size:125%;">smartest thing you can do to gear up is to enlist the aid of the Text</i>
<br>

<i style="font-size:125%;">Services Manager (TSM), introduced with System 7.1 to help</i>
<br>

<i style="font-size:125%;">applications communicate with utilities that provide text</i>
<br>

<i style="font-size:125%;">services. Making your application TSM-aware, an easy matter if</i>
<br>

<i style="font-size:125%;">you're using TextEdit and TSMTE, will enable it to use the services</i>
<br>

<i style="font-size:125%;">of utilities designed to handle text input in Chinese, Japanese, and</i>
<br>

<i style="font-size:125%;">Korean. Your application will also be poised to take advantage of</i>
<br>

<i style="font-size:125%;">the wide variety of text services that eventually will be supported</i>
<br>

<i style="font-size:125%;">by the Text Services Manager.</i>
</p>
<p>
Localizing your application for Asian markets, or for Asian language-speaking<br>
customers in the United States, may seem like a daunting task to you, but take heart:<br>
the Text Services Manager (TSM) makes one aspect of localization, handling keyboard<br>
input, easier than you might imagine. Part of the WorldScript technology in the<br>
Macintosh Toolbox, the Text Services Manager enables applications and text service<br>
utilities to communicate without knowing anything about each other's internal<br>
structures or identities. When you make your application TSM-aware, you make it<br>
possible for your Asian language-speaking customers to use your application in<br>
concert with a utility program that does the necessary conversion of keyboard input.
</p>
<p>
This article shows you how to modify your TextEdit-based application to make it<br>
TSM-aware -- that is, so that it makes the appropriate calls to the Text Services<br>
Manager. It doesn't take a lot of modifications, as you'll see from the sample<br>
application (called InlineInputSample) that accompanies this article on this issue's CD<br>
and <i>develop</i>'s Web site. Our application uses TSMTE, an extension that's shipped with<br>
the system), which extends TextEdit to handle the details of TSM awareness with<br>
minimal effort on the part of application writers. Using TSMTE should be sufficient<br>
for most applications; however, for intensive text-processing applications or<br>
applications using a different text-editing engine, you may need to handle all TSM<br>
processing yourself.
</p>
<p>
Before we look at the changes you need to make to your application to make it<br>
TSM-aware, I'll briefly explain how keyboard input works for Chinese, Japanese, and<br>
Korean. If you'd like to read more about common problems of localization, see "Writing<br>
Localizable Applications" in <i>develop</i> Issue 14. For details on the Text Services<br>
Manager, consult Chapter 7 of <i>Inside Macintosh: Text</i>.
</p>
<h2>ASIAN LANGUAGES AND KEYBOARD INPUT</h2>
<p>
As you can guess, supporting keyboard input for Asian languages isn't the same as<br>
handling English, because they're written in different scripts. A <i>script</i> is a writing<br>
system that can be used to represent one or more human languages.
</p>
<p>
&nbsp;&nbsp;English and other European languages are written in the Roman script, which is an<br>
<i>alphabetic</i> script. In alphabetic scripts, the various characters of the script are<br>
combined in different ways to form words. Alphabetic scripts have a small repertoire<br>
of characters compared to other types of writing systems. It's a simple matter to<br>
represent all the characters in an alphabetic script on a keyboard. Because there are<br>
fewer than 256 characters in such scripts, it takes only one byte to uniquely identify<br>
each character, so these scripts are known as <i>1-byte scripts</i>.
</p>
<p>
Asian languages are quite different, being written in scripts that include ideographic<br>
characters borrowed from ancient China. An <i>ideograph</i> is a symbolic character that<br>
usually represents a single concept, action, or thing. Figure 1 shows some examples of<br>
Japanese and simplified Chinese ideographs. Because each character represents a<br>
single concept, there are -- by necessity -- many, many more characters than in the<br>
Roman script. Most literate Chinese speakers know around 5000 ideographs, and a<br>
literate Japanese knows around 3000 ideographs. Two bytes are required to uniquely<br>
identify each character in an ideographic script, and thus these scripts are known as<br>
<i>2-byte scripts</i>. Chinese, Japanese, and Korean also incorporate alternative script<br>
systems based on syllabic or phonetic characters (characters that represent certain<br>
sounds).
</p>
<p>
<img src="img/130.gif" width="576 px"></img>
</p>
<p>
<b>Figure 1.</b> Some Japanese and Chinese ideographs and their English translations
</p>
<p>
<b>INPUT METHODS</b>
</p>
<p>
How is it possible for users of 2-byte script systems to get by with a standard<br>
Macintosh keyboard? Obviously, they can't simply press the key corresponding to the<br>
one character they want out of 3000 or 5000 characters. Enter the text service<br>
utility known as an <i>input method</i> or a <i>front-end processor (FEP)</i>. An input method<br>
allows users to type phonetic or syllabic characters on a standard keyboard and<br>
automatically converts what they type into ideographic representations.
</p>
<p>
For Chinese speakers, the appropriate input method converts keyboard input from<br>
Pinyin (Roman) or Zhuyinfuhao (phonetic, also known colloquially as Bopomofo) to<br>
ideographic Hanzi. For Japanese speakers, the input method converts input from<br>
phonetic Katakana or Hiragana into ideographic Kanji, as illustrated by the example in<br>
Figure 2. The input method for Korean speakers converts phonetic Jamo into<br>
nonideographic Hangul (complex clusters of Jamo).
</p>
<p>
<img src="img/131.gif" width="432 px"></img>
</p>
<p>
<b>Figure 2.</b> The same sentence as entered in Hiragana and as converted to Kanji
</p>
<p>
Apple currently ships four 2-byte keyboard input methods: Kotoeri (Japanese),<br>
Power Input Method (Korean), Traditional Chinese (as used in Taiwan), and<br>
Simplified Chinese (as used in the People's Republic of China). The same input<br>
methods are shipped with the Apple Language Kits, and third-party input methods are<br>
also available.
</p>
<p>
Regardless of the language, all input methods have a similar user interface. When<br>
more than one script is installed on the Mac OS, as is the case for localized systems<br>
since all systems have the Roman script installed, the Keyboard menu becomes<br>
available in the menu bar. Each available keyboard layout and input method is listed in<br>
the Keyboard menu; the icon for the active keyboard layout or input method appears as<br>
the menu's title in the menu bar. Figure 3 shows a Keyboard menu displaying items for<br>
Apple's Simplified Chinese and Kotoeri (Japanese) input methods, as well as keyboard<br>
layouts from some other script systems. The Simplified Chinese input method is<br>
active; it's checked in the menu and its icon appears highlighted in the menu bar. The<br>
pencil icon in the menu bar is displayed only when an input method is active (in other<br>
words, not when the user is typing in English or another language that doesn't require<br>
an input method); it's the title for the menu belonging to that input method. Some input<br>
methods use a different icon, but it appears in the same place as the pencil icon.
</p>
<p>
<img src="img/132.gif" width="375 px"></img>
</p>
<p>
<b>Figure 3.</b> Input method icons in the Keyboard menu and the menu bar
</p>
<p>
<b>BOTTOMLINE VS. INLINE INPUT</b>
</p>
<p>
When the user begins typing, the raw text appears on the screen as entered, either in a<br>
<i>floating input window</i> that's usually displayed in the lower portion of the screen or in<br>
the application window where the text is intended to appear. The first style of text<br>
entry is known as <i>bottomline input</i>, while the second is called <i>inline input</i> (see Figure<br>
4). Applications that aren't TSM-aware can make indirect use of the Text Services<br>
Manager's floating window service to enable bottomline input (as explained on page<br>
7-13 of <i>Inside Macintosh: Text</i>), but users generally prefer inline input, which only<br>
TSM-aware applications can offer. TSM-aware applications can also offer bottomline<br>
input, which users may prefer if the size of the text displayed in the document makes<br>
reading the characters difficult.
</p>
<p>
<img src="img/133.gif" width="423 px"></img>
</p>
<p>
Bottomline input
</p>
<p>
<img src="img/134.gif" width="359 px"></img>
</p>
<p>
Inline input
</p>
<p>
<b>Figure 4.</b> Bottomline vs. inline input
</p>
<p>
In the case of inline input, the just-entered text appears in what is known as the<br>
<i>active input area</i> or <i>inline hole</i>. Text in the active input area or the floating input<br>
window is underlined in gray or highlighted in some other manner, depending on the<br>
application.
</p>
<p>
With either bottomline or inline input, the raw text is converted from its phonetic or<br>
syllabic representation to ideographic or complex syllabic characters, and the gray<br>
underline (if there is one) turns to black or changes in some other manner determined<br>
by the application, when the user gives a signal such as pressing the space bar after<br>
entering a sequence of characters. There may be more than one possible reading of a<br>
given character sequence, in which case the input method will display a list of<br>
candidates in a <i>candidate window</i>, as shown in Figure 5. When the user selects one of<br>
the candidate readings, the raw text is converted.
</p>
<p>
<img src="img/135.gif" width="515 px"></img>
</p>
<p>
<b>Figure 5.</b> Selecting a conversion option for inline input in a candidate window
</p>
<p>
The user then confirms the converted text, generally by pressing Return. (In Korean,<br>
conversion happens continuously and automatically, and the text is confirmed when the<br>
user presses either Return or the space bar.) In the case of bottomline input, the<br>
confirmed text is flushed from the input window and sent to the application as<br>
key-down events. For inline input, the confirmed text is copied into the application's<br>
text buffer (as shown in Figure 5) and the active input area is closed. When the user<br>
begins typing again, the underline beneath the confirmed text disappears entirely and a<br>
new active input area opens.
</p>
<p>
Before you start feeling overwhelmed by all this, realize that most of the user<br>
interface elements I've just described are handled by the input method or TSMTE and<br>
not your application. The input method takes all the keystrokes and processes them;<br>
your application simply draws the input method's text buffer in the application<br>
window. All you need to do to get the benefit of this kind of text service is to make a few<br>
modifications to your application. Once your application is TSM-aware, you can work<br>
with any input method regardless of language and thus offer your Asian<br>
language-speaking customers the convenience of inline input.
</p>
<h2>MAKING YOUR APPLICATION TSM-AWARE</h2>
<p>
Making your application TSM-aware is a matter of adding calls to send information to<br>
input methods by way of the Text Services Manager. Most of the popular text-editing<br>
engines for the Mac OS other than TextEdit are already TSM-aware. One of these,<br>
WASTE (the WorldScript-Aware Styled Text Engine, developed by Marco Piovanelli),<br>
makes all but four of the necessary calls: InitTSMAwareApplication,<br>
CloseTSMAwareApplication, TSMEvent, and SetTSMCursor. These calls need to be made<br>
by the application. Optionally, a WASTE-based application can install pre- and<br>
post-TSM-update callback routines. If you use WASTE for your text-editing engine,<br>
most of the techniques described in this section apply. The WASTE source code is<br>
available online at many popular Macintosh ftp sites; I highly recommend looking at it<br>
for examples of how to handle the TSM protocol directly.
</p>
<p>
Using TSMTE, as our application InlineInputSample does, you can make your<br>
TextEdit-based application TSM-aware with a few modifications to your<br>
event-handling, cursor-handling, window, and menu code. Most of the changes are<br>
quite simple and limited to particular subroutines of the application, as demonstrated<br>
by InlineInputSample. Our application is a version of TESample, a program written by<br>
Apple's Developer Technical Support group and provided with many development<br>
environments as part of the example code (it's also on this issue's CD). The code that<br>
makes our version of the program TSM-aware is conditionalized with qInline<br>
conditionals so that you can easily pick it out. You might want to take a look at that code<br>
as you read this section.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>To see the full capabilities</b> of the InlineInputSample application, you<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;need a Macintosh with System 7.1 or later localized for Chinese, Japanese, or<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Korean, or with one or more of the Asian language kits installed.*
</p>
<p>
<b>TESTING FOR THE TEXT SERVICES MANAGER AND TSMTE</b>
</p>
<p>
Before using the Text Services Manager and TSMTE, we need to check and see if they're<br>
available. The Text Services Manager is available on all versions of the system after<br>
7.1. However, TSMTE ships only with localized versions of the system and with the<br>
Apple Language Kits for Chinese, Japanese, and Korean. The support for inline input<br>
discussed in this article will be active only while you're using one of these languages.<br>
Listing 1 shows the code we use to check for availability of the Text Services Manager<br>
and TSMTE. If we were writing our own protocol handlers, we would eliminate the<br>
gestaltTSMTEAttr test.
</p>
<p>
______________________________
</p>
<p>
<b>Listing 1.</b> Testing for TSM and TSMTE availability
</p>
<p>
<code>static void CheckForTextServices(void)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;long&nbsp;&nbsp;gestaltResponse;</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;gHasTextServices = false;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// unless proven otherwise</code><br>
<code>&nbsp;&nbsp;&nbsp;gHasTSMTE = false;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// unless proven otherwise</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;if (TrapAvailable(_Gestalt)) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((Gestalt(gestaltTSMgrVersion, &amp;gestaltResponse) == noErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; (gestaltResponse &gt;= 1)) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gHasTextServices = true;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Gestalt(gestaltTSMTEAttr, &amp;gestaltResponse) == noErr)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gHasTSMTE = BTst(gestaltResponse, gestaltTSMTEPresent);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code>&nbsp;&nbsp;&nbsp;}</code><br>
<code>}</code>
</p>
<p class="spacer">&nbsp;</p>
<p>
______________________________
</p>
<p>
The selector gestaltTSMgrVersion returns the version number of the Text Services<br>
Manager if it's installed. You should test to make sure that the version is greater than<br>
or equal to 1, the current version of the Text Services Manager. This will allow your<br>
application to work with future TSM versions as well.
</p>
<p>
<b>INITIALIZING THE APPLICATION</b>
</p>
<p>
Once we've established that the Text Services Manager and TSMTE are available, we<br>
need to extend our Toolbox initialization sequence to initialize the Text Services<br>
Manager. This is done by calling InitTSMAwareApplication. We also want to store the<br>
current state of the Script Manager's smFontForce variable (the font force flag) and<br>
set it to false while our application is running. This flag ensures the correct<br>
text-handling behavior in applications that don't use the Script Manager. Since we're<br>
using the Script Manager to support text in different languages, we should turn this<br>
off, as shown in Listing 2.
</p>
<p>
______________________________
</p>
<p>
<b>Listing 2.</b> Initializing as a TSM-aware application
</p>
<p>
<code>if (!(gHasTSMTE &amp;&amp; InitTSMAwareApplication() == noErr)) {</code><br>
<code>&nbsp;&nbsp;&nbsp;// If this happens, just move on without text services.</code><br>
<code>&nbsp;&nbsp;&nbsp;gHasTextServices = false;</code><br>
<code>&nbsp;&nbsp;&nbsp;gHasTSMTE = false;</code><br>
<code>}</code><br>
<code>// Get global font force flag; make sure it's off whenever we run.</code><br>
<code>// Do this even if text services don't exist.</code><br>
<code>gSavedFontForce = GetScriptManagerVariable(smFontForce);</code><br>
<code>(void) SetScriptManagerVariable(smFontForce, 0);</code>
</p>
<p class="spacer">&nbsp;</p>
<p>
______________________________
</p>
<p>
Of course, since we do this work at initialization, we need to clean up when our<br>
application quits. In our termination routine, we restore the value of the font force<br>
flag and call CloseTSMAwareApplication. The font force flag also needs to be restored<br>
anytime control passes from the application to the system when we're dealing with<br>
fonts and such; it particularly should be restored in the case of a suspend event.
</p>
<p>
<b>EXTENDING THE DOCUMENT STRUCTURE</b>
</p>
<p>
Now we need to extend our document record to store the additional data structures<br>
related to TSM awareness. Our application's original DocumentRecord data structure is<br>
extended to include two additional fields, as follows:
</p>
<p>
<code>typedef struct {</code><br>
<code>&nbsp;&nbsp;&nbsp;WindowRecord&nbsp;&nbsp;&nbsp;docWindow;</code><br>
<code>&nbsp;&nbsp;&nbsp;TEHandle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;docTE;</code><br>
<code>&nbsp;&nbsp;&nbsp;ControlHandle&nbsp;&nbsp;docVScroll;</code><br>
<code>&nbsp;&nbsp;&nbsp;ControlHandle&nbsp;&nbsp;docHScroll;</code><br>
<code>&nbsp;&nbsp;&nbsp;TEClickLoopUPP docClick;</code><br>
<code>&nbsp;&nbsp;&nbsp;Boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modified;</code><br>
<code>&nbsp;&nbsp;&nbsp;TSMTERecHandle docTSMTERecHandle;&nbsp;&nbsp;&nbsp;// added</code><br>
<code>&nbsp;&nbsp;&nbsp;TSMDocumentID&nbsp;&nbsp;docTSMDoc;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// added</code><br>
<code>} DocumentRecord, *DocumentPeek;</code>
</p>
<p class="spacer">&nbsp;</p>
<p>
The TSMTERecHandle is used by TSMTE to maintain the data it uses. The<br>
TSMDocumentID identifies a TSM <i>document</i>, which is an opaque data structure used by<br>
the Text Services Manager to maintain the current status of the input methods in use.<br>
Generally, one TSM document (defined by the TSMDocument data type) is allocated per<br>
application window, but some applications may allocate a single global TSM document.<br>
Since the TSM document maintains context/state information about the current input<br>
method, you should customize allocation of the TSM document for your application's<br>
text-handling behavior.
</p>
<p>
Each TSM document also maintains a reference constant, which can be set by the<br>
application. Applications using TSMTE must stuff the TSMTERecHandle into the refCon;<br>
if you're creating your own handlers, the refCon can be customized to suit the needs of<br>
your application.
</p>
<p>
<b>CREATING AND DELETING A TSM DOCUMENT</b>
</p>
<p>
When creating a user document, we need to set up the TSM document and the<br>
TSMTERecHandle correctly, as illustrated in Listing 3. We pass four parameters to<br>
NewTSMDocument. The first parameter indicates the version of the TSM protocol that<br>
we're using; currently, the only defined protocol version is 1. The next parameter,<br>
supportedInterfaces, is an array of OSTypes that the Text Services Manager uses to<br>
find components that support the service the client is interested in. For our<br>
application, we set supportedInterfaces[0] to kTSMTEInterfaceType, indicating that<br>
we're using TSMTE support. Other applications providing full TSM support will want<br>
to set supportedInterfaces[0] to kTextService. Currently these are the only defined<br>
interface types. The final two parameters are a pointer to the TSMDocumentID storage<br>
and a pointer to our TSM refCon (in this case the TSMTERecHandle).
</p>
<p>
______________________________
</p>
<p>
<b>Listing 3.</b> Creating a TSM document
</p>
<p>
<code>if (good &amp;&amp; gHasTSMTE) {</code><br>
<code>&nbsp;&nbsp;&nbsp;supportedInterfaces[0] = kTSMTEInterfaceType;</code><br>
<code>&nbsp;&nbsp;&nbsp;if (NewTSMDocument(1, supportedInterfaces, &amp;doc-&gt;docTSMDoc,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(long) &amp;doc-&gt;docTSMTERecHandle) == noErr) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TSMTERecPtr tsmteRecPtr = *(doc-&gt;docTSMTERecHandle);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsmteRecPtr-&gt;textH = doc-&gt;docTE;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsmteRecPtr-&gt;preUpdateProc = gTSMTEPreUpdateUPP;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsmteRecPtr-&gt;postUpdateProc = gTSMTEPostUpdateUPP;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsmteRecPtr-&gt;updateFlag = kTSMTEAutoScroll;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsmteRecPtr-&gt;refCon = (long) window;</code><br>
<code>&nbsp;&nbsp;&nbsp;}</code><br>
<code>&nbsp;&nbsp;&nbsp;else</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;good = false;</code><br>
<code>}</code>
</p>
<p>
______________________________
</p>
<p>
Once we've allocated the TSM document, we need to set up the TSMTERecHandle. We set<br>
the TextEdit record for the handle and install UniversalProcPtrs for the pre- and<br>
post-update handlers. These handlers are called before and after TSMTE handles the<br>
update event. The pre-update handler in our sample application works around a bug in<br>
TSMTE version 1.0, and the post-update handler adjusts the scroll bar to bring the<br>
new text into view. We also set the updateFlag and the refCon.
</p>
<p>
Obviously, since we allocate certain structures when we create our TSM document, we<br>
need to deallocate those structures before we destroy the TSM document (that is, when<br>
we close the window). Listing 4 shows how to handle deleting a TSM document.
</p>
<p>
______________________________
</p>
<p>
<b>Listing 4.</b> Deleting a TSM document
</p>
<p>
<code>if (theDocument-&gt;docTSMDoc != nil) {</code><br>
<code>&nbsp;&nbsp;&nbsp;(void) FixTSMDocument(theDocument-&gt;docTSMDoc);</code><br>
<code>&nbsp;&nbsp;&nbsp;// DeleteTSMDocument might cause a crash if we don't deactivate</code><br>
<code>&nbsp;&nbsp;&nbsp;// first, so...</code><br>
<code>&nbsp;&nbsp;&nbsp;(void) DeactivateTSMDocument(theDocument-&gt;docTSMDoc);</code><br>
<code>&nbsp;&nbsp;&nbsp;(void) DeleteTSMDocument(theDocument-&gt;docTSMDoc);</code><br>
<code>}</code>
</p>
<p>
______________________________
</p>
<p>
The FixTSMDocument call causes the Text Services Manager to confirm the text in the<br>
active input area and enter it into the user document. In a real application you'd then<br>
give the user the opportunity to save the user document before deleting the TSM<br>
document and closing the window, but we skip that step here. After "fixing" the<br>
document, we call DeactivateTSMDocument and then DeleteTSMDocument. We need to<br>
deactivate the document before deleting it because in certain circumstances<br>
DeleteTSMDocument may crash if we call it on an active document.
</p>
<p>
<b>MODIFYING THE EVENT LOOP</b>
</p>
<p>
Making your application TSM-aware with TSMTE requires very little modification to<br>
your existing event loop code. First we need to give the Text Services Manager an<br>
opportunity to handle events that might actually be for an input method and not our<br>
application. This is accomplished by calling TSMEvent and passing in the EventRecord<br>
returned from either WaitNextEvent or GetNextEvent. In our sample application, we<br>
wrap the call to TSMEvent in the IntlTSMEvent subroutine, as shown in Listing 5, to<br>
work around a bug that could cause the port to be set to the wrong window. Listing 6<br>
shows how we modified the application's event loop to call TSMEvent before handling an<br>
event.
</p>
<p>
______________________________
</p>
<p>
<b>Listing 5.</b> The IntlTSMEvent subroutine
</p>
<p>
<code>static Boolean IntlTSMEvent(EventRecord *event)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oldFont;</code><br>
<code>&nbsp;&nbsp;&nbsp;ScriptCode&nbsp;&nbsp;&nbsp;keyboardScript;</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;// Make sure we have a port and it's not the Window Manager port.</code><br>
<code>&nbsp;&nbsp;&nbsp;if (qd.thePort != nil &amp;&amp; FrontWindow() != nil) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oldFont = qd.thePort-&gt;txFont;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyboardScript = GetScriptManagerVariable(smKeyScript);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (FontToScript(oldFont) != keyboardScript)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TextFont(GetScriptVariable(keyboardScript,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;smScriptAppFond));</code><br>
<code>&nbsp;&nbsp;&nbsp;}</code><br>
<code>&nbsp;&nbsp;&nbsp;return TSMEvent(event);</code><br>
<code>}</code>
</p>
<p>
______________________________
</p>
<p>
<b>Listing 6.</b> The application's event loop
</p>
<p>
<code>void EventLoop(void)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;RgnHandle&nbsp;&nbsp;&nbsp;cursorRgn;</code><br>
<code>&nbsp;&nbsp;&nbsp;Boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gotEvent, handledByTSM;</code><br>
<code>&nbsp;&nbsp;&nbsp;EventRecord event;</code><br>
<code>&nbsp;&nbsp;&nbsp;Point&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mouse;</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;cursorRgn = NewRgn();</code><br>
<code>&nbsp;&nbsp;&nbsp;while (!gQuitting) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Set global font force flag so other apps don't get confused.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void) SetScriptManagerVariable(smFontForce, gSavedFontForce);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (gHasWaitNextEvent) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GetGlobalMouse(&amp;mouse);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AdjustCursor(mouse, cursorRgn);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gotEvent = WaitNextEvent(everyEvent, &amp;event, GetSleep(),</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cursorRgn);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SystemTask();</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gotEvent = GetNextEvent(everyEvent, &amp;event);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Clear font force flag again so it doesn't upset our</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// operations.</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gSavedFontForce = GetScriptManagerVariable(smFontForce);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void) SetScriptManagerVariable(smFontForce, 0);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (gHasTextServices) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handledByTSM = IntlTSMEvent(&amp;event);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!handledByTSM &amp;&amp; gotEvent) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AdjustCursor(event.where, cursorRgn);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DoEvent(&amp;event);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DoIdle();</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (gotEvent) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AdjustCursor(event.where, cursorRgn);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DoEvent(&amp;event);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DoIdle();</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code>&nbsp;&nbsp;&nbsp;}</code><br>
<code>}</code>
</p>
<p>
______________________________
</p>
<p>
Next, input methods must be given a chance to handle mouse events for the pencil<br>
menu. Whenever the user presses the mouse button in the menu bar, we need to pass<br>
the menu selection to the Text Services Manager and see if it's a system menu before<br>
we try to handle it as an application menu. We modify the subroutine for handling<br>
mouse-down events as shown in Listing 7.
</p>
<p>
______________________________
</p>
<p>
<b>Listing 7.</b> Checking the menu selection in the mouse-down event handling
</p>
<p>
<code>case inMenuBar:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Process a mouse-down in menu bar (if any).</code><br>
<code>&nbsp;&nbsp;&nbsp;AdjustMenus();</code><br>
<code>&nbsp;&nbsp;&nbsp;menuResult = MenuSelect(event-&gt;where);</code><br>
<code>&nbsp;&nbsp;&nbsp;if (!(gHasTextServices &amp;&amp; TSMMenuSelect(menuResult)))</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DoMenuCommand(menuResult);</code><br>
<code>&nbsp;&nbsp;&nbsp;HiliteMenu(0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Needed even if TSM or Script Manager handles</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the menu.</code><br>
<code>&nbsp;&nbsp;&nbsp;break;</code>
</p>
<p>
______________________________
</p>
<p>
After calling our subroutine to adjust the menus so that the invalid items are dimmed,<br>
we pass the menu selection to the Text Services Manager. We call TSMMenuSelect with<br>
the menu result as a parameter. If the selection is in the pencil menu, the Text<br>
Services Manager will handle it for your application and return true; otherwise, it<br>
will return false and your application should handle the selection normally. Regardless<br>
of the results of TSMMenuSelect, your application needs to call HiliteMenu(0) to<br>
finish handling the selection.
</p>
<p>
The next step in handling a menu selection is to confirm the text in the active input<br>
area with a call to FixTSMDocument before performing the menu action. This is<br>
recommended in the current Macintosh Human Interface Guidelines. But this guideline<br>
is somewhat contested, so if you don't think it makes sense for your application, you<br>
might consider a more selective policy for automatically confirming inline input.<br>
Whatever you decide, remember to be consistent and try it out on real users.
</p>
<p>
Now that we've finished modifying our menu-handling code, we'll move on to modifying<br>
our window event handler, as shown in Listing 8. We need to make sure that the active<br>
TSM document is changed when necessary. Assuming that we're allocating one TSM<br>
document per user document or window, we also need to handle window activate and<br>
deactivate events differently. When we receive a deactivate event, we need to call<br>
DeactivateTSMDocument on the TSM document associated with that window. Similarly,<br>
we need to call ActivateTSMDocument when we receive an activate event for our<br>
window.
</p>
<p>
______________________________
</p>
<p>
<b>Listing 8.</b> Handling window events
</p>
<p>
<code>void DoActivate(WindowPtr window, Boolean becomingActive)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;RgnHandle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tempRgn, clipRgn;</code><br>
<code>&nbsp;&nbsp;&nbsp;Rect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;growRect;</code><br>
<code>&nbsp;&nbsp;&nbsp;DocumentPeek&nbsp;&nbsp;&nbsp;doc;</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;if (IsDocumentWindow(window)) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doc = (DocumentPeek) window;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (becomingActive) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;// TextEdit-handling code</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (doc-&gt;docTSMDoc != nil)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void) ActivateTSMDocument(doc-&gt;docTSMDoc);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (doc-&gt;docTSMDoc != nil)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void) DeactivateTSMDocument(doc-&gt;docTSMDoc);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;// TextEdit-handling code</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br>
<code>&nbsp;&nbsp;&nbsp;}</code><br>
<code>}</code>
</p>
<p>
______________________________
</p>
<p>
If you use your own scheme for allocating TSM documents, be sure to call<br>
ActivateTSMDocument and DeactivateTSMDocument when appropriate. If you don't<br>
activate TSM documents correctly, the system can get confused and revert to Roman, in<br>
which case the user may click on a run of 2-byte text and not get inline input. If<br>
you're debugging your program and this happens, check to see what the current<br>
keyboard script is by calling
</p>
<p>
<code>keyScript = GetScriptMgrVariable(keyScript);</code>
</p>
<p>
If the keyboard script is smRoman, the problem could be related to activating and<br>
deactivating TSM documents.
</p>
<p>
We finish up our event loop modifications by ensuring that our application handles<br>
mouse-moved events in a way that works with the Text Services Manager and input<br>
methods. Input methods need to track mouse-moved events within the content area of<br>
your application, because when the user moves the cursor over an active input area,<br>
the input method needs to change the cursor's shape. This is demonstrated in the first<br>
half of Listing 9. Before attempting to change the cursor's appearance, your<br>
application should call SetTSMCursor, which returns a Boolean indicating whether the<br>
input method has already changed the cursor's appearance.
</p>
<p>
______________________________
</p>
<p>
<b>Listing 9.</b> Allowing the input method to change the cursor
</p>
<p>
<code>// Before we commit to anything, let's check whether some text</code><br>
<code>// service has a different idea.</code><br>
<code>if (!(gHasTextServices &amp;&amp; SetTSMCursor(mouse))) {</code><br>
<code>&nbsp;&nbsp;&nbsp;// Change the cursor and the region parameter.</code><br>
<code>&nbsp;&nbsp;&nbsp;if (PtInRgn(mouse, iBeamRgn)) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetCursor(*GetCursor(iBeamCursor));</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CopyRgn(iBeamRgn, region);</code><br>
<code>&nbsp;&nbsp;&nbsp;}</code><br>
<code>&nbsp;&nbsp;&nbsp;else {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetCursor(&amp;qd.arrow);</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CopyRgn(arrowRgn, region);</code><br>
<code>&nbsp;&nbsp;&nbsp;}</code><br>
<code>}</code><br>
<code>// No matter how nice the region, with text services it can't be</code><br>
<code>// bigger than a point. Yes, this defeats the purpose of all the</code><br>
<code>// calculations.</code><br>
<code>if (gHasTextServices)</code><br>
<code>&nbsp;&nbsp;&nbsp;SetRectRgn(region, mouse.h, mouse.v, mouse.h, mouse.v);</code>
</p>
<p>
______________________________
</p>
<p>
Now we need to set up the correct mouseRgn parameter to WaitNextEvent. To work<br>
correctly with input methods, our application should create a mouseRgn that's no<br>
larger than a point, as shown in the second half of Listing 9. If we don't set up this<br>
region correctly, the input method may not be able to interact with our users as they<br>
would expect. Yes, being forced to use a point-sized region sort of defeats the purpose<br>
of a mouseRgn. We're working on extending the Text Services Manager so that you can<br>
obtain the region that the input method is interested in, but for now you'll just have to<br>
live with this limitation.
</p>
<p>
<b>ADDING FONT-KEYBOARD SYNCHRONIZATION</b>
</p>
<p>
Both TextEdit and WASTE automatically perform font-keyboard synchronization,<br>
meaning that they adjust the Keyboard menu so that the current keyboard layout or<br>
input method reflects the user's font selection. For instance, if the user selects Chicago<br>
or Courier (Roman fonts) from the Font menu, the application sets the current<br>
keyboard to a Roman keyboard layout (U.S., German, Italian, or whatever the default<br>
Roman keyboard is, according to the localizer). Similarly, if the user selects Osaka or<br>
HonMincho (Japanese fonts), the keyboard is<i>synchronized</i> with the font selection.
</p>
<p>
If you're not using TextEdit or WASTE, you can add the code in Listing 10 to provide<br>
font-keyboard synchronization. Using Toolbox routines, we determine the script of the<br>
font from the font ID. Then we call KeyScript, which changes the Keyboard menu<br>
settings to the default keyboard and input method combination for the new script.
</p>
<p>
______________________________
</p>
<p>
<b>Listing 10.</b> Synchronizing the keyboard with the font selection
</p>
<p>
<code>case mFont:</code><br>
<code>&nbsp;&nbsp;&nbsp;GetMenuItemText(GetMenuHandle(mFont), menuItem, theFontName);</code><br>
<code>&nbsp;&nbsp;&nbsp;GetFNum(theFontName, &amp;theFontID);</code><br>
<code>&nbsp;&nbsp;&nbsp;theTextStyle.tsFont = theFontID;</code><br>
<code>&nbsp;&nbsp;&nbsp;TESetStyle(doFont, &amp;theTextStyle, true, te);</code><br>
<code>&nbsp;&nbsp;&nbsp;if ((*te)-&gt;selEnd - (*te)-&gt;selStart &gt; 0)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theDocument-&gt;modified = true;</code><br>
<code>&nbsp;&nbsp;&nbsp;AdjustScrollbars(window, false);</code><br>
<code>&nbsp;&nbsp;&nbsp;theScript = FontToScript(theFontID);</code><br>
<code>&nbsp;&nbsp;&nbsp;KeyScript(theScript);</code><br>
<code>&nbsp;&nbsp;&nbsp;break;</code>
</p>
<p>
______________________________
</p>
<p>
Font-keyboard synchronization is another one of those contested international human<br>
interface issues. Japanese users tend to be very divided on the issue, since this feature<br>
makes it difficult to set Roman characters to the Osaka font (the workaround is to<br>
select the Roman mode within the input method after selecting the Osaka font);<br>
however, users working in most other 2-byte languages like font-keyboard<br>
synchronization. Again, the best idea is to try out this interface feature on several real<br>
users and get their impressions.
</p>
<p>
<b>OTHER USER INTERFACE ISSUES</b>
</p>
<p>
When you make your application TSM-aware, you may need to work around a couple of<br>
other user interface issues. One of them is implementing passwords. When the user is<br>
typing a password, you don't want an input method to come up, so you should change the<br>
current keyboard layout to the Roman default. This is accomplished similarly to<br>
font-keyboard synchronization, using the following code:
</p>
<p>
<code>KeyScript(smRoman);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Switch to Roman.</code><br>
<code>KeyScript(smKeyDisableKybdSwitch);&nbsp;&nbsp;&nbsp;&nbsp;// Lock out keyboard switching.</code><br>
<code>... // Do your password stuff here.</code><br>
<code>KeyScript(smKeyEnableKeyboards);</code><br>
<code>KeyScript(smKeySwapScript);</code>
</p>
<p>
If you're writing game software, in play mode the user can't or shouldn't be<br>
manipulating input with an input method. In this case, you should also change the<br>
current keyboard layout to Roman, and you might want to lock out keyboard switching.<br>
In certain other modes (such as the high score list), users do need the services of an<br>
input method, so you should restore the original keyboard layout.
</p>
<p>
Also, even though most users prefer inline input, some actually don't like it, or they<br>
prefer the bottomline style of input in certain situations. For example, it's difficult to<br>
distinguish Kanji characters at point sizes smaller than 12, so when the user is<br>
working on a document in a small font, looking at the raw input in a larger font in the<br>
floating input window may be desirable. You should provide a preference mechanism so<br>
that the user can select either inline or bottomline input. This is implemented by<br>
calling the TSM function UseInputWindow and then passing it the document ID and a<br>
Boolean indicating whether the user wants inline input.
</p>
<p>
<b>TESTING YOUR APPLICATION</b>
</p>
<p>
Once you've made your application TSM-aware, you'll want to test it with a variety of<br>
input methods, since not all of them interpret the TSM protocol in quite the same way.<br>
If you're fortunate enough to have testers who speak Chinese, Japanese, or Korean,<br>
you've got it made. But if you don't have anyone around who speaks these languages, it's<br>
still possible to test your application in English with an input method. For some<br>
suggestions on how non-Asian language speakers can successfully test your code, see<br>
"Testing Two-Byte Script Support."
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______________________________
</p>
<h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TESTING TWO-BYTE SCRIPT SUPPORT</h2>
<p>
<b style="font-size:80%;;margin-left:9px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BY GREG ANDERSON</b>
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I know what you're thinking: "Great, now I can add support for 2-byte scripts<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to my application. But I can't read Japanese or Chinese characters, so how am I<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;supposed to test my code to make sure it does the right thing with 2-byte<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;characters?"
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Good news: You don't have to learn Japanese or Chinese. Instead, you can test<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;your code using the 2-byte Roman input mode provided by Kotoeri. That's<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right -- I said "2-byte Roman."
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Most of the characters in the ASCII character set are replicated in one section<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;of the Japanese 2-byte character set; you'll find the numbers and letters<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;around $8250 to $829A. The 2-byte Roman characters look like their 1-byte<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counterparts, except that they're always monospaced and they take about twice<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as much space horizontally as the 1-byte characters do. These characters are<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;very useful for testing 2-byte script support, because they look the same as<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the characters you use every day but they behave like other 2-byte characters<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;such as Chinese and Japanese ideographs.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Entering the 2-byte Roman characters is easy. After you've installed the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Japanese Language Kit, choose Kotoeri from the Keyboard menu (shown<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;earlier in Figure 3) and click the button labeled with the wide uppercase A in<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the operations palette, which will then look like this:
</p>
<p>
<img style="margin-left:44px" src="img/136.gif" width="189 px"></img>
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Then just type Roman characters the same way you normally would. For<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;example, if you want a Q, hold down the Shift key and press the Q key on the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyboard. You're now ready to edit 2-byte Roman characters in your<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;application to make sure it handles them correctly. Here are some things to<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;check:
</p>
<ul>
<li style="margin-left: 44px">    Is the insertion point drawn in the right place, or are you using<br>
a Roman font to measure Japanese text?</li>
<li style="margin-left: 44px"> If the insertion point is positioned after a 2-byte character and<br>
you press the Delete key, is the entire character deleted, or do you<br>
leave the first byte dangling in your document?</li>
<li style="margin-left: 44px"> If you add a 2-byte uppercase B (which has an encoded value of<br>
$8261) to your document and use your Find command to search for a<br>
1-byte lowercase a (which has an encoded value of $61), does your<br>
application find the 2-byte B? (It shouldn't, and it won't if you're<br>
using CharacterByteType correctly.)</li>
</ul>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If these things work for you, you're well on your way to supporting 2-byte<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scripts in your application.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______________________________
</p>
<h2>THE TSM PROTOCOL</h2>
<p>
Although TSMTE should provide enough support for most application developers who<br>
want to make their TextEdit-based applications TSM-aware, some developers may<br>
want or need to handle all the details themselves. This section provides a very brief<br>
overview of the TSM 1.0 protocol for the benefit of the latter.
</p>
<p>
The TSM protocol is based on the exchange of Apple events between the application and<br>
the input method, allowing them to share information about the active input area. The<br>
protocol consists of a suite of three required events (Position To Offset, Offset To<br>
Position, and Update Active Input Area) and an optional fourth event (Get Text).
</p>
<p>
<b>THE POSITION TO OFFSET EVENT</b>
</p>
<p>
The Position To Offset event is used to convert a global position into a meaningful offset<br>
in the document's text buffer. This event is sent from the input method to the<br>
application when the input method handles an event that occurs within the context of<br>
the application content. (Remember that you need to call TSMEvent to give the Text<br>
Services Manager a chance to handle mouse and keyboard events.)
</p>
<p>
The application must respond to this event by extracting a point on the screen from the<br>
Apple event and converting that point to an offset in the text of the particular<br>
document. In the TSM protocol, offsets are defined as long integers. The application<br>
returns the offset as a key in the reply event.
</p>
<p>
<b>THE OFFSET TO POSITION EVENT</b>
</p>
<p>
The Offset To Position event is sent by the input method when it needs to determine the<br>
global position of a particular document offset. When responding to this event, the<br>
application must return a global point corresponding to this offset. Optionally, the<br>
application can also return information about the typographical style and orientation<br>
(vertical vs. horizontal) of the text. Each of these elements is returned as a key in the<br>
reply event.
</p>
<p>
<b>THE UPDATE ACTIVE INPUT AREA EVENT</b>
</p>
<p>
The Update Active Input Area event is used by the input method to ask the application to<br>
update the active input area. The event contains an offset range array that breaks the<br>
updated text into particular ranges. The offset range is accompanied by a highlight<br>
range, which indicates how the application should highlight the particular range of<br>
text.
</p>
<p>
<b>THE GET TEXT EVENT</b>
</p>
<p>
Get Text is an optional event used only by Kotoeri, the Japanese input method, and some<br>
third-party Japanese input methods. It's documented in a March 1994 technical note<br>
by Takayuki Mizuno, available only in Japanese and roughly entitled "Kotoeri's<br>
Private Apple Event, Get Text." It's an extension to the TSM protocol developed by<br>
Apple as a way for an input method to retrieve text that has already been confirmed.<br>
Since most localized Japanese applications support this event, your users will<br>
probably expect it from your application as well.
</p>
<p>
TSMTE provides support for the Get Text event, so if you use the techniques in this<br>
article your application will be able to take advantage of this extension. The Get Text<br>
event is defined in Table 1. Listing 11 demonstrates how to handle the event directly.
</p>
<p>
______________________________
</p>
<p>
<b>Table 1.</b> Definition of the Get Text event
</p>
<p><table border="0"><tr><td><b>Event class</td><td></b>kTextServiceClass</td></tr>
<tr><td><b>Event ID</td><td></b>kGetText (= 'gtxt')</td></tr>
<tr><td><b>Requested action</td><td></b>Returns the current selection as the</td></tr>
<tr><td></td><td>return parameter</td></tr></table></p>
<p class="spacer">&nbsp;</p>
<p class="spacer">&nbsp;</p>
<p><table border="0"><tr><td><b>Keyword</b></td><td><b></b><b>Descriptor type</b></td><td><b></b><b>Data</b></td></tr>
<tr><td><b>Required parameters</b></td><td></td><td></td></tr>
<tr><td>keyDocumentRefcon</td><td>typeLongInteger</td><td>Standard refCon parameter</td></tr>
<tr><td>keyAEServerInstance</td><td>typeComponentInstance</td><td>Standard component</td></tr>
<tr><td></td><td></td><td>instance parameter</td></tr>
<tr><td><b>Optional parameters</b></td><td></td><td></td></tr>
<tr><td>keyAEBufferSize (= 'buff')</td><td>typeLongInteger</td><td>Maximum number of bytes the</td></tr>
<tr><td></td><td></td><td>input method can receive</td></tr>
<tr><td><b>Return parameters</b></td><td></td><td></td></tr>
<tr><td>keyAETheData</td><td>typeText</td><td>The text specified by the current</td></tr>
<tr><td></td><td></td><td>selection. The maximum byte</td></tr>
<tr><td></td><td></td><td>length is specified by the</td></tr>
<tr><td></td><td></td><td>keyAEBufferSize parameter. Any</td></tr>
<tr><td></td><td></td><td>portion of the text that exceeds</td></tr>
<tr><td></td><td></td><td>the buffer length shouldn't be</td></tr>
<tr><td></td><td></td><td>returned.</td></tr></table></p>
<p class="spacer">&nbsp;</p>
<p class="spacer">&nbsp;</p>
<p>
______________________________
</p>
<p>
<b>Listing 11.</b> Handling the Get Text event
</p>
<p>
<code>pascal OSErr HandleGetText(const AppleEvent *theAppleEvent,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const AppleEvent *reply, long handlerRefcon)</code><br>
<code>{</code><br>
<code>#pragma unused (handlerRefcon)</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;OSErr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err;</code><br>
<code>&nbsp;&nbsp;&nbsp;ComponentInstance&nbsp;&nbsp;&nbsp;serverInstance;</code><br>
<code>&nbsp;&nbsp;&nbsp;TSMTERecHandle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;docRefcon;</code><br>
<code>&nbsp;&nbsp;&nbsp;Handle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text;</code><br>
<code>&nbsp;&nbsp;&nbsp;Size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;textLen;</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;// Identify event and get document refCon and server instance.</code><br>
<code>&nbsp;&nbsp;&nbsp;err = IdentifyTSMCallback(theAppleEvent, &amp;docRefcon,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;serverInstance);</code><br>
<code>&nbsp;&nbsp;&nbsp;if (err) return err;</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;// Get selected text from document.</code><br>
<code>&nbsp;&nbsp;&nbsp;HLock((Handle) docRefcon);</code><br>
<code>&nbsp;&nbsp;&nbsp;err = DoGetText(*docRefcon, serverInstance, &amp;text, &amp;textLen);</code><br>
<code>&nbsp;&nbsp;&nbsp;HUnlock((Handle) docRefcon);</code><br>
<code>&nbsp;&nbsp;&nbsp;if (err) return err;</code><br>
<code>&nbsp;&nbsp;&nbsp;// Add selected text as return parameter.</code><br>
<code>&nbsp;&nbsp;&nbsp;HLock(text);</code><br>
<code>&nbsp;&nbsp;&nbsp;err = AEPutParamPtr(reply, keyAETheData, typeText, (Ptr) *text,</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;textLen);</code><br>
<code>&nbsp;&nbsp;&nbsp;DisposeHandle(text);</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;return err;</code><br>
<code>}</code><br>
<code>OSErr DoGetText(TSMTERecPtr tsmteRecPtr, ComponentInstance</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serverInstance, Handle *text, Size *textLen)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br>
<code>{</code><br>
<code>#pragma unused (serverInstance)</code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;TEHandle hTE;</code><br>
<code>&nbsp;&nbsp;&nbsp;short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;selStart, selEnd;</code><br>
<code>&nbsp;&nbsp;&nbsp;</code><br>
<code>&nbsp;&nbsp;&nbsp;hTE = tsmteRecPtr-&gt;textH;</code><br>
<code>&nbsp;&nbsp;&nbsp;selStart = (*hTE)-&gt;selStart;</code><br>
<code>&nbsp;&nbsp;&nbsp;selEnd&nbsp;&nbsp;= (*hTE)-&gt;selEnd;</code><br>
<code>&nbsp;&nbsp;&nbsp;*textLen = selEnd - selStart;</code><br>
<code>&nbsp;&nbsp;&nbsp;*text = NewHandleClear(*textLen);</code><br>
<code>&nbsp;&nbsp;&nbsp;HLock((Handle) *text);</code><br>
<code>&nbsp;&nbsp;&nbsp;BlockMove((Ptr) (*((*hTE)-&gt;hText) + selStart), (Ptr) (**text),</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*textLen);</code><br>
<code>&nbsp;&nbsp;&nbsp;HUnlock((Handle) *text);</code><br>
<code>&nbsp;&nbsp;&nbsp;return noErr;</code><br>
<code>}</code>
</p>
<p>
______________________________
</p>
<h2>TSM NOW AND FOREVER</h2>
<p>
Although the changes required to make your TextEdit-based application TSM-aware<br>
are small, they dramatically overhaul the experience available to Asian<br>
language-speaking users. Try compiling our sample application both with and without<br>
the inline support flag set so that you can see the difference it makes to users. Even if<br>
you don't have plans to ship your application localized for Chinese, Japanese, or<br>
Korean, making it TSM-aware will please your users who have an Apple Language Kit<br>
installed and want to use your application with their non-English data.
</p>
<p>
Besides having an immediate payoff, the work you do to make your application<br>
TSM-aware will have a future payoff as well. While version 1.0 of the Text Services<br>
Manager offers support solely for keyboard input methods, future versions will be<br>
part of the framework for supporting handwriting and speech/dictation input methods<br>
as well as more general text services such as interactive spelling checkers and<br>
intelligent document scanners. By making your application TSM-aware now, you'll be<br>
poised to take advantage of the wide variety of services that will be available with TSM<br>
2.0.
</p>



<b>RELATED READING</b>
<ul>
<li>"Writing Localizable Applications" by Joseph Ternasky and Bryan<br>
K. "Beaker" Ressler, <i>develop</i> Issue 14.</li>
<li><i>Guide to Macintosh Software Localization</i> by Apple Computer, Inc.<br>
(Addison-Wesley, 1992).</li>
<li><i>Inside Macintosh: Text</i> by Apple Computer, Inc. (Addison-Wesley,<br>
1993), Chapter 7, "Text Services Manager."</li>
<li>Technotes TE 27, "Inline Input for TextEdit With TSMTE," and OV<br>
20, "Internationalization Checklist."</li>
<li><i>Understanding Japanese Information Processing</i> by Ken Lunde<br>
(O'Reilly &amp; Associates, 1993).</li>
<li><i>Writing Systems of the World</i> by Akira Nakanishi (English<br>
edition, Charles E. Tuttle, 1980).</li>
<li>IDRIS scripts, http://idris.com/scripts/Scripts.html.</li>
</ul>



<p>
<b>TAGUE GRIFFITH</b> (tague@apple.com) has&nbsp;&nbsp;appeared on stage with several famous<br>
rock bands and would like to marry a rock star when he grows up. In his spare time,<br>
Tague works in Apple's Text and International Engineering group. If anyone out there<br>
knows Courtney Love's e-mail address, please send it to Tague.*
</p>
<p>
<b>Thanks to</b> our technical reviewers David Bice, Deborah Grits, Osman G&#220;racar, John<br>
Harvey, and Yasuo Kida.*
</p>
</body>
</html>
