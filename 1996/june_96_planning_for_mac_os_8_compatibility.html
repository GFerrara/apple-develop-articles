<!DOCTYPE html>
<html>
<head>
<!-- Article ID: 22 - Extracted from develop-1996 -->
<!-- on 2025-01-18 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by the copyright of its respective owners -->
<title>June 96 - Planning for Mac OS 8 Compatibility</title>
<link href="../common/styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h1>Planning for Mac OS 8 Compatibility</h1>
<h2>STEVE FALKENBURG</h2>
<p>
<img src="img/195.gif" width="180 px"></img>
</p>
<p>
<i style="font-size:125%;">One of the most important goals for Mac OS 8 (formerly known by</i>
<br>

<i style="font-size:125%;">the development name "Copland") is the preservation of</i>
<br>

<i style="font-size:125%;">compatibility with existing applications. Customers consistently</i>
<br>

<i style="font-size:125%;">rank compatibility as a critical factor in their decision whether to</i>
<br>

<i style="font-size:125%;">upgrade to a new OS release, with good reason. This article sheds</i>
<br>

<i style="font-size:125%;">light on what will and won't be compatible, and gives developers a</i>
<br>

<i style="font-size:125%;">road map for ensuring compatibility with the Mac OS 8 release.</i>
</p>
<p>
As one of the driving forces behind Mac OS 8, compatibility is at the forefront of the<br>
minds of Apple engineers hard at work on this system software release. Given the track<br>
record of nearly seamless compatibility with the Power Macintosh, customers will<br>
expect their existing applications to run under Mac OS 8 with few or no problems.<br>
Apple is working hard to deliver on this promise, and we're beginning to succeed. Most<br>
of the specific information for this article was learned the hard way -- by getting<br>
many existing applications up and running.
</p>
<p>
Of course, tradeoffs must be made to move the platform forward. If Mac OS 8 were to<br>
remain compatible with all Macintosh software, the performance, reliability, and<br>
stability of the system would suffer. While some customers have been impressed by<br>
the stability of System 7, others would like to experience even fewer crashes and are<br>
willing to upgrade some of their software in the process. Apple's system software<br>
needs to be more stable, while still maintaining compatibility with most applications.
</p>
<p>
Luckily, there are quite a few techniques that you can use today and guidelines that you<br>
can follow to ensure compatibility with Mac OS 8. This way, you can impress your<br>
friends (and confuse your enemies) at compatibility labs by installing your software<br>
for the first time under Mac OS 8, and walking away 15 minutes later saying, "Gee,<br>
that was easy, everything works!" This is when following all of those <i>Inside Macintosh</i><br>
chapters, <i>develop</i> articles, and Technotes will finally pay off.
</p>
<p>
Don't panic: Mac OS 8 isn't the compatibility "day of reckoning" that you've had<br>
nightmares about. I'm sure many of you have been told by Developer Technical<br>
Support, "Here's a really cool trick, but it may break in the future." In some cases,<br>
"the future" is in fact Mac OS 8, but on the other hand many techniques that are no<br>
longer being recommended (which we of course like to call "sick hacks") will continue<br>
to work.
</p>
<p>
Remember that Mac OS 8 is just the first step in modernizing the Macintosh.<br>
Subsequent system releases will include features such as separate address spaces and<br>
full preemption for all applications. In the future, discouraged techniques will become<br>
areas of incompatibility; so even if your application runs under Mac OS 8, it's worth<br>
cleaning it up in preparation for future systems.
</p>
<p>
In this article, I'll go over a few things that will no longer work under Mac OS 8 as<br>
well as some of the techniques that will continue to work under Mac OS 8 but will<br>
break in future systems. For the more heinous examples of these techniques, I won't<br>
give code samples -- I don't want people saying "Hey, I did it just like they did in<br>
<i>develop</i>" as an excuse. I'll also discuss some specific case histories of application<br>
compatibility problems, to further illustrate the need to be proactive when planning<br>
for compatibility.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>For an overview of Mac OS 8,</b> see http://www.macos.apple.com/macos8<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on the World Wide Web, or the article "Copland: The Mac OS Moves Into the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Future" in <i>develop</i>Issue 22. Other introductory documents can be found on this<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;issue's CD. Please keep in mind when reading these materials, as well as this<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;article, that the terminology has evolved over time and some of it may change<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;again by the time you read this.*
</p>
<h2>WHAT WORKS AND WHAT DOESN'T</h2>
<p>
Before diving into guidelines, warnings, and examples, we'll start with an overview of<br>
exactly which types of software will be compatible with Mac OS 8, which will need to<br>
be updated, and which will need to be redesigned. This article focuses on applications,<br>
but an overview of compatibility in general is helpful to set the stage.
</p>
<p>
First, the good news: Well-written applications conforming to Macintosh development<br>
guidelines should run without any modification. This includes PowerPC(TM)-native<br>
applications as well as emulated applications. Theoretically, you could have written a<br>
Macintosh Solitaire game in 1984 that would also run under Mac OS 8. There are, of<br>
course, caveats to application compatibility, which will be discussed later in this<br>
article.
</p>
<p>
Component software is becoming an important part of the Macintosh experience, and<br>
Mac OS 8 will support OpenDoc part editors as well as application-specific plug-ins<br>
-- again, without any modification. Depending on the "parent" application, there may<br>
be issues with plug-in compatibility (as discussed later).
</p>
<p>
Now, the bad news: Existing extensions, control panels, desk accessories, ASLM<br>
libraries, and most drivers are unsupported for the Mac OS 8 release. Compatibility<br>
tradeoffs needed to be made in these areas to move the system forward and improve<br>
system reliability.
</p>
<p>
Macintosh power users often try to impress each other by comparing how many<br>
extensions load at startup, gracing their "Welcome to Macintosh" screen with several<br>
rows of happy little icons. The proliferation of INITs has made life as a Macintosh user<br>
exciting, if a little hazardous. With Mac OS 8, we're trying to attack the system<br>
stability problem head on by providing new, more reliable mechanisms for<br>
extensibility and patching. While the original Macintosh was presented as a complete<br>
solution, the Mac OS 8 team has realized that third-party extensibility is part of what<br>
makes the system great. This has led us to make ease of extensibility a key goal of the<br>
system.
</p>
<p>
As with extensions, for each existing code type that's not supported under Mac OS 8, a<br>
new and much improved mechanism will be provided. In other words, we'll still have<br>
MacHack entries for years to come, and they'll be just as cool but more reliable.
</p>
<p>
Other, less common software types are also unsupported. These include Text Services<br>
Manager input methods, FSM external file system modules, and debuggers. This article<br>
focuses on application-level issues, so I won't go into a lot of detail in these areas, but<br>
a section on migration paths is included in the article.
</p>
<h2>APPLICATION TAXONOMY</h2>
<p>
For the Mac OS 8 release, the types of applications that developers write can be split<br>
into several major categories. These categories have been defined by the Mac OS 8<br>
project teams, and work is being done to ensure that each of the application types is<br>
fully supported by the Mac OS 8 design. This article doesn't cover each type in detail,<br>
but we'll use the classifications as guideposts for migration and compatibility plans.
</p>
<p>
<b>USER INTERFACE APPLICATIONS</b>
</p>
<p>
The first, and most familiar, application type is the <i>user interface application.</i> This<br>
type makes up the majority of applications on the Macintosh. These applications use<br>
windows, menus, and dialogs and are usually document-centric. Examples include<br>
ClarisWorks, Quicken, and Microsoft Excel. There are three variants of this<br>
application type: Mac OS 8-savvy, minimal-adoption, and Mac OS 8-compatible.
</p>
<p>
<b>Mac OS 8-savvy applications.</b> A <i>Mac OS 8-savvy application</i> is just what you'd<br>
think it would be: an application that takes significant advantage of Mac OS 8 features,<br>
such as preemptive tasking, improved event delivery, and new user interface features.<br>
Because these APIs aren't available under System 7, a Mac OS 8-savvy application<br>
will not run under pre-Mac OS 8 system releases. Note that Mac OS 8-savvy<br>
applications still must maintain a cooperatively scheduled task so that they can call the<br>
Macintosh Toolbox, and this cooperative task lives in the same address space with all<br>
other System 7 and Mac OS 8-savvy applications. It's possible to have other portions<br>
of the application run in separate address spaces, and servers (such as file sharing)<br>
are completely protected from applications.
</p>
<p>
<b>Minimal-adoption applications.</b> Not all developers may want to or be able to<br>
make the move to a Mac OS 8-only application immediately. The <i>minimal-adoption</i><br>
<i>application</i> type is intended for these situations. The characteristics of this category<br>
include "fitting in" with the Mac OS 8 look and feel while still maintaining<br>
compatibility with System 7. Some subset of Mac OS 8 features (not APIs) will be<br>
available to these applications, such as the removal of the fixed-size Memory Manager<br>
heap limitation, and the new-look, theme-specific, user interface elements. This<br>
application type is distinguished from System 7 applications by its correct appearance<br>
under Mac OS 8 and its adoption of Mac OS 8 features on a runtime-check basis.
</p>
<p>
<b>Mac OS 8-compatible applications.</b> Well-written applications authored<br>
originally for pre-Mac OS 8 systems will continue to work under Mac OS 8. If you<br>
follow the guidelines in this article and adhere to documented Macintosh application<br>
programming practices, your application should be Mac OS 8 compatible. Of course, to<br>
take advantage of Mac OS 8 features in your application, you may need to release a new<br>
version.
</p>
<p>
<b>REAL-TIME APPLICATIONS</b>
</p>
<p>
<i>Real-time applications</i> are applications that have time constraints on aspects of their<br>
behaviors. If these constraints aren't met, the application either fails or needs to adapt<br>
gracefully to these operating conditions. Examples include data collection applications<br>
such as LabView, multimedia applications such as Premier, and games such as<br>
Marathon. Under Mac OS 8, real-time applications may choose to take advantage of<br>
enhanced timing services and preemptive scheduling to improve their performance. In<br>
some ways, however, Mac OS 8 provides new challenges to these applications, since<br>
virtual memory is always enabled and preemptive scheduling may cause the<br>
application to lose control of the CPU in unforeseen situations. That said, performance<br>
will be vastly improved from the System 7 Virtual Memory Manager, so this shouldn't<br>
be a concern for most developers.
</p>
<p>
<b>OPENDOC PART EDITORS</b>
</p>
<p>
OpenDoc part editors are a relatively new application type. OpenDoc will continue to be<br>
an important direction for document-oriented applications under the Mac OS 8 release.<br>
As you'll see throughout this article, OpenDoc is also a suggested migration path for<br>
several types of existing applications.
</p>
<p>
<b>SERVERS</b>
</p>
<p>
<i>Servers</i> are a new concept introduced in Mac OS 8. They're preemptively scheduled and<br>
run in their own protected address spaces. These features provide independence from<br>
the cooperative Toolbox environment and mean that servers have greatly enhanced<br>
stability, surviving the crashes of applications or other, ill-behaved servers. New<br>
reentrant services are provided in Mac OS 8 to make servers possible, including<br>
tasking, messaging, memory allocation, file system access, and networking. Only a<br>
subset of the Mac OS 8 APIs are available to servers, and this subset does not include<br>
the Macintosh Toolbox calls (Window Manager, Menu Manager, QuickDraw, and so on).<br>
This means that servers cannot present a user interface. Candidates for servers<br>
include World Wide Web Internet servers, virus checkers, and high-end publishing<br>
print servers.
</p>
<p>
<b>UTILITY APPLICATIONS</b>
</p>
<p>
<i>Utility applications</i> manage a single window for user interface and have no menu bar.<br>
To the user, they aren't usually considered a separate application. Mac OS 8 will<br>
support utility applications as a generalized application type, unlike previous system<br>
releases. An additional use of utility applications is to present a user interface on<br>
behalf of a server. For example, a utility application could be used to configure an<br>
e-mail forwarding server with the proper e-mail addresses. Other examples of this<br>
application type include Apple Guide and configuration control panels.
</p>
<p>
<b>OTHER NON-APPLICATION CLASSIFICATIONS</b>
</p>
<p>
Three other classifications that are useful to our discussions but don't refer to<br>
applications are extension libraries, patch libraries, and drivers.
</p>
<p>
<b>Extension libraries. </b><i>Extension libraries</i> allow additional code to be introduced into<br>
the Code Fragment Manager (CFM) closure for an application. An example use of an<br>
extension library would be to track software launches and quits through CFM<br>
initialization and termination routines to perform software auditing.
</p>
<p>
<b>Patch libraries. </b><i>Patch libraries </i>allow patches to be installed into applications<br>
through data-driven means, simplifying the customization process. Patch libraries<br>
apply their patches in only one context, but can be combined with extension libraries<br>
to achieve global-effect patching. The Get/SetTrapAddress methods of the past have<br>
proven difficult or impossible to maintain and have resulted in greatly decreased<br>
system reliability. The patch library mechanism, with associated extension libraries,<br>
provide a more than capable replacement for the pre-Mac OS 8 patching methods.
</p>
<p>
<b>Drivers.</b>Under Mac OS 8, the device driver mechanism has been rearchitected to<br>
ensure a high-throughput and flexible I/O system. Pre-Mac OS 8 'DRVR'-style<br>
drivers are not supported and so need to be rewritten. As we'll discuss below, some<br>
software written as a driver today may be better written as another application type.
</p>
<h2>MIGRATION PATHS FOR EXISTING APPLICATIONS</h2>
<p>
The first step in preparing for Mac OS 8 is determining the migration path your<br>
application will follow. Depending on what type of application you have today, this<br>
could mean a complete rewrite, minor tweaks, or no changes at all.
</p>
<p>
The most important point along the Mac OS 8 migration path is the first one:<br>
compatibility. Before determining the best way of moving your application forward,<br>
you should ensure that it runs out of the box on Mac OS 8. We'll discuss compatibility<br>
specifics in a later section.
</p>
<p>
Each System 7 application type has a unique migration path; the sections below cover<br>
the available options.
</p>
<p>
<b>USER INTERFACE APPLICATIONS</b>
</p>
<p>
As shown in Figure 1, a System 7-based user interface application has several<br>
alternatives for migration. The simplest alternative is not to revise the application at<br>
all, or, if needed, do the minimum required to make the application Mac OS 8<br>
compatible.
</p>
<p>
<img src="img/196.gif" width="306 px"></img>
</p>
<p>
<b>Figure 1.</b> The migration path for a user interface application
</p>
<p>
Another alternative is to convert the application into an OpenDoc part editor. I'm not<br>
going to go into OpenDoc in this article; if you choose this route, see the article "The<br>
OpenDoc User Experience" in <i>develop</i> Issue 22 for a good overview of how part editors<br>
work from the user's perspective.
</p>
<p>
If having a single binary for both System 7 and Mac OS 8 is important, the<br>
minimal-adoption option may be appropriate. By migrating to minimal adoption, you<br>
ensure user interface consistency and may be able to take advantage of a limited<br>
number of Mac OS 8 features. For example, more efficient memory management is<br>
possible if you restrict yourself to a subset of the Macintosh Memory Manager API and<br>
don't access Memory Manager heap structures directly.
</p>
<p>
The most ambitious path for migration is to make the application Mac OS 8 savvy. This<br>
will mean that the same binary won't run under both System 7 and Mac OS 8. If the<br>
application is made Mac OS 8 savvy, it can take advantage of the wide range of<br>
preemptive tasking services, efficient event handling, and an object-oriented version<br>
of the Macintosh Toolbox.
</p>
<p>
<b>REAL-TIME APPLICATIONS</b>
</p>
<p>
The migration path for a real-time application is more straightforward than for a<br>
user interface application (see Figure 2). Either the application can move to Mac OS 8<br>
without changes or it can take advantage of additional real-time features provided by<br>
Mac OS 8, becoming a Mac OS 8-specific real-time application. Which path is taken<br>
depends on whether the existing application performs properly under Mac OS 8<br>
without changes. For example, the developer of an application that was using Time<br>
Manager tasks for accuracy-critical timing would want to consider migrating to take<br>
advantage of the improved timing services of Mac OS 8.
</p>
<p>
<img src="img/197.gif" width="306 px"></img>
</p>
<p>
<b>Figure 2.</b> The migration path for real-time applications
</p>
<p>
<b>OPENDOC PART EDITORS</b>
</p>
<p>
As shown in Figure 3, existing OpenDoc part editors will be compatible with Mac OS 8,<br>
but a part editor can be updated to take advantage of new Mac OS 8 APIs if the developer<br>
chooses. Both Mac OS 8-savvy and existing OpenDoc part editors can work on the same<br>
OpenDoc documents without problems.
</p>
<p>
<img src="img/198.gif" width="306 px"></img>
</p>
<p>
<b>Figure 3.</b> The migration path for OpenDoc part editors
</p>
<p>
<b>FACELESS BACKGROUND APPLICATIONS</b>
</p>
<p>
Faceless background applications (FBAs), also known as background-only<br>
applications, are supported under Mac OS 8, but the natural migration path for most<br>
FBAs leads to the server application type (see Figure 4).
</p>
<p>
<img src="img/199.gif" width="306 px"></img>
</p>
<p>
<b>Figure 4.</b> The migration path for faceless background applications
</p>
<p>
The preemptive nature of servers makes them easier to write than FBAs, since file<br>
system and networking calls can block until completion instead of being written with<br>
asynchronous calls and chained completion routines. More important, the enhanced<br>
reliability of servers makes this transition an easy decision. One drawback of servers<br>
is that they cannot access the cooperative Toolbox environment, since they're<br>
preemptively scheduled.
</p>
<p>
<b>DESK ACCESSORIES AND CONTROL PANELS</b>
</p>
<p>
We'll cover desk accessories and control panels together, since they share many of the<br>
same user interface characteristics. Most user interaction for these types takes place<br>
in a single window, and neither type maintains a full menu bar. All existing desk<br>
accessories and control panels are unsupported under Mac OS 8 and so need to be<br>
rewritten. As shown in Figure 5, the two suggested replacement application types are<br>
utility applications and OpenDoc part editors.
</p>
<p>
<img src="img/200.gif" width="396 px"></img>
</p>
<p>
<b>Figure 5.</b> The migration path for desk accessories and control panels
</p>
<p>
<b>DRIVERS</b>
</p>
<p>
Figure 6 shows the migration path for drivers. On pre-Mac OS 8 systems, drivers<br>
were typically written for a variety of reasons. The most straightforward use of<br>
old-style drivers was to control hardware devices. With Mac OS 8, a newly designed<br>
driver architecture has been provided for these hardware control drivers.
</p>
<p>
<img src="img/201.gif" width="306 px"></img>
</p>
<p>
<b>Figure 6. </b>The migration path for drivers
</p>
<p>
Another common reason for writing a driver was to get periodic time from the system,<br>
or to present a common interface for other drivers or applications through the<br>
PBControl call. Mac OS 8's server mechanism is a much more capable solution for<br>
these types of products. Servers can get reliable periodic time through the Mac OS 8<br>
kernel's timing services, and messaging or Apple events can be used to communicate<br>
with other servers or applications.
</p>
<p>
Certain existing drivers will be compatible with Mac OS 8. Display and networking<br>
drivers developed in strict accordance with the guidelines in<i>Designing PCI Cards and</i><br>
<i>Drivers for Power Macintosh Computers</i> will work under Mac OS 8 without<br>
modification.
</p>
<p>
Finally, non-QuickDraw GX printer drivers are not supported under Mac OS 8. Since<br>
the printing mechanism for Mac OS 8 is an improved version of QuickDraw GX,<br>
existing non-GX printer drivers need to be updated to the QuickDraw GX printer<br>
driver model.
</p>
<p>
<b>EXTENSIONS</b>
</p>
<p>
Extensions, in the form of both individual INITs and INITs packaged within control<br>
panels, are not supported under Mac OS 8. These extensions, for the most part, can be<br>
divided into two categories: those that need periodic time from the system and those<br>
that operate through global-effect patching. The former will typically be replaced by<br>
servers, while the latter will migrate to either the built-in extensibility services or<br>
the extension library mechanism (as shown in Figure 7).
</p>
<p>
<img src="img/202.gif" width="306 px"></img>
</p>
<p>
<b>Figure 7. </b>The migration path for extensions
</p>
<p>
For extensions that patch traps such as SystemTask to get periodic time to run "on the<br>
dime" of other applications, the Mac OS 8 server model provides a much more<br>
straightforward mechanism. The only drawback to using servers in this way is that the<br>
cooperative Toolbox environment is not available to preemptive callers, so an<br>
old-style faceless background application may be another migration alternative.
</p>
<p>
As mentioned earlier, hooks for extensibility have been designed into the Mac OS 8<br>
system. For this reason, patching is no longer necessary in most cases. These built-in<br>
extensibility hooks should accommodate most former clients of patching.
</p>
<p>
Since we can't forecast every possible way of extending the system, the extension<br>
library and patch library mechanisms have been provided. Through data-driven<br>
means, patches can be installed on a per-application basis to control behaviors. Super<br>
Boomerang, for example, could be rewritten in this way.
</p>
<p>
Some items located in the System 7 Extensions folder will continue to work under Mac<br>
OS 8. These include CFM shared libraries, 'appe' background applications,<br>
Communications Toolbox tools, Chooser extensions, and Apple Guide guide files. Note<br>
that no INITs associated with these extension types will be loaded by Mac OS 8, which<br>
could impact compatibility for these products.
</p>
<p>
Several types of non-INIT Apple extensions are not supported, however, and soneed to<br>
be rewritten. These include sound sifters, inline input methods, and FSM modules.
</p>
<p>
<b>APPLICATION PLUG-INS</b>
</p>
<p>
By application plug-ins, we're referring to products like Kai's Power Tools for<br>
Photoshop. There shouldn't be any compatibility issues specific to plug-ins operating<br>
in existing applications. There are, however, compelling reasons for application<br>
developers to update the way they present plug-in interfaces. Figure 8 shows the<br>
migration path. For applications that present their plug-in model in an<br>
object-oriented fashion, the System Object Model (SOM) should be used. Its many<br>
advantages include strong type checking, object-oriented interfaces, and a solution to<br>
the fragile base-class problem. For developers who want to maintain a functional<br>
interface, the Code Fragment Manager is the best option.
</p>
<p>
<img src="img/203.gif" width="312 px"></img>
</p>
<p>
<b>Figure 8.</b> The migration path for application plug-ins
</p>
<p>
There are some potential pitfalls related to plug-in compatibility with Mac OS 8.<br>
Although mixing Mac OS 8 APIs with System 7 APIs is permitted, there may be<br>
problems running System 7 plug-ins with Mac OS 8-savvy versions of applications.<br>
For instance, Photoshop could choose to take advantage of new memory management<br>
services provided in Mac OS 8. For the payoff of not having a fixed-size Memory<br>
Manager heap, they promise not to make certain Memory Manager calls. If a System 7<br>
Photoshop plug-in makes any of these disallowed Memory Manager calls, Photoshop<br>
may not work.
</p>
<p>
For this reason, we're suggesting that all applications that support a plug-in model<br>
provide isolation for these plug-ins from system calls. If the plug-in needs to allocate<br>
memory, for example, it should call the application to do so, instead of calling the<br>
Memory Manager directly. In this way, plug-ins can take advantage of new Mac OS 8<br>
features without ever being updated.
</p>
<p>
Several existing plug-in mechanisms are either not available or not encouraged for<br>
use under Mac OS 8. The Apple Shared Library Manager, as we'll discuss later, is not<br>
available. The Component Manager is available but is not recommended for use, since<br>
the Code Fragment Manager and SOM are now the preferred mechanisms.
</p>
<h2>PREPARING FOR MAC OS 8 TODAY</h2>
<p>
There are quite a few steps you can take to ensure application compatibility with Mac<br>
OS 8. You've heard a lot of these suggestions before, while some are new. All are<br>
important techniques that can save you many hours of debugging.
</p>
<p>
You'll find that in the Mac OS 8 release, a debugging version of the system has been<br>
provided that will assert via the debugger whenever your application performs a<br>
questionable behavior. Hopefully, if you follow the guidelines in this article, you won't<br>
ever have to see these assertions.
</p>
<p>
For each suggestion, we'll show a snippet of code or an example of the technique where<br>
appropriate. Each one of these techniques can be put into action today.
</p>
<p>
<b>USE THE LATEST UNIVERSAL INTERFACES</b>
</p>
<p>
Within Apple, all Macintosh development is now done using the same set of universal<br>
interfaces. These interfaces are periodically released to developers on the MPW Pro<br>
disk and online, and are also available on this issue's CD. Some third-party tools, such<br>
as Metrowerks CodeWarrior, also ship with the latest interfaces. By using these<br>
interfaces, you'll be developing with the same C, Pascal, and assembly headers as<br>
Apple engineers, which ensures that you'll be up to date with the latest changes from<br>
Apple.
</p>
<p>
Over time, the universal interfaces will have Mac OS 8 features conditionally added.<br>
For example, several compile-time switches will be added to indicate which calls are<br>
available in certain situations.
</p>
<p>
<b>PORT YOUR APPLICATION TO POWERPC CODE</b>
</p>
<p>
Mac OS 8 is, at heart, a PowerPC processor-based system. Porting only<br>
performance-critical sections of your application to PowerPC code and leaving the<br>
rest in 680x0 code will begin to become more of a liability than an advantage under<br>
Mac OS 8. New API calls introduced in Mac OS 8 will not have traps associated with<br>
them. They'll be made available only through CFM and SOM-based interfaces. This<br>
means that 680x0 code will not be able to access these new services. Note, however,<br>
that 680x0 applications are still fully supported under Mac OS 8 for compatibility.
</p>
<p>
<b>USE A SUPPORTED FRAMEWORK</b>
</p>
<p>
Considering all the changes coming for developers in the Mac OS 8 release, you may<br>
choose to move your application to a well-supported Macintosh framework. Apple is<br>
already working closely with several framework providers, and you may decide to take<br>
advantage of their efforts. One word of caution is that using a framework doesn't<br>
guarantee compatibility. If that framework "breaks the rules," or if your own<br>
application code uses unsupported behaviors, you still have compatibility concerns.
</p>
<p>
<b>SUPPORT ONLY SYSTEM 7 AND LATER</b>
</p>
<p>
While getting a variety of applications running on the Mac OS 8 release, we've found<br>
that many developers have obsolete code buried in their applications. For instance,<br>
several developers used the code shown in Listing 1 to check for the availability of<br>
certain system traps. Note the function ToolboxTrapTableSize. This code checks to see<br>
if the application is running on a Macintosh with an expanded Toolbox trap table --<br>
but this has been the case ever since Color QuickDraw was introduced. Considering that<br>
the applications performing this check were PowerPC native, this check is overkill<br>
and so can be removed.
</p>
<p>
<b>Listing 1.</b> Obsolete code for checking trap availability<p class="spacer">&nbsp;</p>
</p>
<pre>Boolean IsTrapAvailable(short theTrap)
{
   TrapType      trapType;
   Boolean      available;
  
   if ((theTrap &amp; 0x0800) &gt; 0)
      trapType = ToolTrap;
   else
      trapType = OSTrap;
   if (trapType == ToolTrap) {
      theTrap &amp;= 0x07FF;
      if (theTrap &gt;= ToolboxTrapTableSize())
         theTrap = _Unimplemented;
   }
   available = NGetTrapAddress(theTrap, trapType)
      != GetToolTrapAddress(_Unimplemented);
   return available;
}

short ToolboxTrapTableSize(void)
{
   if (GetToolTrapAddress(_InitGraf) == GetToolTrapAddress(0xAA6E))
      return 0x0200;
   else
      return 0x0400;
}</pre>
<p class="spacer">&nbsp;</p>
<p>
Other examples of long-obsolete behaviors include using old SFGetFile-style Standard<br>
File calls and relying on HFS working directories to make file system calls. In other<br>
words, you can safely assume that Apple will not introduce a PowerPC<br>
processor-based Macintosh that runs System 6.
</p>
<p>
<b>MINIMIZE PATCHING</b>
</p>
<p>
Many applications use patching to excess. A well-written PowerPC-native application<br>
should not have to patch any traps. Along the lines of removing old code, consider<br>
removing patches installed simply to work around a long-fixed bug, at least<br>
conditionally.
</p>
<p>
We found a particularly bad example of application trap patching when bringing up a<br>
major word processing application. The application called the Alert routine to display<br>
an alert to the user. The developers decided that they wanted a cool 3D button instead of<br>
the Macintosh-standard button, so they patched NewControl and watched for<br>
NewControl to be called from NewDialog (itself called from Alert) with the expected<br>
pushButProc procID. When this call was intercepted, they substituted their 3D button<br>
procID, and the alert was displayed with their button. Of course, they could have<br>
simply called the Dialog Manager and Control Manager themselves, thereby avoiding<br>
the trap patch entirely. There's no law that says you need to call Alert, after all.
</p>
<p>
We can't stress enough the importance of patch minimization. Relying on side effects<br>
that are undocumented, such as the fact that Alert will end up calling NewControl, may<br>
cause your application to break unexpectedly with any new system release. We found<br>
out about the above example because the Mac OS 8 Dialog Manager used its new modern<br>
mechanisms within Alert. To maintain compatibility with this application, we had to<br>
back off from this and revert to the existing mechanisms. In many key areas, Apple<br>
can't innovate as much as developers would like because of the behaviors of many<br>
existing applications.
</p>
<p>
<b>FACTOR YOUR APPLICATION</b>
</p>
<p>
As has been common for some time with cross-platform development, it's a useful<br>
exercise to separate your application into several distinct parts in preparation for<br>
Mac OS 8. At least two of these parts should be the user interaction component and the<br>
compute engine component. Separating all Macintosh-specific calls such as disk access<br>
and networking into modules may also be helpful.
</p>
<p>
Mac OS 8 provides several new facilities to make factoring your application easier.<br>
Tasking and synchronization services provided by the system allow you to divide<br>
computation into several tasks, resulting in greatly improved CPU usage. Unlike the<br>
Thread Manager, Mac OS 8's new tasking services provide preemptive multitasking. In<br>
addition, the Apple event mechanism has been significantly improved in both<br>
performance and functionality. The Apple Event Manager can be called by both<br>
preemptive and cooperative tasks, and is the preferred method of communication<br>
among an application's factored tasks.
</p>
<p>
The reasons for factoring your application are twofold. First, the separation will allow<br>
you to more easily bridge the gap between your Mac OS 8 source base and your System<br>
7 source base. You could separate your core functionality (such as an image processing<br>
algorithm) from your user interface code, thereby allowing you to write a new Mac OS<br>
8-savvy user interaction module. Or, under Mac OS 8, you could choose to run your<br>
image processing module preemptively in another task. This modularity could make it<br>
possible to substitute Mac OS 8-specific file system calls, for example, to achieve<br>
better throughput.
</p>
<p>
The second reason has a more immediate payoff. Factoring your application will help<br>
make it scriptable and recordable with AppleScript. With Mac OS 8, the event routing<br>
mechanism will change from a polling to a delivery mechanism, with high-level<br>
synthetic events being produced from lower-level user actions. This new model is just<br>
a short step from a System 7 AppleScript-recordable application.
</p>
<p>
<b>USE STANDARD DEFINITION PROCEDURES WHEREVER POSSIBLE</b>
</p>
<p>
With Mac OS 8, the Macintosh user experience will get a major facelift. Any number of<br>
user-selectable themes can be chosen to alter the appearance of windows, menus, and<br>
controls. Some examples of theme-specific windows are shown in Figure 9.
</p>
<p>
<img src="img/204.gif" width="600 px"></img>
</p>
<p>
<b>Figure 9.</b> Theme-specific windows
</p>
<p>
As you can see, the appearance of themes can vary greatly. The big compatibility<br>
challenge here is that many developers have lost patience with Apple in the area of<br>
user interface look enhancements, and have implemented their own unique application<br>
appearances already. A user who switches the theme on his or her Macintosh will<br>
expect the appearance of all applications to change. The new Apple-supplied<br>
theme-specific appearances are tied to Apple-standard Toolbox definition procedures.<br>
If an application developer uses a custom 3D button or checkbox, it will look the same<br>
no matter which theme is selected. Needless to say, this can create combinations no<br>
graphic artist would ever approve of.
</p>
<p>
To prevent this situation, we're suggesting that you avoid using custom WDEFs, CDEFs,<br>
and MDEFs wherever possible, and if you must use them for competitive reasons, give<br>
the user the option of turning them off to revert to the system appearance. We realize<br>
that there are some cases where Apple doesn't provide a look that meets your needs,<br>
and in these cases custom definition procedures will still need to be used. Apple has<br>
provided some additional definition procedures recently, such as the floating palette<br>
window WDEF 124 with System 7.5 (note that this WDEF doesn't provide the floating<br>
behavior, only the correct appearance).
</p>
<p>
<b>USE OPEN TRANSPORT WHEN AVAILABLE</b>
</p>
<p>
Open Transport is the native networking stack for Mac OS 8. The traditional Device<br>
Manager AppleTalk and MacTCP calls are still supported for backward compatibility,<br>
but for maximum networking performance with Mac OS 8, Open Transport should be<br>
used directly. By adopting a factored approach to your application, you should be able<br>
to support both Open Transport and the traditional APIs in a single binary.
</p>
<p>
<b>SUPPORT QUICKDRAW GX PRINTING</b>
</p>
<p>
The native printing implementation for Mac OS 8 is based on QuickDraw GX, although<br>
the non-GX printing API is supported for compatibility. This means that your<br>
application is much more likely to print faster and more reliably if you support the<br>
QuickDraw GX printing API. Again, it's fairly easy to maintain support for both<br>
traditional and QuickDraw GX print loops -- and again, traditional printing calls are<br>
supported for backward compatibility. (See the article "Adding QuickDraw GX Printing<br>
to QuickDraw Applications" in <i>develop</i>Issue 19.)
</p>
<p>
<b>USE THE LOW-MEMORY ACCESSORS</b>
</p>
<p>
With the advent of the Power Macintosh, new calls were added to provide access to<br>
supported low-memory locations. By migrating to the LMGet/LMSet accessor functions<br>
today, you can be assured that you aren't relying on any undocumented low-memory<br>
globals. The existing LMGet/LMSet calls will eventually be migrated to the individual<br>
owner components, where they'll be made into full-fledged API calls, and their<br>
connection with low memory will be broken. Note that in Mac OS 8, the LMGet/LMSet<br>
calls still do access the global low-memory area.
</p>
<p>
<b>BE VIRTUAL MEMORY FRIENDLY</b>
</p>
<p>
In the instruction manuals of many popular Macintosh software applications, you'll<br>
find the directive to turn virtual memory off for optimal performance. This is not an<br>
option for Mac OS 8, but fortunately the memory usage of the system and the virtual<br>
memory architecture have been substantially improved for much better performance.<br>
Given that virtual memory is always on, competing with it by designing your own<br>
virtual memory system would be unwise. If you have your own memory management<br>
system, count on doing some performance tuning once you get your application up and<br>
running.
</p>
<p>
<b>LOCATE SPECIAL FOLDERS WITH FINDFOLDER</b>
</p>
<p>
This tip is along the lines of the "System 7 and later" directive above. FindFolder,<br>
which has been available since System 7, can be used to locate the System Folder,<br>
Preferences folder, Extensions folder, and other system-created folders. A corollary<br>
of this guideline is always to store all user-specific preference information in the<br>
Preferences folder. By using FindFolder and correctly storing your preferences, you'll<br>
be compatible with the workspaces mechanism in Mac OS 8, which allows different<br>
system users to have their own sets of application settings.
</p>
<p>
<b>USE DEBUGGING VERSIONS OF SYSTEM COMPONENTS</b>
</p>
<p>
Several portions of the system are already available in debugging versions. These<br>
special versions will flag questionable behaviors, allowing you to correct problems<br>
that would otherwise go undetected. Currently, debugging versions of both the Modern<br>
Memory Manager and QuickDraw GX are available for use with System 7.5. These tools<br>
should save valuable time in the Mac OS 8 application debugging process.
</p>
<p>
<b>SPECIFY YOUR STACK SIZE IN THE CODE FRAGMENT RESOURCE</b>
</p>
<p>
If your application needs additional stack space above and beyond the default stack size,<br>
it should use the application stack size field provided in the code fragment ('cfrg')<br>
resource. Calls to GetApplLimit and SetApplLimit have no effect on PowerPC-native<br>
applications in Mac OS 8. Applications compiled for 680x0 systems should still use<br>
these calls to adjust their stack size.
</p>
<p>
<b>PREPARE FOR MAC OS 8 MEMORY MANAGEMENT</b>
</p>
<p>
A major problem for Macintosh applications, in terms of both performance and<br>
efficiency, is the way that they manage memory. The Macintosh Memory Manager,<br>
whose fundamental structure was designed for the original 128K Macintosh, is<br>
woefully out of date, especially when used in Mac OS 8's demand-paged virtual memory<br>
environment.
</p>
<p>
To address this problem, the Mac OS 8 designers have provided two new ways to<br>
manage memory. For developers who don't want to redesign their memory usage model,<br>
a transitional API, based on a subset of the old Memory Manager entry points, is<br>
provided. Developers who are fully adopting Mac OS 8 APIs can use a completely new,<br>
modern memory management service. You won't have to adopt any new memory<br>
management techniques to make your application compatible with Mac OS 8; not<br>
adopting them just means that your application won't benefit from memory<br>
enhancements such as unbounded application heaps.
</p>
<p>
To prepare your application for Mac OS 8 from a memory management standpoint, you<br>
should avoid certain uses of the Memory Manager. Some steps you can take today are<br>
listed below; this list is not exhaustive, and you may need to do additional work to take<br>
advantage of the transitional API.
</p>
<ul>
<li>Don't dispose of pointers and handles that are allocated indirectly<br>
by the Toolbox. For example, don't call DisposeHandle on a control allocated<br>
with NewControl.</li>
<li>Don't access handles, pointers, or heap zones outside the<br>
application heap or system heap.</li>
<li>Don't allow application plug-ins to call the Memory Manager<br>
directly. Instead, have them call back into the application to manage memory.<br>
This way, you can be sure any plug-ins for your application also follow the<br>
new Memory Manager requirements.</li>
<li>Avoid allocating memory in the system heap or in temporary<br>
memory. Temporary memory is still supported for compatibility, but the<br>
transitional memory API is based on the classic Memory Manager API, which<br>
doesn't encompass temporary memory.</li>
<li>Avoid or abstract the use of the following Memory Manager calls,<br>
which will all be unsupported in the transitional memory API: InitApplZone,<br>
SetApplBase, InitZone, GetApplLimit, SetApplLimit, MaxApplZone,<br>
MoreMasters, NewHandleSys, NewHandleSysClear, NewEmptyHandleSys,<br>
HandleZone, RecoverHandle, NewPtrSys, NewPtrSysClear, PtrZone, FreeMem,<br>
MaxMem, CompactMem, ReservMem, PurgeMem, TopMem, GrowZoneProcs,<br>
and PurgeProcs.</li>
</ul>
<h2>UNSUPPORTED BEHAVIORS UNDER MAC OS 8</h2>
<p>
We're making every effort to maintain compatibility with existing applications for the<br>
Mac OS 8 release, but unfortunately we're not able to support some behaviors that may<br>
work under current system releases. We're trying to get the word out early on these<br>
unsupported behaviors so that developers have plenty of time to correct the problems.
</p>
<p>
<b>DON'T USE ASLM</b>
</p>
<p>
The Apple Shared Library Manager is not available under Mac OS 8. Applications that<br>
rely on ASLM as a shared library mechanism or to maintain plug-ins will need to be<br>
redesigned. If an object-oriented shared library mechanism is still required, SOM<br>
should be used; in cases where object-oriented interfaces aren't necessary, the Code<br>
Fragment Manager can be used.
</p>
<p>
<b>DON'T ACCESS THE TRAP TABLE DIRECTLY</b>
</p>
<p>
Some applications access the trap table directly, either to call traps without going<br>
through the trap dispatcher or to apply patches. This is no longer allowed, since under<br>
Mac OS 8 the trap table is no longer maintained by the same mechanism. Attempts to<br>
write to or read from the trap table directly will not produce the expected results. An<br>
example of code that won't work is shown in Listing 2.
</p>
<p>
<b>Listing 2.</b> Unsupported trap table access<p class="spacer">&nbsp;</p>
</p>
<pre>// UNSUPPORTED!
void PatchSysBeep(void)
{
   long   trapTableBase, sysBeepOffset, *sysBeepAddress;
  
   (void) Gestalt(gestaltToolboxTable, &amp;trapTableBase);
   sysBeepOffset = (_SysBeep &amp; 0x03ff) * sizeof(long);
   sysBeepAddress = (long *) (trapTableBase + sysBeepOffset);
   *sysBeepAddress = (long) MySysBeep;
}</pre>
<p class="spacer">&nbsp;</p>
<p>
<b>DON'T USE A GNEFILTER TO INTERCEPT EVENTS GLOBALLY</b>
</p>
<p>
A common programming technique under System 7 is to install a GetNextEvent filter<br>
procedure into the GNEFilter low-memory location (0x29A). This behavior is<br>
documented in the Macintosh Technical Note "GetNextEvent; Blinking Apple Menu" (TB<br>
11). Mac OS 8 supports the GNEFilter mechanism on a per-context basis only. The<br>
code in Listing 3 shows a sample GNEFilter faceless background application that beeps<br>
whenever a key is pressed. Under Mac OS 8, this code would not work, since<br>
background applications don't receive key-down events, and a GNEFilter installed by a<br>
particular application is called only for events received by that application.
</p>
<p>
<b>Listing 3.</b> An unsupported GetNextEvent filter procedure<p class="spacer">&nbsp;</p>
</p>
<pre>// UNSUPPORTED!
GNEFilterUPP   gOldGNEFilter;
Boolean         gContinue;

void main(void)
{  
   EventRecord   ev;

   gContinue = true;  
   gOldGNEFilter = LMGetGNEFilter();
   LMSetGNEFilter(NewGetNextEventFilterProc(MyEventFilter));
   while (gContinue)
      WaitNextEvent(everyEvent, &amp;ev, 60, NULL);
   LMSetGNEFilter(gOldGNEFilter);
   ExitToShell();
}

void MyEventFilter(EventRecord *theEvent, Boolean *result)
{
   if (theEvent-&gt;what == keyDown) {
      SysBeep(1);
      if (theEvent-&gt;modifiers &amp; controlKey) {
         gContinue = false;
      }
   }
   CallGetNextEventFilterProc(gOldGNEFilter, theEvent, result);
}</pre>
<p class="spacer">&nbsp;</p>
<p>
<b>DON'T CALL PPOSTEVENT</b>
</p>
<p>
Some pre-Mac OS 8 applications post fake keyboard or mouse events into the event<br>
queue with PPostEvent. The call works by posting an empty event into the application's<br>
event queue and returning a pointer to that queue element. PPostEvent is not supported<br>
under Mac OS 8, since the Event Manager no longer maintains the event queue in this<br>
way. The code in Listing 4 shows a typical use of PPostEvent.
</p>
<p>
<b>Listing 4.</b> An unsupported PPostEvent call
</p><p class="spacer">&nbsp;</p>
<pre>// UNSUPPORTED!
void PostMouseDown(Point *mouseDownPoint)
{
   EvQElPtr   eventQueueElement;
  
   (void) PPostEvent(mouseDown, 0, &amp;eventQueueElement);
   eventQueueElement-&gt;evtQWhere = *mouseDownPoint;
}</pre>
<p class="spacer">&nbsp;</p>
<p>
<b>DON'T ACCESS PRIVATE TRAPS OR PRIVATE LOW MEMORY</b>
</p>
<p>
As we've been warning developers for years, relying on private traps and private<br>
low-memory globals can cause compatibility problems for applications. All private<br>
traps have been removed from the Mac OS 8 trap table, since the system software no<br>
longer calls other services via the trap mechanism. This means that any emulated<br>
application that calls a private trap, or any native application that calls<br>
GetTrapAddress on a private trap and then CallUniversalProc on that address, will<br>
break under Mac OS 8. (See Listing 5.)
</p>
<p>
<b>Listing 5. </b>Calling private traps in an unsupported way
</p><p class="spacer">&nbsp;</p>
<pre>// UNSUPPORTED!
#if GENERATING680x0
   extern pascal OSErr InitDogCow(short moofCount)
      ONEWORDINLINE(0xA89F);

   void main(void)
   {
      (void) InitDogCow(2);
   }
  
#else
   enum {
      uppInitDogCowProcInfo = kPascalStackBased
         | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))
         | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(short)))
   };
  
   void main(void)
   {
      UniversalProcPtr   initDogCowUPP;
     
      initDogCowUPP = GetToolboxTrapAddress(_InitDogCow);
      (void) CallUniversalProc(initDogCowUPP,
          uppInitDogCowProcInfo, 2);
   }
#endif</pre>
<p class="spacer">&nbsp;</p>
<p>
<b>DON'T LINK AGAINST PRIVATEINTERFACELIB</b>
</p>
<p>
Enterprising Macintosh hackers have realized that there's a CFM library on the<br>
PowerPC processor-based Macintosh systems named PrivateInterfaceLib. This library<br>
contains CFM entry points for private system calls. Under Mac OS 8,<br>
PrivateInterfaceLib no longer exists. Applications that link against<br>
PrivateInterfaceLib will not work under Mac OS 8.
</p>
<p>
<b>DON'T ACCESS CERTAIN PUBLIC LOW-MEMORY GLOBALS</b>
</p>
<p>
Certain public low-memory globals are no longer supported under Mac OS 8. If a<br>
low-memory global is no longer supported, accessing it should be benign. For<br>
example, the low-memory global AuxWinHead is no longer used by the Window<br>
Manager, so calling LMGetAuxWinHead will return NULL.
</p>
<p>
<b>DON'T RELY ON FILE SYSTEM HOOKS OR PATCHES</b>
</p>
<p>
The existing file system hooks ExtFSHook and FSQueueHook are not supported under<br>
Mac OS 8. In addition, patching the existing API as documented in Inside Macintosh:<br>
Files is allowed from within an application, but the patch will only affect file system<br>
calls made from within the cooperative task of the application.
</p>
<p>
<b>DON'T USE COMPRESSED RESOURCES</b>
</p>
<p>
Compressed resources may not be supported by the Mac OS 8 Resource Manager, so<br>
your application and its files should not contain any compressed resources. The<br>
resource compression mechanism has never been public and should be avoided.
</p>
<p>
<b>DON'T ALLOCATE ALL OF TEMPORARY MEMORY</b>
</p>
<p>
Since Mac OS 8 is a demand-paged system, it grows the virtual memory space as<br>
necessary to accommodate additional applications or memory allocations. For this<br>
reason, asking how much temporary memory is available and then allocating all of it,<br>
or all but a certain amount, is a bad idea. This would just consume all your available<br>
disk space, giving you far more memory than you wanted.
</p>
<p>
<b>DON'T ALLOCATE ALL HARD DRIVE SPACE</b>
</p>
<p>
Similarly, allocating all hard drive free space is a bad idea, since you may be<br>
consuming all possible storage for virtual memory swap space, and this will<br>
immediately lead to major system problems.
</p>
<p>
<b>DON'T SHARE TOOLBOX STRUCTURES BETWEEN APPLICATIONS</b>
</p>
<p>
With the Mac OS 8 release, Apple is beginning to partition applications from one<br>
another. Although applications still run in the same address space, the individual Mac<br>
OS 8 managers maintain structures on a per-application basis. For this reason,<br>
creating a menu, for example, in one application and attaching it to the menu bar in<br>
another application will not work correctly under Mac OS 8. The same is true for<br>
other system structures, such as windows, dialogs, controls, resource refNums, file<br>
refNums, and working directory IDs, among others. Memory Manager structures such<br>
as handles and pointers can still be shared across applications.
</p>
<p>
<b>DON'T HARD-CODE FONT USAGE</b>
</p>
<p>
Mac OS 8 allows users to customize the system's appearance. Among the settings they<br>
control is which font to use for the system font and for the application font. For this<br>
reason, applications should use the calls GetSysFont and GetAppFont instead of<br>
hard-coding font selections (to, for example, Chicago 12).
</p>
<p>
<b>DON'T WRITE TO YOUR APPLICATION'S DATA FORK</b>
</p>
<p>
Many existing applications prompt users for their name and serial number the first<br>
time the application is launched. Several PowerPC-native applications store this<br>
information directly into the application's data fork, while the application is running.<br>
Under pre-Mac OS 8 systems, this is allowed because of a loophole in the system<br>
software. Under Mac OS 8, PowerPC-native applications are always file-mapped read<br>
only with exclusive access. This means that an application will get an error from the<br>
file system when it tries to open its data fork with write access. Instead, applications<br>
should store their personalization information in either a resource or a preferences<br>
file. If this information must be stored in the data fork, it will need to be written by<br>
another application, such as the Installer.
</p>
<p>
<b>DON'T ACCESS HARDWARE DIRECTLY</b>
</p>
<p>
Some applications access hardware directly under pre-Mac OS 8 systems. With Mac OS<br>
8, only applications executing in supervisor mode, such as drivers, may access<br>
hardware. This limitation greatly improves system stability. An example of<br>
unsupported hardware access is an application that accesses the GPI serial pin directly<br>
to detect phone rings.
</p>
<p>
<b>DON'T ASSUME THE SYSTEM STATE IN NOTIFICATION MANAGER</b><br>
<b>COMPLETION ROUTINES</b>
</p>
<p>
Some developers have noticed that when a Notification Manager completion routine is<br>
called, they can make certain assumptions about the state of the system. For example,<br>
they assume that the routine will always be called in the context of the frontmost<br>
application, and they either access that application's window list or create a window or<br>
dialog of their own (as shown in Listing 6). Under Mac OS 8, these assumptions are no<br>
longer true.
</p>
<p>
<b>Listing 6.</b> Unsupported Notification Manager hacking
</p><p class="spacer">&nbsp;</p>
<pre>// UNSUPPORTED!
NMRec      gNMRec;

void PostWindowInFrontApplication(void)
{
   gNMRec.qType = nmType;
   gNMRec.nmMark = 0;
   gNMRec.nmIcon = NULL;
   gNMRec.nmSound = NULL;
   gNMRec.nmStr = NULL;
   gNMRec.nmResp = NewNMProc(HackResponseRoutine);
   gNMRec.nmRefCon = GetCurrentA5();
   (void) NMInstall(&amp;gNMRec);
}

pascal void HackResponseRoutine(NMRecPtr nmReqPtr)
{
   long        savedA5;
   WindowPtr   aWindow;
   Rect        bounds;
   Str32       windowTitle;
   (void) NMRemove(nmReqPtr);
  
   savedA5 = SetA5(nmReqPtr-&gt;nmRefCon);
   BlockMoveData("\pSurprise!", windowTitle, 10);
   SetA5(savedA5);
   bounds.top = bounds.left = 40;
   bounds.bottom = bounds.right = 350;
   aWindow = NewWindow(NULL, &amp;bounds, windowTitle, true, documentProc,
      (WindowRef)-1L, true, 0);
}</pre>
<p class="spacer">&nbsp;</p>
<p>
<b>DON'T CHANGE THE WINDOW LIST DIRECTLY</b>
</p>
<p>
Before Mac OS 8, the Window Manager didn't support floating windows. Some<br>
developers implemented floating windows by manipulating the window list directly<br>
rather than calling the Window Manager API. Under Mac OS 8, the Window Manager<br>
maintains the window list separately from the nextWindow field, so changing this field<br>
directly will cause problems. Instead, BringToFront and SendBehind should be used to<br>
maintain the window list. See the article "Floating Windows: Keeping Afloat in the<br>
Window Manager" in <i>develop</i> Issue 15 if you need to maintain floating windows on<br>
pre-Mac OS 8 systems.
</p>
<p>
<b>DON'T SET THE GLOBAL SHARE BIT IN A CFM LIBRARY THAT CONTAINS</b><br>
<b>CODE</b>
</p>
<p>
Linking against a per-context library from within a global library can create<br>
problems for that per-context library. The per-context library may end up with a<br>
different copy of its per-context globals than it expects. To avoid this problem, you<br>
should never set the global share bit in any CFM library that contains code. If you need<br>
to maintain systemwide global data, you should do so in a separate library that only<br>
contains data and doesn't link against any other libraries.
</p>
<p>
With the initial Power Macintosh system software, the InterfaceLib CFM shared<br>
library had its data section globally shared across all applications. Under Mac OS 8,<br>
however, the notion of CFM per-context data is used widely by all system components.<br>
For example, the File Manager tracks which files each application has opened via<br>
per-context globals in the Files shared library.
</p>
<p>
The global share bit is accessible in Metrowerks CodeWarrior from the "share data<br>
section" checkbox in the PPC Pef preferences pane, and from the -s option in the<br>
MakePef MPW tool.
</p>
<p>
<b>DON'T RELY ON THE STRUCTURE OF SYSTEM MEMORY</b>
</p>
<p>
Relying on information such as where certain code is loaded or where memory is<br>
allocated may cause compatibility problems under Mac OS 8. The relative locations of<br>
the system heap, application heap, and application stacks may change. For example, if<br>
you assume that loaded CFM data will appear in your application heap, and check a<br>
pointer to that data against the heap's boundaries, your application will not work<br>
properly.
</p>
<p>
<b>DON'T RELY ON AOCE INTERFACES</b>
</p>
<p>
Not all currently available AOCE interfaces may be available under Mac OS 8. Because<br>
of this, if you use AOCE in your application, you should be sure to weak-link against<br>
the AOCE library, and check Gestalt for the availability of any AOCE features.
</p>
<h2>SUPPORTED BUT DISCOURAGED BEHAVIORS</h2>
<p>
Some questionable techniques are still supported under Mac OS 8 to maintain<br>
compatibility with existing applications. Although supported, they're discouraged from<br>
use and may not continue to be compatible with future system software releases.
</p>
<p>
There's also a new concept in Macintosh programming called <i>deprecation</i>, whereby<br>
certain API calls are discouraged from use in preparation for their future removal;<br>
see "Deprecation" for more about this.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______________________________
</p>
<h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DEPRECATION</h2>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In many areas of the Mac OS 8 system, new API calls have been provided to<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace existing mechanisms. For example, the files API described in Inside<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Macintosh: Files was designed with the old pre-Mac OS 8 interrupt model in<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mind and does not translate well to usage in a preemptive environment. For<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this reason, a new File Manager API has been introduced for Mac OS 8. The old<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;files API is still available, but it's deprecated, meaning that it's no longer the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preferred way of performing file system operations. In fact, new technical<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;documentation that replaces the old Inside Macintosh will not include<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;references to deprecated calls.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In the universal interfaces, several preprocessor definitions can be used to<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;control API availability. By setting either of these first two, your application<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;can still access functions that have been deprecated:
</p>
<ul>
<li style="margin-left: 44px">BUILDING_FOR_SYSTEM7 -- Code is intended to run on a System<br>
7 machine or earlier.</li>
<li style="margin-left: 44px">BUILDING_FOR_SYSTEM7_AND_SYSTEM8 -- Code is intended to<br>
run on System 7 or Mac OS 8.</li>
</ul>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setting either of the following means that deprecated calls will not be available<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to your application:
</p>
<ul>
<li style="margin-left: 44px">BUILDING_FOR_SYSTEM8 -- Code is intended to run on Mac OS 8<br>
only.</li>
<li style="margin-left: 44px">BUILDING_PREEMPTIVE_CODE -- Code is intended to run as a Mac<br>
OS 8 server or driver.</li>
</ul>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______________________________
</p>
<p>
<b>DRAWING TO THE SCREEN DIRECTLY</b>
</p>
<p>
Applications that write directly to the base address of the screen will continue to work<br>
properly under Mac OS 8. As before, ShieldCursor and ShowCursor should be used to<br>
ensure that the mouse pointer isn't overwritten; for more on this, see the Graphical<br>
Truffles column in develop Issue 11. Also see the Graphical Truffles column in this<br>
issue (Issue 26) of develop for some additional warnings about writing directly to the<br>
screen.
</p>
<p>
<b>PATCHING WITHIN AN APPLICATION</b>
</p>
<p>
Although existing INITs aren't supported, patching within an application is still<br>
allowed, via both SetTrapAddress and the new patch library mechanism. As mentioned<br>
above in the "Preparing for Mac OS 8 Today" section, you should try to minimize your<br>
use of patching, since it lowers overall system reliability and introduces<br>
compatibility risks.
</p>
<p>
<b>ACCESSING MEMORY IN OTHER APPLICATIONS</b>
</p>
<p>
Some applications may pass pointers to data to each other through Apple events, Gestalt<br>
routines, or other means. This is definitely not the recommended way of exchanging<br>
data between applications, because in future system software releases each application<br>
will run in its own protected address space. However, since under Mac OS 8 all<br>
traditional applications (not servers or drivers) run in the same address space,<br>
sharing data across applications is supported. If it's absolutely necessary for two<br>
applications to share memory, allocating the memory in the system heap will enhance<br>
future compatibility.
</p>
<p>
<b>READING OR WRITING LOW MEMORY DIRECTLY</b>
</p>
<p>
Some developers aren't using the LMSet/LMGet accessor functions from within their<br>
PowerPC-native applications. Since under Mac OS 8 the LMSet/LMGet calls still<br>
change low-memory locations, writing and reading directly from low memory is still<br>
supported; however, it will stop working in future releases.
</p>
<p>
<b>USING A CUSTOM MBDF</b>
</p>
<p>
As stated in Inside Macintosh: Macintosh Toolbox Essentials on page 3-87, Apple<br>
recommends that you always use the standard menu bar definition procedure. Under<br>
Mac OS 8, custom MBDFs are supported to a limited extent only. Your custom MBDF<br>
will be called only to process requests not related to drawing. The current theme, as<br>
selected by the user, maintains control of the menu bar and menu border appearances.
</p>
<p>
<b>PATCHING TOOLBOX DEFINITION PROCEDURES</b>
</p>
<p>
Some developers have discovered that it's possible to customize the behavior of<br>
windows, menus, or controls without writing an entire custom WDEF, MDEF, or CDEF.<br>
Instead, they write handlers for only the definition procedure messages they want to<br>
customize (wDraw for WDEFs, for example) and then call back into the standard<br>
definition procedure for all other messages.
</p>
<p>
Although not in the original spirit of the Toolbox design, this behavior is supported<br>
under Mac OS 8. "Stub" definition procedures have been provided for all standard<br>
WDEFs, CDEFs, and MDEFs (and the standard MBDF), which call back into the<br>
appropriate Toolbox managers to finish the definition procedure processing.
</p>
<h2>CASE STUDIES IN (IN)COMPATIBILITY</h2>
<p>
In the process of getting existing applications running on Mac OS 8, we've come across<br>
some interesting bugs in shipping applications that may provide insight to other<br>
developers. Not all of these bugs prevent the applications from running, but some do.
</p>
<p>
Of course, Apple cares about its developers, so the names have been omitted to protect<br>
the guilty. When we find a bug in an application, we're sure to let the application<br>
developer know so that it can be corrected in the next version. In any case, it's<br>
interesting what you find when you rewrite the system from scratch.
</p>
<p>
<b>FAILING TO CALL INITDIALOGS</b>
</p>
<p>
This application was crashing when it displayed a Standard File dialog. After much<br>
debugging, we realized that when the Standard File dialog was displayed, it contained<br>
several ParamText strings, even though ParamText had never been called. Further<br>
analysis led us to discover that the Dialog Manager had garbage values for the<br>
ParamText strings, and accessing these strings caused a crash. We finally determined<br>
that the Mac OS 8 Dialog Manager initialized these ParamText strings in InitDialogs,<br>
which the application did not call.
</p>
<p>
<b>FAILING TO CALL INITMENUS</b>
</p>
<p>
This application always crashed when it tried to draw the menu bar. After some poking<br>
around, we figured out that it was assuming that InitWindows called InitMenus as a<br>
side effect. The completely new Mac OS 8 implementations of windows and menus no<br>
longer have this behavior.
</p>
<p>
<b>ACCESSING LOCATION 0</b>
</p>
<p>
This application accessed location 0 by accident, treating it as a pointer to a C string.<br>
At startup, due to an obscure bug in their C++ code structure, the developers passed<br>
NULL as the parameter to a routine expecting a string. They then tried to copy this<br>
string to another buffer, which was 240 bytes in length. Under System 7.5, it just so<br>
happens that there's usually a 0 byte in the first 240 bytes of memory (some of the<br>
ROM vectors contain 0 bytes). Under Mac OS 8, the low-memory globals area<br>
contains, by default, -1 (0xFF) in every location, so there were no 0 bytes to be<br>
found. The string copy overwrote the buffer and crashed the machine.
</p>
<p>
<b>CALLING SETITEMMARK WITH NULL</b>
</p>
<p>
During launch, this application was accidentally calling SetItemMark on a NULL<br>
MenuHandle. It turns out that the developers iterated one item too far in a list of<br>
menus. Under System 7.5, there's an undocumented check in the Menu Manager that<br>
exits if the menu is NULL. The Mac OS 8 Menu Manager, written to the Inside<br>
Macintosh spec, didn't have this check. This led to a crash, until the check was added<br>
back into the Mac OS 8 code.
</p>
<p>
<b>CREATING MENUS WITHOUT THE MENU MANAGER</b>
</p>
<p>
This application cached the contents of the Font menu across launches. It stored this<br>
information in a resource, but not one of type 'MENU'. To read the cached information<br>
back, it called GetResource on this resource and then called CountMenuItems on the<br>
handle. The Menu Manager had no idea that this was a menu, since it wasn't created<br>
with either NewMenu or GetMenu.
</p>
<p>
<b>TREATING ROM85 AS A POINTER</b>
</p>
<p>
Within a WDEF, this application checked to see which version of the ROM was installed<br>
by checking the low-memory global ROM85. Unfortunately, the developers accessed<br>
ROM85 as if it were a pointer to a ROM version number, but in reality it's a value, not<br>
a pointer. This caused them to dereference 0x3FFF, which on Mac OS 8 was not a<br>
mapped memory address.
</p>
<p>
<b>CALLING OPENSLOTSYNC BY ACCIDENT</b>
</p>
<p>
This application, which was converted to PowerPC code from 680x0 assembly, called<br>
OpenSlotSync when it instead meant to call HOpenSync. The reason for the confusion<br>
was that both calls use exactly the same trap word (0xA200) but don't share the same<br>
CFM entry point. The 680x0-to-PowerPC converter converted A200 to OpenSlotSync,<br>
while the application wanted HOpenSync.
</p>
<h2>MAC OS 8 COMPATIBILITY STARTS TODAY</h2>
<p>
Using the techniques and guidelines outlined in this article, application developers<br>
should be able to begin working toward 100% Mac OS 8 compatibility immediately. By<br>
laying the groundwork for compatibility early, you'll find the preliminary releases of<br>
Mac OS 8 much more valuable, and you'll be able to concentrate on adding great new<br>
functionality to your software.
</p>
<p>
Compatibility is one of the critical factors for Mac OS 8's success in the marketplace.<br>
We're counting on developers to help us ensure that Mac OS 8 compatibility is not<br>
simply a promise, but also a reality.
</p>



<b>RELATED READING</b>
<ul>
<li>"Copland: The Mac OS Moves Into the Future" by Tim Dierks,<br>
<i>develop</i> Issue 22.</li>
<li><i>Designing PCI Cards and Drivers for Power Macintosh Computers</i><br>
(Apple Computer, 1995). This book is available through the Apple<br>
Developer Catalog.</li>
</ul>



<p>
<b>STEVE FALKENBURG</b> has worked on Mac OS 8 for several different groups at Apple,<br>
starting with being the Mac OS 8 liaison in Developer Technical Support, then moving<br>
into the Mac OS 8 High-Level Toolbox group, and finally finding a home in the Mac OS<br>
8 Program Office Engineering Team. Steve is hoping to help ship Mac OS 8 without<br>
changing offices or groups again; then he plans to take a long vacation with his wife,<br>
Nancy, that doesn't involve computers or moving boxes.*
</p>
<p>
Thanks to our technical reviewers Ken Bereskin, Paul Black, Jeff Cobb, Sharon<br>
Everson, Winston Hendrickson, Matt Mora, and Mike Neil.*
</p>
</body>
</html>
