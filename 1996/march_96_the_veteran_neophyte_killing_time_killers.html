<!DOCTYPE html>
<html>
<head>
<!-- Article ID: 16 - Extracted from develop-1996 -->
<!-- on 2025-01-18 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by the copyright of its respective owners -->
<title>March 96 - THE VETERAN NEOPHYTE: Killing Time Killers</title>
<link href="../common/styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h1>THE VETERAN NEOPHYTE: Killing Time Killers</h1>
<h2>Bo3b Johnson</h2>
<p>
<img src="img/184.gif" width="126 px"></img>
</p>
<p>
So I'm sitting at my desk, mouse in hand, digging through the guts of my Mac, trying to<br>
track down yet another pathetic bug. The only trouble is, this is getting dull. I've done<br>
it a thousand times, and I always win; it's just a question of how much time the old ball<br>
and chain is going to eat up this time. Worse, the wind is blowing 20 knots right<br>
outside my window, and for the windsurfers in the crowd, you know the exquisite<br>
torture of good wind that you aren't allowed to transform into mind-blowing speed.
</p>
<p>
Maybe for you it's that you'd like to get home to see your insanely great mate. Or<br>
you've got kids whose names you can't pronounce. It's even likely that some of you just<br>
graduated from college and are still astonished that they pay you for something that's<br>
so much fun. But you're thinking, "If I can get this bug fixed quickly, I can get back to<br>
writing that rad Marathon hack to make the other net players slower than me."<br>
Perhaps your boss has started to notice that you spend a lot of time on the job but you<br>
don't really get very much done. Getting a little nervous? What if he's thinking of<br>
pulling the plug on your baby because you're too slow?
</p>
<p>
Or maybe you shipped the 1.0 version, but it had a few too many bugs, and<i>MacWEEK</i><br>
was so incensed that they broke with the tradition of objective journalism and are<br>
calling for your head. People who bought your software with actual money have been<br>
calling every day, filling your answering machine with unveiled threats. It seems that<br>
you left a bug in there that just cost several thousand people each about two weeks of<br>
valuable time, reentering their data.
</p>
<p>
In particular, recognize that the wasted time from programming errors and bugs gets<br>
exponentially more expensive the further into the process you get. If I make a syntax<br>
error, I just fix it and recompile. If I toss buggy code over the fence to the testers, now<br>
I'm wasting <i>their</i> time. If I ship software with occasional crashing bugs that I just<br>
can't quite track down, I'm wasting thousands of people's time.
</p>
<p>
The point is, there are lots of ways to waste time while programming. I'm here today to<br>
offer some ideas on how to save time through better programming habits, so that you<br>
can take up windsurfing, or maybe the electric guitar, or learn how to pronounce your<br>
kids' names, or gain "the power to crush the other kids" while playing Marathon.<br>
Whenever I mention windsurfing, substitute your favorite quality-of-life enhancer.
</p>
<p>
I'll use some real life examples, and we'll see what sorts of lessons we can learn from<br>
them. I've categorized these ideas in three ways. First, there are some obvious time<br>
wasters that can be eradicated; these aren't really bug related, just daily time wasters.<br>
Considering how much time bugs cost, the second category consists of high-value rules<br>
that can find bugs quickly and painlessly. Finally, there are the super-value rules that<br>
prevent bugs from happening at all. Be sure to consider how these ideas might apply in<br>
your specific circumstances.
</p>
<h2>RIGOROUS, YET REUSABLE</h2>
<p>
OK, I'm in the midst of writing the MMU tables for Blat, and I realize that I've already<br>
got a similar table. Not being a fool, I know not to rewrite code I've already written, so<br>
I open that file and casually copy and paste the table into my current work. Oh no, not<br>
another copy and paste casualty! Apparently I missed changing those two table entries,<br>
and with MMU tables that means the machine hangs before MacsBug loads. Seems like<br>
every time I paste in code there's something I miss, making it not compile -- or<br>
worse, causing a malfunction.
</p>
<p>
Even with small chunks of code, I've found it helps to review the pasted code line by<br>
line, carefully, and not to assume that since it ran before, it'll run now. Some subtle<br>
assumptions may have changed, and even though reusing code is certainly superior to<br>
writing it again, don't be misled into thinking this is risk free. A more powerful<br>
technique is to seriously modularize code, so that when I copy and paste I take an entire<br>
routine, not just a few lines. With a well-defined interface, the chances of blowing it<br>
are greatly reduced. This means adopting the habit of writing each routine with the<br>
idea that I'm going to reuse it later. This radically improves every routine I write.
</p>
<p>
New rule: Reuse code modules, not code fragments. If the code has to be altered, inspect<br>
it as if it were new (which it is).
</p>
<h2>VERBOSE, YET LUCID</h2>
<p>
While in the guts of Font/DA Mover, I ran across some very strange code that didn't<br>
make any sense to me at all -- and it wasn't documented. It was never executed as far<br>
as I could determine, but I painstakingly figured out that it was looking for System file<br>
3.2 and, if found, would patch the OS to fix a font bug. I would have saved a full day of<br>
effort had there been a comment in that funny little splat of code. Like I'm supposed to<br>
know what the bugs in System 3.2 are off the top of my head?
</p>
<p>
&nbsp;&nbsp;Comments really are necessary to make code reusable and maintainable. I always<br>
write "strategy" comments, which say what the routine is trying to do, and avoid<br>
writing "tactical" comments, like what it's doing line by line. Remember, sometimes<br>
the time savings occur in the future, not at the moment. I've found that skipping<br>
comments is being penny wise and pound foolish. Usually the strategy comments help<br>
clarify my thinking on the routine as well, so there actually is a short-term gain.
</p>
<p>
New rule: Always write strategy comments. It's possible to decipher intent from the<br>
code, but why not just explicitly say it?
</p>
<h2>PLUMP, YET HONED</h2>
<p>
I used to think it was important to save every line of assembly code that was possible.<br>
The first program I wrote for the Mac was Anaclock, an analog clock program, and I<br>
remember thinking that if I changed the order of some routines I could save code. Don't<br>
we all get into that mode sometimes? If I just change these two lines, I can save an<br>
assignment, and blah blah. It must come from the old 128K Macs and Apple IIs.
</p>
<p>
&nbsp;&nbsp;Well, guess what? These machines are so stuffed full of junk nowadays that saving<br>
just one or two lines is as meaningless an effort as trying to decide how many demons<br>
fit on the head of a transistor. Worse, I spent my own valuable time deciding something<br>
that has zero impact. Sorry, no can do anymore. My philosophy now is: write it<br>
straightforward, easy to read, vanilla. I want to save my windsurfing time, not pretend<br>
that I know up front what needs optimizing. In the Anaclock example, the computer had<br>
an entire second between screen updates. When I actually measured execution time, all<br>
the time was spent in CopyBits updating the screen, and waiting in the main event loop<br>
for the next second to arrive. There was zero measurable time in my entire clock<br>
calculation and offscreen drawing code.
</p>
<p>
New rule: No premature optimization. Measure with performance tools first. Then<br>
optimize only where it counts.
</p>
<h2>TEMPERAMENTAL, YET DISCRIMINATING</h2>
<p>
During System 7 development, we once tracked down a bug, taking seven hours in the<br>
middle of the night to find it, and it wound up being a bad parameter passed to a ROM<br>
routine. Incredibly, I could have found that bug in about 15 seconds if I'd used the<br>
Discipline tool. Nowadays, I never debug something by hand unless it has passed all the<br>
debugging tools that Fred Huxham and I talked about in our article in <i>develop</i> Issue 8.
</p>
<p>
There are lots and lots of tools available now, and I use all of them. I don't care how<br>
hard they are to use; if they can find a bug in seconds that might take me hours or days,<br>
then I win. This includes such notorious tools as Blat and Jasik's debugger. I know<br>
Blat's a pain, since it doesn't work on all machines, but hey, it's too valuable to skip.<br>
Same with Jasik's debugger. Sure it's confusing, but it's got features no one else<br>
provides. Before throwing the software over to the testers, I make sure it passes all<br>
the tools.
</p>
<p>
High-value rule: Use the best tools, all the time. Don't spend time in a debugger when a<br>
test tool will hand you the answer on a silver platter.
</p>
<h2>SPECULATIVE, YET REWARDING</h2>
<p>
As part of a contract, my job was to make a program to save, print, and display 300<br>
dpi bitmaps that were scanned in from a fax machine through new hardware. This was<br>
to be a low-cost scanner, and my software would be the initial scan-and-display code.<br>
Nothing too fancy, but it still required basic functionality. I bid 15 hours for the<br>
entire program. Was I crazy? Well, of course, but not for this reason. I used MacApp<br>
to give me the application functionality, and the FracApp300 sample program was a<br>
good starting point for 300 dpi bitmap handling. All I really did was add an object to<br>
talk to the scanning hardware, and I came in under bid!
</p>
<p>
Sometimes learning those new tough coding tools can really pay off. I generally try to<br>
sample every new tool and coding advance that comes along to see if it can help me save<br>
time. MacApp was clearly a massive win, because it focused my programming onto<br>
teensy parts to be added instead of all the Toolbox calls of a typical application. In<br>
addition, it was fully debugged and very robust, giving me a more solid final<br>
application. I try not to be wedded to any given style or approach; I just want to use the<br>
best stuff currently available.
</p>
<p>
High-value rule: Try new things. New ideas, approaches, tools, and programming<br>
styles can be like winning the free-time lottery.
</p>
<h2>PAVLOVIAN, YET TRAINABLE</h2>
<p>
Sometimes it takes a while to recognize bad habits for what they are. While writing<br>
Bowser, which turned into Mouser and then MacBrowser, I wrote the source code<br>
parser by hand, to look for keywords. This was not a good strategy. It was quick and<br>
dirty, and stayed dirty, and was less quick all the time. It would be reasonable to<br>
expect that after modifying the parser for the eighth or ninth time to handle some<br>
stupid language exception, I would have gotten a clue that this was not the right<br>
approach. The right answer was to learn how the lex and yacc tools worked, since<br>
parsers for both Object Pascal and C++ already existed in that format.
</p>
<p>
&nbsp;&nbsp;After seeing similar bugs go by several times, it becomes clear that something must<br>
be done to stop that kind of bug. I don't want to spend time fixing the same problem<br>
over and over again, so now my goal is to permanently fix bugs so that they can't<br>
happen again. By this I mean changing how I do things, so that that specific bug will<br>
either be caught quickly or never happen again. It can be as simple as adding a test to a<br>
test suite to ensure that bugs of that form are caught immediately, or adding an assert<br>
to catch that error. Or it can be as hard as changing my programming habits to never<br>
use pointer math. Whatever it takes, I try to learn from each bug and make sure it<br>
can't happen again. Especially after I've done something twice, it's time to write a tool<br>
to fix that problem.
</p>
<p>
High-value rule: Learn from mistakes. If my dog gets bonked on the nose every time he<br>
gets near the door, he learns to avoid the door. I want to be at least as smart as my dog.
</p>
<h2>FASTIDIOUS, YET NOBLE</h2>
<p>
Another slant on the Bowser problem is that I wasn't really trying to make the parser<br>
right. If I'd been a little more quality conscious, I wouldn't have gone that route,<br>
because it was clear that the hand-built parser was clunky. As noted before, the longer<br>
a bug survives, the more expensive it will be. Early bug extinction is my goal, so I<br>
consciously try to write with quality in mind. Examples are: using the strictest coding<br>
rules, not using any tricky features of the compiler, using type-suggestive variable<br>
names, insisting on type checking, not using raw pointer variables, avoiding type<br>
coercion, adopting a simple easy-to-read style, writing clear module interfaces, and<br>
using full warnings in the compiler.
</p>
<p>
Since I started noticing how much time bugs cost, I've changed my mindset on them. I<br>
no longer automatically accept that code will just have bugs. I hate 'em. I want to kill<br>
'em. Better, I want to kill 'em before they hatch. Since they take up my personal time,<br>
I feel it's only proper to take it personally when they show up.
</p>
<p>
Super-value rule: Write with quality in mind. As they say, the inner game of<br>
programming is <i>so</i> important.
</p>
<h2>UGLY, YET EVOLVED</h2>
<p>
Once upon a time, I was asked to fix a couple of bugs in Font/DA Mover and make it<br>
work with TrueType fonts, as an interim solution before System 7. The program was<br>
so disgusting to me that I just had to go in and clean it up. Move this here, change these<br>
names, document some pieces, take out the redundant code, modularize some pieces --<br>
ah, how aesthetically pleasing. Oops . . . I just introduced a couple of bugs while I was<br>
"improving" the code. It felt like progress, but actually it was just motion. You know,<br>
like company reorgs.
</p>
<p>
&nbsp;&nbsp;What to do? Don't "improve" code, unless it's never been debugged. Any fully debugged<br>
code, no matter how shoddily written, is superior to newly written code, no matter<br>
how pristine. It went against my grain, but the right answer was to leave it gross. That<br>
heavily used Font/DA Mover code had thousands of hours of value in it, with literally<br>
millions of testers, that were all lost when I rewrote it. Rewriting it took time that I<br>
wanted to spend on something more valuable, like fixing the last few remaining bugs<br>
-- and then getting outside and windsurfing! Once I rewrote the code, it was like a new<br>
program, and thus needed a full development/testing/debugging cycle. I backed off to an<br>
earlier "skanky" version and just debugged that.
</p>
<p>
Super-value rule: Never rewrite something that's been fully tested. It may be ugly,<br>
but evolution is on its side.
</p>
<h2>BORING, YET ELEGANT</h2>
<p>
We all know about the "cool" things that C can do, and some tricky ways of using it, but<br>
sometimes isn't it a bit like juggling live weasels? When I found that using a #define<br>
had added an extra unwanted character to each place I used it, it no longer seemed so<br>
clever, and felt more like I was playing tricks on myself. Or how about that favorite of<br>
putting an actual assignment in an if statement? It's cleverly camouflaged, but there<br>
aren't any natural predators here, so I'm not sure this is needed. These simple<br>
examples obviously don't do justice to the possible tricks that we've all seen, but they<br>
all cost time and rarely add value.
</p>
<p>
OK, so it's clear that being "clever" often winds up being a way to play tricks on<br>
myself. Is there anything wrong with doing it simply, in a straightforward, vanilla<br>
style? I know for sure I'll get it done sooner and, even better, the programmer who<br>
has to maintain this code won't have to waste a bunch of time understanding mindless<br>
tricks (remembering of course that that maintenance programmer might very well be<br>
me, two years after I forgot what tricks I was playing). And let's just forget the<br>
malarkey about it saving code. Is it really worth saving 10 whole bytes out of a 16 meg<br>
machine, at the expense of wasting my time? I want to count cycles and bytes only in<br>
places where it makes a measurable difference.
</p>
<p>
Super-value rule: Write vanilla code. Doing it simply, and the same way each time,<br>
also makes it more likely to be correct.
</p>
<h2>ASSERTIVE, YET FRIENDLY</h2>
<p>
Back in the deep dark Macintosh past, I wrote the driver for an external RAM disk<br>
called DASCH. This high-speed serial link required some different debugging tactics<br>
than I'd used previously, because I couldn't step through the code; it was time critical.<br>
Any slight perturbation in speed would overrun and cause an error, but I still needed<br>
to debug it. It was like a "look Mom, no hands" type of debugging. Code inspection is OK,<br>
but I wanted to be sure it worked as I read it. Have you ever read a piece of code that<br>
took a branch you didn't expect?
</p>
<p>
The answer, although I didn't use the name at the time, was to use asserts. These have<br>
been talked about a fair amount, and you've probably used primitive asserts under the<br>
name of DebugStr. Nowadays, the most powerful combination I've used is to hook<br>
together asserts with a failure handler like MacApp's catch/fail mechanism. Asserts<br>
make it easy to build a debug-only version that checks every stupid thing that can go<br>
wrong and lets me know right up front during testing, but doesn't compile into the<br>
final version. The catch/fail stuff makes it easy to handle every possible error in a<br>
graceful way. (See the article "Using C++ Exceptions in C" in this issue.)
</p>
<p>
If something absolutely positively cannot fail, I use a debugging-version assert to<br>
catch the occasional times when it does fail, so that I can surprise myself early and not<br>
spend hours tracking down the "impossible" error. One great thing to check with<br>
asserts is input parameters, to catch those inevitable times when some routine passes<br>
in rubbish.
</p>
<p>
Super-value rule: Use asserts along with a failure handler. Catching bugs as they<br>
happen is vastly superior to backtracking 15 miles after the program crashes.
</p>
<h2>ENDING, YET BEGINNING</h2>
<p>
I'm not going to pretend that this is all there is to the idea of saving time, but hopefully<br>
the idea seems worth pursuing. It has certainly helped me get better at my carving<br>
jibes and, not incidentally, better at programming at the same time. Higher-quality<br>
code, fewer bugs, earlier ship dates, happier customers, and more free time. Yup, I'd<br>
say it's been worth it. If you've got some additional time-saving ideas, I'd naturally be<br>
interested in trying them too, so write me at bo3b@rahul.net.
</p>
<p>



<b>RECOMMENDED READING</b>
</p>
<ul>
<li><i>Writing Solid Code</i> by Steve Maguire (Microsoft Press, 1993).</li>
<li><i>Debugging the Development Process</i> by Steve Maguire (Microsoft Press,<br>
1995).</li>
<li>"Macintosh Debugging: A Weird Journey Into the Belly of the Beast" by<br>
Bo3b Johnson and Fred Huxham, <i>develop</i> Issue 8, and "Macintosh Debugging:<br>
The Belly of the Beast Revisited" by Fred Huxham and Greg Marriott, develop<br>
Issue 13.</li>
<li><i>Zen and the Art of Windsurfing</i> by Frank Fox (Amberco Press, 1988).</li>
</ul>
<p>
<b>BO3B JOHNSON</b> (bo3b@rahul.net) is completely whacked out about windsurfing,<br>
and takes summers off in order to windsurf every day. But since it's winter, he's doing<br>
consulting so that he can pay for his next windsurf board and windsurf trip to Aruba.<br>
Bo3b prefers to be addressed as "Bob," since the 3 is silent.*
</p>
<p>
Where's Dave? That other Johnson, who usually writes this column, is probably at the<br>
public library researching his obsession du jour, taking his dogs for very long walks,<br>
or reclining on the couch reading a book. Since he's cut back his working hours, we're<br>
having guest Neophytes write this column. We can't promise they'll all be Johnsons,<br>
however.*
</p>
<p>
Thanks to Jeff Barbose, Jim Friedlander, Brian Hamlin, Fred Huxham, Dave Johnson,<br>
Jim Reekes, and Patty Walters for their terribly helpful review comments.*
</p>
</body>
</html>
