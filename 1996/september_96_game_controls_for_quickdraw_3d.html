<!DOCTYPE html>
<html>
<head>
<!-- Article ID: 41 - Extracted from develop-1996 -->
<!-- on 2025-01-18 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by the copyright of its respective owners -->
<title>September 96 - Game Controls for QuickDraw 3D</title>
<link href="../common/styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h1>Game Controls for QuickDraw 3D</h1>
<h2>Philip McBride</h2>
<p>
<img src="img/256.gif" width="197 px"></img>
</p>
<p>
<i style="font-size:125%;">Whether the user is navigating a starship or examining a model of</i>
<br>

<i style="font-size:125%;">the DNA helix, your first-person 3D application must allow user</i>
<br>

<i style="font-size:125%;">control of the camera movements in a scene. You must keep</i>
<br>

<i style="font-size:125%;">changing the camera's position and orientation in response to what</i>
<br>

<i style="font-size:125%;">the user wants to see. Here you'll learn how to create those camera</i>
<br>

<i style="font-size:125%;">movements and handle the user's directions. As part of the bargain,</i>
<br>

<i style="font-size:125%;">you'll even get a refresher course in the associated geometry.</i>
</p>
<p>
Letting the user control the movement of the camera (and thus the view) is critical to<br>
first-person interactive 3D games and extremely useful in 3D modeling systems.<br>
Through QuickDraw 3D's camera functions and supporting mathematical functions, you<br>
can create game controls that direct the position and orientation of a camera. In<br>
general, game controls take user input from any input device and control the camera in<br>
ways that emulate movements of players, such as people or aircraft. Game controls are<br>
useful for any type of 3D viewer application, including 3D Internet browsers.
</p>
<p>
You'll start your career as a camera operator by learning about the basic moves you<br>
can make with the camera. Then you'll create the various camera movements, keep the<br>
camera movements smooth, and translate user inputs to move the camera. The sample<br>
code (which is provided on this issue's CD) is a 3D viewer application with camera<br>
movements activated by the keyboard or the mouse. In all of the code, the geometry has<br>
been kept as simple as possible, but if you need to brush up, you'll find a refresher<br>
course on calculating points and vectors in 3D space.
</p>
<p>
For an overview of QuickDraw 3D, turn to "QuickDraw 3D: A New Dimension for<br>
Macintosh Graphics" in <i>develop</i> Issue 22. That article discusses topics like reading<br>
models, using a viewer, creating a camera, and managing documents that have 3D<br>
information. To learn more about those and related topics, see the list of recommended<br>
reading at the end of this article.
</p>
<h2>MOVING THE CAMERA</h2>
<p>
We'll be controlling camera movements based on first-person viewing, so the camera<br>
will be our eyes. But before we move through a scene, let's take a look at the kind of<br>
camera moves we plan to use. The camera movements you would create in a 3D game<br>
for a person who is driving a vehicle or walking on level ground are examples of<br>
ground movements. These camera moves include moving forward, backward, sideways<br>
to the left, and sideways to the right, plus turning to the left (pan or yaw left) and<br>
turning to the right (pan or yaw right). Figure 1 illustrates these basic ground<br>
movements.
</p>
<p>
<img src="img/257.gif" width="540 px"></img>
</p>
<p>
<b>Figure 1.</b> Ground movements
</p>
<p>
You can also go airborne with a variety of camera movements. These fancier camera<br>
moves are changes that might be typical of an aircraft. They include ascending and<br>
descending (moving upward and downward), pitching (tilting) up and down, and<br>
rolling (tilting) left and right. Figure 2 illustrates these moves.
</p>
<p>
<img src="img/258.gif" width="600 px"></img>
</p>
<p>
<b>Figure 2.</b> Air movements
</p>
<p>
Now to the fun part -- let's get that camera moving! What you must do to achieve the<br>
previously described camera movements, both ground and air, involves some<br>
geometry. If you're like most of us and have forgotten your 3D geometry, see "3D<br>
Geometry 101" for a refresher course. The 3D geometry for our camera moves is<br>
quite simple; it will stick to the kinds of calculations illustrated in "3D Geometry<br>
101."
</p>
<p>
First, let's take a look at our world. In Figure 3, we have an object in the world<br>
coordinate system and a camera looking at the object. The camera has its own<br>
coordinate system defined by its location (in world coordinates), up vector, and point<br>
of interest.
</p>
<p>
<img src="img/259.gif" width="330 px"></img>
</p>
<p>
<b>Figure 3.</b> Our world
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______________________________
</p>
<p>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3D GEOMETRY 101</b>
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you're new to 3D programming (and perhaps a little rusty on your math),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;here's a brief introduction to some of the 3D concepts you'll find in this<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;article's code.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A point is represented in 3D space by x, y, and z values in a coordinate system.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A vector is a magnitude (length) and direction; it's represented by an initial<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;point (usually the origin of the coordinate system) and a final point {x, y, z}.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Figure 4 illustrates a point and a vector in 3D space.
</p>
<p>
<img style="margin-left: 43px;"  src="img/260.gif" width="252 px"></img>
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Figure 4.</b> A point and a vector in 3D space
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To add a vector and a point, you place the vector's initial point on that point<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(keeping the vector's direction and magnitude). The new final point of the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moved vector is the point resulting from the addition. (See Figure 5.)
</p>
<p>
<img style="margin-left: 43px;"  src="img/261.gif" width="318 px"></img>
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Figure 5.</b> Adding a vector and a point
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To subtract a vector from a point, you place the vector's final point on that<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;point (keeping the vector's direction and magnitude). The new initial point of<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the moved vector is the result (Figure 6).
</p>
<p>
<img style="margin-left: 43px;"  src="img/262.gif" width="312 px"></img>
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Figure 6.</b> Subtracting a vector from a point
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To create a vector between two points, you subtract the vectors defined by the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;points (called position vectors). To do this, you first reverse (turn around)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the second vector and place its initial point on the final point of the first<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vector. Then you make a new vector from the first vector's initial point to the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;second vector's new final point. This new vector has the direction and<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;magnitude of the vector between the two points (Figure 7).
</p>
<p>
<img style="margin-left: 43px;"  src="img/263.gif" width="300 px"></img>
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Figure 7.</b> Creating a vector between two points
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A translation of a point or a vector by Tx, Ty, and Tz values moves the point or<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the vector by adding the T values to its own values (Figure 8).
</p>
<p>
<img style="margin-left: 43px;"  src="img/264.gif" width="300 px"></img>
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Figure 8.</b> Translating a point or a vector by T
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In Figure 8, the translation value T is really from the translation part of a<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transformation matrix. A transformation matrix is used to transform a point<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;or a vector by translation, rotation, and scaling. The transformation matrix<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;you use is 4 x 4 -- with the upper-left 3 x 3 portion acting as the rotation<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matrix, the bottom-left 1 x 3 portion acting as the translation matrix, and the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;top-left to bottom-right diagonal of the rotation matrix acting as the scaling<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matrix. The following transformation matrix has elements labeled for<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;translation (T), rotation (R), and scaling (S). The fourth column is ignored<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for simplicity.
</p>
<p>

        <p style="margin-left: 43px;">
            <math>
                <mrow>
                    <mo>{</mo>
                    <mtable>
                        <mtr>
                            <mtd>
                                <mrow>
                                    <msub>
                                        <mi>S</mi>
                                        <mn>x</mn>
                                    </msub>
                                    <mo>*</mo>
                                    <msub>
                                        <mi>R</mi>
                                        <mrow>
                                            <mn>0</mn>
                                            <mo>,</mo>
                                            <mn>0</mn>
                                        </mrow>
                                    </msub>
                                </mrow>
                            </mtd>
                            <mtd>
                                <mrow>
                                    <msub>
                                        <mi>R</mi>
                                        <mrow>
                                            <mn>0</mn>
                                            <mo>,</mo>
                                            <mn>1</mn>
                                        </mrow>
                                    </msub>
                                </mrow>
                            </mtd>
                            <mtd>
                                <mrow>
                                    <msub>
                                        <mi>R</mi>
                                        <mrow>
                                            <mn>0</mn>
                                            <mo>,</mo>
                                            <mn>2</mn>
                                        </mrow>
                                    </msub>
                                </mrow>
                            </mtd>
                            <mtd>
                                <mn>0</mn>
                            </mtd>
                        </mtr>
                        <mtr>
                            <mtd>
                                <mrow>
                                    <msub>
                                        <mi>R</mi>
                                        <mrow>
                                            <mn>1</mn>
                                            <mo>,</mo>
                                            <mn>0</mn>
                                        </mrow>
                                    </msub>
                                </mrow>
                            </mtd>
                            <mtd>
                                <mrow>
                                    <msub>
                                        <mi>S</mi>
                                        <mn>y</mn>
                                    </msub>
                                    <mo>*</mo>
                                    <msub>
                                        <mi>R</mi>
                                        <mrow>
                                            <mn>1</mn>
                                            <mo>,</mo>
                                            <mn>1</mn>
                                        </mrow>
                                    </msub>
                                </mrow>
                            </mtd>
                            <mtd>
                                <mrow>
                                    <msub>
                                        <mi>R</mi>
                                        <mrow>
                                            <mn>1</mn>
                                            <mo>,</mo>
                                            <mn>2</mn>
                                        </mrow>
                                    </msub>
                                </mrow>
                            </mtd>
                            <mtd>
                                <mn>0</mn>
                            </mtd>
                        </mtr>
                        <mtr>
                            <mtd>
                                <mrow>
                                    <msub>
                                        <mi>R</mi>
                                        <mrow>
                                            <mn>2</mn>
                                            <mo>,</mo>
                                            <mn>0</mn>
                                        </mrow>
                                    </msub>
                                </mrow>
                            </mtd>
                            <mtd>
                                <mrow>
                                    <msub>
                                        <mi>R</mi>
                                        <mrow>
                                            <mn>2</mn>
                                            <mo>,</mo>
                                            <mn>1</mn>
                                        </mrow>
                                    </msub>
                                </mrow>
                            </mtd>
                            <mtd>
                                <mrow>
                                    <msub>
                                        <mi>S</mi>
                                        <mn>z</mn>
                                    </msub>
                                    <mo>*</mo>
                                    <msub>
                                        <mi>R</mi>
                                        <mrow>
                                            <mn>2</mn>
                                            <mo>,</mo>
                                            <mn>2</mn>
                                        </mrow>
                                    </msub>
                                </mrow>
                            </mtd>
                            <mtd>
                                <mn>0</mn>
                            </mtd>
                        </mtr>
                        <mtr>
                            <mtd>
                                <mrow>
                                    <msub>
                                        <mi>T</mi>
                                        <mn>x</mn>
                                    </msub>
                                </mrow>
                            </mtd>
                            <mtd>
                                <mrow>
                                    <msub>
                                        <mi>T</mi>
                                        <mn>y</mn>
                                    </msub>
                                </mrow>
                            </mtd>
                            <mtd>
                                <mrow>
                                    <msub>
                                        <mi>T</mi>
                                        <mn>z</mn>
                                    </msub>
                                </mrow>
                            </mtd>
                            <mtd>
                                <mn>1</mn>
                            </mtd>
                        </mtr>
                    </mtable>
                    <mo>}</mo>
                </mrow>
            </math>
        </p>
    
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When you apply a transformation to a point or a vector, you multiply by the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matrix, as in the following formula for our point {x, y, z} and a<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transformation matrix:
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[{Sx*R0,0*x&nbsp;&nbsp;+&nbsp;&nbsp;R1,0*y&nbsp;&nbsp;+&nbsp;&nbsp;R2,0*z&nbsp;&nbsp;+&nbsp;&nbsp;Tx},<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{R0,1*x&nbsp;&nbsp;+&nbsp;&nbsp;Sy*R1,1*y&nbsp;&nbsp;+&nbsp;&nbsp;R2,1*z&nbsp;&nbsp;+&nbsp;&nbsp;Ty},<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{R0,2*x&nbsp;&nbsp;+&nbsp;&nbsp;R1,2*y&nbsp;&nbsp;+&nbsp;&nbsp;Sz*R2,2*z&nbsp;&nbsp;+&nbsp;&nbsp;Tz}]
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;As you can see from this formula, if you only want the matrix to apply a<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;translation (the T's), the 3 x 3 rotation matrix will be all 0's except for the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scaling diagonal, which will be all 1's.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A <b>rotation</b> of a vector through an arbitrary angle about different axes will<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use various R elements (the 3 x 3 rotation matrix of the transformation<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matrix), depending on which axis you're rotating about. For rotations<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;of<i>[[theta]]</i> about the x axis, you get the matrix
</p>
<p>

        <p style="margin-left: 43px;">
            <math>
                <mrow>
                    <mo>{</mo>
                    <mtable>
                        <mtr>
                            <mtd>
                                <mn>1</mn>
                            </mtd>
                            <mtd>
                                <mn>0</mn>
                            </mtd>
                            <mtd>
                                <mn>0</mn>
                            </mtd>
                        </mtr>
                        <mtr>
                            <mtd>
                                <mn>0</mn>
                            </mtd>
                            <mtd>
                                <mrow>
                                    <mo>cos</mo>
                                    <mi>&theta;</mi>
                                </mrow>
                            </mtd>
                            <mtd>
                                <mrow>
                                    <mo>sin</mo>
                                    <mi>&theta;</mi>
                                </mrow>
                            </mtd>
                        </mtr>
                        <mtr>
                            <mtd>
                                <mn>0</mn>
                            </mtd>
                            <mtd>
                                <mrow>
                                    <mo>-sin</mo>
                                    <mi>&theta;</mi>
                                </mrow>
                            </mtd>
                            <mtd>
                                <mrow>
                                    <mo>cos</mo>
                                    <mi>&theta;</mi>
                                </mrow>
                            </mtd>
                        </mtr>
                    </mtable>
                    <mo>}</mo>
                </mrow>
            </math>
        </p>
    
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For rotations about the z axis, you get
</p>
<p>

        <p style="margin-left: 43px;">
            <math>
                <mrow>
                    <mo>{</mo>
                    <mtable>
                        <mtr>
                            <mtd>
                                <mrow>
                                    <mo>cos</mo>
                                    <mi>&theta;</mi>
                                </mrow>
                            </mtd>
                            <mtd>
                                <mrow>
                                    <mo>sin</mo>
                                    <mi>&theta;</mi>
                                </mrow>
                            </mtd>
                            <mtd>
                                <mn>0</mn>
                            </mtd>
                        </mtr>
                        <mtr>
                            <mtd>
                                <mrow>
                                    <mo>-sin</mo>
                                    <mi>&theta;</mi>
                                </mrow>
                            </mtd>
                            <mtd>
                                <mrow>
                                    <mo>cos</mo>
                                    <mi>&theta;</mi>
                                </mrow>
                            </mtd>
                            <mtd>
                                <mn>0</mn>
                            </mtd>
                        </mtr>
                        <mtr>
                            <mtd>
                                <mn>0</mn>
                            </mtd>
                            <mtd>
                                <mn>0</mn>
                            </mtd>
                            <mtd>
                                <mn>1</mn>
                            </mtd>
                        </mtr>
                    </mtable>
                    <mo>}</mo>
                </mrow>
            </math>
        </p>
    
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;And for rotations about the y axis, you get the following matrix:
</p>
<p>

        <p style="margin-left: 43px;">
            <math>
                <mrow>
                    <mo>{</mo>
                    <mtable>
                        <mtr>
                            <mtd>
                                <mrow>
                                    <mo>cos</mo>
                                    <mi>&theta;</mi>
                                </mrow>
                            </mtd>
                            <mtd>
                                <mn>0</mn>
                            </mtd>
                            <mtd>
                                <mrow>
                                    <mo>-sin</mo>
                                    <mi>&theta;</mi>
                                </mrow>
                            </mtd>
                        </mtr>
                        <mtr>
                            <mtd>
                                <mn>0</mn>
                            </mtd>
                            <mtd>
                                <mn>1</mn>
                            </mtd>
                            <mtd>
                                <mn>0</mn>
                            </mtd>
                        </mtr>
                        <mtr>
                            <mtd>
                                <mrow>
                                    <mo>sin</mo>
                                    <mi>&theta;</mi>
                                </mrow>
                            </mtd>
                            <mtd>
                                <mn>0</mn>
                            </mtd>
                            <mtd>
                                <mrow>
                                    <mo>cos</mo>
                                    <mi>&theta;</mi>
                                </mrow>
                            </mtd>
                        </mtr>
                    </mtable>
                    <mo>}</mo>
                </mrow>
            </math>
        </p>
    
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;So to apply a rotation about an axis, you simply multiply the appropriate<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rotation matrix by the vector. In Figure 9, the vector on the right is rotated<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;90deg. about the <b>z</b> axis in the <b>{x, y}</b> plane.
</p>
<p>
<img style="margin-left: 43px;"  src="img/269.gif" width="222 px"></img>
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Figure 9.</b> Rotating a vector about an axis
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______________________________
</p>
<p>
We'll be dealing with the vectors making up the camera's coordinate system for many<br>
of our movement functions, so let's keep these in our application's document structure.<br>
We'll keep the camera placement data there as well.
</p>
<p>
The document structure looks like this:
</p>
<pre>typedef struct _DocumentRecord {
   ...
   TQ3Point3D      cameraLocation;
   TQ3Point3D      pointOfInterest;
   TQ3Vector3D      xVector;
   TQ3Vector3D      yVector;      // up vector
   TQ3Vector3D      zVector;
   ...
} DocumentRecord, *DocumentPtr;</pre>
<p class="spacer">&nbsp;</p>
<p>
The first time we set up our camera, we'll set the values in our document to<br>
correspond to the initial camera position. Then with each subsequent movement of the<br>
camera, we'll update these fields. The initial camera data is constructed by the code in<br>
Listing 1. In the function MyGetCameraData, we do some of our geometric calculations<br>
to get the x and z vectors. We subtract the two endpoints (the initial and final points)<br>
of the z vector to get that vector. And we get the x vector by cross-multiplying the y<br>
and z vectors.
</p>
<p>
______________________________
</p>
<p class="spacer">&nbsp;</p>
<p>
<b>Listing 1.</b> Initializing the camera data
</p>
<pre>void MyGetCameraData(DocumentPtr theDocument,
     TQ3CameraObject theCamera)
{
   TQ3CameraPlacement   cameraPlacement;

   // Get the camera data.
   Q3Camera_GetPlacement(theCamera, &amp;cameraPlacement);

   // Set the document's camera data.
   theDocument-&gt;cameraLocation = cameraPlacement.cameraLocation;
   theDocument-&gt;pointOfInterest = cameraPlacement.pointOfInterest;
   theDocument-&gt;yVector = cameraPlacement.upVector;

   // Calculate the x and z vectors and assign them to the document.
   Q3Point3D_Subtract(&amp;theDocument-&gt;pointOfInterest,
      &amp;theDocument-&gt;cameraLocation, &amp;theDocument-&gt;zVector);
   Q3Vector3D_Cross(&amp;theDocument-&gt;zVector,
      &amp;theDocument-&gt;yVector, &amp;theDocument-&gt;xVector);
}</pre>
<p class="spacer">&nbsp;</p>
<p>
______________________________
</p>
<p>
After the fields in our document have been updated by some camera movement function,<br>
we'll want to reset the camera to that new data with the function MySetCameraData<br>
(Listing 2).
</p>
<p>
______________________________
</p>
<p class="spacer">&nbsp;</p>
<p>
<b>Listing 2.</b> Setting the camera data after a move
</p>
<pre>void MySetCameraData(DocumentPtr theDocument,
     TQ3CameraObject theCamera)
{
   TQ3CameraPlacement   cameraPlacement;

   // Set the camera placement data.
   cameraPlacement.cameraLocation = theDocument-&gt;cameraLocation;
   cameraPlacement.pointOfInterest = theDocument-&gt;pointOfInterest;
   cameraPlacement.upVector = theDocument-&gt;yVector;

   // Set the camera data to the camera.
   Q3Camera_SetPlacement(theCamera, &amp;cameraPlacement);
}</pre>
<p class="spacer">&nbsp;</p>
<p>
______________________________
</p>
<p class="spacer">&nbsp;</p>
<p>
With that camera infrastructure, we're ready to move the camera around a bit. You can<br>
find the code for all the moves on this issue's CD. Here you'll find only the code for<br>
those movements that are unique. Code for those moves not shown (but previously<br>
mentioned) is almost identical to one of the functions shown in the listings.
</p>
<p>
To move the camera along the z axis either forward or backward, we call the function<br>
MyMoveCameraZ (Listing 3). This function translates the camera location and point of<br>
interest by the given delta. Note that the associated z vector isn't changed.
</p>
<p class="spacer">&nbsp;</p>
<p class="spacer">&nbsp;</p>
<p class="spacer">&nbsp;</p>
<p>
______________________________
</p>
<p class="spacer">&nbsp;</p>
<p>
<b>Listing 3.</b> Moving the camera along the z axis
</p>
<pre>void MyMoveCameraZ(DocumentPtr theDocument, float dZ)
{
   TQ3ViewObject      theView;
   TQ3CameraObject   theCamera;
   TQ3Vector3D         scaledVector;
   TQ3Point3D         newPoint;

   // Get the view and the camera objects.
   theView = theDocument-&gt;theView;
   Q3View_GetCamera(theView, &amp;theCamera);

   // Scale the y vector to make it dY longer.
   Q3Vector3D_Scale(&amp;theDocument-&gt;yVector,
      dY/Q3Vector3D_Length(&amp;theDocument-&gt;yVector),
      &amp;scaledVector);
   // Move the camera position and direction by the new vector.
   Q3Point3D_Vector3D_Add(&amp;theDocument-&gt;cameraLocation,
      &amp;scaledVector, &amp;newPoint);
   theDocument-&gt;cameraLocation = newPoint;
   Q3Point3D_Vector3D_Add(&amp;theDocument-&gt;pointOfInterest,
      &amp;scaledVector, &amp;newPoint);
   theDocument-&gt;pointOfInterest = newPoint;

   // Set the updated camera data to the camera.
   MySetCameraData(theDocument, theCamera);

   // Update the view with the changed camera and dispose of the
   // camera.
   Q3View_SetCamera(theView, theCamera);
   Q3Object_Dispose(theCamera);
}</pre>
<p class="spacer">&nbsp;</p>
<p>
______________________________
</p>
<p class="spacer">&nbsp;</p>
<p>
To move the camera along the x axis (right or left ) or along the y axis (ascending or<br>
descending), you use code similar to Listing 3. The only difference is that you base the<br>
translation on the change in x or y instead of the change in z. In both cases, the<br>
associated vectors don't change.
</p>
<p>
Next, to rotate the camera right or left about the y axis, we call the function<br>
MyRotateCameraY (Listing 4). This function first creates a transformation matrix<br>
whose rotation matrix represents rotating about the y axis. It then transforms both<br>
the z and x vectors by that rotation (thus rotating those two vectors about the y axis).<br>
From the rotated z vector, we obtain the point of interest by adding the camera location<br>
to the vector.
</p>
<p>
______________________________
</p>
<p class="spacer">&nbsp;</p>
<p>
<b>Listing 4.</b> Rotating the camera about the y axis
</p>
<pre>void MyRotateCameraY(DocumentPtr theDocument, float dY)
{
   TQ3ViewObject      theView;
   TQ3CameraObject   theCamera;
   TQ3Vector3D         rotatedVector;
   TQ3Matrix4x4      rotationMatrix;

   // Get the view and the camera objects.
   theView = theDocument-&gt;theView;
   Q3View_GetCamera(theView, &amp;theCamera);

   // Create the rotation matrix for rotating about the y axis.
   Q3Matrix4x4_SetRotateAboutAxis(&amp;rotationMatrix,
      &amp;theDocument-&gt;cameraLocation, &amp;theDocument-&gt;yVector, dY);

   // Rotate the z vector about the y axis.
   Q3Vector3D_Transform(&amp;theDocument-&gt;zVector, &amp;rotationMatrix,
      &amp;rotatedVector);
   theDocument-&gt;zVector = rotatedVector;

   // Rotate the x vector about the y axis.
   Q3Vector3D_Transform(&amp;theDocument-&gt;xVector, &amp;rotationMatrix,
      &amp;rotatedVector);
   theDocument-&gt;xVector = rotatedVector;

   // Update the point of interest from the new z vector.
   Q3Point3D_Vector3D_Add(&amp;theDocument-&gt;cameraLocation,
      &amp;theDocument-&gt;zVector, &amp;theDocument-&gt;pointOfInterest);

   // Set the updated camera data to the camera.
   MySetCameraData(theDocument, theCamera);

   // Update the view with the changed camera and dispose of the
   // camera.
   Q3View_SetCamera(theView, theCamera);
   Q3Object_Dispose(theCamera);
}</pre>
<p class="spacer">&nbsp;</p>
<p>
______________________________
</p>
<p class="spacer">&nbsp;</p>
<p>
Rotating the camera about the x axis (pitching up or down) or about the z axis (rolling<br>
left or right) is similar to rotating it about the y axis. The main difference is in how<br>
the rotation matrix is constructed (from the axis in question) and which axes are<br>
rotated (the other two). The only other difference is that when rotating the camera<br>
about the z axis, you don't have to update the point of interest because it doesn't change.
</p>
<h2>SMOOTH SAILING</h2>
<p>
To see what we've done to our world, we need a rendering loop, which you'll find in the<br>
code on the CD. Since we don't do anything special in our rendering loop, we'll skip the<br>
details. For an explanation of rendering loops, see the article "QuickDraw 3D: A New<br>
Dimension for Macintosh Graphics" in develop Issue 22.
</p>
<p>
The real issue for us in viewing our camera movements is how smooth and fast those<br>
moves appear. The factors that determine how smoothly and quickly the moves work<br>
are the sizes (scales) of the deltas (the arguments to the movement functions) and the<br>
speed of the machine (and therefore the subsequent speed of the rendering loop).<br>
Adjusting for the speed of the machine is beyond the scope of this article.
</p>
<p>
The sizes of the deltas determine the size of the jumps taken by each camera movement.<br>
If the deltas are very small, the camera will move very slightly. And if these<br>
movements are repeated, the camera will appear to move slowly over time. If the<br>
deltas are large, the camera will appear to move fast.
</p>
<p>
If you move the camera too slowly, the movement will appear jumpy because the user<br>
will see the delays in rendering time. If you move the camera too fast, the movement<br>
will appear jumpy because, well, you're making the camera take big jumps. To find<br>
just the right speed, you need to experiment with the sizes of the deltas. The main<br>
thing to notice is that you should correlate the deltas to the size of the model.
</p>
<p>
Listing 5 shows how you might set up the delta multipliers (called factors here) that<br>
are used to help control movement. From the model's bounding box, the<br>
MyInitDeltaFactors function determines the size of the largest dimension. This model<br>
size is then used to generate the various factors for different movement functions.<br>
Since accelerating the movements (say, by a control key) is quite useful, this function<br>
sets that up too.
</p>
<p class="spacer">&nbsp;</p>
<p>
______________________________
</p>
<p class="spacer">&nbsp;</p>
<p>
<b>Listing 5.</b> Creating delta factors based on the model's dimensions
</p>
<pre>void MyInitDeltaFactors(DocumentPtr theDocument)
{
   TQ3BoundingBox       viewBBox;
   TQ3Vector3D            diagonalVector;
   float                  maxDimension;

   // Get the bounding box and find the scene dimension.
   MyGetBoundingBox(theDocument, &amp;viewBBox);
   Q3Point3D_Subtract(&amp;viewBBox.max, &amp;viewBBox.min,
       &amp;diagonalVector);
   maxDimension = Q3Vector3D_Length(&amp;diagonalVector);

   // Now set the delta factors.
   theDocument-&gt;xRotFactor = kXRotFactorBase * maxDimension;
   theDocument-&gt;yRotFactor = kYRotFactorBase * maxDimension;
   theDocument-&gt;zRotFactor = kZRotFactorBase * maxDimension;
   theDocument-&gt;xMoveFactor = kXMoveFactorBase * maxDimension;
   theDocument-&gt;yMoveFactor = kYMoveFactorBase * maxDimension;
   theDocument-&gt;zMoveFactor = kZMoveFactorBase * maxDimension;

   // Set up the control factor.
   theDocument-&gt;controlFactor = kControlFactorBase * maxDimension;
}</pre>
<p class="spacer">&nbsp;</p>
<p>
______________________________
</p>
<p class="spacer">&nbsp;</p>
<p>
Your mileage may vary, so it's a good idea to take your camera out for a spin and see<br>
what factors work for your application.
</p>
<h2>CONTROLLING THE CONTROLS</h2>
<p>
Now that you have the means of moving the camera this way and that, you need to have<br>
something controlling those movements. Our application will use the keyboard and the<br>
mouse.
</p>
<p>
To take input from the keyboard or the mouse, or both, we don't do anything unusual.<br>
For the keyboard, we take the key-down events as they happen and determine whether<br>
any other keys were held down at the time of the event (for multiple key inputs). For<br>
the mouse, we just continually track it.
</p>
<p>
In both cases, the user can indicate movement along more than one dimension. For<br>
example, if moving the mouse forward means "forward" and moving the mouse left<br>
means a combination of "turn left" and "roll left," a mouse movement that's both<br>
forward and to the left is a combination of three camera movements.
</p>
<p>
Based on whether the user input is simple or complex, our code makes calls to the<br>
appropriate camera movement functions. In the case of the mouse, the speed of the<br>
mouse (the difference between the last position and the current position) is also used<br>
to adjust the deltas for the camera movement. Listing 6 shows the code used for mouse<br>
tracking, but without the error handling and some details of GWorlds and local<br>
coordinates (see this issue's CD for the full source code). Here we've hard coded the<br>
meanings of the different mouse movements and control keys for simplicity. Ideally,<br>
you would have this stored in preference data that the user can set.
</p>
<p>
______________________________
</p>
<p class="spacer">&nbsp;</p>
<p>
<b>Listing 6.</b> Tracking the mouse
</p>
<pre>void MyDoMouseMove(WindowPtr theWindow, EventRecord *theEvent)
{
   DocumentPtr    theDocument;
   Point          newMouse;
   long           dx, dy, oldX, oldY;
   float          xRot, yRot;
   short          usingControl = false;

   // Get the document from the window.
   theDocument = MyGetDocumentFromWindow(theWindow);

   // Get the current mouse position.
   GetMouse(&amp;newMouse);     
   oldX = newMouse.h;
   oldY = newMouse.v;

   // If the control key is down, we're in depth mode.
   if (theEvent-&gt;modifiers &amp; controlKey)
      usingControl = true;

   // Loop, moving the camera while the mouse is down.
   while (StillDown()) {
      // Get the next mouse position.
      GetMouse(&amp;newMouse);

      // Calculate the difference from the last mouse position.
      dx = newMouse.h - oldX;
      dy = oldY - newMouse.v;
     
      // If there's some difference, move the camera.
      if ((dx != 0) || (dy != 0)) {
         // Calculate the rotation about the y axis (pan) and rotate.
         yRot = ((float) dx * (kQPi / 180.0)) / theDocument-&gt;width;
         MyRotateCameraY(theDocument,
             -yRot * theDocument-&gt;yRotFactor);

         // If the control key is down, move along the z axis;
         // otherwise, rotate about the x axis.
         if (usingControl) {
            // Move the camera along the z axis
            // (change in mouse's y).
            MyMoveCameraZ(theDocument,
                dy * theDocument-&gt;zMoveFactor);
         } else {
            // Calculate the rotation about the x axis (pitch) and
            // rotate.
            xRot = ((float) dy * (kQPi / 180.0)) /
                      theDocument-&gt;height;
            MyRotateCameraX(theDocument,
                xRot * theDocument-&gt;xRotFactor);
         }
         // Update the screen for each move.
         MyUpdateScreen(theDocument);
      }
      // Set the current mouse position as the old mouse position for
      // the next update.
      oldX = newMouse.h;
      oldY = newMouse.v;
   }
}</pre>
<p class="spacer">&nbsp;</p>
<p>
______________________________
</p>
<p class="spacer">&nbsp;</p>
<p>
The code for handling keyboard input is even simpler. See the CD for that part of the<br>
code.
</p>
<p>
Many other input devices are also applicable, especially 3D input devices. The proper<br>
way to handle such input devices is through the QuickDraw 3D Pointing Device<br>
Manager with its controllers and trackers. To use this approach, we would need to<br>
define a tracker for our camera and assign it to the available controllers. We would<br>
also change the camera movement functions so that they took deltas of both position and<br>
orientation. See the book 3D Graphics Programming With QuickDraw 3D and the<br>
Graphical Truffles column "Making the Most of QuickDraw 3D" in develop Issue 24 for<br>
more on controllers and trackers. (As of now, QuickDraw 3D doesn't have built-in<br>
controllers for the mouse and the keyboard, so this code handles them directly.)
</p>
<h2>AIMING FOR EFFICIENCY</h2>
<p>
To make the geometry and the code for this article clearer, some efficiency issues were<br>
ignored. But for most applications, the time spent in moving the camera will be<br>
minimal when compared to the time spent rendering and displaying each frame.
</p>
<p>
However, if the time used for the rendering-rastering phase is minimal and the<br>
camera movements use a more significant percentage of the total time, there are a<br>
number of solutions. The ultimate efficiency solution is to avoid making any<br>
multiplications or divisions in the camera movements by using finite differencing<br>
techniques when calculating the moves. This strategy involves keeping more<br>
information about each intermediate change and making only the incremental<br>
calculations necessary for the next move. This approach is similar to operator<br>
reductions in compilers.
</p>
<h2>MAKING YOUR NEXT MOVE</h2>
<p>
A number of applications can use game controls like those discussed here, not just<br>
first-person 3D games. Another application that's a good candidate for the kinds of<br>
game controls presented here would be a 3D Internet browser. You would want similar<br>
3D controls, but you would also want some controls for selecting Web hot spots that<br>
would take you to another 3D Web site.&nbsp;&nbsp;So now the next move is up to you.
</p>



<p>
<b>RECOMMENDED READING</b>
</p>
<ul>
<li>"QuickDraw 3D: A New Dimension for Macintosh Graphics" by<br>
Pablo Fernicola and Nick Thompson, <i>develop</i> Issue 22.</li>
<li>"Graphical Truffles: Making the Most of QuickDraw 3D" by Nick<br>
Thompson and Pablo Fernicola, <i>develop</i> Issue 24.</li>
<li><i>3D Graphics Programming With QuickDraw 3D</i> by Apple<br>
Computer, Inc. (Addison-Wesley, 1995).</li>
<li><i>Mathematical Elements for Computer Graphics</i>, 2nd Edition, by<br>
David F. Rogers and J. Alan Adams (McGraw-Hill, 1990).</li>
<li><i>Tricks of the Mac Game Programming Gurus</i> by Jamie McCornack<br>
and others (Hayden Books, 1995).</li>
</ul>



<p>
<b>PHILIP MCBRIDE</b>(mcbride@apple.com) is currently adding QuickDraw 3D and<br>
QuickTime VR to HyperCard 3.0. He used to spend time contemplating the meaning of<br>
the universe until he figured it out. Now he can be seen wandering the halls at Apple<br>
and mumbling something about needing more content. Lately, Philip has been looking<br>
into investing in anteaters after learning that a full 20% of the earth's biomass is<br>
made up of ants and termites. Just think about that overcrowding the next time<br>
someone says we don't need to invest in space travel.
</p>
<p>
<b>Thanks to</b> our technical reviewers Rick Evans, Richard Lawler, John Louch, Tim<br>
Monroe, Nick Thompson, and Dan Venolia.
</p>
</body>
</html>
