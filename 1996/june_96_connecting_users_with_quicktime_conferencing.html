<!DOCTYPE html>
<html>
<head>
<!-- Article ID: 21 - Extracted from develop-1996 -->
<!-- on 2025-01-18 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by the copyright of its respective owners -->
<title>June 96 - Connecting Users with QuickTime Conferencing</title>
<link href="../common/styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h1>Connecting Users With QuickTime Conferencing</h1>
<h2>DEAN BLACKKETTER</h2>
<p>
<img src="img/188.gif" width="233 px"></img>
</p>
<p>
<i style="font-size:125%;">QuickTime Conferencing (QTC) is a new Apple technology that helps</i>
<br>

<i style="font-size:125%;">developers add real-time sharing of sound, video, and data to their</i>
<br>

<i style="font-size:125%;">applications. This overview suggests the different ways you can</i>
<br>

<i style="font-size:125%;">use QTC to help users collaborate. The article describes the</i>
<br>

<i style="font-size:125%;">components that most developers will need to use to take</i>
<br>

<i style="font-size:125%;">advantage of QTC and discusses Watcher and Caster, two QTC</i>
<br>

<i style="font-size:125%;">applications that enable users to tune into network broadcasts and</i>
<br>

<i style="font-size:125%;">create broadcasts for others to view.</i>
</p>
<p>
Video telephones abound in science fiction movies. From Buck Rogers to Star Trek,<br>
visions of the future show people communicating visually over long distances. This<br>
futuristic technology is available to Macintosh developers and users now. QuickTime<br>
Conferencing provides a platform for developers to easily enable users to share sound,<br>
video, and data across a variety of networks.
</p>
<p>
QTC ships with selected Power Macintosh computers and with some hardware bundles,<br>
and can be licensed by developers to ship with their applications. Apple provides a<br>
basic videoconferencing application, Apple Media Conference (AMC), and developers<br>
are encouraged to create QTC applications that interoperate with AMC and add cool new<br>
collaborative features.
</p>
<p>
This article will give you background information on the QTC architecture, tell you<br>
about the components that make up that architecture, and then describe in detail the<br>
workings of two simple QTC applications, Watcher and Caster, that enable the user to<br>
watch audio and video and to broadcast them onto a network. This issue's CD contains<br>
the source code for these applications as well as the QTC documentation and the<br>
extension and header files.
</p>
<h2>QUICKTIME CONFERENCING -- THE BIG PICTURE</h2>
<p>
QuickTime Conferencing provides a platform for building Macintosh applications that<br>
can send and receive audio, video, and data between computers connected on a network.<br>
QTC supports basic two-way audio communication and a video "telephone" type of<br>
connection, and it supports a wide variety of other models as well. One of the goals of<br>
QTC is to provide developers with a set of tools that make it easy to add real-time<br>
media sharing across a number of different kinds of networks.
</p>
<p>
&nbsp;&nbsp;This opens up the possibility of adding sound and video to multiuser applications<br>
where it would have been prohibitively difficult before -- and these don't have to be<br>
conventional telephony-style applications. Imagine a flight simulator that allows you<br>
to talk with your fellow squadron members, or a groupware document-markup<br>
application that lets your fellow editors see your expression upon examining the latest<br>
changes. Picture a regional educational system that enables dozens of students to tune<br>
into an 8 A.M. lecture from their dorm rooms across campus or across the state. This<br>
isn't the stuff of science fiction anymore.
</p>
<p>
QTC uses many of the services provided by QuickTime itself and shares an<br>
architectural basis in the Component Manager. QTC takes advantage of the Image<br>
Compression Manager for video compression and decompression, the sequence grabber<br>
components for capturing media, and the Movie Toolbox for recording movies to disk.<br>
When new features and improvements are added to QuickTime, they often can be used<br>
by QTC immediately. For example, components created for video or sound compression<br>
in QuickTime are automatically available to QTC.
</p>
<p>
<b>CONFERENCE CONFIGURATIONS</b>
</p>
<p>
QTC's basic metaphor for real-time media connections is that of a conference.<br>
Conferences are quite flexible and can be configured in a variety of ways. They can<br>
have one, a few, or many members, connected symmetrically or asymmetrically. As<br>
illustrated in Figure 1, connections can take one of three forms: <i>point to point</i>, for<br>
two-way conferences; <i>multipoint</i>, for virtual meetings and groupware applications; or<br>
<i>broadcast</i>, for transmitting from one member to many others.
</p>
<p>
<img src="img/189.gif" width="534 px"></img>
</p>
<p>
<b>Figure 1.</b> The three types of conference connections
</p>
<p>
Members can send or receive sound, video, or data. Media types can be added, removed,<br>
or changed during a conference. Members can join or leave a conference at any time.<br>
Conferences can be merged, and data can be sent to one or all of the conference<br>
members.
</p>
<p>
Depending on the application, you may want to give users a single configuration --<br>
say, a two-way audio and video connection -- or allow them to modify the conference<br>
configuration themselves. QTC was designed to support a wide variety of conference<br>
configurations and to leave it up to developers to decide which features they need.<br>
Indeed, some applications may need to switch between different configurations within a<br>
single conference. The applications described later in this article each operate in a<br>
single configuration; one can broadcast video and sound to an unlimited number of<br>
recipients and the other can tune into one or more broadcast conferences.
</p>
<p>
<b>NETWORK, PROTOCOL, AND MEDIA INDEPENDENCE</b>
</p>
<p>
QTC is network, protocol, and media independent. This means that applications don't<br>
have to know the specifics of a particular network to set up a QTC conference. QTC<br>
1.0.2 ships with support for TCP/IP and AppleTalk networks; third parties and Apple<br>
are working on adding new networks like ISDN, isoEthernet, and ATM to the list. QTC<br>
1.0.2 supports a new media-oriented network protocol, called MovieTalk, but can also<br>
support other media protocols such as the ITU H.320 standard and the emerging<br>
standards used on the Internet Multicast Backbone (MBONE).
</p>
<p>
&nbsp;&nbsp;The media that flows between conference members is organized into one or more<br>
streams of a particular media type. QTC 1.0.2 supports sound and video streams,<br>
which can be compressed with any sound or video compressor. Future versions of QTC<br>
will be able to support other media types, such as music and text, to parallel the<br>
different track types that can be stored in a QuickTime movie.
</p>
<p>
<b>THE CONFERENCING EXPERIENCE</b>
</p>
<p>
QTC provides some of the basic user interface elements called for in a conferencing<br>
application. For example, each member of a conference can be represented on the<br>
screen with a stream controller, in much the same way that a QuickTime movie<br>
controller provides a control representation for a QuickTime movie. In fact, the<br>
stream controller and the movie controller share a similar user interface, so that a<br>
user who has some experience with one can apply that knowledge to the other.
</p>
<p>
QTC also provides a standard user interface enabling users to choose who to call and<br>
include in a QTC conference, in the form of browser components. Browsers work a bit<br>
like the Standard File Package that allows users to open and save files: they provide a<br>
standard interface for choosing fellow users or searching through PowerTalk catalogs<br>
to find other conference members and place calls to them.
</p>
<h2>QUICKTIME CONFERENCING COMPONENTS</h2>
<p>
QTC, like much of QuickTime, is built of Component Manager components. Apple<br>
provides a basic suite of components that enable the user to share data and send and<br>
receive compressed video and audio on a few different networks. Before we dive into<br>
our example applications, let's go over some of the component types that make up the<br>
QTC component suite.
</p>
<p>
&nbsp;&nbsp;There are three main types of QTC components that most developers will need to know<br>
about to add QTC support to their applications: the <i>conference component</i>, the <i>stream</i><br>
<i>controller componen</i>t, and the <i>browser component</i>. I'll describe these in some detail.<br>
Developers who want to do fancier things will probably need to know about some of the<br>
other components; the key ones are briefly described later.
</p>
<p>
Because of the modular architecture of QTC, developers can add, extend, or replace<br>
features and components. For example, a developer who wants to add support for a new<br>
network multimedia protocol can create a new transport component and register it<br>
with the Component Manager. Applications can then find that component and specify its<br>
use in a conference. Developers who want to improve on the QTC stream controller can<br>
capture the standard controller, delegate many of the functions, and replace the ones of<br>
interest.
</p>
<p>
<b>THE CONFERENCE COMPONENT</b>
</p>
<p>
The conference component is the key player in a QTC conference. It acts as a central<br>
hub and does the bulk of the work required to orchestrate the comings and goings of the<br>
conference. It's responsible for listening in on the various networks, placing and<br>
answering calls, managing and merging multiple conferences, and more. The<br>
conference component can also provide some higher-level functionality, such as<br>
setting up media capture, handling user events, and even creating and managing<br>
conference windows.
</p>
<p>
Applications create a conference component instance and let the conference component<br>
do much of the work needed to create, manage, and end conferences. Applications can<br>
then tell the conference component to listen on the networks for incoming calls or to<br>
place a call to another member.
</p>
<p>
Conference components create <i>conference events</i> when they need to express some<br>
change in a conference to the application. For example, when an incoming call is made<br>
to a conference, the conference component will generate an event of type<br>
mtIncomingCallEvent to notify the application of the call. Applications call the<br>
component routine MTConferenceGetNextEvent periodically to get the events from the<br>
conference component, much as applications call the system routine WaitNextEvent to<br>
get user and system events from the Event Manager.
</p>
<p>
In response to these conference events, applications work with the conference<br>
component to respond appropriately -- for example, creating a window to display a<br>
new conference member or send messages to other conference members. Details of<br>
working with the conference component will be discussed later when we look at our<br>
sample applications, Watcher and Caster.
</p>
<p>
<b>THE STREAM CONTROLLER COMPONENT</b>
</p>
<p>
Stream controllers are responsible for handling the default user interface for<br>
controlling QTC media streams as well as managing their display on the screen and<br>
through the speaker. The conference component is responsible for creating and<br>
managing stream controller components. Applications are passed references to the<br>
stream controllers by the conference component so that they can keep track of where<br>
and how the media is being displayed.
</p>
<p>
The standard stream controller looks quite a bit like the standard QuickTime movie<br>
controller, with buttons to control the flow of media, resize the visual portion of the<br>
stream, and adjust the sound levels. The stream controller adds some utility buttons<br>
that the movie controller doesn't have: a snapshot button for capturing the current<br>
image displayed in the controller and a record button that provides a standard way for<br>
a user to record the media in a stream controller. (The conference component or the<br>
application is responsible for actually handling the snapshots or recorded movies after<br>
the controller has initiated them.)
</p>
<p>
Controllers associated with the sending side of a media stream (known as <i>source</i><br>
<i>controllers</i>) have a slightly different appearance and behavior from those associated<br>
with the receiving side (known as <i>sink controllers</i>), as shown in Figure 2. The source<br>
controller may have a microphone "gain" button that's animated to indicate the level of<br>
the audio being sent across the connection. Users who click this button can adjust the<br>
volume of the sound being sent across the connection. On the receiving end, the sink<br>
controller may display a volume control button that behaves like the speaker button on<br>
the standard movie controller, allowing the user to adjust the volume of the incoming<br>
stream.
</p>
<p>
<img src="img/190.gif" width="522 px"></img>
</p>
<p>
<b>Figure 2.</b> Source and sink controller user interfaces
</p>
<p>
<b>THE BROWSER COMPONENT</b>
</p>
<p>
To place a call or add another member to a conference, the user needs to specify the<br>
other member to call. Browser components provide a simple way for users to browse<br>
the network and identify other members. Browser components come in two flavors:<br>
network-specific browsers and the PowerTalk browser. The PowerTalk browser and<br>
browsers specific to TCP/IP and AppleTalk are shown in Figure 3.
</p>
<p>
<img src="img/191.gif" width="474 px"></img>
</p>
<p>
<b>Figure 3.</b> Browsers
</p>
<p>
For each different network type -- such as TCP/IP or AppleTalk -- unique browser<br>
components are provided that allow the user to specify a network-specific address. For<br>
example, as shown in Figure 3, the AppleTalk browser presents the user with a<br>
Chooser-style interface whereby the user can choose the zone and then the registered<br>
name within that zone on an AppleTalk network, similar to using the Chooser to pick a<br>
LaserWriter on an AppleTalk network. The TCP/IP browser provides a simple type-in<br>
interface that can accept TCP/IP addresses in numerical or text form.
</p>
<p>
The PowerTalk browser, on the other hand, is considered a generic or universal<br>
browser, not tied to a particular network or addressing scheme. Users who have<br>
PowerTalk installed can take advantage of the various PowerTalk catalogs and business<br>
cards; these provide an integrated way for users to organize and find other QTC users<br>
in the same way that they access electronic mail addresses via PowerTalk. The<br>
PowerTalk browser allows the user to choose a business card from a PowerTalk catalog<br>
that contains a QTC entry (provided by the QTC PowerTalk Template). This works for<br>
local user catalogs and catalogs provided by PowerShare servers, as well as the<br>
generic AppleTalk network catalog, which allows the user to look out onto the network<br>
and into AppleTalk zones for other users. Users can edit their personal catalogs from<br>
within the Finder, consistent with the standard PowerTalk human interface.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______________________________
</p>
<p class="spacer">&nbsp;</p>
<h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ABOUT APPLETALK MULTICAST</h2>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Digital video and sound can generate a great deal of data, even when<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;compressed. Hard disk space is getting to be quite cheap, but network<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bandwidth is still an expensive and shared commodity. To keep your fellow<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;users and network administrators happy, we developed multicast extensions to<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AppleTalk that allow a single copy of QuickTime Conferencing media sent out<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onto a network to be received and displayed by any number of users.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AppleTalk Multicast consists of a special packet format and a routing protocol<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;that makes efficient use of the network bandwidth. On a single network<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;segment, AppleTalk Multicast uses multicast packets that can be received by<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;anyone on that local network. On an AppleTalk internet, multicast-aware<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;routers communicate with each other with a new protocol called SMRP, the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Simple Multicast Routing Protocol, as shown in Figure 4. The routers deliver<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copies of the media data only to other networks in which there's a user who<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wants to receive that data. Networks with no users interested in the broadcast<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aren't burdened with the network usage.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Apple has licensed AppleTalk Multicast and the SMRP protocol to Cisco<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Systems, Inc. Cisco's router software as of version 11.0 supports this<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;multimedia protocol.
</p>
<p>
<img style="margin-left:45px" src="img/192.gif" width="528 px">          </img>
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Figure 4.</b> AppleTalk Multicast routing
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______________________________
</p>
<p>
<b>OTHER QUICKTIME CONFERENCING COMPONENTS</b>
</p>
<p>
QTC defines and uses many other kinds of components besides the three just mentioned.<br>
Several of these component types may be of interest to developers who want to add<br>
support for new networks or new media protocols; others may be of use to developers<br>
who want to have more control over their conferences. Some of these are listed here.
</p>
<ul>
<li><i>Stream director components</i> are responsible for managing the media<br>
streams that flow between conference members. Stream directors are of two<br>
types: source stream directors and sink stream directors. Source stream<br>
directors work with media sources, such as QuickTime sequence grabbers, to<br>
capture audio and video data to be sent across the network. Sink stream<br>
directors are responsible for setting up and displaying incoming media data:<br>
video to the screen and sound to the speaker. Conference components and<br>
controller components handle most of the management and control of stream<br>
directors.</li>
<li><i>Transport components</i> are responsible for implementing the network<br>
protocol that communicates media data, formats, and control information.<br>
MovieTalk, the default QTC protocol, is implemented as a transport component.<br>
Apple's H.320/ISDN conferencing card adds another transport type that<br>
supports the ITU H.320 video conferencing standard. Developers who want to<br>
support new media protocols can create new transport components to translate<br>
the control messages from a conference into messages appropriate for the new<br>
protocol and vice versa.</li>
<li><i>Network components</i> contain code specific to a given network type. QTC<br>
1.0.2 provides network components for AppleTalk and TCP/IP. Future<br>
versions of QTC will provide direct OpenTransport network interfaces as well<br>
as others. Network components can provide access to multicast services on<br>
some shared networks so that media data can be sent to multiple recipients<br>
without having to send out multiple copies of that data. (See "About AppleTalk<br>
Multicast" for a discussion of one such multicast service.) The conference<br>
component automatically takes advantage of multicast network services when<br>
they're available.</li>
<li><i>Recorder components</i> attach to stream directors and provide a mechanism<br>
to record to disk the media sent or received within a conference. Apple<br>
provides a recorder component that records media into QuickTime movies and<br>
can attach to multiple members via stream directors to create movies of<br>
entire conferences at once.</li>
</ul>
<p>
Several other components are used within QTC, including player components, flow<br>
control components, and others of interest to developers who want to extend QTC to<br>
support new networks, protocols, and media. Figure 5 shows how a number of QTC<br>
components typically work together within the all-encompassing conference<br>
component. For information on all of the components that make up QTC, check out the<br>
QTC documentation on this issue's CD.
</p>
<p>
<img src="img/193.gif" width="546 px"></img>
</p>
<p>
<b>Figure 5.</b> How QTC components work together within the conference component
</p>
<h2>TUNING IN WITH WATCHER</h2>
<p>
Probably the best way to show how to use QTC in an application is with some examples,<br>
so we've created Watcher and Caster. Watcher lets the user tune into broadcasts on<br>
AppleTalk networks, while Caster enables the user to create broadcasts that can be<br>
watched by others on the AppleTalk network. Watcher and Caster are compatible with<br>
Apple Media Conference (AMC), the QTC application that Apple ships with selected<br>
CPUs and product packages, so you can use Watcher to watch a broadcast that's being<br>
sent by AMC or Caster, and you can use Caster to create broadcasts that can be received<br>
by Watcher and AMC.
</p>
<p>
Note that in several places in Watcher and Caster, we do some work manually that<br>
otherwise could be done automatically by the conference component. We do this extra<br>
work to demonstrate how you can customize an application if the behavior that you<br>
want is different from the default behavior offered by the conference component.
</p>
<p>
<b>HOW WATCHER WORKS</b>
</p>
<p>
Watcher is a relatively simple Macintosh application. After setting up the application<br>
environment, Watcher sets up the conference component that will place calls and<br>
manage the incoming media. Then, within the event loop, the application checks for<br>
user and system events and also checks the conference component for conference<br>
events, which indicate changes in the conference state and may require responses from<br>
the application.
</p>
<p>
&nbsp;&nbsp;The overall flow of Watcher or any QTC application that uses the conference<br>
component is as follows:
</p>
<pre>QTCApp()
{
   SetupApplication();
   SetupConferenceComponent();
   StartListening();
   do {
      ProcessUserEvents();
      ProcessConferenceEvents();
   } while (!gQuit);
   CleanUpConferenceComponent();
   CleanUpApplication();
   ExitToShell();
}</pre>
<p class="spacer">&nbsp;</p>
<p>
Below, I'll go into more detail about the three major application responsibilities --<br>
setting up the conference component, handling conference events, and cleaning up at<br>
the end of the conference -- showing the core routines that deal directly with the<br>
conference component. Check out the full source code to see them in the context of the<br>
entire application.
</p>
<p>
<b>SETTING UP A CONFERENCE</b>
</p>
<p>
Listing 1 shows how the conference component is created and initially configured. The<br>
Component Manager call OpenDefaultComponent is used to create and open an instance<br>
of the conference component; then the conference component mode is set to indicate that<br>
the conference will be used to receive media. Finally, the component is told what<br>
networks to prepare for connections on -- AppleTalk in this case -- and how to<br>
identify itself on that network.
</p>
<p>
MTConferenceListen (as well as MTBrowserBrowse, a call we'll encounter a little<br>
later) uses a C string of type MTCString to describe the network and transport<br>
configurations. In Listing 1, the string "mtlkatlk\tNoIncomingCalls\x0D" indicates<br>
that the conference component should listen for calls that have a transport subtype of<br>
'mtlk' (the component subtype for the MovieTalk transport component) and a network<br>
subtype of 'atlk' (the subtype for AppleTalk networks). The "\t" delimits the subtypes<br>
from the network-specific configuration data that follows. For AppleTalk networks,<br>
this is the Name Binding Protocol (NBP) type "No Incoming Calls." Finally, the<br>
configuration is terminated with a carriage return ("\x0D"). You can string together<br>
multiple configuration strings (each terminated with a carriage return) to listen in<br>
on multiple networks for calls. Check out the full documentation for a more complete<br>
explanation of the configuration strings.
</p>
<p>
<b>Listing 1.</b> CreateWatchConference
</p>
<pre>ComponentResult CreateWatchConference(MTCString63 userName)
{
   ComponentResult   err;
  
   /* Create a conference record. */
   err = NewConference(&amp;gConference);
   if (err == noErr) {
      gConference-&gt;confComponent
         = OpenDefaultComponent(kMTConferenceType,
              kMTMovieTalkSubType);
      if (gConference-&gt;confComponent) {
         /* Tell the conference component that we only want to */
         /* receive media, not send. */
         err = MTConferenceSetMode(gConference-&gt;confComponent,
                  mtReceiveMediaModeMask);
         /* Tell the conference component to prepare to use
            AppleTalk.
            The funky C string tells the conference component:
               mtlk = use the MovieTalk transport component
               atlk = use the AppleTalk network component
               NoIncomingCalls = the AppleTalk-specific NBP type
               that's used for listening;
                i.e., there will be no incoming calls
         */
         if (err == noErr)
            err = MTConferenceListen(gConference-&gt;confComponent,
                      userName /* User name */,
                      userName /* Service name */,
                      (MTCString)"mtlkatlk\tNoIncomingCalls\x0D");
      }
      else
         err = couldntGetRequiredComponent;
   }
   return err;
}</pre>
<p class="spacer">&nbsp;</p>
<p>
<b>BROWSING THE NETWORK</b>
</p>
<p>
Now that the conference is set up, we can place a "call" out onto the network to the<br>
broadcaster that the user wants to watch. We'll use the AppleTalk browser component<br>
to pick a registered broadcaster.
</p>
<p>
&nbsp;&nbsp;The BrowseName routine (Listing 2) opens the browser component and uses the<br>
MTBrowserBrowse component call to specify which kind of network entity to look for.<br>
In this case it's a MovieTalk entity registered on an AppleTalk network with the NBP<br>
type of "Multicaster"; this type identifies broadcasts from Caster and AMC.<br>
MTBrowserBrowse then presents users with the browser dialog, where they can<br>
"surf" the network and find the appropriate broadcaster. Some browsers (like the<br>
PowerTalk browser) can return multiple names in an MTNameList. We're only<br>
interested in the one AppleTalk broadcast picked by the user, so we pick off the first<br>
MTName from the MTNameList.
</p>
<p>
<b>Listing 2.</b> BrowseName
</p>
<pre>ComponentResult BrowseName(MTNamePtr name)
{
   MTNameListPtr         allNames = 0;
   ComponentResult       err;
   MTBrowserComponent    browser = nil;

   browser = OpenDefaultComponent(kMTBrowserType,
                kMTAppleTalkSubType);
   if (browser) {
      err = MTBrowserBrowse(browser, 0, nil,
               (MTCString)"mtlkatlk\tMulticaster\x0D", 0, &amp;allNames);
      CloseComponent(browser);
   }
   else
      err = couldntGetRequiredComponent;
   if ((allNames != 0) &amp;&amp; (err == noErr)) {
      /* Copy the first name record; that's all we're interested */
      /* in. */
      *name = allNames-&gt;list[0];
      /* Dispose of the list of names. */
      DisposePtr((Ptr)allNames);
   }
   return err;
}</pre>
<p class="spacer">&nbsp;</p>
<p>
<b>TUNING IN</b>
</p>
<p>
CallMember (Listing 3) is the code needed to tell the conference component to place a<br>
call to the broadcaster. The calling routine passes in the MTName (obtained from<br>
BrowseName) and a pointer to the window in which the broadcast is to appear (and that<br>
window's size). The resize parameter will be used later to determine whether to resize<br>
the window automatically to the dimensions of the video being broadcast. CallMember<br>
returns a pointer to a new MemberRecord data structure, where the information about<br>
each broadcast-watching window is kept. The important conference component call<br>
here is MTConferenceCall, which is passed a reference to the conference component, an<br>
arbitrary name for the conference, and the MTName describing the party whose<br>
broadcast we want to watch.
</p>
<p>
&nbsp;&nbsp;Note that the conference component manages each independent connection to a<br>
broadcaster as a unique conference. That's just fine for our application, since the<br>
broadcast windows are really independent. In multiparty connections, however,<br>
conferences can be joined and then individual members can belong to the same<br>
conference. In that case the conference name parameter in MTConferenceCall<br>
("Watcher" in Listing 3) may have more meaning and may be used to distinguish<br>
independent conferences. In our case, we give them all the same name.
</p>
<p>
<b>Listing 3.</b> CallMember
</p>
<pre>ComponentResult CallMember(MTName* name, WindowPtr wind, Rect* box,
                           Boolean resize, MemberRecord** member)
{
   MemberRecord*      mr;
   ComponentResult   err;

   /* Create a new member record. */
   err = NewMember(&amp;mr);
   if (err == noErr) {
      mr-&gt;member = MTConferenceCall(gConference-&gt;confComponent,
                            (MTCString)"Watcher", name);
      mr-&gt;box = *box;
      mr-&gt;window = wind;
      mr-&gt;resize = resize;
      if (member)
         *member = mr;
   }
   return err;
}</pre>
<p class="spacer">&nbsp;</p>
<p>
<b>TURNING ON</b>
</p>
<p>
Now that the conference call has been placed, we need to check the conference<br>
component periodically to find out about changes in the conference. Listing 4 shows the<br>
routine CheckConferenceEvents, which is intended to be called within the main event<br>
loop of the application. Each time through the loop, we call MTConferenceGetNextEvent.<br>
Most of the time this will return false, indicating that there are no new events. When<br>
some state in the conference has changed, it will return true, and we should then parse<br>
the event (with HandleConferenceEvent) to see what the correct response is.
</p>
<p>
<b>Listing 4.</b> CheckConferenceEvents
</p>
<pre>ComponentResult CheckConferenceEvents(void)
{
   MTConferenceEvent confEvent;
   ComponentResult   err;
  
   if (MTConferenceGetNextEvent(gConference-&gt;confComponent,
          &amp;confEvent))
      err = HandleConferenceEvent(&amp;confEvent);
   return err;
}</pre>
<p class="spacer">&nbsp;</p>
<p>
The MTConferenceEvent data structure, also known as an event record, has several<br>
fields that we'll use in the following listings. The <b>what</b> field indicates the type of<br>
event; depending on this, HandleConferenceEvent (Listing 5) switches to the individual<br>
subroutines corresponding to each event. The <b>surprise</b> field, if not set to 0, contains<br>
a handle to data that's associated with the event and needs to be disposed of after use.<br>
The other fields, <b>who</b>, <b>err</b>, and <b>bonus</b>, contain references to the members, error<br>
codes, and event-specific data, respectively. See the documentation for details on the<br>
meanings of these fields for all event types.
</p>
<p>
<b>Listing 5.</b> HandleConferenceEvent
</p>
<pre>ComponentResult HandleConferenceEvent(MTConferenceEventPtr confEvent)
{
   ComponentResult   err = noErr;
  
   /* Like a user event handler, we switch on the different
      conference events. */
   switch (confEvent-&gt;what) {
      case mtConferenceReadyEvent:
         err = DoConfReady(confEvent);
         break;
      case mtMemberReadyEvent:
         err = DoMemberReady(confEvent);
         break;
      case mtMemberTerminatedEvent:
         err = DoMemberTerminated(confEvent);
         break;
      case mtMemberJoiningEvent:
         err = DoMemberJoining(confEvent);
         break;
      case mtPhoneRingingEvent:
         err = DoPhoneRinging(confEvent);
         break;
      case mtRefusedEvent:
      case mtFailedEvent:
         err = confEvent-&gt;err;
         break;
      default:      /* Ignore all others. */
         break;
      }

   /* If there's data associated with this event, free it. */
   if (confEvent-&gt;surprise)
      DisposeHandle(confEvent-&gt;surprise);
   return err;
}</pre>
<p class="spacer">&nbsp;</p>
<p>
After a call has been placed and a connection has been established with the remote side,<br>
an event of type mtMemberJoiningEvent is returned by the conference component.<br>
Upon receiving this event our application calls DoMemberJoining (Listing 6) and<br>
simply makes a record of this new member and adds it to our list of members. The<br>
conference component will continue to establish the connection and will notify us<br>
further when the connection has been completely brought up.
</p>
<p>
<b>Listing 6.</b> DoMemberJoining
</p>
<pre>struct MemberRecord {
   MTControllerComponent   controller;
   MTDirectorComponent     director;
   MTConferenceMember      member;
   WindowPtr               window;
   Boolean                 resize;
   Rect                    box;
   MemberRecord*           next;
};
...
ComponentResult DoMemberJoining(MTConferenceEventPtr confEvent)
{
   MemberRecord*      currMember;
   ComponentResult    err = noErr;

   err = NewMember(&amp;currMember);
   if (err != noErr) {
      currMember-&gt;member = confEvent-&gt;who;
      AddMember(gConference, currMember);
   }
   return err;
}</pre>
<p class="spacer">&nbsp;</p>
<p>
Once the connection has been fully established, the conference component sends us an<br>
event of type mtMemberReadyEvent. Now we have a little more work to do. In this case,<br>
the application needs to create a controller and place that controller into a window for<br>
incoming media to be displayed. The conference component can do much of this work for<br>
you, including creating a controller (and its associated stream director) as well as<br>
creating a window and even handling user events for that window, with the<br>
MTConferenceNewPreparedController call. For many applications this method is<br>
perfectly adequate, but if you need more control over event handling and window<br>
management in your application, you'll want to do this work manually, as we do in<br>
Watcher and Caster. Use of MTConferenceNewPreparedController is demonstrated in<br>
the SeeWorld sample applications included on this issue's CD; check out the Rogues and<br>
Guardian examples in particular.
</p>
<p>
DoMemberReady (Listing 7) first checks to see if we can expect media to be sent by<br>
the new member. (If the member isn't sending media, there's no point in setting up a<br>
window.) If the member is sending media, we create a controller component and a<br>
stream director component, which are responsible for displaying the media data. After<br>
this, we call MTControllerNewAttachedController to connect the controller to the<br>
stream director and point it at a window for display. We then do one more thing to the<br>
controller before activating it in the conference: we set an action filter for it. The<br>
action filter is a callback routine that the controller calls whenever any important<br>
action happens within the controller. In our application, the only action that we care<br>
about is the resizing of the media data so that we can resize the window. The action<br>
filter routine is shown in Listing 8.
</p>
<p>
<b>Listing 7.</b> DoMemberReady
</p>
<pre>ComponentResult DoMemberReady(MTConferenceEventPtr confEvent)
{
   ComponentResult   err = noErr;
   MemberRecord*      currMember;
   Point               where = {0, 0};
   Boolean            aTrue = true;
  
   if (confEvent-&gt;bonus &amp; mtReceiveMediaModeMask) {
      currMember = FindMember(gConference, confEvent-&gt;who);
      if (currMember == nil)
         return noErr;
      currMember-&gt;controller =
         OpenDefaultComponent(kMTControllerType,
             kMTMovieTalkSubType);
      if (currMember-&gt;controller == 0)
         err = couldntGetRequiredComponent;
      if (err == noErr) {
         currMember-&gt;director = OpenDefaultComponent(
                           kMTSinkStreamDirectorType, kMTPlayerType);
         if (currMember-&gt;director == 0)
            err = couldntGetRequiredComponent;
      }
      if (err == noErr)
         err = MTControllerNewAttachedController(
                  currMember-&gt;controller, currMember-&gt;director,
                  currMember-&gt;window, where);
      if (err == noErr)
         err = MTControllerSetActionFilter(currMember-&gt;controller,
                  actionFilterUPP, (long)currMember);
      if (err == noErr)
         err = MTConferenceActivateMember(gConference-&gt;confComponent,
                  confEvent-&gt;who, currMember-&gt;controller);
      if (err == noErr)
         err = MTControllerDoAction(currMember-&gt;controller,
                  mtControllerActionPlay, &amp;aTrue);
   }
   return err;
}</pre>
<p class="spacer">&nbsp;</p>
<p>
<b>Listing 8.</b> MyControllerActionFilter
</p>
<pre>pascal Boolean MyControllerActionFilter(MTControllerComponent mtc,
                                       MTControllerActionType action,
                                       void* params, long refCon)
{
   void*       unused1 = params;
   long        unused2 = refCon;
   RgnHandle   controllerRgn;
   Boolean     handled = false;
   Rect        box;
   WindowPtr   controllerWindow =
                       (WindowPtr)MTControllerGetControllerPort(mtc);
  
   switch (action) {
      case mtControllerActionControllerSizeChanged:
         /* Find out how big the controller is. */
         controllerRgn = MTControllerGetWindowRgn(mtc,
                                                   controllerWindow);
         /* Resize the window accordingly. */
         if (controllerRgn != nil) {
            box = (**controllerRgn).rgnBBox;
            DisposeRgn(controllerRgn);
            SizeWindow(controllerWindow, box.right, box.bottom,
                true);
         }
         break;
      default:
         break;
      }
   return handled;
}</pre>
<p class="spacer">&nbsp;</p>
<p>
Finally, DoMemberReady calls MTConferenceActivateMember to activate the member,<br>
and we pass MTConferenceActivateMember the newly created controller. Before<br>
exiting, we call MTControllerDoAction to tell the controller component to begin<br>
playing the incoming media as soon as it begins. (Controllers are by default in a paused<br>
state when they're created.)
</p>
<p>
<b>DROPPING OUT</b>
</p>
<p>
When the user has decided to close down the reception of the broadcast (say, by closing<br>
a broadcast window), the application calls CloseWatch (Listing 9). CloseWatch will<br>
find the member record corresponding to the conference member and obtain the<br>
conference token associated with that member. (Remember, each member is part of a<br>
unique conference, so the member has both a conference token and a unique<br>
ConferenceMember identifier.) Then we begin to terminate the conference by calling<br>
MTConferenceTerminate.
</p>
<p>
<b>Listing 9.</b> CloseWatch
</p>
<pre>ComponentResult CloseWatch(WindowPtr window)
{
   ComponentResult       err = noErr;
   MTConferenceToken    theConference;
   MemberRecord*         theMember;
  
   theMember = FindMemberWindow(gConference, window);
   if (theMember == nil)
      err = paramErr;
   if (err == noErr) {
      theConference = MTConferenceGetMemberConference(
                        gConference-&gt;confComponent,
                        theMember-&gt;member);
      err = MTConferenceTerminate(gConference-&gt;confComponent,
                                    theConference);
   }
   return err;
}</pre>
<p class="spacer">&nbsp;</p>
<p>
The conference isn't completely terminated until we receive an event of type<br>
mtMemberTerminatedEvent, which is handled by DoMemberTerminated (Listing 10).<br>
DoMemberTerminated is called when the conference connection for this member has<br>
been completely terminated, either by an MTConferenceTerminate call or by the<br>
remote side closing down. In response, we'll close down the controller and stream<br>
director components and the associated window, then free up our application's<br>
MemberRecord for this member.
</p>
<p>
<b>Listing 10.</b> DoMemberTerminated
</p>
<pre>ComponentResult DoMemberTerminated(MTConferenceEventPtr confEvent)
{
   MemberRecord*      member;
   ComponentResult   err;
  
   member = FindMember(gConference, confEvent-&gt;who);
   if (member == nil)
      return noErr;
   RemoveMember(gConference, member);
   if (member-&gt;controller)
      CloseComponent(member-&gt;controller);
   if (member-&gt;director)
      CloseComponent(member-&gt;director);
   if (member-&gt;window)
      CloseWindow(member-&gt;window);
   err = DisposeMemberRecord(member);
   return err;
}</pre>
<p class="spacer">&nbsp;</p>
<p>
That's it for the key QTC routines in Watcher. Check out the source code on the CD to<br>
see the entire package come together.
</p>
<h2>BROADCASTING WITH CASTER</h2>
<p>
Caster, the broadcasting side of this networked multimedia system, is similar to<br>
Watcher in many ways. It uses a conference component (see Figure 6) and processes<br>
conference events, but it handles the other side of the conference establishment:<br>
setting up and transmitting media and accepting incoming calls. In some ways, Caster<br>
is simpler: since it broadcasts to anybody who wants to tune in, it doesn't need to keep<br>
track of each member individually.
</p>
<p>
<img src="img/194.gif" width="600 px"></img>
</p>
<p>
<b>Figure 6.</b> A QTC broadcaster and two watchers
</p>
<p>
<b>SETTING UP THE SEQUENCE GRABBER</b>
</p>
<p>
Probably the trickiest part of Caster is the code that sets up the sequence grabber to<br>
capture video and sound. The call MTConferenceNewPreparedController from the<br>
conference component could be used to set up the sequence grabber (as well as the<br>
controller and stream director) in many cases, but as mentioned earlier for Watcher,<br>
this call won't be adequate if you need more control.
</p>
<p>
&nbsp;&nbsp;In the SetupSequenceGrabber routine (Listing 11), we first create the sequence<br>
grabber component by calling OpenDefaultComponent. Once the component is initialized<br>
with SGInitialize, we create the individual sound and video channels. We can use other<br>
calls in the sequence grabber component API to adjust settings, like frame rate and<br>
compressor type. We also need to call SGSetChannelUsage to tell the controller that the<br>
channels can be used for preview and record and that they will play through during<br>
recording (seqGrabPreview + seqGrabRecord + seqGrabPlayDuringRecord).
</p>
<p>
<b>Listing 11.</b> SetupSequenceGrabber
</p>
<pre>ComponentResult SetupSequenceGrabber(
        SeqGrabComponent* sg, SGChannel* soundChannel,
        SGChannel* videoChannel)
{
   ComponentResult    err = noErr;
   SeqGrabComponent    grabber = nil;

   *soundChannel = nil;
   *videoChannel = nil;
   grabber = OpenDefaultComponent(SeqGrabComponentType, 0);
   if (grabber == nil)
      err = couldntGetRequiredComponent;
   else {
      err = SGInitialize(grabber);
      if (err == noErr) {
         err = SGNewChannel(grabber, SoundMediaType, soundChannel);
         if (err == noErr)
            SGSetChannelUsage(*soundChannel,
                seqGrabPreview + seqGrabRecord);
         err = SGNewChannel(grabber, VideoMediaType, videoChannel);
         if (err == noErr) {
             SGSetFrameRate(*videoChannel, 0);
            /* 'rpza' is the Apple Video Compressor. */
            SGSetVideoCompressorType(*videoChannel, 'rpza');
            SGSetChannelUsage(*videoChannel,
                seqGrabPreview + seqGrabRecord
                   + seqGrabPlayDuringRecord);
         }
         /* Reset in case we had a problem opening a channel */
         /* (e.g., there was no digitizer). */
         err = noErr;
      }
   }
   if (err != noErr) {
      if (grabber)
         CloseComponent(grabber);
      grabber = nil;
   }
   *sg = grabber;
   return err;
}</pre>
<p class="spacer">&nbsp;</p>
<p>
<b>ATTACHING THE SEQUENCE GRABBER</b>
</p>
<p>
Now that we have the sequence grabber created as a source for captured data, we need<br>
to hook it up to the stream director and controller and create a pipeline for the media,<br>
which will eventually be fed into the conference component and out onto the network.<br>
OpenCast (Listing 12) takes a sequence grabber and a window to display it in, creates a<br>
source stream director and controller, and configures them.
</p>
<p>
<b>Listing 12.</b> OpenCast
</p>
<pre>typedef struct {
   WindowPtr               window;
   SeqGrabComponent        sg;
   MTConferenceComponent   confComponent;
   MTControllerComponent   controller;
   MTDirectorComponent     director;
   Boolean                 casting;
   MTConferenceToken       conference;
} CastRecord;
...

ComponentResult OpenCast(WindowPtr window, SeqGrabComponent sg,
CastRecord** cr)
{
   ComponentResult   err = noErr;
   CastRecord*         newRecord = nil;
   Point               origin = {0,0};
   /* Specify the default window bounds for a 160-by-120 video window;
add 16 to the height
      to make space for the controller. */
   Rect               bounds = {0, 0, 120 + 16, 160};
   Boolean            aFalse = false;

   newRecord = (CastRecord*)NewPtrClear(sizeof(CastRecord));
   if (newRecord == nil)
      err = MemError();
   if (err == noErr) {
      newRecord-&gt;window = window;
      newRecord-&gt;sg = sg;  
      newRecord-&gt;director =
OpenDefaultComponent(kMTSourceStreamDirectorType, kMTGrabberSubType);
      if (newRecord-&gt;director == nil)
         err = couldntGetRequiredComponent;
   }
   if (err == noErr) {
      newRecord-&gt;controller = OpenDefaultComponent(kMTControllerType,
kMTMovieTalkSubType);
      if (newRecord-&gt;controller == nil)
         err = couldntGetRequiredComponent;
   }
   if (err == noErr)
      err = MTControllerSetActionFilter(newRecord-&gt;controller,
actionFilterUPP, 0);
   if (err == noErr)
      err = MTDirectorSetMediaComponent(newRecord-&gt;director, sg);
   if (err == noErr)
      err = MTControllerNewAttachedController(newRecord-&gt;controller,
newRecord-&gt;director, window,
                        origin);
   if (err == noErr)  
      err = MTControllerDoAction(newRecord-&gt;controller,
mtControllerActionSetShowSnapshot, &amp;aFalse);
   if (err == noErr)
      err = MTControllerSetControllerBoundsRect(newRecord-&gt;controller,
&amp;bounds);
   if (err == noErr)  
      *cr = newRecord;
   else
      CloseCast(newRecord);
   return err;
}</pre>
<p class="spacer">&nbsp;</p>
<p>
After the source stream director and controller are created, we attach a controller<br>
action filter routine (as we did before for Watcher) and connect the sequence grabber<br>
to the stream director with the MTDirectorSetMediaComponent call. The value of the<br>
source stream director subtype is the same as the value of the sequence grabber type,<br>
indicating that this source stream director has a sequence grabber as its source. We<br>
then call MTControllerNewAttachedController to attach the controller to the stream<br>
director; MTControllerDoAction with mtControllerActionSetShowSnapshot, passing in<br>
false to hide the snapshot button (not the default behavior); and finally<br>
MTControllerSetControllerBoundsRect to give the controller an initial bounds size.
</p>
<p>
<b>STARTING TO BROADCAST</b>
</p>
<p>
Now that we're ready to start broadcasting, we'll create the conference component and<br>
have it start listening for incoming calls from watchers, as shown in Listing 13.<br>
MTConferenceSetMode indicates to the controller that we'll want to send media (which<br>
we didn't want to do with Watcher) and that we expect to share a single<br>
director/controller source with multiple members of a conference. We won't actually<br>
attach the controller/director/sequence grabber chain to the conference component<br>
until somebody calls in.
</p>
<p>
<b>Listing 13.</b> StartCasting
</p>
<pre>ComponentResult StartCasting(CastRecord* cr, Str63 name)
{  
   MTCString63         cName;
   ComponentResult   err = noErr;
  
   PToCString(name, cName);  
   cr-&gt;confComponent =
       OpenDefaultComponent(kMTConferenceType, kMTMovieTalkSubType);
   if (cr-&gt;confComponent == nil)
      err = couldntGetRequiredComponent;
   if (err == noErr)
      err = MTConferenceSetMode(cr-&gt;confComponent,
                mtSendMediaModeMask + mtShareableModeMask);
   if (err == noErr)
      err = MTConferenceListen(cr-&gt;confComponent, cName, cName,
                     (MTCString)"mtlkatlk\tMulticaster\x0D");
   if (err == noErr)
      cr-&gt;casting = true;
   return err;
}</pre>
<p class="spacer">&nbsp;</p>
<p>
Finally, we begin listening with the call to MTConferenceListen, passing it the C string<br>
indicating the transport, network, and configuration information. In this case the<br>
transport type is 'mtlk' for the MovieTalk protocol transport component, the network<br>
type is 'atlk' for AppleTalk, and the configuration string is "Multicaster"; the latter<br>
will be used by AppleTalk as an NBP type. This is the AppleTalk NBP type that the<br>
browser in Watcher looked for while browsing the network. (This is also the type that<br>
AMC uses, so we'll be able to watch Caster broadcasts with it, too.)
</p>
<p>
<b>ANSWERING THE CALLS WHEN THEY COME IN</b>
</p>
<p>
Once the conference component has been set up, Caster periodically checks it for<br>
conference events, just as Watcher does. Some of the behavior in response to these<br>
events is a little different, mainly because Caster is receiving incoming calls and<br>
sending media. Listing 14 shows the routines that get called in response to the<br>
following conference events: mtIncomingCallEvent, mtConferenceReadyEvent,<br>
mtMemberReadyEvent, and mtConferenceTerminatedEvent.
</p>
<p>
<b>Listing 14.</b> Routines for responding to conference events
</p>
<pre>ComponentResult DoIncomingCall(CastRecord* cr,
    MTConferenceEventPtr confEvent)
{  
   return MTConferenceReply(cr-&gt;confComponent, confEvent-&gt;who, 0);
}

ComponentResult DoConferenceReady(CastRecord* cr,
    MTConferenceEventPtr confEvent)
{
   ComponentResult   err = noErr;

   if (cr-&gt;conference == 0) {
      cr-&gt;conference = confEvent-&gt;who;
      err = MTConferenceActivateConference(cr-&gt;confComponent,
                cr-&gt;conference, cr-&gt;controller);
   }
   else
      err = MTConferenceMerge(cr-&gt;confComponent, cr-&gt;conference,
                confEvent-&gt;who);
   return err;
}

ComponentResult DoMemberReady(CastRecord* cr,
    MTConferenceEventPtr confEvent)
{
   ComponentResult   err = noErr;

   err = MTConferenceActivateMember(cr-&gt;confComponent,
             confEvent-&gt;who, 0);
   if (err == noErr)
      err = MTConferenceDetachMember(cr-&gt;confComponent,
                confEvent-&gt;who);
   return err;
}

ComponentResult DoConferenceTerminated(CastRecord* cr,
    MTConferenceEventPtr confEvent)
{
   ComponentResult   err = noErr;

   if (cr-&gt;conference == confEvent-&gt;who) {
      cr-&gt;conference = 0;
      MTControllerDoAction(cr-&gt;controller, mtControllerActionPlay,
          &amp;aTrue);
   }
   return err;
}</pre>
<p class="spacer">&nbsp;</p>
<p>
In response to an mtIncomingCallEvent, the DoIncomingCall routine simply invokes the<br>
conference component's MTConferenceReply function to essentially answer the call<br>
immediately. A more complex version of this routine might check the caller's identity<br>
to determine whether the caller has permission to watch the broadcast. Caster will<br>
take all callers and reply immediately.
</p>
<p>
Upon receipt of the mtConferenceReadyEvent, passed when the conference has been<br>
fully established, we'll take one of two courses of action:
</p>
<ul>
<li>If this is the first incoming caller, and therefore the first conference,<br>
we'll save the conference token (in the conference event's who field) and<br>
activate the conference with the MTConferenceActivateConference function.<br>
This is where we connect up the controller/stream director/sequence grabber<br>
configuration by passing in a reference to the source controller.</li>
<li>If this is the second or later watcher tuning in, this watcher will join as a<br>
new member in a new conference. We'll call MTConferenceMerge to merge this<br>
new conference with the original conference so that the new member is sent<br>
the media.</li>
</ul>
<p>
Now that the conference is set up, we should expect to receive an event of type<br>
mtMemberReadyEvent. Here we simply activate the member to start receiving the<br>
broadcast. Then we call a special function designed to help us take advantage of<br>
multicast network services if available, MTConferenceDetachMember. This function<br>
will "detach" the member from a direct point-to-point connection and will rely on<br>
multicast services to get the member its data. In this case the receiving side and Caster<br>
can't send reliable messages to each other, but for our application that's just fine; we'd<br>
rather minimize the network traffic.
</p>
<p>
Finally, when a watcher disconnects, for whatever reason, we're notified with an<br>
mtConferenceTerminatedEvent and call DoConferenceTerminated. If this is the first<br>
conference, we forget about it by resetting our conference token to 0. (We also get<br>
termination events for conferences that were merged, so we just ignore those.) When<br>
the connection is torn down the media is stopped by the stream director, so to continue<br>
the preview for the user we tell the controller to start playing again with the<br>
MTControllerDoAction function.
</p>
<p>
<b>ADJUSTING THE PICTURE</b>
</p>
<p>
Typically, developers want to enable users to change media settings of the sequence<br>
grabber when it's connected to the other components and even when we're sending to a<br>
conference. In Listing 15, we use the sequence grabber SGSettingsDialog function to<br>
present users with a configuration dialog so that they can change the video or audio<br>
settings. It's not really safe to talk to the sequence grabber directly without warning<br>
the other parts of the connection that the media formats will change.
</p>
<p>
<b>Listing 15.</b> CastChannelSettings
</p>
<pre>ComponentResult CastChannelSettings(CastRecord* cr,
    SGChannel channel)
{
   ComponentResult   err = noErr;
  
   err = MTControllerChangedStreams(cr-&gt;controller, false);
   if (err == noErr) {
      err = SGSettingsDialog(cr-&gt;sg, channel, 0, nil, 0, nil, nil);
      MTControllerChangedStreams(cr-&gt;controller, true);
   }
   return err;
}</pre>
<p class="spacer">&nbsp;</p>
<p>
We surround the call to SGSettingsDialog with calls to the controller function<br>
MTControllerChangedStreams. The second parameter is a Boolean that indicates<br>
whether we've finished changing the streams. Calling MTControllerChangedStreams<br>
with this parameter set to false pauses the media in the connection and makes it safe to<br>
change the setting. Then after the sequence grabber has been adjusted, we call<br>
MTControllerChangedStreams again with this parameter set to true to indicate that<br>
we're done. This in turn starts the process of "renegotiating" the media formats across<br>
the connection safely.
</p>
<h2>CONNECTING FURTHER</h2>
<p>
There's a wealth of documentation available to help you add QTC support to your new<br>
and existing applications.
</p>
<p>
<i>Inside Macintosh: QuickTime Conferencing</i> can be found on this issue's CD, documenting<br>
the API for all of the QTC components as well as the MovieTalk protocol. The rest of the<br>
QTC documentation, including more sample code, human interface notes, and<br>
documentation on AppleTalk Multicast, can be found on the Mac OS SDK edition of the<br>
<i>Developer CD Series</i>. To learn about the intricacies of the sequence grabber and other<br>
media- and component-related topics, check out <i>Inside Macintosh: QuickTime</i> and<br>
<i>Inside Macintosh: QuickTime Components</i>.
</p>
<p>
Come visit us on the World Wide Web at http://qtc.quicktime.apple.com/; you'll find<br>
abundant QTC information there, including developer documentation and free software.<br>
To share your ideas about uses for QTC, you can reach the QTC team at<br>
movietalk@applelink.apple.com (AppleLink MOVIETALK). To get the licensing terms<br>
for QTC, contact Apple's Software Licensing department at<br>
sw.license@applelink.apple.com (AppleLink SW.LICENSE) or (512)919-2645, or<br>
write to Apple Computer, Inc., 2420 Ridgepoint Drive, M/S 198-SWL, Austin, TX<br>
78754.
</p>
<p>
I hope that I've been able to give you an idea of what QuickTime Conferencing is all<br>
about and how to get started using this exciting new technology. No longer just the stuff<br>
of science fiction, videophone and other multimedia connections can be part of the<br>
Macintosh experience for everyone.
</p>
<p>
Thanks to our technical reviewers Eric Carlson, Brian Cox, Godfrey DiGiorgi, Kevin<br>
Gong, Eric Hoffert, and Guy Riddle.
</p>
<p>
<b>DEAN BLACKKETTER</b> (dean@artemis.com) used to work for Apple in the Advanced<br>
Technology Group. He now has a gig with Artemis Research working on "the next big<br>
thing." He plays in San Francisco with his wife, their cat, and the scary elf who lives<br>
on top of the fridge.
</p>
</body>
</html>
