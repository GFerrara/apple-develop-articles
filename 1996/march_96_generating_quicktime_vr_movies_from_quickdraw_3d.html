<!DOCTYPE html>
<html>
<head>
<!-- Article ID: 5 - Extracted from develop-1996 -->
<!-- on 2025-01-18 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by the copyright of its respective owners -->
<title>March 96 - Generating QuickTime VR Movies From QuickDraw 3D</title>
<link href="../common/styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h1>Generating QuickTime VR Movies From QuickDraw<br>
3D</h1>
<h2>Philip McBride</h2>
<p>
<img src="img/132.gif" width="126 px"></img>
</p>
<p>
<i>QuickTime VR is a new technology from Apple that provides users with a virtual</i><br>
<i>reality experience through interactive panoramic and object movies. You can generate</i><br>
<i>images for QuickTime VR movies with either a real camera or a three-dimensional</i><br>
<i>rendering system such as QuickDraw 3D. Here you'll learn how to create images from</i><br>
<i>QuickDraw 3D models and generate movies from these images with the QuickTime VR</i><br>
<i>Authoring Tools Suite version 1.0.</i>
</p>
<p>
QuickTime VR lets you create two kinds of interactive virtual reality<br>
movies:<i>panoramic movies</i> and <i>object movies</i>. In a panoramic movie, users can<br>
interactively view a scene at nearly all camera angles from a particular point in<br>
space, which gives them the impression of being there and looking around. In an object<br>
movie, users can interactively spin an object around and thereby see it from all sides.<br>
Panoramic and object movies can be linked together or used separately.
</p>
<p>
QuickTime VR has several advantages over three-dimensional modeling systems for<br>
making interactive movies. Its movie files are much smaller than complex 3D models<br>
in situations where complete interactivity with the scene isn't necessary, or where<br>
the scene contains complex objects or large numbers of textures. With QuickTime VR,<br>
the complexity of the scene and the number of textures used are irrelevant to runtime<br>
performance, so even users with lower-end machines can effectively interact with the<br>
scene. Finally, a QuickTime VR scene needs only a few megabytes of free space in<br>
memory, much less than the enormous amount of RAM usually taken up by complex 3D<br>
scenes.
</p>
<p>
You can create QuickTime VR movies using either digitized images captured from a real<br>
camera or synthetic images generated by a 3D rendering system, such as QuickDraw<br>
3D. In this article, you'll learn how to generate images with QuickDraw 3D and<br>
convert them to QuickTime VR movies. To make a panoramic movie, you create a<br>
panoramic image from a 3D scene, generate a linear QuickTime movie from the image,<br>
and convert the linear movie to an interactive panoramic movie using the QuickTime<br>
VR Authoring Tools Suite (ATS). (The ATS is a set of tools that you use from within<br>
MPW, the Macintosh Programmer's Workshop.) To create an object movie, you<br>
generate a series of images from a 3D model, add the images to a linear QuickTime<br>
movie, and then use the QuickTime VR ATS to convert the linear movie to an interactive<br>
object movie.
</p>
<p>
Before we get into the specifics of making movies, we'll explore the basic concepts of<br>
QuickTime VR. We assume you have a general understanding of QuickDraw 3D, which<br>
you can get by reading "QuickDraw 3D: A New Dimension for Macintosh Graphics" in<br>
<i>develop</i> Issue 22 and "The Basics of QuickDraw 3D Geometries" in <i>develop</i> Issue 23.<br>
You can learn all about QuickDraw 3D in the book <i>3D Graphics Programming With</i><br>
<i>QuickDraw 3D</i>.
</p>
<p>
This issue's CD contains all the code necessary to generate panoramic images and linear<br>
object movies from QuickDraw 3D models. For brevity, the listings in the article omit<br>
error handling; the code on the CD includes the complete versions of these functions.
</p>
<h2>QUICKTIME VR BASICS</h2>
<p>
The basic components of QuickTime VR movies are panoramas, nodes, objects, and<br>
scenes.
</p>
<ul>
<li> A <i>panorama</i> is an image spanning 360deg. or less in a real or virtual<br>
scene. The image is viewed from a particular location in the scene, called<br>
a<i>node</i>. A single-node panoramic movie enables a user to look in all directions<br>
from that location.</li>
<li> An <i>object</i> is an interactive item that can be viewed from all angles. Object<br>
movies can be linked to panoramic movies in a scriptable authoring<br>
environment, enabling a user to pick up and turn the objects from within a<br>
panorama. Object movies can also be used independently of panoramic movies.</li>
<li> In our case, the object of the movie is generated from a QuickDraw 3D<br>
model, which contains a single geometric object (or group of objects); we'll<br>
use the term <i>model</i> in this article to refer to the object in a QuickTime VR<br>
object movie.</li>
<li> A <i>scene</i> is a collection of several panoramas or nodes, a panorama with<br>
one or more objects, or several panoramas and objects all linked together by<br>
interactive hot spots. In a multinode scene, a user can navigate from node to<br>
node to move about the scene.</li>
</ul>
<p>
<b>SHOOTING AN OBJECT</b>
</p>
<p>
For object movies, you need to photograph the model (or the real object) from all<br>
directions, as shown in Figure 1. All vertical camera positions above the center of the<br>
model are considered positive, and all positions below it are considered negative. The<br>
vertical position with the camera directly above the model looking down at it is called<br>
<i>vertical pan 90deg.</i>; the vertical position directly below and looking up is called<br>
<i>vertical pan -90deg.</i>. <i>Vertical pan 0deg.</i> is at the model's center (equator). Horizontal<br>
positions are measured in degrees from <i>horizontal pan 0deg.</i> to <i>360deg.</i>. <i>Horizontal</i><br>
<i>pan 0deg.</i> is typically at the back of the model.
</p>
<p>
<img src="img/133.gif" width="420 px"></img>
</p>
<p>
<b>Figure 1. </b>Shooting a model (or a real object)
</p>
<p>
Images must be stored as frames in row order from top to bottom in a linear<br>
QuickTime movie. For best results, we (along with the QuickTime VR documentation)<br>
recommend that you have a frame every 10deg. between positions in both the<br>
horizontal and vertical direction. If you shoot at increments greater than 10deg., the<br>
motion of the model in the QuickTime VR movie will be choppier when the user turns<br>
it. If you shoot at increments of less than 10deg., the motion will be smoother, but<br>
you'll need more disk space to store all the frames. Whatever increment you choose, it<br>
should be consistent between all horizontal and vertical frames for the object and<br>
divide evenly into the horizontal and vertical pan ranges.
</p>
<p>
Your first frame at each horizontal position should be of the back of the model, so that<br>
the frame showing the front of the model is halfway through the series at that<br>
horizontal position. This improves disk access time at run time since the user will<br>
most likely be looking at the front of the model.
</p>
<p>
<b>SHOOTING A PANORAMA</b>
</p>
<p>
If you're using a real camera to shoot a panorama, you need to take the appropriate<br>
number of equally spaced pictures in a circle, as shown in Figure 2.
</p>
<p>
<img src="img/134.gif" width="516 px"></img>
</p>
<p>
<b>Figure 2. </b>Shooting a panorama
</p>
<p>
Although this sounds simple, there are a few things you must be aware of. First, you<br>
need to make sure you're taking the right number of shots for the lens you're using<br>
(see Chapter 6 in Volume 1 of the QuickTime VR ATS documentation for a full<br>
explanation of this). The entire camera rig should be level at all times, and the nodal<br>
point of the lens should be directly over the point of rotation of the rig. For best<br>
results, you should also have a consistent overlap between images; the more overlap,<br>
the better (30% to 50% is recommended). Finally, you should maintain consistency<br>
between images in each panorama by using similar exposure and a fixed focus.
</p>
<p>
Because this can get quite complicated, Apple strongly recommends the use of a<br>
professional photographer for making any production-quality titles. However, one way<br>
around this is to use rendered data, as we do in this article. The programmatic control<br>
we have over the "virtual" camera in a 3D environment such as QuickDraw 3D<br>
eliminates all of the problems just mentioned.
</p>
<h2>MAKING MOVIES WITH THE SAMPLE CODE</h2>
<p>
The sample code on this issue's CD enables you to make object and panoramic movies<br>
from any 3DMF file (a file that conforms to the QuickDraw 3D Object Metafile<br>
standard). For either type of movie, the code creates a new document record structure,<br>
reads in the model from a 3DMF file, renders the images, and writes out the images in<br>
a form that the QuickTime VR tools can work with. Here we'll look at the first few<br>
steps, which are common to both types of movies. The other steps for making<br>
QuickTime VR movies -- rendering and writing out the images and converting linear<br>
movies to interactive movies -- are different for object and panoramic moviemaking<br>
and are described later.
</p>
<p>
<b>CREATING A NEW DOCUMENT</b>
</p>
<p>
All of our scene information is stored in a document record structure, shown in Listing<br>
1.
</p>
<p>
<b>Listing 1.</b> The document record structure for a scene
</p>
<pre>typedef struct _DocumentRecord {
  CWindowPtr     theWindow;            // Display window
  FSSpec         theFileSpec;          // Model file specification
  short          fRefNum;              // and reference
  GWorldPtr      drawContextOffScreen; // Offscreen buffer
  TQ3GroupObject documentGroup;        // Main group for the document
  TQ3ViewObject  theView;              // The document's view object
  TQ3Matrix4x4   modelRotation;        // The model transform
  TQ3Point3D     documentGroupCenter;  // Center of the model
   ...   // Miscellaneous view, model, and QuickTime file details
} DocumentRecord, *DocumentPtr, **DocumentHandle;</pre>
<p class="spacer">&nbsp;</p>
<p>
The MyNewDocument function (Listing 2) creates the document record structure and<br>
sets up the view, camera, and other elements associated with the scene. It also adds the<br>
background buffer and window used to display the rendered images of the scene.
</p>
<p>
<b>Listing 2. </b>Creating a new document record structure
</p>
<pre>DocumentPtr MyNewDocument()
{
   DocumentPtr             theDocument;
   CWindowPtr              theWindow;
   TQ3DrawContextObject    theDrawContext;
   Rect                    myBounds = kMyBoundsRect;
   TQ3CameraObject         camera = NULL;
   RGBColor                blackColor = kMyBlackColor;
   ...

   theDocument = (DocumentPtr)NewPtrClear(sizeof(DocumentRecord));

   // Create the window for the document record and add references to
   // the document record.
   theWindow = (CWindowPtr)NewCWindow(0L, &amp;myBounds,
         "\pRendering Window", true, documentProc, (WindowPtr)-1L,
         true, NULL);
   theDocument-&gt;theWindow = theWindow;

   // Create and set up the offscreen GWorld/context.
   // ** Notice that QuickDraw 3D prefers direct color. **
   NewGWorld(&amp;theDocument-&gt;drawContextOffScreen, 32,
         &amp;theWindow-&gt;portRect, nil, nil, 0L);
   ...
   SetGWorld(theDocument-&gt;drawContextOffScreen, nil);
   EraseRect(&amp;theDocument-&gt;drawContextOffScreen-&gt;portRect);
   ...

   // Create the new pixmap draw context.
   theDrawContext = MyNewDrawContext(theDocument);

   // Create the view and set up the view attributes.
   ...
   // Initialize the model rotation and transitions used for object
   // movie rotations.
   Q3Matrix4x4_SetIdentity(&amp;theDocument-&gt;modelRotation);

   // Add more model and view properties to the document record.
   ...
   // Create the camera and add it to the view.
   camera = MyNewCamera(theDocument-&gt;theWindow);
   Q3View_SetCamera(theDocument-&gt;theView, camera);
   Q3Object_Dispose(camera);

   // Add the renderer to the view. Set the window's GWorld.
   Q3View_SetRendererByType(theDocument-&gt;theView,
         kQ3RendererTypeInteractive);
   SetGWorld(theWindow, nil);

   return (theDocument);
}</pre>
<p class="spacer">&nbsp;</p>
<p>
<b>CREATING THE CAMERA</b>
</p>
<p>
The camera used to render the images for the movies is created by the MyNewCamera<br>
function, shown in Listing 3.
</p>
<p>
<b>Listing 3. </b>Creating the rendering camera
</p>
<pre>TQ3CameraObject MyNewCamera(CWindowPtr theWindow)
{
   TQ3ViewAngleAspectCameraData   perspectiveData;
   TQ3CameraObject               camera;
   // For object movies, we set the field of view to 30 degrees (or
   // 30.0*kQ3Pi/180.0 radians). For panoramic movies, we set it to
   // 74 degrees (or 74*kQ3Pi/180.0 radians). QuickDraw 3D requires
   // angles to be in radians, while QuickTime VR requires them to
   // be in degrees.
   float                         fieldOfView = 30.0*kQ3Pi/180.0;
   TQ3Status                     returnVal = kQ3Failure;

   // Assign default placement.
   perspectiveData.cameraData.placement.cameraLocation
       = kMyDefaultFrom;
   perspectiveData.cameraData.placement.pointOfInterest
       = kMyDefaultTo;
   perspectiveData.cameraData.placement.upVector = kMyDefaultUp;
   perspectiveData.cameraData.range.hither = kMyDefaultHither;
   perspectiveData.cameraData.range.yon = kMyDefaultYon;

   // Assign standard view port.
   perspectiveData.cameraData.viewPort.origin.x = -1.0;
   perspectiveData.cameraData.viewPort.origin.y = 1.0;
   perspectiveData.cameraData.viewPort.width = 2.0;
   perspectiveData.cameraData.viewPort.height = 2.0;

   perspectiveData.fov = fieldOfView;
   perspectiveData.aspectRatioXToY =
      (float) (theWindow-&gt;portRect.right
               - theWindow-&gt;portRect.left) /
      (float) (theWindow-&gt;portRect.bottom
               - theWindow-&gt;portRect.top);

   camera = Q3ViewAngleAspectCamera_New(&amp;perspectiveData);

   return (camera);
}</pre>
<p class="spacer">&nbsp;</p>
<p>
For object movies, we set the field of view to approximately 30deg.. This is not a fixed<br>
number; you can use any number that you see fit, based generally on the aspect ratio of<br>
your viewing window and how much information you'd like to display inside it.
</p>
<p>
For panoramic movies, we set the field of view to 74deg.. This matches the horizontal<br>
field of view of a 15mm lens for our image. We specify the horizontal rather than<br>
vertical field of view since our image is taller than it is wide (768 x 512 pixels), and<br>
QuickDraw 3D requires the field of view to be specified as that of the shorter side of<br>
the image (whether width or height). We calculate the horizontal field of view based on<br>
the size of our image and the known vertical field of view of a 15mm lens (97deg., as<br>
specified in Chapter 9 of the QuickTime VR ATS documentation).
</p>
<p>
<b>READING IN THE MODEL</b>
</p>
<p>
For the model to be read from a 3DMF file, you must first create 3D file and storage<br>
objects associated with that file. Once they've been created, you build up the model by<br>
reading in all the drawable objects from the file and adding them to a group, as shown<br>
in Listing 4.
</p>
<p>
<b>Listing 4.</b> Reading in the model
</p>
<pre>TQ3Status MyReadScene(TQ3FileObject file, DocumentPtr theDocument)
{
   TQ3Object         object;
   TQ3Boolean        isEOF;
   TQ3ViewObject     view;
   TQ3Object         model;
   TQ3GroupObject    lightGroup = NULL;

   // Create the new model and get the view.
   model = Q3DisplayGroup_New();
   theDocument-&gt;documentGroup = model;
   view = theDocument-&gt;theView;

   // Collect all drawable objects (into the model) and collect any
   // lights (into the lightGroup).
   while ((isEOF = Q3File_IsEndOfFile(file)) == kQ3False) {
      object = Q3File_ReadObject(file);

      if (Q3Object_IsDrawable(object))
         Q3Group_AddObject(model, object);

      if (Q3Object_IsType(object, kQ3SharedTypeViewHints))
         if (view)
            Q3ViewHints_GetLightGroup((TQ3ViewHintsObject)object,
                  &amp;lightGroup);

      if (object != NULL)
         Q3Object_Dispose(object);
   }

   // Add any lights found to the view. Otherwise create default
   // lights.
   if (lightGroup) {
      Q3View_SetLightGroup(view, lightGroup);
      Q3Object_Dispose(lightGroup);
   }
   else
      MyNewLights(theDocument);

   Q3File_Close(file);
   return kQ3Success;
}</pre>
<p class="spacer">&nbsp;</p>
<p>
If the model includes any lighting, we use those lights; otherwise we create our own<br>
lighting for the model.
</p>
<p>
<b>GETTING THE DIMENSIONS OF THE MODEL</b>
</p>
<p>
We must know the dimensions of the entire model as well as its center in order to place<br>
the camera in its initial position and to guide both camera and model transformations.<br>
You obtain the dimensions and center of an already constructed model by getting the<br>
model's <i>bounding sphere</i> with the function MyGetBoundingSphere (Listing 5). The<br>
bounding sphere is another 3D object that fully surrounds the model and has as its<br>
center the exact center of the model.
</p>
<p>
<b>Listing 5.</b> Getting the model's bounding sphere
</p>
<pre>void MyGetBoundingSphere(TQ3ViewObject viewObject, TQ3GroupObject
      mainGroup, TQ3BoundingSphere *viewBSphere)
{
   TQ3Status      status;

   Q3View_StartBoundingSphere(viewObject,
       kQ3ComputeBoundsApproximate);
   do {
      status = Q3DisplayGroup_Submit(mainGroup, viewObject);
   } while (Q3View_EndBoundingSphere(viewObject, viewBSphere) ==
         kQ3ViewStatusRetraverse);
}</pre>
<p class="spacer">&nbsp;</p>
<p>
For object movies, the bounding sphere has an additional purpose. Although a 3D model<br>
from a QuickDraw 3DMF file may contain more than one geometric object, a QuickTime<br>
VR object movie has only one geometric object or one group of objects. Thus, we use<br>
the bounding sphere to get the dimensions of the entire group of objects.
</p>
<h2>MAKING A QUICKTIME VR OBJECT MOVIE</h2>
<p>
Now we'll get into the specifics of making a QuickTime VR object movie. The<br>
MyConvert3DMFToObject function (shown in Listing 6) drives the entire process,<br>
from creating the new document to generating the linear object movie. You use the<br>
QuickTime VR ATS to generate an interactive object movie from this linear movie.
</p>
<p>
<b>Listing 6.</b> Converting 3DMF files to linear object movies
</p>
<pre>void MyConvert3DMFToObject(FSSpec *myFSS)
{
   DocumentPtr      theDocument;

   // Create the document record and make the view, camera, lights,
   // window, and so on.
   theDocument = MyNewDocument();

   // Read in the model and add it to the document record's group.
   MyOpenFile(myFSS);

   // Set up the initial camera position.
   MyInitObjCamera(theDocument);

   // Draw initial view to the screen.
   MyDrawOffScreen(theDocument);
   MyDrawOnScreen(theDocument);

   // Assign the codec type.
   theDocument-&gt;theCodecType = kMyCodec;

   // Generate all the images and add them to the movie.
   MyGenerateObjImages(theDocument, 36, 19, 360, 0, 90, -90);

   ...
}</pre>
<p class="spacer">&nbsp;</p>
<p>
<b>DOING THE MODEL AND CAMERA WORK</b>
</p>
<p>
Photographing a real object involves using a spherical camera rig to rotate a camera<br>
around the object. For 3D models, it's just as easy to rotate the model in front of a<br>
stationary camera. Furthermore, since the camera doesn't move in this case, the<br>
lighting is easier to manage because it doesn't need to be rotated with the camera<br>
(unless you want the object to appear to be lighted from a certain angle).
</p>
<p>
In our case, we'll render images of the model by rotating the model around two of its<br>
axes while the camera views it from the third axis; thus the camera gets a view of the<br>
model from every angle. In our case, we'll place the camera along the <i>z</i> axis and rotate<br>
the model around the <i>x </i>and <i>y</i> axes. The initial positions of the camera and the model can<br>
be seen in Figure 3.
</p>
<p>
<img src="img/135.gif" width="372 px"></img>
</p>
<p>
<b>Figure 3. </b>Initial positions of the camera and the model for object movies
</p>
<p>
The initial placement of the camera for an object movie is performed by the function<br>
MyInitObjCamera, shown in Listing 7. First we get the bounding sphere of the<br>
drawable group of the model. From this we can get the center 3D point of the drawable<br>
group (as the origin of the bounding sphere) and the radius. From the center point we<br>
place the camera a distance of five times the radius down the <i>z</i> axis from the object.
</p>
<p>
<b>Listing 7. </b>Setting the initial camera position for an object movie
</p>
<pre>TQ3Point3D MyInitObjCamera(DocumentPtr theDocument)
{
   TQ3BoundingSphere    viewBSphere;
   float                  viewRadius;

   // Get the bounding sphere of the drawable group
   // (the entire model) in the view.
   MyGetBoundingSphere(theDocument-&gt;theView,
         theDocument-&gt;documentGroup, &amp;viewBSphere);

   // Get the bounding sphere's center and radius.
   theDocument-&gt;documentGroupCenter = viewBSphere.origin;
   viewRadius = viewBSphere.radius;

   // Position the camera down the z axis from the bounding sphere
   // based on the center and the radius.
   MyPlaceCamera(theDocument, theDocument-&gt;documentGroupCenter.x,
         theDocument-&gt;documentGroupCenter.y,
         theDocument-&gt;documentGroupCenter.z +
               kMyDistanceFactor*viewRadius + 1.0,
         theDocument-&gt;documentGroupCenter.x,
         theDocument-&gt;documentGroupCenter.y,
         theDocument-&gt;documentGroupCenter.z +
               kMyDistanceFactor*viewRadius);

   return (theDocument-&gt;documentGroupCenter);
}</pre>
<p class="spacer">&nbsp;</p>
<p>
We rotate the model by repeatedly modifying the model's transform object. The<br>
function MyRotateObjectX rotates the object around its <i>x</i> axis (see Listing 8). An<br>
analogous function that's not shown here, MyRotateObjectY, rotates it around the <i>y</i><br>
axis.
</p>
<p>
<b>Listing 8.</b> Rotating the model for object rendering
</p>
<pre>void MyRotateObjectX(DocumentPtr theDocument, float angle)
{
   TQ3Matrix4x4      tempMatrix;

   Q3Matrix4x4_SetTranslate(&amp;tempMatrix,
         -theDocument-&gt;documentGroupCenter.x,
         -theDocument-&gt;documentGroupCenter.y,
         -theDocument-&gt;documentGroupCenter.z);
   Q3Matrix4x4_Multiply(&amp;theDocument-&gt;modelRotation, &amp;tempMatrix,
         &amp;theDocument-&gt;modelRotation);

   Q3Matrix4x4_SetRotate_XYZ(&amp;tempMatrix, angle, 0.0, 0.0);
   Q3Matrix4x4_Multiply(&amp;theDocument-&gt;modelRotation, &amp;tempMatrix,
         &amp;theDocument-&gt;modelRotation);

   Q3Matrix4x4_SetTranslate(&amp;tempMatrix,
         theDocument-&gt;documentGroupCenter.x,
         theDocument-&gt;documentGroupCenter.y,
         theDocument-&gt;documentGroupCenter.z);
   Q3Matrix4x4_Multiply(&amp;theDocument-&gt;modelRotation, &amp;tempMatrix,
         &amp;theDocument-&gt;modelRotation);
}</pre>
<p class="spacer">&nbsp;</p>
<p>
We step through the model rotations to create the images needed for the linear object<br>
movie with the MyGenerateObjImages function, shown in Listing 9. In this function,<br>
we iterate over <i>y</i> angles (rotating around the <i>x</i> axis) while iterating over <i>x</i> angles<br>
(rotating around the <i>y</i> axis). This stepping takes us from the position yAngle =<br>
maxVPan, xAngle = minHPan to the position yAngle = minVPan, xAngle = maxHPan -<br>
minHPan. At each step in the <i>x</i> and <i>y</i> angles, the model is rotated and then rendered. The<br>
resulting images are added to a previously created movie, as described in the next<br>
section. Note that QuickTime VR likes angles in degrees and QuickDraw 3D likes angles<br>
in radians, so we have to do these conversions.
</p>
<p>
<b>Listing 9. </b>Generating images for the linear object movie
</p>
<pre>void MyGenerateObjImages(DocumentPtr theDocument, short rows, short
     columns, long maxHPan, long minHPan, long maxVPan, long minVPan)
{
   float      xStart, yStart, xStep, yStep, xAngle, yAngle;

   // Assign stepping angles.
   yStep = ((float)(maxVPan-minVPan))/(float)(rows-1);
   xStep = ((float)(maxHPan-minHPan))/(float)(columns-1);

   MyPrepareDestMovie(theDocument);

   for (yAngle = maxVPan; yAngle &gt;= minVPan; yAngle -= yStep) {
      for (xAngle = 0; xAngle &lt;= maxHPan-minHPan; xAngle += xStep) {
         // Rotate the object to the correct position.
         xStart = (-kQ3Pi*(xAngle -
                  ((float)(maxHPan-minHPan))/2.0))/180.0;
         yStart = kQ3Pi*((float)yAngle)/180.0;
         MyRotateObjectY(theDocument, xStart);
         MyRotateObjectX(theDocument, yStart);

         // Render the model (to get a PixMap image).
         MyDrawOffScreen(theDocument);
         MyDrawOnScreen(theDocument);

         // Add the rendered PixMap image to the movie.
         MyAddImageToMovie(theDocument);

         // Undo the rotation.
         MyRotateObjectX(theDocument, -yStart);
         MyRotateObjectY(theDocument, -xStart);
      }
   }
   MyCloseDestMovie(theDocument);
}</pre>
<p class="spacer">&nbsp;</p>
<p>
<b>CONSTRUCTING THE LINEAR OBJECT MOVIE</b>
</p>
<p>
The destination movie is an ordinary QuickTime movie. The movie file, track, and<br>
track media need to be set up before rendered images can be added to the movie. The<br>
images are added as frames to a track. (See <i>Inside Macintosh: QuickTime</i> for more<br>
details about this process.) The movie is constructed in the function<br>
MyPrepareDestMovie, shown in Listing 10.
</p>
<p>
<b>Listing 10.</b> Creating the destination linear object movie
</p>
<pre>OSErr MyPrepareDestMovie(DocumentPtr theDocument)
{
   long              keyFrameRate, compressedFrameSize;
   short             frameRate, width, height, i;
   CodecComponent    theCodec;
   FSSpec            theFSSpec;
   TimeScale         dstTimeScale;
   TimeValue         duration;
   CodecQ            spatialQuality;
   Str255            movieName = "\pObjectMovie";

   keyFrameRate = 1;       // Every frame must be a key frame. If
                           // not, we'll get garbage around the edges
                           // of our objects when we rotate them.
                           // QuickTime refreshes only key frames
                           // completely.
   theCodec = anyCodec;                  // We'll use what's there
   spatialQuality = codecHighQuality;   // and make it look pretty.
   frameRate = 10;         // This can be any value.
   dstTimeScale = 600;     // This can be any value that's a multiple
                           // of frameRate.
   duration = dstTimeScale/frameRate;

   width = theDocument-&gt;theWindow-&gt;portRect.right -
           theDocument-&gt;theWindow-&gt;portRect.left;
   height = theDocument-&gt;theWindow-&gt;portRect.bottom -
            theDocument-&gt;theWindow-&gt;portRect.top;

   theFSSpec = theDocument-&gt;theFileSpec;
   BlockMove(movieName, theFSSpec.name, movieName[0]+1);

   CreateMovieFile(&amp;theFSSpec, creatorType, 0,
         createMovieFileDeleteCurFile, &amp;theDocument-&gt;dstMovieRefNum,
         &amp;theDocument-&gt;dstMovie);
   theDocument-&gt;dstTrack = NewMovieTrack(theDocument-&gt;dstMovie,
         ((long)width) << 16, ((long)height) << 16, 0);
   theDocument-&gt;dstMedia = NewTrackMedia(theDocument-&gt;dstTrack,
         VideoMediaType, dstTimeScale, 0, 0);
   BeginMediaEdits(theDocument-&gt;dstMedia);

   GetMaxCompressionSize(theDocument-&gt;drawContextOffScreen
         -&gt;portPixMap,
         &amp;theDocument-&gt;drawContextOffScreen-&gt;portRect, 32,
         spatialQuality, theDocument-&gt;theCodecType, theCodec,
         &amp;compressedFrameSize);
   theDocument-&gt;compressedData = NewHandle(compressedFrameSize);
   theDocument-&gt;compressedDataPtr =
         StripAddress(*(theDocument-&gt;compressedData));
   HLock(theDocument-&gt;compressedData);
   theDocument-&gt;idh = (ImageDescriptionHandle)NewHandle(4);
   ...
}</pre>
<p class="spacer">&nbsp;</p>
<p>
We add the rendered images to the movie with the QuickTime function AddMediaSample,<br>
which is called from within the function MyAddImageToMovie (Listing 11).<br>
MyAddImageToMovie is called after each model rendering, as seen earlier in the<br>
MyGenerateObjImages function.
</p>
<p>
<b>Listing 11.</b> Adding images to the linear object movie
</p>
<pre>OSErr   MyAddImageToMovie(DocumentPtr theDocument)
{
   CodecQ      spatialQuality;
   TimeValue   duration, currentTime;

   spatialQuality = codecHighQuality;
   duration = 60;

   LockPixels(theDocument-&gt;drawContextOffScreen-&gt;portPixMap);
   CompressImage(theDocument-&gt;drawContextOffScreen-&gt;portPixMap,
         &amp;theDocument-&gt;drawContextOffScreen-&gt;portRect,
         spatialQuality, theDocument-&gt;theCodecType, theDocument-&gt;idh,
         theDocument-&gt;compressedDataPtr);
   UnlockPixels(theDocument-&gt;drawContextOffScreen-&gt;portPixMap);

   AddMediaSample(theDocument-&gt;dstMedia, theDocument-&gt;compressedData,
         0, (**(theDocument-&gt;idh)).dataSize, duration,
         (SampleDescriptionHandle)theDocument-&gt;idh, 1, 0,
         &amp;currentTime);
   ...
}</pre>
<p class="spacer">&nbsp;</p>
<p>
<b>GENERATING THE INTERACTIVE OBJECT MOVIE</b>
</p>
<p>
To generate the interactive object movie, open the linear movie you just created with<br>
the Navigable Movie Player application (in the QuickTime VR ATS) and choose the Add<br>
Navigable Data menu item. This brings up the dialog shown in Figure 4. Fill in the<br>
fields with the values shown and click OK to change the linear movie to an interactive<br>
movie. Turn the model to the position you want it to be in at the beginning of the<br>
interactive movie, choose the Set Poster View menu item, and you're done!
</p>
<p>
<img src="img/136.gif" width="510 px"></img>
</p>
<p>
<b>Figure 4. </b>The Add Navigable Data dialog
</p>
<h2>MAKING A QUICKTIME VR PANORAMIC MOVIE</h2>
<p>
There are two approaches to creating panoramic movies. One way is to simulate a real<br>
camera, rotate the camera to generate a series of images, and then "stitch" the images<br>
together into a single 360deg. panoramic PICT file with the QuickTime VR stitching<br>
tool. This panoramic picture file can be converted first to a linear movie and then to an<br>
interactive movie with the QuickTime VR ATS. This is the technique we'll look at first.<br>
You can also render a single panoramic image directly; this avoids the need for the<br>
stitching tool and enables us to convert the image into an interactive panoramic movie<br>
with only one line of script. The setup is similar for both approaches.
</p>
<p>
Throughout the QuickTime VR documentation, examples and references assume a<br>
vertically oriented, 360deg. full panorama that's 768 pixels across by 2496 pixels<br>
high, captured with a 15mm lens using portrait orientation. This is exactly the<br>
panorama we'll create.
</p>
<p>
Before you begin making the movie, you need to determine the number of shots<br>
required to make your panorama. For a real 360deg. panorama, the number of shots is<br>
a function of the length of your lens and the amount of overlap between the shots. For a<br>
rendered panorama, however, the number of shots is a function only of the horizontal<br>
field of view. Because the camera position and lighting conditions are controlled in the<br>
code, overlap between the shots isn't necessary. You can specify any amount of overlap,<br>
but theoretically a one-pixel overlap is all that's required.
</p>
<p>
In our case, we'll simulate the camera that's recommended in the QuickTime VR<br>
documentation -- that is, a camera with a 15mm lens. To be consistent with the<br>
examples in the documentation, we'll shoot 12 pictures, each 30deg. apart. This will<br>
give us an overlap of about 50%.
</p>
<p>
The function MyConvert3DMFToPano (Listing 12) drives the entire panoramic<br>
moviemaking process. Much like MyConvert3DMFToObject, this function creates a<br>
document, reads in the model, and renders the appropriate images.
</p>
<p>
<b>Listing 12.</b> Converting 3DMF files to panoramic images
</p>
<pre>void MyConvert3DMFToPano(FSSpec *myFSS)
{
   DocumentPtr      theDocument;

   // Create the document record.
   theDocument = MyNewDocument();

   // Read the model into the document record.
   MyOpenFile(myFSS);

   // Set up the initial camera position.
   MyInitPanoCamera(theDocument);

   // Draw initial view to the screen.
   MyDrawOffScreen(theDocument);
   MyDrawOnScreen(theDocument);
   ...
   // Create a series of images to stitch together into a panorama.
   MyGeneratePanoFrames(theDocument);

   // To create a single panoramic image, call
   // MyGeneratePanoMovieDirect instead of MyGeneratePanoFrames.
   ...
}</pre>
<p class="spacer">&nbsp;</p>
<p>
<b>DOING THE MODEL AND CAMERA WORK</b>
</p>
<p>
The initial placement of the camera is performed by the function MyInitPanoCamera<br>
(Listing 13). It first gets the bounding sphere of the model's drawable group, and from<br>
the bounding sphere gets the center 3D point of the group (as the origin of the<br>
bounding sphere). Of course, you can place your camera anywhere you like in the<br>
scene. For simplicity, we placed our camera in the center. From that position, the<br>
camera is rotated to create the images.
</p>
<p>
<b>Listing 13. </b>Setting the initial camera position for a panoramic movie
</p>
<pre>TQ3Point3D MyInitPanoCamera(DocumentPtr theDocument)
{
   TQ3BoundingSphere    viewBSphere;
   float                  viewRadius;

   // Get the bounding sphere of the drawable group
   // (the entire model) in the view.
   MyGetBoundingSphere(theDocument-&gt;theView,
         theDocument-&gt;documentGroup, &amp;viewBSphere);

   // Get the bounding sphere's center and radius.
   theDocument-&gt;documentGroupCenter = viewBSphere.origin;
   viewRadius = viewBSphere.radius;

   // Position the camera in the center of the bounding sphere.
   MyPlaceCamera(theDocument, theDocument-&gt;documentGroupCenter.x,
         theDocument-&gt;documentGroupCenter.y,
         theDocument-&gt;documentGroupCenter.z,
         theDocument-&gt;documentGroupCenter.x,
         theDocument-&gt;documentGroupCenter.y,
         theDocument-&gt;documentGroupCenter.z + 1.0);

   return (theDocument-&gt;documentGroupCenter);
}</pre>
<p class="spacer">&nbsp;</p>
<p>
For panoramic rendering, we rotate the camera around its y axis with the function<br>
MyRotateCameraY, shown in Listing 14. To do the rotation, we do the equivalent of<br>
translating to local coordinates, rotate, and then translate back to world coordinates.<br>
We do the transformation by making a rotation matrix about the local y axis (the up<br>
vector) at our location, getting our local z axis (by subtracting the point of interest<br>
from the current location), and then rotating the z vector around the y axis. We then<br>
apply this transformation to get a new point of interest. The rectangles encircling the<br>
camera in Figure 2 represent the images rendered after each camera rotation.
</p>
<p>
<b>Listing 14.</b> Rotating the camera for panoramic rendering
</p>
<pre>void MyRotateCameraY(DocumentPtr theDocument, float dY)
{
   TQ3CameraObject         camera;
   TQ3CameraPlacement      cameraPos;
   TQ3Matrix4x4            myRotation;
   TQ3Vector3D             initialVector, rotatedVector;

   Q3View_GetCamera(theDocument-&gt;theView, &amp;camera);
   Q3Camera_GetPlacement(camera, &amp;cameraPos);

   // Get the z vector.
   Q3Point3D_Subtract(&amp;cameraPos.pointOfInterest,
         &amp;cameraPos.cameraLocation, &amp;initialVector);

   // Rotate around the y axis.
   Q3Matrix4x4_SetRotateAboutAxis(&amp;myRotation,
         &amp;cameraPos.cameraLocation, &amp;cameraPos.upVector, dY);

   // Rotate the z vector around the y axis.
   Q3Vector3D_Transform(&amp;initialVector, &amp;myRotation, &amp;rotatedVector);

   // Get the point of interest from the rotated vector. The upVector
   // doesn't change.
   Q3Point3D_Vector3D_Add(&amp;cameraPos.cameraLocation, &amp;rotatedVector,
         &amp;cameraPos.pointOfInterest);

   Q3Camera_SetPlacement(camera, &amp;cameraPos);
   Q3View_SetCamera(theDocument-&gt;theView, camera);
   Q3Object_Dispose(camera);
}</pre>
<p class="spacer">&nbsp;</p>
<p>
To create a series of images, we step through the camera rotations with the<br>
MyGeneratePanoFrames function (Listing 15). Here we rotate the camera 30deg. at a<br>
time, render an image, and write the image to a PICT file. This gives us 12 PICT files<br>
named 01 through 12 that can be used in a very straightforward manner by the<br>
QuickTime VR ATS. To create a single panoramic image, you use the function<br>
MyGeneratePanoMovieDirect, as shown later.
</p>
<p>
<b>Listing 15. </b>Generating a series of images for a panoramic movie
</p>
<pre>void MyGeneratePanoFrames(DocumentPtr theDocument)
{
   PicHandle      thePict;
   float          zAngle;
   long           counter = 0;
   Str255         fName;
   GWorldPtr      gw;
   GDHandle       gd;
   FSSpec         outSpec;

   GetGWorld(&amp;gw, &amp;gd);
   SetGWorld(theDocument-&gt;theWindow, nil);

   outSpec = theDocument-&gt;theFileSpec;
   for (zAngle = 360; zAngle &gt;0; zAngle -= 30) {
      short      i;
      MyRotateCameraY(theDocument, -30.0*kQ3Pi/180.0);
      SetGWorld(theDocument-&gt;theWindow, nil);
      MyDrawOffScreen(theDocument);
      MyDrawOnScreen(theDocument);

      SetGWorld(theDocument-&gt;drawContextOffScreen, nil);
      thePict =
            OpenPicture(
                &amp;theDocument-&gt;drawContextOffScreen-&gt;portRect);

      LockPixels(theDocument-&gt;drawContextOffScreen-&gt;portPixMap);
     
CopyBits((BitMap*)&amp;theDocument-&gt;drawContextOffScreen-&gt;portPixMap,
            (BitMap*)&amp;theDocument-&gt;drawContextOffScreen-&gt;portPixMap,
            &amp;theDocument-&gt;drawContextOffScreen-&gt;portRect,
            &amp;theDocument-&gt;drawContextOffScreen-&gt;portRect,
            srcCopy, NULL);
      UnlockPixels(theDocument-&gt;drawContextOffScreen-&gt;portPixMap);
      ClosePicture();
      ...   // Set up the outSpec for the next image.
      MySavePICT(thePict, &amp;outSpec);
      KillPicture(thePict);
   }
   ...
}</pre>
<p class="spacer">&nbsp;</p>
<p>
<b>GENERATING THE INTERACTIVE PANORAMIC MOVIE</b>
</p>
<p>
You use the MPW tools and scripts provided in the QuickTime VR ATS to generate your<br>
interactive panoramic movie. (See the QuickTime VR ATS documentation for more<br>
information.)
</p>
<p>
<b>Stitching the images. </b>The stitching tool, called by the Stitch768 script, joins the<br>
series of computer-rendered images of your panorama into a single 360deg.<br>
panoramic PICT file. It's also used to stitch digitized photographic images together. The<br>
following example shows a portion of a stitch worksheet, with appropriate values set<br>
for each of the input variables. The stitching tool will use images numbered from 01 to<br>
12 located on the drive named HappyMac.
</p>
<pre>set panInFolder "HappyMac:RenderedFrames:"
set panOutFolder "HappyMac:RenderedFrames:"
set panRotate 0
set panX 100
set panDX 20
set panY 0
set panDY 10
export panInFolder panOutFolder panRotate panX panDX panY panDY
Stitch768 01-12 MyPano.srcPict</pre>
<p class="spacer">&nbsp;</p>
<p>
This script stitches your images into a vertically oriented, 360deg. full panorama<br>
that's 768 pixels across by 2496 pixels high, named MyPano.srcPict.
</p>
<p>
<b>Dicing the image into a linear movie.</b> The SrcPictToMovie script calls the<br>
dicing tool, which compresses your PICT file and divides it into equal-sized sections<br>
called <i>tiles</i>. For example, a standard-size panorama is "diced" into 24 tiles, 1 across<br>
by 24 down. Since we haven't included hot spots in our movie, our worksheet will<br>
include only one line, which calls the SrcPictToMovie script:
</p>
<pre>SrcPictToMovie "HappyMac:RenderedFrames:MyPano.srcPict"
   [[partialdiff]] "HappyMac:RenderedFrames:MyPano.srcMoov"</pre>
<p class="spacer">&nbsp;</p>
<p>
This script dices your 360deg. panoramic PICT into a standard QuickTime linear movie<br>
using 1-by-24 tiling and the Cinepak compressor.
</p>
<p>
<b>Converting the linear movie to an interactive movie. </b>The<br>
MakeSingleNodeMovie script takes the linear movie we just created and generates an<br>
interactive panoramic movie. Since we're creating a very standard type of interactive<br>
movie, this script does everything we need.
</p>
<p>
This example creates a single-node interactive panoramic movie file named<br>
My3DMovie:
</p>
<pre>MakeSingleNodeMovie "MyPano.srcMooV" "My3DMovie"</pre>
<p>
<b>RENDERING YOUR PANORAMA DIRECTLY</b>
</p>
<p>
You can avoid using the stitching tool by rendering your panorama directly. However,<br>
since QuickDraw 3D supports rendering directly to a plane but not to a cylinder, we<br>
have to approximate cylindrical rendering with a "slit" approach, using the cameras<br>
available to us.
</p>
<p>
The slit approach is the equivalent of using a real panoramic slit camera, which spins<br>
around, taking very thin pictures and laying them next to each other on the film. When<br>
simulating cylindrical rendering, we do the camera work described earlier, but<br>
instead of rotating 30deg. at a time and grabbing each frame, we rotate a very small<br>
amount each time and just grab a slit out of the middle of each frame, thus<br>
approximating a cylinder. The narrower the slit width, the closer we get to a true<br>
cylinder. If you're curious about the mathematics of slit sizes, see "Calculating the<br>
Optimal Slit Width."
</p>
<p class="spacer">&nbsp;</p>



<p>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CALCULATING THE OPTIMAL SLIT WIDTH</b>
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In the slit approach to simulating cylindrical rendering for QuickTime VR<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panoramic movies, narrower slits approximate cylinders better than wider<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ones. In our calculations, the size of the error shows us the effect of<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;increasingly wide slits.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Our error is defined as the vertical distance between the top of our projection<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plane at the maximum vertical field of view and the top of the cylinder we're<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trying to approximate. We consider an error of less than 0.5 pixels to be<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acceptable. Since fractional pixels can't be drawn, errors greater than 0.5<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;will round up to be a full pixel error. Because this error is so small, we can<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use the same field of view for generating both the slits and the entire frame.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To determine the vertical error, we must first determine the maximum<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;horizontal distance between the plane and the cylinder. This distance, labeled<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y, can be seen in the top view of our camera and cylinder, as shown in Figure<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5. The two triangles formed are identical (except for their orientation). The<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width of our slit is 2x.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given that 2x is the width of the slit, y is the distance between the plane and<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the cylinder, r is the radius of the cylinder, and [[alpha]] is the angle:
</p>
<p>

        <p style="margin-left: 88px">
            <math>
                <mtable columnalign="left" columnspacing="4em">
                    <mtr>
                        <mtd>
                            <mi>c</mi>
                            <mo>=</mo>
                            <mrow>
                                <mn>2</mn>
                                <mn>&pi;</mn>
                                <mo>&it;</mo>
                                <mi>r</mi>
                            </mrow>
                        </mtd>
                        <mtd>
                            <mi>r</mi>
                            <mo>=</mo>
                            <mfrac>
                                <mi>c</mi>
                                <mrow>
                                    <mn>2</mn>
                                    <mn>&pi;</mn>
                                </mrow>
                            </mfrac>
                        </mtd>
                    </mtr>
                    <mtr>
                        <mtd>
                            <mi>sin</mi>
                            <mi>&alpha;</mi>
                            <mo>=</mo>
                            <mfrac>
                                <mi>x</mi>
                                <mi>r</mi>
                            </mfrac>
                        </mtd>
                        <mtd>
                            <mi>&alpha;</mi>
                            <mo>=</mo>
                            <msup>
                                <mi>sin</mi>
                                <mn>-1</mn>
                            </msup>
                            <mo>(</mo>
                                <mfrac>
                                    <mi>x</mi>
                                    <mi>r</mi>
                                </mfrac>
                            <mo>)</mo>
                        </mtd>
                    </mtr>
                    <mtr>
                        <mtd>
                            <mi>cos</mi>
                            <mi>&alpha;</mi>
                            <mo>=</mo>
                            <mfrac>
                                <mrow>
                                    <mi>r</mi>
                                    <mo>-</mo>
                                    <mi>y</mi>
                                </mrow>
                                <mi>r</mi>
                            </mfrac>
                            <mo>=</mo>
                            <mn>1</mn>
                            <mo>-</mo>
                            <mfrac>
                                <mi>y</mi>
                                <mi>r</mi>
                            </mfrac>
                        </mtd>
                        <mtd>
                            <mi>&alpha;</mi>
                            <mo>=</mo>
                            <msup>
                                <mi>cos</mi>
                                <mn>-1</mn>
                            </msup>
                            <mo>(</mo>
                            <mn>1</mn>
                            <mo>-</mo>
                            <mfrac>
                                <mi>y</mi>
                                <mi>r</mi>
                            </mfrac>
                            <mo>)</mo>
                        </mtd>
                    </mtr>
                </mtable>
            </math>
        </p>
    
</p><p class="spacer">&nbsp;</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Therefore, where r is the radius of the cylinder and c is the circumference:
</p>
<p>

        <p style="margin-left: 88px">
            <math>
                <mtable columnalign="left" columnspacing="4em">
                    <mtr>
                        <mtd>
                            <mi>&alpha;</mi>
                            <mo>=</mo>
                            <msup>
                                <mi>sin</mi>
                                <mn>-1</mn>
                            </msup>
                            <mo>(</mo>
                            <mfrac>
                                <mi>x</mi>
                                <mi>r</mi>
                            </mfrac>
                            <mo>)</mo>
                            <mo>=</mo>
                            <msup>
                                <mi>cos</mi>
                                <mn>-1</mn>
                            </msup>
                            <mo>(</mo>
                            <mn>1</mn>
                            <mo>-</mo>
                            <mfrac>
                                <mi>y</mi>
                                <mi>r</mi>
                            </mfrac>
                            <mo>)</mo>
                        </mtd>
                    </mtr>
                    <mtr>
                        <mtd>
                            <mi>y</mi>
                            <mo>=</mo>
                            <mi>r</mi>
                            <mo>&it;</mo>
                            <mo>(</mo>
                            <mn>1</mn>
                            <mo>-</mo>
                            <mi>cos</mi>
                            <mo>(</mo>
                            <msup>
                                <mi>sin</mi>
                                <mn>-1</mn>
                            </msup>
                            <mo>(</mo>
                            <mfrac>
                                <mi>x</mi>
                                <mi>r</mi>
                            </mfrac>
                            <mo>)</mo>
                            <mo>)</mo>
                            <mo>)</mo>
                        </mtd>
                    </mtr>
                    <mtr>
                        <mtd>
                            <mi>y</mi>
                            <mo>=</mo>
                            <mfrac>
                                <mrow>
                                    <mi>c</mi>
                                    <mo>&it;</mo>
                                    <mo>(</mo>
                                    <mn>1</mn>
                                    <mo>-</mo>
                                    <mi>cos</mi>
                                    <mo>(</mo>
                                    <msup>
                                        <mi>sin</mi>
                                        <mn>-1</mn>
                                    </msup>
                                    <mo>(</mo>
                                    <mfrac>
                                        <mrow>
                                            <mn>2</mn>
                                            <mn>&pi;</mn>
                                            <mi>x</mi>
                                        </mrow>
                                        <mi>c</mi>
                                    </mfrac>
                                    <mo>)</mo>
                                    <mo>)</mo>
                                    <mo>)</mo>
                                </mrow>
                                <mrow>
                                    <mn>2</mn>
                                    <mn>&pi;</mn>
                                </mrow>
                            </mfrac>
                        </mtd>
                    </mtr>
                </mtable>
            </math>
        </p>
    <!-- second fragment -->
    
</p><p class="spacer">&nbsp;</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Since we know the final panorama we end up with is 2496 pixels wide, we can<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use this as our circumference, and
</p>
<p>

        <p style="margin-left: 88px">
            <math>
                <mi>y</mi>
                <mo>=</mo>
                <mn>397.25</mn>
                <mo>&it;</mo>
                <mo>(</mo>
                <mn>1</mn>
                <mo>-</mo>
                <mi>cos</mi>
                <mo>(</mo>
                <msup>
                    <mi>sin</mi>
                    <mn>-1</mn>
                </msup>
                <mo>(</mo>
                <mfrac>
                    <mi>x</mi>
                    <mn>397.25</mn>
                </mfrac>
                <mo>)</mo>
                <mo>)</mo>
                <mo>)</mo>
            </math>
        </p>
    <!-- third fragment -->
    
</p><p class="spacer">&nbsp;</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;However, this only gives us the slit width for a given distance y, so we must<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concern ourselves next with the important error, the vertical error, labeled<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ev. A side view of the panorama showing this error appears in Figure 6.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ev is the distance in pixels between the pixel we see on the plane and the pixel<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;we see on the cylinder for a given field of view. Since we already have an<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;equation for y in terms of our slit width (2x), and we know that the vertical<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;field of view (FOVv) of the lens we're using is 97deg., we can easily determine<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this error using the tangent equation
</p>
<p>

        <p style="margin-left: 88px">
            <math>
                <mtable columnalign="left" columnspacing="4em">
                    <mtr>
                        <mtd>
                            <msub>
                                <mi>E</mi>
                                <mi>v</mi>
                            </msub>
                            <mo>=</mo>
                            <mi>y</mi>
                            <mo>&it;</mo>
                            <mi>tan</mi>
                            <mo>(</mo>
                            <mfrac>
                                <msub>
                                    <mi>FOV</mi>
                                    <mi>v</mi>
                                </msub>
                                <mn>2</mn>
                            </mfrac>
                            <mo>)</mo>
                        </mtd>
                    </mtr>
                    <mtr>
                        <mtd>
                            <msub>
                                <mi>E</mi>
                                <mi>v</mi>
                            </msub>
                            <mo>=</mo>
                            <mn>397.25</mn>
                            <mo>&it;</mo>
                            <mo>(</mo>
                            <mn>1</mn>
                            <mo>-</mo>
                            <mi>cos</mi>
                            <mo>(</mo>
                            <msup>
                                <mi>sin</mi>
                                <mn>-1</mn>
                            </msup>
                            <mo>(</mo>
                            <mfrac>
                                <mi>x</mi>
                                <mn>397.25</mn>
                            </mfrac>
                            <mo>)</mo>
                            <mo>)</mo>
                            <mo>)</mo>
                            <mo>&it;</mo>
                            <mi>tan</mi>
                            <mo>(</mo>
                            <mfrac>
                                <msub>
                                    <mi>FOV</mi>
                                    <mi>v</mi>
                                </msub>
                                <mn>2</mn>
                            </mfrac>
                            <mo>)</mo>
                        </mtd>
                    </mtr>
                </mtable>
            </math>
        </p>
    <!-- fourth fragment -->
    
</p><p class="spacer">&nbsp;</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Since we know that our FOVv is 97deg., we have
</p>
<p>

        <p style="margin-left: 88px">
            <math>
                <msub>
                    <mi>E</mi>
                    <mi>v</mi>
                </msub>
                <mo>=</mo>
                <mi>y</mi>
                <mo>&it;</mo>
                <mi>tan</mi>
                <mo>(</mo>
                <mn>48.5</mn>
                <mo>)</mo>
            </math>
        </p>
    <!-- fifth fragment -->
    
</p><p class="spacer">&nbsp;</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which leaves us with a final equation of
</p>
<p>

        <p style="margin-left: 88px">
            <math>
                <msub>
                    <mi>E</mi>
                    <mi>v</mi>
                </msub>
                <mo>=</mo>
                <mn>397.25</mn>
                <mo>&it;</mo>
                <mo>(</mo>
                <mn>1</mn>
                <mo>-</mo>
                <mi>cos</mi>
                <mo>(</mo>
                <msup>
                    <mi>sin</mi>
                    <mn>-1</mn>
                </msup>
                <mo>(</mo>
                <mfrac>
                    <mi>x</mi>
                    <mn>397.25</mn>
                </mfrac>
                <msub>
                    <mi>E</mi>
                    <mi>v</mi>
                </msub>
                <mo>)</mo>
                <mo>)</mo>
                <mo>)</mo>
                <mo>&it;</mo>
                <mi>tan</mi>
                <mo>(</mo>
                <mn>48.5</mn>
                <mo>)</mo>
            </math>
        </p>
    <!-- sixth fragment -->
    
</p><p class="spacer">&nbsp;</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The slit widths for various vertical errors are as follows:
</p>
<p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Vertical error (Ev) Slit width (2x)</b></code>
</p>
<pre>          0.14228682           20</pre>

<pre>          0.20490732           24</pre>

<pre>          0.27892462           28</pre>

<pre>          0.36434438           32</pre>

<pre>          0.4611731            36</pre>

<pre>          0.56941818           40</pre>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For a slit width of about 38, we have an error of less than 0.5. Theoretically,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this should yield accurate pictures. Therefore, for panoramas that are 2496<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pixels wide, like ours, the optimal slit width is 32 (the largest factor of<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2496 that's still less than 38).
</p>
<p>
<img style="margin-left: 44px" src="img/143.gif" width="264 px"></img>
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Figure 5. </b>Determining y, the distance between the plane and the cylinder
</p>
<p>
<img style="margin-left: 44px" src="img/144.gif" width="288 px"></img>
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Figure 6.</b> Determining Ev, the vertical error
</p>
<p>
In our case, the largest slit size that gives us a very small amount of error is 32, so<br>
we use this number to generate our panorama (Listing 16). To try different sizes,<br>
simply put in a different number for the slit size constant, which we've called factor.
</p>
<p>
<b>Listing 16.</b> Rendering the panorama directly
</p>
<pre>#define factor 32.0
void MyGeneratePanoMovieDirect(DocumentPtr theDocument)
{
   PicHandle     thePict;
   float         zAngle;
   short         i;
   GWorldPtr     gw, largeGW;
   GDHandle      gd;
   FSSpec        outSpec;
   Rect          sourceRect, destRect, largeRect = {0, 0, 768, 2496};

   GetGWorld(&amp;gw, &amp;gd);
   SetGWorld(theDocument-&gt;theWindow, nil);
   outSpec = theDocument-&gt;theFileSpec;

   NewGWorld(&amp;largeGW, 32, &amp;largeRect, nil, nil, useTempMem);
   LockPixels(largeGW-&gt;portPixMap);
   SetGWorld(largeGW, nil);
   EraseRect(&amp;largeRect);
   sourceRect = destRect = largeRect;
   sourceRect.left = 256 - factor/2.0;
   sourceRect.right = sourceRect.left + (short)factor;
   destRect.left = 0;
   destRect.right = (short)factor;

   for (zAngle = 360.0; zAngle &gt; 0.0;
        zAngle -= 360.0/(2496.0/factor)) {
      MyRotateCameraY(theDocument, -2*kQ3Pi/(2496.0/factor));

      SetGWorld(theDocument-&gt;theWindow, nil);
      MyDrawOffScreen(theDocument);
      MyDrawOnScreen(theDocument);

      SetGWorld(largeGW, nil);
      LockPixels(theDocument-&gt;drawContextOffScreen-&gt;portPixMap);
      CopyBits(
            (BitMap*)&amp;theDocument-&gt;drawContextOffScreen-&gt;portPixMap,
            (BitMap*)&amp;largeGW-&gt;portPixMap, &amp;sourceRect, &amp;destRect,
            srcCopy, NULL);
      UnlockPixels(theDocument-&gt;drawContextOffScreen-&gt;portPixMap);
      destRect.left = destRect.left + (short)factor;
      destRect.right = destRect.right + (short)factor;
   }

   SetGWorld(largeGW, nil);
   thePict = OpenPicture(&amp;largeGW-&gt;portRect);
   CopyBits(
         (BitMap*)&amp;largeGW-&gt;portPixMap, (BitMap*)&amp;largeGW
             -&gt;portPixMap,
         &amp;largeGW-&gt;portRect, &amp;largeGW-&gt;portRect, srcCopy, NULL);
   ClosePicture();
   UnlockPixels(largeGW-&gt;portPixMap);
   DisposeGWorld(largeGW);
   MySavePICT(thePict, &amp;outSpec);
   ...
}</pre>
<p class="spacer">&nbsp;</p>
<p>
The PICT file you get from this operation is oriented horizontally. However, the<br>
QuickTime VR tools expect the stitching tool output to be vertical, so you first need to<br>
rotate your PICT clockwise 90deg. using a PICT editor such as Photoshop or<br>
PhotoFlash. You then use the SrcPictToMovie and MakeSingleNodeMovie scripts as<br>
described above to turn the PICT into an interactive panoramic movie.
</p>
<h2>THE NEXT STEPS</h2>
<p>
So far we've made QuickTime linear object movies and panoramic PICT files that can be<br>
converted to interactive movies with the QuickTime VR ATS. There are a number of<br>
directions you can go from here. If you have your own panoramic renderer, you may<br>
want to substitute it for our slit-based rendering. Or you may want to build a full<br>
interface to allow the user to place the camera and set up all the parameters involved<br>
in QuickTime VR moviemaking. We hope to write a future article about the QuickTime<br>
VR movie file formats and how to write out QuickTime VR movie files.
</p>
<p>
QuickTime VR movies already have several diverse uses. Developers with extensive<br>
collections of 3D data sets can generate QuickTime VR movies from their data sets to<br>
show to potential customers; the movies display the modeled objects more effectively<br>
than a 2D representation and don't compromise the data in the process. Archaeologists<br>
can use QuickTime VR movies to record site information during digs, realtors can use<br>
them to give clients virtual tours through the property they're offering, and cities can<br>
use them to provide tourist information on kiosks. Museums can archive or display<br>
their collections with QuickTime VR movies. For example, Apple and the Asian Art<br>
Museum of San Francisco have put together a virtual walkthrough of one of the<br>
museum's special exhibits; you can check it out on the World Wide Web<br>
athttp://sfasian.apple.com. Also, for the latest information on QuickTime VR,<br>
seehttp://qtvr.quicktime.apple.com. Use your imagination -- the possibilities are<br>
endless!
</p>



<b>RECOMMENDED READING</b>
<ul>
<li>"QuickDraw 3D: A New Dimension for Macintosh Graphics" by Pablo<br>
Fernicola and Nick Thompson, <i>develop</i> Issue 22.</li>
<li>"The Basics of QuickDraw 3D Geometries" by Nick Thompson and Pablo<br>
Fernicola, <i>develop</i> Issue 23.</li>
<li><i>3D Graphics Programming With QuickDraw 3D</i> (Addison-Wesley,<br>
1995).</li>
<li><i>Inside Macintosh: QuickTime and Inside Macintosh: QuickTime</i><br>
<i>Components</i>(Addison-Wesley, 1993).</li>
<li><i>One Hundred Years of Solitude</i> by Gabriel Garc&iacute;a M&aacute;rquez<br>
(Harper &amp; Row, 1970). This won't directly help you with QuickTime VR or<br>
QuickDraw 3D, but it's Philip's favorite novel.</li>
</ul>



<p>
<b>PETE FALCO</b> (AppleLink FALCOP) is a member of Apple's QuickTime VR team. Since<br>
finishing school at Rensselaer Polytechnic Institute in upstate New York, where he<br>
spent the last six years in the rainy, snowy weather of Troy, he's found the sunny<br>
weather of California a welcome treat and vows he'll never leave this area. His latest<br>
projects include working on the next release of QuickTime VR as well as integrating all<br>
of Apple's multimedia technologies with QuickTime VR.*
</p>
<p>
<b>PHILIP MCBRIDE</b> (mcbride@apple.com) has been working on multimedia tools and<br>
the underlying media technologies since he's been at Apple. Most recently this included<br>
helping to add QuickTime VR to Apple Media Tool 2.0. While not working with digital<br>
multimedia, Philip likes to work with real multimedia by sculpting. In fact, he's been<br>
developing a new product that will involve clay, a mouse, and a bottle of cabernet. The<br>
details are sketchy, but he has a cool T-shirt for it.*
</p>
<p>
Thanks to our technical reviewers Eric Chen, Michael Chen, Ken Doyle, Ian Small, and<br>
Nick Thompson. Special thanks to Chris Flick and Pablo Fernicola.*
</p>
</body>
</html>
