<html>
<head>
<!-- Article ID: 22 - Extracted from develop-1994 -->
<!-- on 2024-05-24 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by the copyright of its respective owners -->
<title>June 94 - Exploiting Graphics Speed on the Power Macintosh</title>
<link href="../common/styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h2>June 94 - Exploiting Graphics Speed on the Power<br>
Macintosh</h2>
<h1>KONSTANTIN OTHMER, SHANNON HOLLAND, AND<br>
BRIAN COX</h1>
<p>
<img src="img/180.gif" width="180 px"></img>
</p>
<p>
<i>The new QuickDraw on the PowerPC platform substantially improves graphics</i><br>
<i>performance. A study comparing the performance of QuickDraw and custom blitters on</i><br>
<i>the Power Macintosh and 680x0-based machines provides information you can use to</i><br>
<i>ensure that the user benefits from those improvements. Further analysis, detailing</i><br>
<i>where CopyBits spends its time, leads to an implementation strategy for applications</i><br>
<i>that demand the fastest possible graphics.</i>
</p>
<p class="spacer">&nbsp;</p>
<p>
Understanding the motivation for and consequences of the changes to QuickDraw on the<br>
Power Macintosh can help you write faster applications. This article presents studies<br>
that show QuickDraw as one of the most speed-critical parts of the Macintosh<br>
Operating System together with studies that break down how applications spend CPU<br>
time. Knowing how much time applications actually spend in various system routines<br>
will help you develop a strategy for writing applications that perform well on both the<br>
Power Macintosh and 680x0-based machines.
</p>
<p>
In porting QuickDraw to the PowerPCTM platform, Apple took advantage of the<br>
opportunity to make some changes. We'll detail these changes and their consequences<br>
for writing code. With that foundation, we'll move on to an in-depth discussion<br>
comparing the QuickDraw CopyBits routine with custom blitters. The goal is to write<br>
applications using routines that result in the fastest possible graphics performance on<br>
both platforms -- PowerPC and 680x0 -- as well as on machines equipped with<br>
graphics accelerators such as the new Apple Macintosh Display Card 24 AC. Sample<br>
code on this issue's CD demonstrates a method of timing blitter routines so that your<br>
application can use the fastest routine at run time.
</p>
<h2>HOW SPEED-CRITICAL IS QUICKDRAW?</h2>
<p>
Most of the Macintosh Operating System is written in 680x0 assembly language. In<br>
order to reach time-to-market goals for the Power Macintosh, Apple had to focus<br>
porting efforts on the most speed- critical parts of the system, so a study was<br>
conducted to profile system usage of several common applications. System usage<br>
depended largely on the operations performed in particular applications, but many<br>
applications showed similar patterns. 
</p>
<p>
Figure 1 is based on a subset of the study. It turns out that most applications spend<br>
from 50% to 95% of their time in system code, with many spending more than 80%.<br>
Figure 2 shows the percentage of total CPU time spent in the most frequently called<br>
system routines for typical applications and for a pointer-based application (one that<br>
avoids using handles).
</p>
<p>
<img src="img/181.gif" width="533 px"></img>
</p>
<p>
<b>&nbsp;Figure 1. </b>CPU time breakdown: application versus system
</p>
<p>
<img src="img/182.gif" width="600 px"></img>
</p>
<p>
<b>Figure 2. </b>System routine usage
</p>
<p class="spacer">&nbsp;</p>
<p>
&nbsp;The data made it clear that QuickDraw was one of the most critical components of<br>
Apple's porting efforts. This article discusses QuickDraw version 1.3.5, which was<br>
developed to run on the PowerPC platform. The new QuickDraw is based on QuickDraw<br>
version 1.3.0, the most recent version of QuickDraw running on the Macintosh<br>
Quadra, but with some changes (see the section "What's Different With Version<br>
1.3.5?"). The new version, written in C, was compiled for the Power Macintosh as<br>
QuickDraw version 1.3.5 and shipped with the new machines. The new QuickDraw C<br>
code can also be compiled for 680x0-based machines and will be available in future<br>
software releases.
</p>
<p>
&nbsp;The graphics speed comparisons made in this article compare the following:
</p>
<ul>
<li>QuickDraw version 1.3.0 or other 680x0 code running on a 680x0-based<br>
Macintosh (usually a Macintosh Quadra)</li>
<li>QuickDraw version 1.3.0 or other 680x0 code running through the<br>
emulator on a Power Macintosh</li>
<li>QuickDraw version 1.3.5 or other PowerPC code running on a Power<br>
Macintosh</li>
</ul>
<h2>&nbsp;TAKING ADVANTAGE OF THE SPEED</h2>
<p>
Figure 3 compares times of various QuickDraw routines for version 1.3.0 running on<br>
a Macintosh Quadra and version 1.3.5 running on a Power Macintosh -- there's no<br>
question that the new QuickDraw routines run faster. However, published surveys<br>
comparing the speed of 680x0-based machines to the Power Macintosh haven't always<br>
shown the dramatic results indicated by Figure 3.&nbsp;&nbsp;&nbsp;This is partly because some<br>
operations offer greater increased speed than others, so depending on which operations<br>
an application uses heavily, overall speed varies. A second important factor is that the<br>
applications surveyed are often emulated applications.
</p>
<p>
<img src="img/183.gif" width="600 px"></img>
</p>
<p>
<b>Figure 3. </b>Comparing QuickDraw version 1.3.0 to version 1.3.5
</p>
<p>
Emulated applications are those written for 680x0-based machines that run through<br>
the emulator on the Power Macintosh (see "Making the Leap to PowerPC,"<i>develop</i> Issue<br>
16). These applications don't benefit fully from the PowerPC platform, because an<br>
application that spends 80% of its time in system code on 680x0-based machines,<br>
when emulated on a Power Macintosh, spends substantially more time in the<br>
application. In general, completely emulated application code runs at about half the<br>
speed of a Macintosh Quadra 700. Those same applications, when recompiled as<br>
PowerPC code, usually run four or five times faster than on a Macintosh Quadra; code<br>
that makes extensive use of floating point may be 20 times or more faster. However,<br>
emulated graphics-intensive code, assuming it uses QuickDraw, is substantially faster<br>
on a Power Macintosh than on a 680x0-based Macintosh because of the increased speed<br>
of QuickDraw 1.3.5.
</p>
<p>
&nbsp;Clearly, to take full advantage of QuickDraw version 1.3.5, you need to write your<br>
applications for the Power Macintosh in PowerPC code. Beyond that general strategy,<br>
developing awesome applications for the PowerPC platform means figuring out how to<br>
harness all that CPU power -- how to take advantage of the speed. For example, the<br>
high speed of QuickDraw version 1.3.5 allows you to do high-quality animations.<br>
Figure 3 shows that you can now do twice as many (or more) CopyBits operations per<br>
second, which means that animations such as zooming, scrolling, and window dragging<br>
(leave this one to Apple) can be done in real time without being chunky or annoying.<br>
Text drawing is also much faster, so interactive word wrapping while positioning<br>
objects in text is easy to do and looks better than it would on a 680x0-based<br>
Macintosh. Overall, it's an open field for developers.
</p>
<p>
<b>Tips for increasing the speed</b> of PowerPC code are given in this issue's Balance of<br>
Power column. *
</p>
<p>
&nbsp;Although this article focuses on QuickDraw, of course there are other, nongraphical,<br>
ways of harnessing the power of the PowerPC processor. Floating point-intensive<br>
applications benefit tremendously from the speed of the new processor. 
</p>
<p>
<b>&nbsp;The Graphing Calculator desk accessory </b> that ships with the Power Macintosh<br>
is an excellent example of harnessing CPU power for both the user interface and<br>
computation-bound part of an application. As a floating point-intensive application,<br>
Graphing Calculator benefits from the speed of the PowerPC processor. The user<br>
interface has a number of nice touches, such as live scrolling, live zooming, and<br>
interactive formula and graph manipulation. *
</p>
<h2>WHAT'S DIFFERENT WITH VERSION 1.3.5?</h2>
<p>
In the porting of QuickDraw to the PowerPC platform, many algorithms were<br>
rethought and reimplemented. The result is slightly different (and we hope better!)<br>
behavior. This section outlines some changes to keep in mind when you're writing code.
</p>
<p class="spacer">&nbsp;</p>
<p>
<b>QDERROR</b><br>
QuickDraw version 1.3.0 didn't do a very good job of setting and clearing QDError. In<br>
version 1.3.5, every call sets QDError (which can cause problems for applications<br>
that assume QDError will be preserved across most simple calls, like SetRect). In<br>
some cases, version 1.3.0 jumps to SysError if there isn't enough memory; version<br>
1.3.5 returns an error in QDError instead. This is usually an improvement, but it can<br>
lead to strange behavior for applications that depend on SysError being invoked. For<br>
example, some applications might put up a dialog asking the user to increase the<br>
application partition size if QuickDraw invokes SysError. Since QuickDraw version<br>
1.3.5 doesn't invoke SysError (returning a QDError instead), the application code<br>
that puts up the dialog isn't triggered, so the user doesn't know to increase the memory<br>
and the application might fail by not drawing anything. In choosing to always set<br>
QDError, Apple chose the lesser of two evils. 
</p>
<p>
<b>MATCHING COLOR TABLES</b><br>
QuickDraw version 1.3.0 uses the color table of the pixMap for the current GDevice,<br>
not the color table of the destination pixMap, to map colors to the destination pixMap.<br>
QuickDraw version 1.3.5 sets up a surrogate GDevice to make sure that the the<br>
destination pixMap's and the GDevice's color tables always match. This may cause<br>
problems for applications that relied on undefined behavior when the color tables<br>
didn't match or for applications that were getting the right results by luck under<br>
QuickDraw version 1.3.0. Again, Apple chose the lesser of two evils, and added the<br>
surrogate device (known as the skank device). When QuickDraw is forced to set up the<br>
skank device, the application pays a slight performance penalty. Also, if you do<br>
operations such as index-to-color when your color tables don't match, and then later<br>
use that color in a drawing, you won't necessarily draw with the index you expect. The<br>
easiest cure: use GWorlds!
</p>
<p>
<b>&nbsp;For more information </b>on QDError, GDevices, pixMaps, and color tables, see <br>
<i>Inside Macintosh: Imaging With QuickDraw </i> or <i>Inside Macintosh </i> Volume V. *
</p>
<p>
<b>TRANSFER MODES</b><br>
There's no way to pass the transfer space (the bit depth at which transfer occurs)<br>
when doing transfer modes in QuickDraw. (QuickDraw GX remedies thisshortcoming.)<br>
So if you're using an arithmetic mode from 8-bit to 16-bit, there are noguarantees<br>
whether the transfer will occur at 5 bits per component (16-bit), 8 bits per<br>
component (32-bit), or 16 bits per component (as in the 8-bit color table). It turns<br>
out that most arithmetic modes in QuickDraw version 1.3.0 perform the transfer<br>
operation at a resolution of 16 bits per color, while version 1.3.5 does most<br>
operations at a resolution of 8 bits per color. This sometimes causes slight cosmetic<br>
differences. 
</p>
<p>
<b>DITHERING</b><br>
The dithering algorithm in QuickDraw version 1.3.5 is slightly different. This makes<br>
it a nightmare to programmatically determine whether version 1.3.5 is generating the<br>
same results as version 1.3.0, but visually the results are nearly identical. 
</p>
<p>
<b>STRETCHING AND SHRINKING IMAGES</b><br>
The way CopyBits stretches and shrinks images for nonintegral ratios has been<br>
improved in QuickDraw version 1.3.5 (integral ratios still produce the same results).<br>
The advantage of this new algorithm is that it's symmetrical: if you stretch an image<br>
and then shrink it back to the original size, the same pixels that were replicated in the<br>
stretch are combined in the shrink.
</p>
<p>
The disadvantage of the new algorithm is that some applications stretch or shrink<br>
without knowing it (the classic off-by-one error, resulting in a destination rectangle<br>
that's smaller or larger than the source rectangle by one pixel). Such applications<br>
may now drop (or replicate) a different scan line.&nbsp;&nbsp;&nbsp;This can cause slight cosmetic<br>
blemishes in some applications.
</p>
<p>
<b>UNEXPECTED REGISTER CONTENTS</b><br>
Because QuickDraw version 1.3.5 runs PowerPC code, all emulated 680x0 registers<br>
are preserved across calls. Thus, applications that expect the contents of volatile<br>
registers (A0, A1, D0, D1, D2) to contain specific values on exit from a QuickDraw<br>
call will break. (Conversely, don't rely on 680x0 registers being preserved, either!)<br>
There's one exception: for compatibility with some existing applications, CopyBits<br>
always sets D0 to 0. 
</p>
<p>
<b>PATCHING</b><br>
Patching any QuickDraw version 1.3.5 routine with 680x0 code degrades performance<br>
because of mode-switch overhead time. A mode switch occurs when a 680x0 caller is<br>
calling PowerPC code, or vice versa. 680x0 patches on ShieldCursor are particularly<br>
expensive because ShieldCursor is called by nearly every QuickDraw drawing routine.
</p>
<p>
<b>&nbsp;For more information </b>on the Mixed Mode Manager and mode switching, see<br>
"Making the Leap to PowerPC" in <i>develop</i>&nbsp;&nbsp;Issue 16.*
</p>
<p>
<b>DISABLED ACCELERATOR CARDS</b><br>
QuickDraw version 1.3.0 makes calls through many low-level (undocumented)<br>
vectors. Version 1.3.5 doesn't use these trap vectors, which disables most accelerator<br>
cards. Of course, the frame buffer on these cards continues to work.
</p>
<h2>THE COPYBITS/CUSTOM BLITTER RACE</h2>
<p>
A favorite developer sport is complaining about how slow CopyBits is and writing<br>
custom blit loops to replace it. A favorite sport among QuickDraw engineers is working<br>
all night trying to speed up some part of CopyBits. This competition is healthy so long<br>
as speed-critical applications call the faster code. 
</p>
<p>
<b>&nbsp;"Blitter" </b>informally refers to any routine that moves memory, usually visual<br>
information to the screen or an off-screen buffer; the operation is called a "blit." <br>
These terms derive from the PDP-10 block transfer instruction, BLT. *
</p>
<p>
Through the years, Apple engineers have yearned for a way to get a substantial lead in<br>
the race with the speed-hungry special-case developer. The answer lies in the Power<br>
Macintosh: raw 680x0 code runs substantially slower through the emulator, while<br>
QuickDraw version 1.3.5 CopyBits takes advantage of the lightning-fast RISC<br>
processor.
</p>
<p>
Figure 4 compares various ways of moving the memory used by an 8-bit, 32-by-32<br>
pixMap and an 8- bit, 400-by-400 pixMap to the screen. BlockMove gives a baseline:<br>
the typical amount of time needed to move that much raw memory. The 680x0 blitter<br>
is a custom blitter written for 680x0-based machines and emulated on the Power<br>
Macintosh. The PowerPC blitter is a custom blitter written for the Power Macintosh<br>
(it can't be run on a 680x0 machine). 
</p>
<p>
<img src="img/184.gif" width="600 px"></img>
</p>
<p>
<b>Figure 4. </b>CopyBits versus custom blitters
</p>
<p>
As you can see, the custom PowerPC blitters beat QuickDraw's CopyBits for the small<br>
image hands down for both 680x0-based machines and the Power Macintosh. (With the<br>
small image the constant overhead of CopyBits has a big impact on the overall time.)<br>
However, the 680x0 blitter is much slower than CopyBits on a Power Macintosh. This<br>
is due to the overhead of emulation.
</p>
<p>
The interesting case is the custom PowerPC blitter versus CopyBits for the large<br>
image on the Power Macintosh. Here CopyBits wins. This is due to optimizations that<br>
CopyBits has for large images that the PowerPC blitter doesn't have. In this case,<br>
CopyBits is also faster than BlockMove, because of optimizations in CopyBits for the<br>
PowerPC processor's frame buffer (which has a 64-bit data path). BlockMove is<br>
optimized for copying to main memory, so it's slower when copying to the frame<br>
buffer. (This is why the PowerPC blitter is faster than BlockMove for the small<br>
image.) If you compare BlockMove and CopyBits using an off-screen pixMap as the<br>
destination, you discover that BlockMove is faster.
</p>
<p>
<b>&nbsp;For maximum performance </b>of emulated applications, the emulator treats<br>
BlockMove as a special case. *
</p>
<p>
The design of a frame buffer can have a great impact on overall blit speed. These times<br>
were measured on the on-board video for the Macintosh Quadra and a fast<br>
processor-direct slot video card for the Power Macintosh. If you install a<br>
NuBusTMframe buffer on both machines and do a similar comparison, you find that the<br>
difference in times is less. That's because NuBus is the bottleneck for the copy<br>
operation. The situation changes radically, however, if the NuBus card is accelerated.<br>
Then only calls to CopyBits get the acceleration; custom blit loops are still<br>
bottlenecked by NuBus transfer rates. 
</p>
<p>
<b>&nbsp;Most of the comparisons </b>in this section compare raw memory-moving power.<br>
While QuickDraw is efficient at stretching bits, it's very inefficient at large indexed<br>
shrinks. The problem is that CopyBits looks at every pixel and preserves the highest<br>
index value. (This was done so that when icons are shrunk, they don't inadvertently go<br>
to solid white.) For a shrink by a factor of four, this means that CopyBits is looking at<br>
16 times too much data.*
</p>
<h2>REDUCING QUICKDRAW OVERHEAD</h2>
<p>
There are two aspects to any given QuickDraw operation: setup and actual drawing.<br>
Much of the time saved when an application uses a custom blit loop instead of CopyBits<br>
is a consequence of avoiding the overhead of QuickDraw's setup. While QuickDraw has<br>
extremely efficient blit routines, its downfall is that it has no idea how it's going to be<br>
called from one time to the next, so it has to do all the setup every time it's called. (See<br>
"Drawing in GWorlds for Speed and Versatility" in<i>develop</i> Issue 10 for a discussion of<br>
QuickDraw's setup.)
</p>
<p>
An application knows exactly how many of what it's drawing to where, so it can do the<br>
setup for many operations once at the beginning, use custom blitters to do the drawing,<br>
and then restore everything to its previous condition at the end, thus eliminating much<br>
of the setup time. This is where you get the biggest gains when writing your own<br>
blitters. On large operations, the overhead is relatively small, so you don't gain much<br>
with custom routines. Small operations are often dominated by setup time, so a custom<br>
routine can improve performance significantly. 
</p>
<p>
&nbsp;Figure 5 compares setup time to total time for two CopyBits operations. Both are a<br>
copy of a 32-by- 32, 8-bit, off-screen pixMap to the screen (no stretching or<br>
shrinking, long aligned). The difference is that in the first CopyBits call, the color<br>
tables match and in the second call they don't match (the first case is faster because<br>
there's no need to invoke a pixel translation loop). Figure 6 shows the same two tests<br>
as Figure 5, but this time the pixMaps being copied are 400-by-400. If you look<br>
carefully, you can see that the setup time remained almost the same, but the<br>
proportion between setup time and total time has changed drastically.
</p>
<p>
&nbsp;In general, the setup time on the Power Macintosh is minimal, since the setup is<br>
computation- intensive and doesn't depend on memory access. Remember that setup<br>
time is constant -- it remains the same no matter how much data is being copied.<br>
Therefore, the relative efficiency of CopyBits depends on the amount of data being<br>
copied. 
</p>
<p>
<img src="img/185.gif" width="524 px"></img>
</p>
<p>
<b>&nbsp;Figure 5. </b>CopyBits setup time to total time for a small copy
</p>
<p>
<img src="img/186.gif" width="542 px"></img>
</p>
<p>
<b>&nbsp;Figure 6. </b>CopyBits setup time to total time for a large copy
</p>
<p>
&nbsp;The systems compared in Figures 5 and 6 are a Power Macintosh 8100/80 running<br>
QuickDraw version 1.3.5 and a Macintosh Quadra 700 running QuickDraw version<br>
1.3.0. These comparisons show that QuickDraw blit times can vary greatly across<br>
different machines and different versions of QuickDraw. 
</p>
<p>
<b>&nbsp;QuickDraw GX uses caches </b>extensively to keep intermediate results. This allows<br>
part of the overhead to be short-circuited when a similar operation is performed<br>
multiple times. *
</p>
<p>
Accelerator vendors use a number of different strategies for boosting QuickDraw's<br>
performance. The Macintosh 8*24GC card attempted to accelerate entire operations,<br>
while most third-party accelerators just concentrate on the blits. These cards often<br>
use custom chips to substantially increase the speed of writing to memory; you're still<br>
forced to pay for the setup time, but the blit time decreases substantially. 
</p>
<p>
The upshot of this is that you're only guaranteed the best results if you profile the<br>
candidates and pick a winner at run time. This is the topic of the following section. 
</p>
<h2>STRATEGY FOR SPEED-CRITICAL APPLICATIONS</h2>
<p>
For applications in which speed is critical, you want to run as fast as possible on<br>
every machine. The easiest way to do this is to time the system code and any custom<br>
code and use the faster version, perhaps even on a call by call basis. By comparing the<br>
speed of a custom implementation with the Toolbox implementation and picking the<br>
faster one at application initialization time, applications can automatically take<br>
advantage of hardware accelerators when they exist, or highly specialized custom blit<br>
loops when required. Of course, you would use this strategy only when speed is<br>
extremely important. While developing your application, you should always try to use<br>
system calls when they're available before reinventing (a sometimes square) wheel.
</p>
<p>
Listing 1 shows two routines, TimeBlitProc and BestBlitter, that compare CopyBits<br>
with a custom blitter and return the address of the faster routine. (The code is also on<br>
this issue's CD.) Writing the custom blitter is left as an exercise for the reader.
</p>
<p>
BestBlitter takes a pointer to a BlitProc, a PixMapHandle, and a source and destination<br>
rectangle and returns the address of the faster routine -- the custom BlitProc or<br>
CopyBits. It assumes that the destination rectangle is for the current graphics port and<br>
current GDevice. For the sake of simplicity, the mode is assumed to be srcCopy and<br>
there's no mask region. 
</p>
<p>
<b>Listing 1. </b>Timing routines
</p><p class="spacer">&nbsp;</p>
<pre>#include &lt;Timer.h&gt;
#include &lt;FixMath.h&gt;
#include &lt;Traps.h&gt;
#if powerc
    extern QDGlobals qd;
#endif

// Decide how many microseconds represent a "meaningful" difference.
#define     kMeaningfulDiff     0
#define     ABS(x)                  ((x &lt; 0)? (-x) : (x))

unsigned long TimeBlitProc(BlitProcPtr theBlitProc,
    BitMapPtr srcBits, BitMapPtr dstBits, Rect *srcRect,
    Rect *dstRect, short mode, RgnHandle mask)
{
    UnsignedWide    startMicroSec, endMicroSec;

    Microseconds(&amp;startMicroSec);
    (*theBlitProc)(srcBits, dstBits, srcRect, dstRect, mode, mask);
    Microseconds(&amp;endMicroSec);
    // WideSubtract isn't defined for 680x0-based machines; however,
    // a version is included on the CD.
    WideSubtract((wide *) &amp;endMicroSec,
        (wide *) &amp;startMicroSec);
    return endMicroSec.lo;
}
BlitProcPtr BestBlitter(BlitProcPtr customBlitProc,
    PixMapHandle srcPixHandle, Rect *srcRect, Rect *dstRect)
{
    unsigned long   customBitsTime, copyBitsTime;
    long                leDifference;
    PixMapHandle    portPixMap;
    BlitProcPtr     copyBitsPtr;
    Str255          numStr;
   
    // To factor out the trap overhead, get the trap address for
    // CopyBits. PowerPC can get the address of the shared library
    // routine directly. By getting the address of the library
    // routine like this, we don't need to worry about calling
    // CopyBits through CallUniversalProc.
#if powerc
    copyBitsPtr = (BlitProcPtr) &amp;CopyBits;
#else
    copyBitsPtr = (BlitProcPtr) GetToolTrapAddress(_CopyBits);
#endif
   
    portPixMap = ((CGrafPtr) qd.thePort)-&gt;portPixMap;

    // Normally, it's not necessary to lock a pixMap or its pixels
    // before calling CopyBits. But in this case, we're calling
    // TimeBlitProc, which could hit the Segment Loader and cause
    // memory to move. So we lock the pixMap handles before
    // dereferencing them here.
    HLock((Handle) portPixMap);
    LockPixels(portPixMap);
    copyBitsTime = TimeBlitProc(copyBitsPtr,
        (BitMapPtr) *srcPixHandle, (BitMapPtr) *portPixMap, srcRect,
        dstRect, srcCopy, nil);
    customBitsTime = TimeBlitProc(customBlitProc,
        (BitMapPtr) *srcPixHandle, (BitMapPtr) *portPixMap, srcRect,
         dstRect, srcCopy, nil);
    UnlockPixels(portPixMap);
    HUnlock((Handle) portPixMap);
    leDifference = (long)(customBitsTime - copyBitsTime);
    if (ABS(leDifference) &gt; kMeaningfulDiff &amp;&amp; leDifference &lt; 0)
        return customBlitProc;
    else
        return copyBitsPtr;
}</pre>
<p class="spacer">&nbsp;</p>
<p>
BestBlitter gets the address of CopyBits (factoring out trap dispatch overhead if<br>
running on a 680x0- based Macintosh, as you might want to do in your speed-critical<br>
loops) and calls TimeBlitProc to get the time taken by each of the calls. If the<br>
difference is enough to be meaningful (more than a few microseconds) and favors the<br>
new BlitProc, BestBlitter returns a pointer to the BlitProc; otherwise, it returns a<br>
pointer to CopyBits. 
</p>
<p>
The actual timing is done by TimeBlitProc, which assumes that the current graphics<br>
port and GDevice are set up and ready for copying. TimeBlitProc takes a pointer to the<br>
BlitProc to be timed and a list of arguments expected by CopyBits.
</p>
<p>
We've made the assumption that the caller has flushed or loaded the caches<br>
appropriately for the test.&nbsp;&nbsp;&nbsp;In comparing the routines, it would be unfair to one<br>
routine if it had to spend time loading the data into the cache and the other routine<br>
didn't! FlushInstructionCache and FlushDataCache are no longer available for<br>
applications written in PowerPC code, so it's up to the caller to decide whether to test<br>
these BlitProcs cached or uncached. (See "Here's the Cache" for a discussion of caching<br>
on the Power Macintosh.) In any case, TimeBlitProc assumes that the caches are<br>
already in the proper state. 
</p>
<p>
Since caching is such a hardware-specific operation and can have both very obvious<br>
and subtle effects on the execution of your code, it's hard to predict how different cache<br>
architectures will affect yourperformance. In general, if you try to optimize for<br>
smaller caches, you'll achieve better overall performance across a range of platforms.<br>
To be completely fair, TimeBlitProc should also disable interrupts. If file sharing<br>
comes in to work on a background copy in the middle of the timing, that blit loop will<br>
appear to be really slow compared to the uninterrupted time. 
</p>
<p>
TimeBlitProc calls a new trap, Microseconds, that takes a pointer to an UnsignedWide<br>
(two longs) and fills it with the number of microseconds that have elapsed since the<br>
system was booted. It calls Microseconds before and after the call to the BlitProc that<br>
was passed in, calls WideSubtract to get the delta, and returns the low-order 32 bits<br>
of the subtraction. This assumes that the elapsed time will fit into an unsigned long, or<br>
that the BlitProc will take less than 71 minutes to complete! 
</p>
<h2>HERE'S THE CACHE</h2>
<p>
The traps FlushInstructionCache and FlushDataCache were originally created to give<br>
direct control over the instruction and data caches on 68040-based Macintosh Quadra<br>
models. These two traps are very closely tied to the 68040 processor, both<br>
conceptually and in their implementation. The PowerPC 601 chip has a unified cache<br>
-- a single 32K cache for both data and instructions. Rather than trying to contort the<br>
definition of the two existing traps to make sense on the PowerPC processor, Apple<br>
engineers asked why you need to flush caches in the first place. The new<br>
cache-management strategies are intended to be better abstracted, less dependent on a<br>
specific processor, and definitely forward compatible.
</p>
<p>
Following are the four main reasons you might want to flush the caches and how<br>
they've been (or need to be) addressed on the Power Macintosh.
</p>
<p>
<b>Generate code dynamically.</b><br>
Normally, to execute some data as instructions, you need to flush the caches. On the<br>
Power Macintosh, you call the new system routine MakeDataExecutable, passing the<br>
base address and the length of the data to be executed. (This routine doesn't exist --<br>
even in an undocumented form -- on the 680x0-based machines, so to flush<br>
instructions in the data cache, you need to call FlushInstructionCache and<br>
FlushDataCache.)
</p>
<p>
<b>Ensure that the data shared by other hardware is actually written.</b><br>
For example, memory that's shared by a coprocessor&nbsp;&nbsp;has to be accessible when the<br>
other processor needs to read it. To address this problem, the PowerPC-family<br>
architecture includes a type of "bus snooping." Whenever someone wants to read an<br>
address that's represented in the cache, the cache is flushed automatically before the<br>
data is returned. This way, you don't need to anticipate all the different ways the cache<br>
can get out of sync.
</p>
<p>
<b>Ensure that data gets written to memory in the correct order.</b><br>
For example, if you're writing to the screen, make sure the title bar gets written<br>
before the contents. A caching mechanism could screw up this ordering, so to ensure<br>
the proper ordering, the data cache must be flushed between writes. Screen memory is<br>
marked as <i> write-through</i> , which sends the data to the cache and on through to the<br>
screen memory. Writes for write-through memory are as slow as for uncached<br>
memory. The benefit is that reads from write-through memory can still take<br>
advantage of the cache. This feature is present on the 68040 Macintosh and remains<br>
unchanged on the Power Macintosh.
</p>
<p>
<b>Ensure that timing data you get when you compare two similar routines</b><br>
<b>hasn't been distorted by the caching mechanism.</b><br>
Unfortunately, you're out of luck here. There's no officially sanctioned method for<br>
doing this. But there are some techniques you can use to get around the caching.
</p>
<p>
If you anticipate that your procedure will usually have its data cached when it's called,<br>
compare the routines for the cached condition. Simply call the routines twice and time<br>
only the second call.
</p>
<p>
To compare the routines for the noncached case, you can "flush" the cache by reading<br>
every byte in a 32K buffer. Not only is this ugly, but it's not even guaranteed to work<br>
with future machines (such as the PowerPC 603, which goes back to using separate<br>
data and instruction caches). And even on the 601 chip, this would flush only the<br>
on-chip cache; it wouldn't necessarily flush the much larger, but slightly slower,<br>
external cache.
</p>
<h2>OFF AND RUNNING</h2>
<p>
The Power Macintosh provides a new range of computing power for the next generation<br>
of the Macintosh line. The challenge for Apple is converting from a largely 680x0<br>
assembly code base to PowerPC-code system services and substantially improving the<br>
user experience in the process. The challenge for application developers is inventing<br>
new uses for all the power provided by RISC, and designing creative user interface<br>
elements that take advantage of the horsepower. 
</p>
<p>
Use the studies presented here as a guide to writing graphics-intensive applications<br>
that shine on both platforms. By using techniques such as runtime determination of the<br>
most efficient routines, you can guarantee that your application will get the most out<br>
of the system today and in the future. 
</p>
<p>
<b>KONSTANTIN OTHMER, SHANNON HOLLAND, AND BRIAN COX</b> , who are always<br>
ready to explore new avenues in software development for the QuickDraw team, have<br>
finally hit the nail on the head. Their secret is high-tech equipment and proper<br>
delegation of work. Alternating between periods of sleep and contemplation, they use<br>
telepathic communication to transmit source code to each new team member, who can<br>
then look forward to many days of compile cycles on a trusty Macintosh Plus<br>
(providing our authors with even more time for sleep and contemplation). The team is<br>
on the lookout for new labor-saving devices. Donations are welcome -- comfortable<br>
couches to make room for future expansion would be particularly appreciated.*
</p>
<p>
<b>Thanks </b>to our technical reviewers Lew Cirne, Jean-Charles Mourey, Guillermo<br>
Ortiz, and Andy Stadler; to Kate Cremer for generating the graphs; and to Tom Adams,<br>
Becky Hammaker, Marianne Hsiung, Mac MacDougall, and David Searles for conducting<br>
the application evaluations.*
</p>
</body>
</html>
