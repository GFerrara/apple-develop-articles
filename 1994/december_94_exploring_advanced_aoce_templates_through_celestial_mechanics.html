<html>
<head>
<!-- Article ID: 58 - Extracted from develop-1994 -->
<!-- on 2024-05-24 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by the copyright of its respective owners -->
<title>December 94 - Exploring Advanced AOCE Templates Through Celestial Mechanics</title>
<link href="../common/styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h1>Exploring Advanced AOCE Templates Through<br>
Celestial Mechanics</h1>
<h2>Harry R. Chesley</h2>
<p>
<img src="img/262.gif" width="182 px"></img>
</p>
<p>
<i>PowerTalk provides AOCE catalogs to store and edit collections of information. The</i><br>
<i>Catalogs Extension to the Finder lets you use AOCE templates to extend the types of</i><br>
<i>information stored and the means of editing it, which makes the catalogs open-ended</i><br>
<i>rather than limited to the information types provided by Apple with the PowerTalk</i><br>
<i>software. This article explores several advanced features of AOCE templates, showing</i><br>
<i>how new types of entries can be added that store information about planets and</i><br>
<i>calculate their current locations and orbits.</i>
</p>
<p>
The AOCE Catalogs Extension (CE) -- an extension to the Finder and one of the<br>
PowerTalk components -- was originally conceived as an open-ended means of<br>
providing addresses for PowerTalk mail and messaging; however, it goes well beyond<br>
that original goal. The CE allows third-party developers to extend the Finder in a<br>
variety of ways, including providing new catalog entry types, new views on the<br>
contents of entries, new means of editing those contents, runtime calculation of<br>
information to be displayed, and new actions to perform in the case of drag and drop<br>
and double-click operations. AOCE templates, which serve as the extension mechanism,<br>
provide resources and code that define the format, appearance, and functionality of<br>
catalog entries.
</p>
<p>
Because this article explores advanced features of the AOCE template mechanism, we<br>
assume some familiarity with AOCE catalogs and a basic understanding of AOCE<br>
templates and the terms used to describe them. The article "Getting the Most out of<br>
AOCE Catalog Records" in this issue gives an overview of AOCE catalogs and templates.<br>
For in-depth information, the definitive reference is <i>Inside Macintosh: AOCE</i><br>
<i>Application Interfaces.</i>
</p>
<p>
&nbsp;&nbsp;In this article, we demonstrate how the template mechanism can be extended to plot<br>
the orbits of the planets. For those of you who aren't interested in celestial mechanics<br>
and could care less about the mathematics involved in calculating the position of a<br>
celestial body, don't worry -- the article focuses on templates; you can skip the<br>
details on celestial mechanics without limiting your understanding. But if you are<br>
interested, see "Algorithms for Calculating Planetary Positions."
</p>


    <h2>ALGORITHMS FOR CALCULATING PLANETARY <br>
        POSITIONS</h2>
    <p>
        Here we discuss the parameters and algorithms used for calculating the <br>
        positions of the planets. Orbits are three dimensional, but for our purpose - <br>
        plotting the orbit from an overhead perspective - we need only two dimensions.<br>
        Extending the templates to three dimensions is an excellent exercice for the <br>
        reader.
    </p>
    <p>
        The parameters needed for calculating a planed's orbit are as follows:
    </p>
    <style>
        td.centered {
            text-align: center;
        }
        td.r_padded {
            padding-right: 12px;
        }
        td.l_padded {
            padding-left: 12px;
        }
    </style>
    <p>
    <table>
        <tr>
            <td class="centered">
                <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Symbol&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</b>
            </td>
            <td>
                <b>Meaning</b>
            </td>
        </tr>
        <tr>
            <td class="centered">
                <math>
                    <msub>
                        <mi mathvariant="normal">T</mi>
                        <mpadded depth="10%">
                            <mi mathvariant="normal">p</mi>
                        </mpadded>
                    </msub>
                </math>
            </td>
            <td>Period (tropical years)</td>
        </tr>
        <tr>
            <td class="centered">
                <math>
                    <mi mathvariant="normal">&epsilon;</mi>
                </math>
            </td>
            <td>Longitude at epoch (degrees)</td>
        </tr>
        <tr>
            <td class="centered">
                <math>
                    <mover accent="true">
                        <mi mathvariant="normal">&omega;</mi>
                        <mo>¯</mo>
                    </mover>
                </math>
            </td>
            <td>Longitude at the perihelion (degrees)</td>
        </tr>
        <tr>
            <td class="centered">e</td>
            <td>Eccentricity of the orbit</td>
        </tr>
        <tr>
            <td class="centered">a</td>
            <td>Semi-major axis of the orbit</td>
        </tr>
    </table>
    </p>
    <p>
        These parameters are for the epoch 1990 January 0.0. We use them to calculate <br>
        a series of intermediate values, leading up to calculating the x and y <br>
        coordinates used to plot the planet's position for the specified date and time.<br>
        Table 1 below shows the actual values of the orbital parameters for each of <br>
        the planets.
    </p>
    <p style="margin: 0px; height: 8px;" />
    <p>
        <b>Table 1.</b> Orbital parameter values<br>
    </p>
    <p>
    <table>
        <tr>
            <th style="text-align: left;">Planet</th>
            <th>
                <math>
                    <msub>
                        <mi mathvariant="bold">T</mi>
                        <mpadded depth="10%">
                            <mi mathvariant="bold">p</mi>
                        </mpadded>
                    </msub>
                </math>
            </th>
            <th>
                <math>
                    <mi mathvariant="bold">&epsilon;</mi>
                </math>
            </th>
            <th>
                <math>
                    <mover accent="true">
                        <mi mathvariant="bold">&omega;</mi>
                        <mo>¯</mo>
                    </mover>
                </math>
            </th>
            <th>e</th>
            <th>a</th>
        </tr>
        <tr>
            <td class="r_padded">Mercury</td>
            <td class="r_padded l_padded">0.240852</td>
            <td class="r_padded l_padded">60.750646</td>
            <td class="r_padded l_padded">77.299833</td>
            <td class="r_padded l_padded">0.205633</td>
            <td class="r_padded l_padded">0.387099</td>
        </tr>
        <tr>
            <td class="r_padded">Venus</td>
            <td class="r_padded l_padded">0.615211</td>
            <td class="r_padded l_padded">88.455855</td>
            <td class="r_padded l_padded">131.430236</td>
            <td class="r_padded l_padded">0.003778</td>
            <td class="r_padded l_padded">0.723332</td>
        </tr>
        <tr>
            <td class="r_padded">Earth</td>
            <td class="r_padded l_padded">1.00004</td>
            <td class="r_padded l_padded">99.403308</td>
            <td class="r_padded l_padded">102.768413</td>
            <td class="r_padded l_padded">0.016713</td>
            <td class="r_padded l_padded">1.00000</td>
        </tr>
        <tr>
            <td class="r_padded">Mars</td>
            <td class="r_padded l_padded">1.880932</td>
            <td class="r_padded l_padded">240.739474</td>
            <td class="r_padded l_padded">335.874939</td>
            <td class="r_padded l_padded">0.093396</td>
            <td class="r_padded l_padded">1.523688</td>
        </tr>
        <tr>
            <td class="r_padded">Jupiter</td>
            <td class="r_padded l_padded">11.863075</td>
            <td class="r_padded l_padded">90.638185</td>
            <td class="r_padded l_padded">14.170747</td>
            <td class="r_padded l_padded">0.048482</td>
            <td class="r_padded l_padded">5.202561</td>
        </tr>
        <tr>
            <td class="r_padded">Saturn</td>
            <td class="r_padded l_padded">29.471362</td>
            <td class="r_padded l_padded">287.690033</td>
            <td class="r_padded l_padded">92.861407</td>
            <td class="r_padded l_padded">0.055581</td>
            <td class="r_padded l_padded">9.554747</td>
        </tr>
        <tr>
            <td class="r_padded">Uranus</td>
            <td class="r_padded l_padded">84.039492</td>
            <td class="r_padded l_padded">271.063148</td>
            <td class="r_padded l_padded">172.884833</td>
            <td class="r_padded l_padded">0.046321</td>
            <td class="r_padded l_padded">19.21814</td>
        </tr>
        <tr>
            <td class="r_padded">Neptune</td>
            <td class="r_padded l_padded">164.79246</td>
            <td class="r_padded l_padded">282.349556</td>
            <td class="r_padded l_padded">48.009758</td>
            <td class="r_padded l_padded">0.009003</td>
            <td class="r_padded l_padded">30.109570</td>
        </tr>
        <tr>
            <td class="r_padded">Pluto</td>
            <td class="r_padded l_padded">246.77027</td>
            <td class="r_padded l_padded">221.4127</td>
            <td class="r_padded l_padded">224.133</td>
            <td class="r_padded l_padded">0.24624</td>
            <td class="r_padded l_padded">39.3414</td>
        </tr>
    </table>
    </p>
    <p style="margin: 0px; height: 8px;" />
    <p>
        To begin the calculations, we need to know how many days (d) it has been since <br>
        the start of the epoch. The epoch actually starts on midnight between December <br>
        30 and 31, 1989. This may seem confusing, but it simplifies some of the <br>
        calculations. Thus, 6 A.M., January 5, 1990, is six days and six hours since <br>
        the start of the epoch, or 6.25 days.
    </p>
    <p>
        Next, we need to find the true anomaly (v), which is the angle the planet makes <br>
        with the line between the sun and the perihelion (the point nearest the sun in <br>
        the planet's orbit). To find it, we first calculate the mean anomaly (m), which <br>
        would be the true anomaly if the planet's orbit where circular.
    </p>
    <p>
        <math>
            <mi mathvariant="normal">m</mi>
            <mo>=</mo>
            <mfrac>
                <mn>360</mn>
                <mn>365.242191</mn>
            </mfrac>
            <mo>×</mo>
            <mfrac>
                <mi mathvariant="normal">d</mi>
                <msub>
                    <mi mathvariant="normal">T</mi>
                    <mpadded depth="10%">
                        <mi mathvariant="normal">p</mi>
                    </mpadded>
                </msub>
            </mfrac>
            <mo>+</mo>
            <mi mathvariant="normal">&epsilon;</mi>
            <mo>-</mo>
            <mover accent="true">
                <mi mathvariant="normal">&omega;</mi>
                <mo>¯</mo>
            </mover>
            <mo>&InvisibleTimes;</mo>
            <mtext>degrees</mtext>
        </math>
    </p>
    <p>
        <math>
            <mi mathvariant="normal">v</mi>
            <mo>=</mo>
            <mi mathvariant="normal">m</mi>
            <mo>+</mo>
            <mfrac>
                <mn>360</mn>
                <mi mathvariant="normal">&pi;</mi>
            </mfrac>
            <mo>&InvisibleTimes;</mo>
            <mi mathvariant="normal">e</mi>
            <mo>&InvisibleTimes;</mo>
            <mo>sin</mo>
            <mi mathvariant="normal">m</mi>
            <mo>&InvisibleTimes;</mo>
            <mtext>degrees</mtext>
        </math>
    </p>
    <p>
        The eliocentric longitude (l) is
    </p>
    <p>
        <math>
            <mi mathvariant="normal">l</mi>
            <mo>=</mo>
            <mi mathvariant="normal">v</mi>
            <mo>+</mo>
            <mover accent="true">
                <mi mathvariant="normal">&omega;</mi>
                <mo>¯</mo>
            </mover>
        </math>
    </p>
    <p>
        Now that we know the angle of the planet, all we need is the distance given by<br>
        the radius vector (r).
    </p>
    <p>
        <math>
            <mi mathvariant="normal">r</mi>
            <mo>=</mo>
            <mfrac>
                <mrow>
                    <mi mathvariant="normal">a</mi>
                    <mo>&InvisibleTimes;</mo>
                    <mo>(</mo>
                    <mn>1</mn>
                    <mo>-</mo>
                    <msup>
                        <mi mathvariant="normal">e</mi>
                        <mn>2</mn>
                    </msup>
                    <mo>)</mo>
                </mrow>
                <mrow>
                    <mn>1</mn>
                    <mo>+</mo>
                    <mi mathvariant="normal">e</mi>
                    <mo>&InvisibleTimes;</mo>
                    <mrow>
                        <mo>cos</mo>
                        <mi mathvariant="normal">v</mi>
                    </mrow>
                </mrow>
            </mfrac>
        </math>
    </p>
    <p>
        From here it's simple trigonometry to get the x and y coordinates:
    </p>
    <p>
        <math>
            <mi mathvariant="normal">x</mi>
            <mo>=</mo>
            <mi mathvariant="normal">r</mi>
            <mo>cos</mo>
            <mi mathvariant="normal">l</mi>
        </math>
        <br>
        <math>
            <mi mathvariant="normal">y</mi>
            <mo>=</mo>
            <mi mathvariant="normal">r</mi>
            <mo>sin</mo>
            <mi mathvariant="normal">l</mi>
        </math>
    </p>
    <p>
        You'll see these calculations later in code.
    </p>
    <p>
        <i>Warning:</i> While the above calculations are perfectly sufficient to tell you which <br>
        window to look out of to see Mars, they may lack something if your object is to <br>
        actually reach Mars. For this reason, readers with their own spacecraft should <br>
        not count on these formulas, or the resulting templates, for purposes of <br>
        celestial navigation.
    </p>
    

<p>
We begin by developing a set of templates that plot the positions and orbits of the<br>
planets at a specified time. A sublist on one of the record information pages lists the<br>
planets and their positions. We also develop templates to display information pages for<br>
each planet; these pages enable the user to enter the information needed to calculate a<br>
planet's orbit. The calculations and plotting are performed by code resources in the<br>
templates. Using the techniques described in the article, you could add other types of<br>
celestial bodies (such as comets, moons, and alien spacecraft) that would be defined by<br>
a different set of parameters and have a different algorithm for calculating position<br>
and orbit.
</p>
<p>
&nbsp;&nbsp;Although the templates are quite straightforward in general, the article focuses on<br>
the code resources that implement three advanced features of the template mechanism:
</p>
<ul>
<li>    type conversion between text (RStrings) and custom, internal data<br>
types -- to display and edit floating-point numbers and date/time information</li>
<li>    automatic calculation of property values when other selected property<br>
values change -- to update the planet's position when the time or orbital<br>
parameters change</li>
<li>    drawing in a custom view -- to display the plotted object positions and<br>
orbits</li>
</ul>
<h2>DEFINING THE TEMPLATES</h2>
<p>
The templates we create define a record type of "hrc Orbits" to hold the list of planets<br>
we want to display. The record contains an attribute type "hrc Planet" with one<br>
attribute value per planet and an attribute value tag of 'plnt'. There's also a<br>
single-valued attribute of type "hrc Orbits info," which holds information pertinent to<br>
the orbits record.
</p>
<p>
Using an attribute value tag allows for future expansion to new types of objects --<br>
spacecraft, for instance. In the example, the aspect template for the attribute type<br>
"hrc Planet" is used only for attribute values with the attribute value tag 'plnt'. To add<br>
a new type of object, which may require different orbital parameters and a different<br>
algorithm to calculate the orbits, you would use a different tag. For example, an<br>
attribute value that describes a spacecraft might have an attribute value tag of 'crft'.
</p>
<p>
We need to define the following templates:
</p>
<ul>
<li>    information page templates for the orbits record (record type "hrc<br>
Orbits")</li>
<li>    information page templates for the attribute type "hrc Planets," which<br>
is the attribute type of the sublist entries</li>
<li>    an aspect template for the record type "hrc Orbits"</li>
<li>    an aspect template for the attribute type "hrc Planets"</li>
</ul>
<p>
These templates are included on this issue's CD. There's nothing remarkable about<br>
most of them. This article discusses only those portions of the templates that are more<br>
interesting and unusual.
</p>
<p>
<b>ORBITS RECORD INFORMATION PAGE TEMPLATES</b>
</p>
<p>
We use two information pages to display the information stored in an orbits record<br>
(Figure 1). The List information page contains a sublist of planets (attribute type<br>
"hrc Planet"), allowing the user to create new planets and drag existing ones into and<br>
out of the list. Besides an icon, name, and kind, the sublist on the List page displays x<br>
and y coordinates for each planet. This is the location at the time given in the field at<br>
the top of the page. The user can edit the time to see past and future positions. The<br>
Continuous Update checkbox, when checked, causes the Time field to be constantly<br>
updated to the current time. The state of this checkbox is kept in the "hrc Orbits info"<br>
attribute of the orbits record.
</p>


























<p>
<b></b><img src="img/264.gif" width="600 px"></img>
</p>
<p class="spacer">&nbsp;</p>
<p class="spacer">&nbsp;</p>
<p>
<b>List</b><br>
<b></b><br>
<b></b>
</p>
<p class="spacer">&nbsp;</p>

























<p>
<b></b><img src="img/265.gif" width="600 px"></img>
</p>
<p>
<b>Plot</b>
</p>
<p>
<b>Figure 1. </b>Information pages for the orbits record
</p>
<p>
The Plot information page contains a plot of the position of each planet in the sublist on<br>
the List information page. When the Show Orbits checkbox is checked, the plot shows<br>
not only the position of each planet, but also the future track -- the orbit -- of the<br>
planet. Orbital calculations take a lot of time, especially on slower systems, so the<br>
user can choose whether or not to display this information.
</p>
<p>
Listing 1 shows resource definitions for the Plot information page template. Note that<br>
kOrbitsCustomViewProperty is used for the property number for both the Show Orbits<br>
checkbox and the custom view that plots the positions. Normally two views don't share<br>
the same property. Using the same one here causes an automatic redraw of the custom<br>
view when the checkbox changes. This is simpler than using the code resource to<br>
intercept the property-dirtied call resulting from the checkbox change and using a<br>
dirty-property callback to cause the custom view to be redrawn. (Whenever a<br>
property is changed, a kDETcmdPropertyDirtied call is made to the code resource.)<br>
The bulk of the work for the custom view occurs in the code resource, as described<br>
later in the section "Drawing in a Custom View."
</p>
<p>
<b>Listing 1. </b>Plot information page template
</p>
<pre>resource 'deti' (kOrbitsPlotPage, purgeable) {
   2000, kDETNoSublistRect, noSelectFirstText,
   {
   kDETNoProperty, kDETNoProperty, kOrbitsPlotPage;
   },
   {}
};

resource 'rstr' (kOrbitsPlotPage+kDETTemplateName, purgeable) {
   "hrc Orbits plot page"
};
resource 'rstr' (kOrbitsPlotPage+kDETRecordType, purgeable) {
   kOrbitsRecordType
};
resource 'rstr' (kOrbitsPlotPage+kDETInfoPageName, purgeable) {
   "Plot"
};

resource 'rstr' (kOrbitsPlotPage+kDETInfoPageMainViewAspect,
   purgeable) {
   "hrc Orbits main aspect"
};

resource 'detv' (kOrbitsPlotPage, purgeable){
   {
   kDETSubpageIconRect, kDETNoFlags, kDETAspectMainBitmap,
   Bitmap {kDETLargeIcon};

   {12, kOrbitsPageWidth-120, 28, kOrbitsPageWidth-8},
      kDETNoFlags, kOrbitsCustomViewProperty,
      CheckBox {kPalatino, 12, kDETLeft, kDETBold,
                  "Show Orbits", kOrbitsCustomViewProperty};

   {44, 8, kOrbitsPageHeight-8, kOrbitsPageWidth-8}, kDETNoFlags,
      kDETNoProperty, Box {kDETUnused};

   {47, 11, kOrbitsPageHeight-11, kOrbitsPageWidth-11}, kDETNoFlags,
      kOrbitsCustomViewProperty, Custom {kDETUnused};
   }
};</pre>
<p>
<b>PLANET INFORMATION PAGE TEMPLATES</b>
</p>
<p>
When the user double-clicks a planet in the sublist, a window opens with two more<br>
information pages (Figure 2). The Orbit Calculation information page displays the<br>
position of the planet at a user-specified time. The Orbit Parameters information page<br>
displays, and lets the user enter, the values for the orbital parameters (shown earlier<br>
in Table 1). These two pages could have been combined, but most users aren't<br>
interested in seeing the orbital parameter values once they've been entered. They just<br>
clutter up the interesting information -- the planet's location at a given time.
</p>














<p>
<b></b><img src="img/266.gif" width="336 px"></img>
</p>
<p class="spacer">&nbsp;</p>
<p class="spacer">&nbsp;</p>
<p class="spacer">&nbsp;</p>
<p>
<b>Orbit Calculation</b><br>
<b></b><br>
<b></b>
</p>
<p class="spacer">&nbsp;</p>













<p>
<b></b><img src="img/267.gif" width="336 px"></img>
</p>
<p>
<b>Orbit Parameters</b>
</p>
<p>
<b>Figure 2. </b>Information pages for a planet
</p>
<p>
<b>ORBITS RECORD ASPECT TEMPLATE</b>
</p>
<p>
We define one aspect template for the orbits record (record type "hrc Orbits") -- a<br>
main aspect that also serves as the main view aspect for the orbits record information<br>
pages. The aspect for the orbits record contains the properties listed in Table 2.
</p>
<p>
<img src="img/268.gif" width="570 px"></img>
</p>
<p>
The kOrbitsNowProperty property and the entries in the sublist are stored in the<br>
record, as specified by the 'dett' lookup table resource (shown below). You'll find the<br>
full source code for the orbits record aspect template on this issue's CD.
</p>
<pre>resource 'dett' (kOrbitsMainAspect+kDETAspectLookup, purgeable) {
   {
   {kOrbitsAttributeType}, typeBinary,
      useForInput, useForOutput, notInSublist, isNotAlias,
      isNotRecordRef,
      {
      'long', kOrbitsNowProperty, 0;
      };
   {kPlanetAttributeType}, 'plnt',
      notForInput, notForOutput, useInSublist, isNotAlias,
      isNotRecordRef,
      {};
   }
};</pre>
<p>
<b>ASPECT TEMPLATE FOR ATTRIBUTE TYPE "HRC PLANET"</b>
</p>
<p>
The aspect template for attribute type "hrc Planet" is also a main aspect template. The<br>
properties defined by this aspect are shown in Table 3. The orbital parameters, as<br>
well as the name of the attribute value (for example, "Mercury" or "Venus"), are<br>
stored in the attribute value, so they're included in the 'dett' resource:
</p>
<pre>#define kExtendedPropertyType 2
#define kExtendedPropertyTypeSize 10
...
resource 'dett' (kPlanetMainAspect+kDETAspectLookup, purgeable) {
   {
   {kPlanetAttributeType}, 'plnt',
      useForInput, useForOutput, notInSublist, isNotAlias,
      isNotRecordRef,
      {
      'rstr', kDETAspectName,    0;
      'btyp', kDETNoProperty,    kExtendedPropertyType;
      'blok', kTpProperty,       kExtendedPropertyTypeSize;
      'blok', kEpsilonProperty,  kExtendedPropertyTypeSize;
      'blok', kOmegaBarProperty, kExtendedPropertyTypeSize;
      'blok', keProperty,        kExtendedPropertyTypeSize;
      'blok', kaProperty,        kExtendedPropertyTypeSize;
      };
   }
};</pre>


    <p style="margin: 0px; height: 8px;" />
    <p>
        <b>Table 3.</b> Properties in the "hrc Planet" attribute type's aspect<br>
    </p>
    <p>
    <table>
        <tr>
            <th style="width: 250; text-align: left;">Property</td>
            <th style="width: 500; text-align: left;">Meaning</td>
        </tr>
        <tr>
            <td>kTimeProperty</td>
            <td>The time, as entered by the user in the Time field</td>
        </tr>
        <tr>
            <td>kXProperty</td>
            <td>The x coordinate at that time</td>
        </tr>
        <tr>
            <td>kYProperty</td>
            <td>The y coordinate at that time</td>
        </tr>
        <tr>
            <td>&nbsp;</td>
            <td>&nbsp;</td>
        </tr>
        <tr>
            <td>kTpProperty</td>
            <td>
                <math>
                    <mtext>The&nbsp;</mtext>
                    <msub>
                        <mi mathvariant="normal">T</mi>
                        <mpadded depth="10%">
                            <mi mathvariant="normal">p</mi>
                        </mpadded>
                    </msub>
                    <mtext>&nbsp;orbital parameter</mtext>
                </math>
            </td>
        </tr>
        <tr>
            <td>kEpsilonProperty</td>
            <td>
                <math>
                    <mtext>The&nbsp;</mtext>
                    <mi mathvariant="normal">&epsilon;</mi>
                    <mtext>&nbsp;orbital parameter</mtext>
                </math>
            </td>
        </tr>
        <tr>
            <td>kOmegaBarProperty</td>
            <td>
                <math>
                    <mtext>The&nbsp;</mtext>
                    <mover accent="true">
                        <mi mathvariant="normal">&omega;</mi>
                        <mo>¯</mo>
                    </mover>
                    <mtext>&nbsp;orbital parameter</mtext>
                </math>
            </td>
        </tr>
        <tr>
            <td>keProperty</td>
            <td>The e orbital parameter</td>
        </tr>
        <tr>
            <td>kaProperty</td>
            <td>The a orbital parameter</td>
        </tr>
    </table>
    </p>
    <p style="margin: 0px; height: 8px;" />
    

<p>
Each of the properties in the 'dett' resource except kDETAspectName has a<br>
template-defined custom property type of 2 (kExtendedPropertyType) and is 10<br>
(kExtendedPropertyTypeSize) bytes in size. The actual format is that of the standard<br>
SANE floating-point extended type. The 'btyp' element specifies that all subsequent<br>
'blok' elements should produce properties of the type given (kExtendedPropertyType).<br>
The 'blok' elements that follow specify a fixed-size block, kExtendedPropertyTypeSize<br>
bytes in size. The next section describes how these property types get used.
</p>
<p>
As with the main aspect template for the orbits, the rest of this template is quite<br>
simple and is included on the CD.
</p>
<h2>CUSTOM PROPERTY TYPE CONVERSION</h2>
<p>
The templates we're defining use two property types that aren't supported directly by<br>
the CE: SANE floating-point extended, for orbital parameters and positions, and<br>
date/time, for specifying the time for which the positions should be calculated. In<br>
addition to using these property types for internal calculations, we want to display<br>
them and let the user edit them. To do this, we display the items in text fields and<br>
supply a code resource that translates between the internal representation of the<br>
custom property types and text (RStrings). The code resource implements<br>
convertToRString and convertFromRString when called by the CE. The part of the<br>
Planet routine that figures out when to call the conversion functions is as follows:
</p>
<pre>#define kTimePropertyType 1
#define kTimePropertyTypeSize 8
pascal OSErr Planet(DETCallBlockPtr callBlockPtr)
{
   if (callBlockPtr-&gt;protoCall.target.selector == kDETSelf)
      switch (callBlockPtr-&gt;protoCall.reqFunction) {
         ...
         case kDETcmdConvertToRString:
            return convertToRString(callBlockPtr);
         case kDETcmdConvertFromRString:
            return convertFromRString(callBlockPtr);
         ...
         }
   return kDETDidNotHandle;
}</pre>
<p>
In each case, the conversion function in the code resource first gets the type of the<br>
property being converted -- either kTimePropertyType or kExtendedPropertyType<br>
-- and then performs the conversion appropriate to that property type. The code in<br>
Listing 2 is for the convertToRString case; code for convertFromRString performs the<br>
opposite conversion, taking an RString and turning it into a custom property type.
</p>
<p>
<b>Listing 2. </b>Converting custom property types to a text string
</p>
<pre>OSErr convertToRString(DETCallBlockPtr callBlockPtr)
{
   DETConvertToRStringBlock*    ctrs;
   DETGetPropertyTypeBlock      gpt;

   ctrs = &amp;(callBlockPtr-&gt;convertToRString);

   // Get the type of the property being converted.
   gpt.reqFunction = kDETcmdGetPropertyType;
   gpt.target = ctrs-&gt;target;
   gpt.property = ctrs-&gt;property;
   if (CallBackDET(callBlockPtr,
         (DETCallBackBlock*) &amp;gpt) == noErr) {
      char             s[256];
      RStringHandle    h;

      // Convert time property types.
      if (gpt.propertyType == kTimePropertyType) {
         LongDateTime   ldt;
         char          tStr[256];

         // Get the current value.
         ldt = GetTimeProperty(callBlockPtr, ctrs-&gt;property);

         // Convert it to a string.
         iuldatestring(&amp;ldt, shortDate, s, nil);
         tStr[0] = ' '; tStr[1] = 0;
         strcat(s, tStr);
         iultimestring(&amp;ldt, true, tStr, nil);
         strcat(s, tStr);
         }
      // Convert floating-point extended property types.
      else if (gpt.propertyType == kExtendedPropertyType) {
         extended     n;
         decform      df;
         decimal      d;

         // Get the current value.
         n = GetExtendedProperty(callBlockPtr, ctrs-&gt;property);

         // Convert it to a string.
         df.style = FLOATDECIMAL;
         df.digits = 9;
         num2dec(&amp;df, n, &amp;d);
         dec2str(&amp;df, &amp;d, &amp;s);
         }

      // If we don't know the type, don't convert it.
      else return kDETDidNotHandle;

      // Return the string as an RString handle.
      h = (RStringHandle) NewHandle(strlen(s) +
          sizeof(ProtoRString));
      if (h) {
         HLock((Handle) h);
         OCECToRString(s, smRoman, *h, strlen(s));
         HUnlock((Handle) h);
         ctrs-&gt;theValue = h;
         return noErr;
         }
      else return MemError();
      }

   return kDETDidNotHandle;
}</pre>
<p>
Two utility functions retrieve properties of the new types -- getTimeProperty and<br>
getExtendedProperty. Listing 3 shows getExtendedProperty (getTimeProperty is<br>
virtually identical).
</p>
<p>
<b>Listing 3. </b>getExtendedProperty
</p>
<pre>extended getExtendedProperty(DETCallBlockPtr callBlockPtr,
                               short property)
{
   DETGetPropertyBinaryBlock   gpb;
   extended                     n;

   gpb.reqFunction = kDETcmdGetPropertyBinary;
   gpb.target = callBlockPtr-&gt;protoCall.target;
   gpb.property = property;
   if (CallBackDET(callBlockPtr, (DETCallBackBlock*) &amp;gpb) != noErr)
      return 0.0;
   BlockMove(*gpb.propertyValue, (char*) &amp;n, sizeof(n));
   DisposeHandle(gpb.propertyValue);
   return n;
}</pre>
<p>
The code shown in this section belongs to the aspect template for attribute type "hrc<br>
Planet." Similar code is used for the orbits record aspect template, but that template<br>
never needs to convert extended types -- they're always converted by the "hrc Planet"<br>
attribute type template -- so only the code for converting times is included.
</p>
<p>
The CE makes all the decisions about when to perform the conversions. When it needs<br>
to display a property in a text field, it calls the code resource to convert the property<br>
to text. When the user finishes editing a property and closes the field (by tabbing to<br>
the next field, pressing Enter, switching pages, or closing the window), the CE calls<br>
the code resource to convert the property from text to the internal type.
</p>
<p>
The CE knows what type a property is because the template tells it. In the case of<br>
properties stored in an attribute value, the 'dett' resource includes the type <br>
information, as discussed earlier in the section on the aspect template for attribute<br>
type "hrc Planet."
</p>
<p>
In the case of temporary properties not stored in an attribute value, for which there is<br>
no 'dett' entry, the code resource sets the type, generally while setting the property.<br>
For example, in the aspect template for attribute type "hrc Planet" the code resource<br>
initializes the Time field to the current time as a part of the instanceInit routine,<br>
which is invoked when the code resource is called with the kDETcmdInstanceInit<br>
routine selector (Listing 4).
</p>
<p>
<b>Listing 4. </b>Initializing the Time field in instanceInit
</p>
<pre>OSErr instanceInit(DETCallBlockPtr callBlockPtr)
   {
   DETSetPropertyTypeBlock      spt;
   DETSetPropertyBinaryBlock   spb;
   unsigned long               l;
   LongDateCvt                  ldt;

   // Set the time property type.
   spt.reqFunction = kDETcmdSetPropertyType;
   spt.target = callBlockPtr-&gt;protoCall.target;
   spt.property = kTimeProperty;
   spt.newType = kTimePropertyType;
   CallBackDET(callBlockPtr, (DETCallBackBlock*) &amp;spt);

   // Set the time property to the current time.
   GetDateTime(&amp;l);
   ldt.hl.lHigh = 0; ldt.hl.lLow = l;
   spb.reqFunction = kDETcmdSetPropertyBinary;
   spb.target = callBlockPtr-&gt;protoCall.target;
   spb.property = kTimeProperty;
   spb.newValue = (Ptr) &amp;ldt;
   spb.newValueSize = sizeof(ldt);
   if (CallBackDET(callBlockPtr, (DETCallBackBlock*) &amp;spb) ==
          noErr) {
      // Dirty the time property.
      DETDirtyPropertyBlock   dp;

      dp.reqFunction = kDETcmdDirtyProperty;
      dp.target = callBlockPtr-&gt;protoCall.target;
      dp.property = kTimeProperty;
      CallBackDET(callBlockPtr, (DETCallBackBlock*) &amp;dp);
      }
}</pre>
<h2>CALCULATING POSITIONS AUTOMATICALLY</h2>
<p>
The aspect template for attribute type "hrc Planet" calculates the position of the planet<br>
at a specified time. It takes the time from kTimeProperty and puts the resulting<br>
position in kXProperty and kYProperty. This calculation, which is performed<br>
whenever kTimeProperty changes, is used in three places: in the Orbit Calculation<br>
information page of each "hrc Planet" attribute value; in the sublist on the List<br>
information page of the orbits record; and in calculating where to draw the planets on<br>
the Plot information page of the orbits record. If you want to create another template<br>
that implements a different type of celestial body -- using a different attribute value<br>
tag -- the same procedure would work, even though you may use an entirely different<br>
algorithm to calculate kXProperty and kYProperty from kTimeProperty. We're using<br>
the template as an object-oriented database: Each object (aspect) is of a specific class<br>
(aspect template), which specifies how it should react to certain messages (setting the<br>
kTimeProperty property). Portions of the object (properties) are persistent (stored<br>
in AOCE catalogs).
</p>
<p>
To calculate kXProperty and kYProperty from kTimeProperty, we supply code that<br>
responds to a kDETcmdPropertyDirtied call, as shown in Listing 5. Note that the code<br>
resource also recalculates kXProperty and kYProperty when any of the orbital<br>
parameters changes. The functions degsin and degcos are versions of sin and cos that<br>
take their parameters in degrees rather than radians. The constant kAU is the size of<br>
one astronomical unit (149,600,000.0 meters).
</p>
<p>
<b>Listing 5. </b>Calculating kXProperty and kYProperty from kTimeProperty
</p>
<pre>// Returns days (including fractions) since 1990.
extended daysSince1990(LongDateTime t)
{
    LongDateRec     ldr;
    LongDateTime        t1990;
    extended            et, et1990;

    et = t;
    ldr.ld.era = 0; ldr.ld.year = 1989; ldr.ld.month = 12;
    ldr.ld.day = 31; ldr.ld.hour = 0; ldr.ld.minute = 0;
    ldr.ld.pm = 0;
    LongDate2Secs(&amp;ldr, &amp;t1990);
    et1990 = t1990;
    return et/(24.0*60.0*60.0) - et1990/(24.0*60.0*60.0);
}</pre>
<pre>OSErr propertyDirtied(DETCallBlockPtr callBlockPtr)
{
   DETPropertyDirtiedBlock*   pd;

   pd = (DETPropertyDirtiedBlock*) &amp;callBlockPtr-&gt;propertyDirtied;
   switch (pd-&gt;property) {
      // Recalculate only on selected properties.
      case kTimeProperty:
      case kTpProperty:
      case kEpsilonProperty:
      case kOmegaBarProperty:
      case keProperty:
      case kaProperty:
         {
         DETSetPropertyTypeBlock     spt;
         DETSetPropertyBinaryBlock   spb;
         extended                    d, tp, epsilon, omegaBar, e, a;
         extended                    n, m, l, v, r, x, y;

         // Get the orbital parameters.
         d = daysSince1990(GetTimeProperty(callBlockPtr,
                           kTimeProperty));
         tp = GetExtendedProperty(callBlockPtr, kTpProperty);
         epsilon = GetExtendedProperty(callBlockPtr,
                       kEpsilonProperty);
         omegaBar = GetExtendedProperty(callBlockPtr,
                       kOmegaBarProperty);
         e = GetExtendedProperty(callBlockPtr, keProperty);
         a = GetExtendedProperty(callBlockPtr, kaProperty);

         // If the parameters are zero, return zero.
         if (tp == 0.0) {
            x = 0.0; y = 0.0;
            }
         // Otherwise, calculate the current position.
         else {
            n = fmod((360.0/365.242191)*(d/tp), 360.0);
            m = n+epsilon-omegaBar;
            l = fmod(n+(360.0/pi())*e*degsin(m)+epsilon, 360.0);
            v = l-omegaBar;
            r = kAU*(a*(1.0-e*e))/(1.0+e*degcos(v));
            x = degcos(l)*r;
            y = degsin(l)*r;
            }

         // Prepare to set the type and value of the x and y
         // properties.
         spt.reqFunction = kDETcmdSetPropertyType;
         spt.target = pd-&gt;target;
         spb.reqFunction = kDETcmdSetPropertyBinary;
         spb.target = pd-&gt;target;
         // Set x's type.
         spt.property = kXProperty;
         spt.newType = kExtendedPropertyType;
         if (CallBackDET(callBlockPtr, (DETCallBackBlock*) &amp;spt)
               == noErr) {
            // Set x's value.
            spb.property = kXProperty;
            spb.newValue = (Ptr) &amp;x;
            spb.newValueSize = sizeof(x);
            CallBackDET(callBlockPtr, (DETCallBackBlock*) &amp;spb);
            }

         // Set y's type.
         spt.property = kYProperty;
         spt.newType = kExtendedPropertyType;
         if (CallBackDET(callBlockPtr, (DETCallBackBlock*) &amp;spt)
               == noErr) {
            // Set y's value.
            spb.property = kYProperty;
            spb.newValue = (Ptr) &amp;y;
            spb.newValueSize = sizeof(y);
            CallBackDET(callBlockPtr, (DETCallBackBlock*) &amp;spb);
            }
        
         return noErr:
         }
      }
   return kDETDidNotHandle;
}</pre>
<p>
The calculation in Listing 5 happens automatically when the user changes the Time<br>
field on the Orbit Calculation information page, or any of the orbital parameters on the<br>
Orbit Parameters page. But on the orbits record List information page, we need to do a<br>
little work to make each entry in the sublist change when the user changes the Time<br>
field on that page. The updateOrbitEntries routine sets the time for each item in the<br>
sublist by calling setSublistTimeProperty (Listing 6). The updateOrbitEntries<br>
routine iterates through the sublist until it gets an error return, which happens when<br>
it tries to reference an entry that doesn't exist -- the one just past the end of the list.
</p>
<p>
<b>Listing 6. </b>updateOrbitEntries and setSublistTimeProperty
</p>
<pre>OSErr updateOrbitEntries(DETCallBlockPtr callBlockPtr)
{
   LongDateTime   ldt;
   long            i;

   // Get the time from the Time field.
   ldt = getTimeProperty(callBlockPtr, kOrbitsTimeProperty);

   // Set the time in each sublist entry.
   for (i = 1;; i++)
      if (setSublistTimeProperty(callBlockPtr, kTimeProperty, i, ldt)
            != noErr)
         break;
   return noErr;
}

OSErr setSublistTimeProperty(DETCallBlockPtr callBlockPtr,
          short property, long itemNumber, LongDateTime ldt)
{
   DETSetPropertyBinaryBlock    spb;
   OSErr                        retVal;

   spb.reqFunction = kDETcmdSetPropertyBinary;
   spb.target.selector = kDETSublistItem;
   spb.target.aspectName = nil;
   spb.target.itemNumber = itemNumber;
   spb.property = property;
   spb.newValue = (Ptr) &amp;ldt; spb.newValueSize = sizeof(ldt);
   retVal = CallBackDET(callBlockPtr, (DETCallBackBlock*) &amp;spb);
   if (retVal == noErr) {
      DETDirtyPropertyBlock   dp;
  
      dp.reqFunction = kDETcmdDirtyProperty;
      dp.target.selector = kDETSublistItem;
      dp.target.aspectName = nil;
      dp.target.itemNumber = itemNumber;
      dp.property = kOrbitsTimeProperty;
      retVal = CallBackDET(callBlockPtr, (DETCallBackBlock*) &amp;dp);
      }
   return retVal;
}</pre>
<h2>DRAWING IN A CUSTOM VIEW</h2>
<p>
The CE calls the orbits record aspect template's code resource with the routine<br>
selector kDETcmdCustomViewDraw whenever the part of the Plot information page that<br>
contains the custom view needs redrawing. This can happen because the user has just<br>
flipped to that page, or because all or part of the page was uncovered -- perhaps<br>
because another window was moved out from in front of the orbits record window.
</p>
<pre>pascal OSErr Orbits(DETCallBlockPtr callBlockPtr)
{
   if (callBlockPtr-&gt;protoCall.target.selector == kDETSelf)
      switch (callBlockPtr-&gt;protoCall.reqFunction) {
         ...
         case kDETcmdCustomViewDraw:
            return customViewDraw(callBlockPtr);
         }
   return kDETDidNotHandle;
}</pre>
<p>
Listing 7 shows the calculations we need to perform before we can draw the custom<br>
view. First, we determine the view bounds. Given the bounds of the view, the template<br>
can then calculate the center of the display, which is where it draws the sun. Finally,<br>
the template determines a scaling factor such that the largest orbit will just fill the<br>
display. (Actually, with the algorithm we use, it may overflow the display a bit if the<br>
orbit is very elliptical.) After these preparations, the template can go through each of<br>
the items in the sublist and plot their current positions, names, and (if the Show<br>
Orbits checkbox is checked) orbits (Listing 8). Being able to call on the aspect<br>
template for attribute type "hrc Planet" to do most of the work greatly simplifies this<br>
process.
</p>
<p>
<b>Listing 7. </b>Preparing to draw the custom view
</p>
<pre>DETGetCustomViewBoundsBlock  gcvb;
OSErr                        retVal:
short                        halfWidth, halfHeight, centerX, centerY;
LongDateTime                 ldt;
long                         i;
extended                     x, y, largestDistance, scaleFactor;

// 1. Determine the view bounds.
// If this isn't for our view, ignore it.
if (callBlockPtr-&gt;protoCall.property != kOrbitsCustomViewProperty)
   return kDETDidNotHandle;

// Get the bounds of the view.
gcvb.reqFunction = kDETcmdGetCustomViewBounds;
gcvb.target = callBlockPtr-&gt;protoCall.target;
gcvb.property = callBlockPtr-&gt;protoCall.property;
retVal = CallBackDET(callBlockPtr, (DETCallBackBlock*) &amp;gcvb);
if (retVal != noErr) return retVal;

// 2. Calculate the center of the display.
halfWidth = (gcvb.bounds.right - gcvb.bounds.left) / 2;
halfHeight = (gcvb.bounds.bottom - gcvb.bounds.top) / 2;
centerX = gcvb.bounds.left + halfWidth;
centerY = gcvb.bounds.top + halfHeight;

// Draw space.
PaintRect(&amp;gcvb.bounds);

// Draw the sun.
ForeColor(whiteColor);
r.top = centerY - 4; r.bottom = centerY + 4;
r.left = centerX - 4; r.right = centerX + 4;
PaintOval(&amp;r);

// 3. Determine the proper scaling factor.
// Get the time.
ldt = getTimeProperty(callBlockPtr, kOrbitsTimeProperty);

// Guess the maximum size.
largestDistance = 0.0;
for (i = 1;; i++) {
   extended  newDistance;

   if (getSublistPosition(callBlockPtr, i, ldt, &amp;x, &amp;y) != noErr)
      break;
   newDistance = sqrt(x*x + y*y);
   if (newDistance &gt; largestDistance)
      largestDistance = newDistance;
   }
scaleFactor = (halfHeight - 15) / largestDistance;</pre>
<p>
<b>Listing 8. </b>Drawing the custom view
</p>
<pre>DETGetPropertyRStringBlock        gpr;
long                              showOrbits;
Rect                              r;

// Plot each planet.
showOrbits = getNumberProperty(callBlockPtr,
    kOrbitsCustomViewProperty);
TextFont(kDETApplicationFont);
TextSize(9);
gpr.reqFunction = kDETcmdGetPropertyRString;
gpr.target.selector = kDETSublistItem;
gpr.target.aspectName = nil;
gpr.property = kDETPrName;

for (i = 1;; i++) {
   // Draw the body.
   if (getSublistPosition(callBlockPtr, i, ldt, &amp;x, &amp;y) !=
       noErr)
      break;
   r.top = centerY - ((short) rint(scaleFactor*y)) - 1;
   r.bottom = r.top + 3;
   r.left = centerX + ((short) rint(scaleFactor*x)) - 1;
   r.right = r.left + 3;
   PaintOval(&amp;r);

   // Draw the name.
   gpr.target.itemNumber = i;
   if ((CallBackDET(callBlockPtr, (DETCallBackBlock*) &amp;gpr) ==
         noErr) &amp;&amp; ((*gpr.propertyValue)-&gt;dataLength &lt; 256)) {
      HLock((Handle) gpr.propertyValue);
      MoveTo (r.right + 1,
           r.top &lt; centerY ? r.top - 1 : r.bottom + 10);
      DrawString(((char*) &amp;(*gpr.propertyValue)-&gt;dataLength)
           + 1);
      DisposeHandle((Handle) gpr.propertyValue);
      }

   // Show the orbit (if requested).
   if (showOrbits) {
      LongDateTime    ldtInc;
      extended       orbitInc;
      short          j;

      if (getSublistExtendedProperty(callBlockPtr, i, kTpProperty,
            &amp;orbitInc) != noErr)
         break;
      // orbitInc is calculated such that 36 of them produce a
      // complete one-year orbit.
      orbitInc *= (10.0*24.0*60.0*60.0);
      for (j = 36, ldtInc = ldt + orbitInc; j--;
           ldtInc += orbitInc) {
         if (getSublistPosition(callBlockPtr, i, ldtInc, &amp;x, &amp;y)
               != noErr)
            break;
         r.left = centerX + ((short) rint(scaleFactor*x));
         r.right = r.left + 1;
         r.top = centerY - ((short) rint(scaleFactor*y));
         r.bottom = r.top + 1;
         PaintRect(&amp;r);
         }
      }
   }

// Return things to normal.
ForeColor(blackColor);
updateOrbitEntries(callBlockPtr);</pre>
<h2>BEYOND PLUTO</h2>
<p>
AOCE templates are extraordinarily elastic. You can use them to do all of the following:
</p>
<ul>
<li>    show information such as users, addresses, file servers, and planets<br>
contained in local and remote catalogs</li>
<li>    easily display text and integer information and, with a little work,<br>
display and let the user edit floating-point numbers, times, and virtually any<br>
other data type</li>
<li>    display information as text, pictures, or any developer-defined custom<br>
view</li>
</ul>
<p>
In this article, we developed a set of templates to hold information about planets, to<br>
calculate the positions of the planets, and to plot the positions and orbits of those<br>
planets. This issue's CD contains records with entries for all nine known planets. More<br>
entries can be added as more planets are discovered in our solar system -- or in some<br>
other solar system. The planets supplied are divided into two records: inner planets<br>
and outer planets. If they're all placed in one record, the scaling of the orbit plots,<br>
forced by the size of the outer planet orbits, is such that the inner planets are squished<br>
too close together -- try it.
</p>
<p>
Some readers may wonder why we used AOCE templates for our planetary explorations<br>
rather than HyperCard, a desk accessory, or a full Macintosh application. Templates<br>
provide a lightweight solution, which doesn't require the support of a large application<br>
like HyperCard. Indeed, templates run within the Finder itself and leverage off its<br>
existing user interface code. Desk accessories are also lightweight, but we wanted<br>
permanent storage of the data, for which the AOCE catalog system is perfect.
</p>
<p>
There's plenty of room for extending these templates. Here are a few ideas:
</p>
<ul>
<li>    Add the z coordinate -- see <i>Practical Astronomy With Your Calculator</i><br>
for the appropriate formulas.</li>
<li>    Add new types of celestial objects -- moons and comets for starters.</li>
<li>    Add spacecraft as a type. Allow the user to set the acceleration vector of<br>
the ship.</li>
<li>    Add a page to the orbits record that plots the planet's positions in the<br>
sky from a given location on Earth.</li>
<li>    Add options to the existing Plot information page to allow the user to<br>
choose one of the planets as the center of the plot, rather than the sun.</li>
<li>    Add a pop-up menu to one of the two information pages for the planet<br>
attribute values that selects the color to use when plotting that planet.</li>
</ul>
<p>
We hope you're inspired by this article to write templates for many other uses besides<br>
celestial ones. As you can see, AOCE templates provide capabilities well beyond<br>
supplying electronic mail addresses or browsing network devices.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______________________________
</p>
<p>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RECOMMENDED READING</b>
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>Practical Astronomy With Your Calculator</i>, by Peter Duffett-Smith<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Cambridge University Press, 1988). All the algorithms for the celestial<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mechanics used in the templates come from this excellent book.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>Inside Macintosh: AOCE Application Interfaces</i> (Addison-Wesley, 1994).
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______________________________
</p>
<p>
<b>HARRY R. CHESLEY&nbsp;&nbsp;</b>There are two mysteries that have always -- well --<br>
mystified Harry: (1) Why do mirrors exchange left and right but not top and bottom?<br>
(2) What is consciousness? Harry recently worked out the answer to the first<br>
question. You reverse the scene yourself by turning around to look through the mirror<br>
rather than directly at it. If you'd turned head-over-heels instead of around, the scene<br>
would be top and bottom exchanged but not right and left exchanged. Given this<br>
resolution, Harry feels the answer to the second question can't be far behind.<br>
Meanwhile, Harry works in Apple Online Services, doing Newton programming.
</p>
<p>
<b>Thanks </b>to our technical reviewers Paul Black, Dave Evans, and Bruce Gaya.
</p>
</body>
</html>
