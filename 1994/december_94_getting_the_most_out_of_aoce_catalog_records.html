<html>
<head>
<!-- Article ID: 49 - Extracted from develop-1994 -->
<!-- on 2024-05-24 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by the copyright of its respective owners -->
<title>December 94 - Getting the Most out of AOCE Catalog Records</title>
<link href="../common/styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h2>Getting the Most out of AOCE Catalog Records</h2>
<h1>CHRISTINE BUTTIN</h1>
<p>
<img src="img/246.gif" width="236 px"></img>
</p>
<p>
<i>&nbsp;Apple Open Collaboration Environment (AOCE) catalogs can contain any kind of data,</i><br>
<i>which users can browse and edit using the Finder. Developers and knowledgeable end</i><br>
<i>users can write AOCE templates, which add new record types to catalogs and tell the</i><br>
<i>Finder how to display the data. This article describes AOCE templates and provides an</i><br>
<i>example of using templates to extend PowerTalk's built-in User records to contain</i><br>
<i>your own data.</i>
</p>
<p class="spacer">&nbsp;</p>
<p>
&nbsp;Personal computers are great for storing large amounts of related data. Databases<br>
make it possible to organize data and to find individual items quickly, but it takes a<br>
long time to set up a database and enter data into it. If you're a system administrator or<br>
in-house developer and you want to provide a database for use by others, you also have<br>
to worry about providing and maintaining the database software for everyone involved.<br>
If you're using PowerTalk, however, you already have a way to store information:<br>
AOCE catalogs. What's more, the related Catalogs Extension (CE) to the Finder allows<br>
users to browse and edit catalog records with the Finder.
</p>
<p>
&nbsp;The Human Resources group at Apple Computer France wanted to create a directory of<br>
Apple personnel that included each person's name, title, department, address, and a<br>
list of keywords to identify areas of expertise. Furthermore, the group wanted to be<br>
able to list everyone with a particular area of expertise. Since Human Resources uses<br>
a PowerShare collaboration server, there was already a catalog with a User record<br>
containing all of the information for everyone with an account on the server, except<br>
for areas of expertise. What better way to create the directory than to add the new<br>
keyword data to the User records? To list people related to a specific keyword, the<br>
group could create keyword records by adding a new record type to the AOCE catalog in<br>
which the data was stored.
</p>
<p>
&nbsp;The User records that are defined as part of the PowerTalk system software store<br>
information such as a person's name, title, phone number, and electronic address.<br>
PowerTalk uses AOCE templates -- resource files that go in the Extensions folder in<br>
the System Folder -- to tell the CE how to store and display the data. This article<br>
shows you how to write AOCE templates that extend User records to hold additional<br>
information (keywords identifying areas of expertise) and templates that define a new<br>
record type (keyword records). Although writing templates doesn't necessarily<br>
require writing any code resources at all, you can do more by adding code resources to<br>
your templates. This article goes on to demonstrate how to use a code resource to keep<br>
records synchronized that refer to each other's data. You'll find all the example code on<br>
this issue's CD. Even if you're not using a PowerShare server, you can use the<br>
approach described in this article to store data in a personal catalog on your own<br>
Macintosh.
</p>
<h2>A BIT ABOUT AOCE CATALOGS</h2>
<p>
To get the most out of this article, you should have PowerTalk installed on your<br>
computer and have spent a little time playing with catalogs. A<i>catalog</i> is a<br>
hierarchically arranged store of data. The bottom level of the catalog hierarchy is<br>
the<i>record</i> , which is analogous to a file in the Macintosh hierarchical file system<br>
(HFS). Unlike files, however, when the user double-clicks a record, the application<br>
that opens the record is the Finder itself. How the contents of the record are stored in<br>
the catalog and displayed to the user is determined by sets of resources in files known<br>
as<i>AOCE templates</i> . 
</p>
<p>
<b>&nbsp;For the complete story </b>on AOCE, see <i> Inside Macintosh: AOCE Application</i><br>
<i>Interfaces.</i><i>*</i>
</p>
<p>
A PowerShare collaboration server stores the name and account information of each<br>
entity (person, gateway, or whatever) that has an account on the AOCE server in a<br>
server-based catalog. It uses User records for this purpose. A personal catalog looks<br>
much like a server-based catalog but is, in fact, an HFS file on the local disk. There's<br>
practically no difference between a record in a server-based catalog and one in a<br>
personal catalog; AOCE templates work identically in both cases. 
</p>
<p>
The data in records is organized into<i>attributes</i> . Each attribute has a type (for<br>
example, address or area of expertise) and any number of attribute values, which can<br>
contain any sort of data. Each attribute type is defined by a template that specifies the<br>
format for the data. You can write new templates to expand the types of attributes that<br>
existing record types can contain -- that's precisely what this article does, in fact. 
</p>
<h2>FROM RECORDS TO INFORMATION PAGES</h2>
<p>
When the user double-clicks an AOCE catalog record in the Finder, a window called<br>
an<i>information page window</i> opens. An information page window can contain a single<br>
information page, or several information pages, each with a pop-up menu listing the<br>
other pages. Each information page displays data stored in the record. The window in<br>
Figure 1 shows an information page that displays data stored in a User record. 
</p>
<p>
The CE uses a two-step process to get from a record to an information page. Because<br>
there's not necessarily a one-to-one correspondence between attribute values and the<br>
data you want to display on an information page, the first step consists of parsing the<br>
data in the attribute values into discrete units of data known as<i>properties</i> . For<br>
example, an address attribute value may contain street, city, and zip code properties.<br>
The second step is to specify exactly where and how each property is displayed on the<br>
information page.
</p>
<p>
Two types of AOCE templates specify how the CE performs each of these steps:
</p>
<ul>
<li>An<i> aspect template</i> describes how the attribute values are to be parsed<br>
into properties.</li>
<li>An<i> information page template</i> specifies how the properties are to be<br>
displayed on the information page.</li>
</ul>
<p>
These aspect and information page templates share a data structure in memory that<br>
contains the properties. This data structure is called an<i>aspect</i> . The relationships<br>
among records, aspect templates, aspects, information page templates, and information<br>
pages are illustrated in Figure 2.
</p>
<p>
There are a few important things to note about these relationships:
</p>
<ul>
<li>An aspect template does not have to deal with every attribute type in a<br>
record.&nbsp;&nbsp;&nbsp;There can be any number of aspect templates that apply to a given<br>
record type, and each can describe the parsing of some subset of attribute<br>
types.</li>
<li> An information page template does not have to use every property stored<br>
in an aspect.</li>
<li> More than one information page template can use properties from the<br>
same aspect, but each information page template can use properties from only<br>
one aspect. </li>
<li> The process works in reverse as well. When the user enters data into an<br>
information page, the information page template defines which property that<br>
data belongs to and the aspect template describes how the data should be stored<br>
in an attribute value.</li>
</ul>
<p>
<img src="img/247.gif" width="399 px"></img>
</p>
<p>
<b>Figure 1. </b>An information page window
</p>
<p>
<img src="img/248.gif" width="600 px"></img>
</p>
<p>
<b>Figure 2. </b>Getting from a record to an information page
</p>
<h2>WHAT'S IN A TEMPLATE</h2>
<p>
Every template contains a<i>signature resource</i> that indicates the type of the template and<br>
specifies some other template characteristics. In addition, there are other resources<br>
that are required for every template (such as the template name resource), resources<br>
that are required for specific template types, and a variety of optional resources that<br>
you can include if needed. 
</p>
<p>
The CE identifies each resource by its resource type and by the offset of its resource ID<br>
from the resource ID of the signature resource. For example, the template name<br>
resource and the record type resource (which specifies what type of record the<br>
template applies to) are both 'rstr' resources; the CE can distinguish between them<br>
because the template name resource's ID is equal to the signatureresource's ID plus the<br>
constant value kDETTemplateName, while the record type resource has an ID offset of<br>
kDETRecordType. 
</p>
<p>
Aspect templates contain a resource called a<i>lookup table</i> . The lookup table contains the<br>
instructions to the CE for parsing attribute values into properties and properties into<br>
attribute values. If the CE needs a property that has a property number in the range 0<br>
to 249, and it doesn't find a value for that property that the lookup table constructed<br>
from an attribute value, it looks for a resource with an ID offset equal to the property<br>
number. This means that in the aspect template itself you can provide property values<br>
to be used as default values, initial values, or constant values for properties. 
</p>
<p>
Information page templates contain one or more resources called<i>view lists</i> , which<br>
specify the views that appear on the information page. A<i>view</i>&nbsp;&nbsp;is an item or a field on<br>
an information page displaying one or more property values (for example, a text field<br>
or a radio button). 
</p>
<p>
Unlike the ID of other template resources, a view list's resource ID isn't related to the<br>
signature resource's ID. Instead, the information page template's signature resource<br>
includes references to all the view lists for that template. For each view list, the<br>
signature resource includes two property numbers that identify properties associated<br>
with that view list. The view list is active only if the values of its two associated<br>
properties are equal. You can use this feature to implement<i>conditional views</i> , that is,<br>
information-page features that the CE displays only under certain circumstances. 
</p>
<h2>MAIN VIEWS, SUBLISTS, AND MAIN ASPECTS</h2>
<p>
Figure 3 shows another common feature of information pages -- a<i>sublist</i> . A sublist is<br>
a portion of the information page that contains a list of attribute values or records. In<br>
Figure 3, the sublist holds two records (actually, it holds aliases to the records).<br>
Typically, when the user double- clicks an item in a sublist, the same two-step<br>
process as described earlier in the section "From Records to Information Pages"<br>
occurs; as a result, another information page opens and displays the information<br>
associated with the attribute or record represented by the selected item. For example,<br>
double-clicking the AOCE item in Figure 3 opens an information page displaying all<br>
people with that expertise (as shown in Figure 4 later in this article). 
</p>
<p>
<img src="img/249.gif" width="399 px"></img>
</p>
<p>
<b>Figure 3. </b>Information page with a sublist
</p>
<p>
All the property values displayed on an information page outside the sublist come from<br>
a single aspect, called the<i>main view aspect</i> . This aspect also provides the list of items<br>
to be included in the sublist (if any).
</p>
<p>
Each item in a sublist has its own aspect, called a<i>main aspect</i> , which provides the<br>
property values necessary to display the item in the sublist (such as the name of a<br>
record or the kind of attribute value). A main aspect can contain other property values<br>
as well; in fact, a main aspect can also serve as the main view aspect for an<br>
information page. If you want to create a new information page for an existing record,<br>
you must provide a main view aspect template for that information page. If you're<br>
defining a new record type to be displayed in a sublist, you need to provide a main<br>
aspect template for that record type. The example in this article demonstrates how to<br>
create a main view aspect template and an information page template that extend the<br>
User record to hold keywords. It then shows how to create the main aspect template<br>
needed in order to list keyword records in the new User record information page<br>
sublist.
</p>
<h2>DEFINING THE ASPECT TEMPLATE</h2>
<p>
Now we're ready to define the aspect template for the new information page, which is a<br>
main view aspect template. The main view aspect template serves as the aspect<br>
template for everything on the new User record information page except for the<br>
content of the sublist items. Aspect templates contain a signature resource, a name<br>
resource, a record type resource, resources that specify how to handle objects dropped<br>
on the information page, resources for handling the View menu and Balloon Help, and<br>
the all-important lookup table. 
</p>
<p>
<b>SIGNATURE, NAME, AND RECORD TYPE RESOURCES</b><br>
The ID of the aspect template signature resource, of type 'deta', provides the base<br>
resource ID for the other aspect template resources. The signature resource also<br>
makes some settings related to drag and drop operations, as discussed in the next<br>
section, and specifies whether this template is a main aspect template. 
</p>
<pre>resource 'deta' (kEInfoPageAspect, purgeable) {
    0,                  // Drop-operation order
    dropCheckAlways,    // Drop-check flag
    notMainAspect       // Not the main aspect template
};</pre>
<p>
In our example, the aspect template defines the properties for the new information<br>
page being added to an existing record type -- "aoce User." Because User records<br>
already have a main aspect template provided as part of the PowerTalk system<br>
software, you don't have to provide one yourself. In fact, declaring a template to be the<br>
main aspect template for User records would cause a conflict and the User records<br>
would no longer work correctly.
</p>
<p>
<b>&nbsp;To replace an existing main aspect template, </b> you use a killer template,<br>
which is not covered in this article. See <i>Inside Macintosh: AOCE Application Interfaces</i> <br>
for more on killer templates.*
</p>
<p>
Aspect templates, like other templates, have a name that must be unique to be<br>
identified by other templates. To guarantee uniqueness, start the names of all your<br>
templates (as well as all the new record types and attribute types for which you<br>
provide main aspect templates) with your four- character application signature as<br>
registered with Apple's Developer Support Center. Here's our aspect template name<br>
resource:
</p>
<pre>resource 'rstr' (kEInfoPageAspect+kDETTemplateName, purgeable) {
    "ACFC InfoPage aspect"
};</pre>
<p>
The record type resource identifies the record that the aspect applies to, in this case<br>
the User record:
</p>
<pre>resource 'rstr' (kEInfoPageAspect+kDETRecordType, purgeable) {
    "aoce User"
};</pre>
<p>
<b>&nbsp;Although we're going to be defining</b> a new attribute type that goes in User<br>
records, we don't provide a resource (of type kDETAttributeType) to specify that<br>
attribute type for the aspect template. In fact, if an attribute type were specified for<br>
the aspect template, the CE could use the template only for that attribute type and could<br>
not use it to modify the User record itself. (If the new attribute type were in a sublist<br>
and we provided a main aspect template to describe how that attribute should appear in<br>
the sublist, that main aspect&nbsp;&nbsp;template would contain a kDETAttributeType resource, as<br>
shown in the sample code on this issue's CD.)*
</p>
<p>
<b>DRAG AND DROP RESOURCES</b><br>
The aspect template drag and drop resources in the sample code make it possible for<br>
users to drag keyword records and drop them either on a closed User record or directly<br>
on a sublist on an information page, thereby adding those records to the sublist. 
</p>
<p>
The kDETAspectRecordDragIn resource specifies what types of records can be dropped<br>
on a sublist.&nbsp;&nbsp;&nbsp;Because the CE can't actually store a record in a record, it adds to the<br>
sublist an attribute containing an alias to the dropped record. For each type of record<br>
the user can drag in, you also need to specify the type of attribute to store the alias in.<br>
The following resource indicates that aliases to keyword records should be stored as<br>
attribute type "ACFC Alias keyword":
</p>
<pre>resource 'rst#' (kEInfoPageAspect+kDETAspectRecordDragIn,
     purgeable) {
    {
        "ACFC Keywords", "ACFC Alias keyword"
    }
};</pre>
<p>
The drop-operation order and drop-check flag in the aspect template signature<br>
resource (shown in the previous section) come into play during these drag and drop<br>
operations, as follows:
</p>
<ul>
<li>The drop-check flag controls when the user will be prompted for<br>
confirmation upon performing the drag and drop. Setting this flag to<br>
dropCheckAlways indicates that the prompt message should always appear.<br>
Setting it to dropCheckConflicts limits its appearance to times when the user<br>
drops a record on a closed User record and more than one information page<br>
contains a sublist that accepts that record type. In this case, the CE would have<br>
to determine which information page should have the record added to its<br>
sublist. If you set the drop- check flag to dropCheckConflicts, the user is<br>
prompted for confirmation only if such a conflict arises.</li>
<li>Setting the drop-operation order to 0 indicates that you want the highest<br>
possible priority in case of the conflict just described. If the conflicting<br>
template also set its drop-operation order to 0, the CE makes an arbitrary<br>
decision about which sublist to add the record to. The user can always avoid the<br>
conflict by opening the desired information page and dropping the object<br>
directly on the desired sublist. </li>
</ul>
<p>
You also need to define the prompt message, which can include parameters (token<b>^2</b> is<br>
the destination's name, and token<b>^3</b> is the dragged record's name).
</p>
<pre>resource 'rstr' (kEInfoPageAspect+kDETAspectDragInString,
    purgeable) {
    "Do you want to add %3%"^3"%the selected items% to the "
    "company info for "^2"?"
};</pre>
<p>
In this example, dragging the keyword record named "AppleScript" onto John's<br>
business card produces the message "Do you want to add AppleScript to the company<br>
info for John?" If the user drags several items at once, the CE substitutes "the selected<br>
items" for the name of the dragged item. 
</p>
<p>
<b>VIEW MENU COMMANDS AND BALLOON HELP</b><br>
When a template contains a sublist, the user determines how data is sorted in the<br>
sublist by choosing from the Finder's View menu (for example, "by Name" or "by<br>
Kind") or by clicking the labels above the sublist ("Name" and "Kind" in Figure 3).<br>
For these features to work, you have to provide the items for the View menu and<br>
specify which properties are used for sorting in each case. Our example uses the<br>
metaproperties (properties that are provided by the CE and that don't correspond to<br>
specific attribute values): kDETPrName (the record's name) and kDETPrKind (the<br>
record's kind). 
</p>
<pre>resource 'detm' (kEInfoPageAspect+kDETAspectViewMenu, purgeable) {
    kEInfoPageAspect+kDETAspectViewMenu,
    {
    kDETPrName, "by Name";
    kDETPrKind, "by Kind";
    }
};</pre>
<p>
You also need to add Balloon Help strings for properties. Each property has two<br>
strings: the first one is displayed if the property is editable, the second one if it's not.<br>
The first pair of text strings corresponds to the first property, the second pair to the<br>
second property, and so on. In our example, there's only one property (the employee's<br>
job description):
</p>
<pre>resource 'rst#' (kEInfoPageAspect+kDETAspectBalloons, purgeable) {
    {
    "Description of the employee's job", "Description :"
    " Uneditable because the record is locked or access controlled."
    }
};</pre>
<p>
<b>THE LOOKUP TABLE</b><br>
As mentioned earlier, the lookup table tells the CE how to parse attribute values into<br>
properties and how to convert property values into attributes. For each property that<br>
you want to use on an information page, the lookup table must contain an entry that<br>
describes how to process the property's associated attribute. An attribute is identified<br>
by an attribute type and an attribute value tag:
</p>
<ul>
<li>The attribute type is a string that describes the contents of the attribute<br>
(such as "ACFC Alias keyword" or "aoce Member"). </li>
<li>The attribute value tag is a 4-byte code that specifies the data format of<br>
the attribute value (such as typePackedDSSpec or typeBinary). </li>
</ul>
<p>
A single lookup table entry can specify how to parse more than one attribute type, but<br>
only if they have the same attribute value tag. You can provide separate lookup table<br>
entries for input (that is, translating attribute values to properties) and output<br>
(translating properties to attribute values), but you must provide both.
</p>
<p>
Each lookup table entry contains a set of flags that indicate the following:
</p>
<ul>
<li>whether the entry is used for translating attribute values to properties<br>
(useForInput)</li>
<li>whether the entry is used for translating properties to attribute values<br>
(useForOutput)</li>
<li>whether the attribute value is to be used in a sublist</li>
<li>whether the resulting entry in the sublist is an alias</li>
</ul>
<p>
The entry also includes elements that specify what to do with the attribute. Each<br>
element consists of three parts: a format that drives the parsing process, a property<br>
number, and an extra parameter used in certain types of elements. The format can be a<br>
simple data type that specifies how many bytes of data to take from the attribute and<br>
how to store it in the property. For example, a format of type 'word' takes the next two<br>
bytes from the attribute value and puts it in a number-type property. In the other<br>
direction, it would take two bytes from a number-type property and store it in an<br>
attribute value.
</p>
<p>
<b>&nbsp;Lookup tables are complex </b> and can be used in more ways than described here.<br>
For more information, see <i>Inside Macintosh: AOCE Application Interfaces.</i><i>*</i>
</p>
<p>
In our example, there are two attribute types: one contains the description of an<br>
employee's job (attribute type "ACFC Company Empext Function"); the second is<br>
multivalued and contains the list of keywords or users (contact people, not discussed<br>
in this article), which are records in the catalog.&nbsp;&nbsp;There are two entries in the lookup<br>
table, one for each attribute type: the first one maps the attribute value to a string<br>
property (kFunction, defined on the CD); the second is for sublist items, each of which<br>
is a record of type "ACFC Alias keyword." The notForOutput and notForInputflags are<br>
set for the items in the sublist because sublist items are described in their own main<br>
aspects, not in the main view aspect that defines the sublist. 
</p>
<pre>resource 'dett' (kEInfoPageAspect+kDETAspectLookup, purgeable) {
    {
    {"ACFC Company Empext Function"}, typeBinary,
        useForInput, useForOutput, notInSublist, isNotAlias,
        isNotRecordRef,
        {
        'rstr', kFunction, 0;               // An element
        };
    {"ACFC Alias keyword"}, typePackedDSSpec,
        notForInput, notForOutput, useInSublist, isAlias,
        isNotRecordRef,
        {};
    }
};</pre>
<h2>DEFINING THE INFORMATION PAGE TEMPLATE</h2>
<p>
As described earlier in "What's in a Template," an information page template<br>
specifiesthe contents and layout of an information page. It includes one or more view<br>
lists, which describe the different views on the page, such as text fields or radio<br>
buttons. When your information page contains a sublist, you must include a view list<br>
describing an entry in the sublist. The CE uses this view list to display appropriate<br>
information for each item of the sublist, such as an icon and the name of the item.
</p>
<p>
<b>SIGNATURE, NAME, AND TYPE RESOURCES</b><br>
The information page template signature resource provides the resource IDs of the<br>
view lists associated with the information page, as well as two property numbers for<br>
each view list. As discussed earlier, if the values of these two properties are not equal,<br>
the CE doesn't display the views described by the view list. 
</p>
<p>
The signature resource also specifies the sort-order number of the information page,<br>
the presence or absence of a sublist in the information page, and the rectangle that<br>
contains the sublist (if any). The CE displays the information pages in the sequence<br>
indicated by their sort-order numbers.
</p>
<pre>resource 'deti' (kEInfoPage, purgeable) {
    4000,                       // Sort-order number
    {kSublistTop, kSublistLeft, kSublistBottom, kSublistRight},
    noSelectFirstText, 
            // Don't automatically select the first editable
            // text field when the information page is opened.
    {
    kDETNoProperty, kDETNoProperty, kEInfoPage;
    },
    {
    kDETNoProperty, kDETNoProperty, kEInfoPage+1;
    }
};</pre>
<p>
As with the aspect template, you need to include resources that provide the template<br>
name and the type of record the template applies to:
</p>
<pre>resource 'rstr' (kEInfoPage+kDETTemplateName, purgeable) {
    "ACFC 1stInfoPage"
};</pre>
<pre>resource 'rstr' (kEInfoPage+kDETRecordType, purgeable) {
    "aoce User"
};</pre>
<p>
<b>OTHER REQUIRED RESOURCES</b><br>
Because there's more than one information page for the User record, you need to<br>
provide the string that gets displayed in the information page pop-up menu used for<br>
changing to a different page:
</p>
<pre>resource 'rstr' (kEInfoPage+kDETInfoPageName, purgeable) {
    "Company Info"
};</pre>
<p>
You also need to provide the name of the aspect template that defines the properties<br>
used by the information page:
</p>
<pre>resource 'rstr' (kEInfoPage+kDETInfoPageMainViewAspect, purgeable) {
    "ACFC InfoPage aspect"
};</pre>
<p>
<b>VIEW LISTS</b>Our example has two view lists: the first describes the views (graphical<br>
elements) of the information page, and the second describes an entry in the sublist. To<br>
complete the information page template, you need to define these view lists (see<br>
Listing 1). A view list contains the following information for each view:
</p>
<ul>
<li>the view's bounds</li>
<li>the view's type (such as button or editable text field)</li>
<li>the property associated with this view, if any</li>
<li>information specific to the type of view</li>
</ul><p class="spacer">&nbsp;</p>
<p>
<b>Listing 1. </b>Defining the view lists
</p>
<pre>resource 'detv' (kEInfoPage, purgeable) {
    {
    // Icon
    {6, 156, 22, 172}, kDETNoFlags, kDETAspectMainBitmap,
        Bitmap {kDETSmallIcon};
    // Static text
    {kFunctionTop, kFunctionLeft, kFunctionBottom, kFunctionRight},
        kDETNoFlags, kDETNoProperty,
        StaticTextFromView {kDETApplicationFont,
kDETApplicationFontSize,
            kDETRight, kDETBold,
        "Job description"};
    // Editable text
    {kTEFunctionTop, kTEFunctionLeft, kTEFunctionBottom,
        kTEFunctionRight}, kDETMultiLine, kFunction,
        EditText {kDETApplicationFont, kDETApplicationFontSize,
            kDETLeft, kDETNormal};
    // Sublist label: "Name"
    {kSublistSeeAlsoTop, kSublistSeeAlsoLeft,  
            kSublistSeeAlsoBottom, kSublistSeeAlsoRight},
        kDETNoFlags, kDETPrName,
        StaticCommandTextFromView {kDETDefaultFont,
            kDETDefaultFontSize, kDETLeft, kDETUnderline,
        "Name", kDETChangeViewCommand, -1};
    // Sublist label: "Kind"
    {kSublistKindTop, kSublistKindLeft,
            kSublistKindBottom, kSublistKindRight},
        kDETNoFlags, kDETPrKind,
        StaticCommandTextFromView {kDETDefaultFont,
            kDETDefaultFontSize, kDETLeft, kDETNormal,
        "Kind", kDETChangeViewCommand, -2};
    // Sublist box
    {kSublistTop-1, kSublistLeft-1,
            kSublistBottom+1, kSublistRight+1}, kDETNoFlags,
        kDETNoProperty, Box {kDETUnused};   
     }
};

// Sublist view list -- description of an entry in the sublist
resource 'detv' (kEInfoPage+1, purgeable) {
    {
    // Icon
    {kDETSublistEntryTop, kDETSublistIconColumnLeft,
            kDETSublistEntryBottom, kDETSublistIconColumnRight},
        kDETEnabled, kDETAspectMainBitmap, Bitmap {kDETMiniIcon};
    // Record's name
    {kDETSublistEntryTop, kSeeAlsoColumnLeft,
            kDETSublistEntryBottom, kSeeAlsoColumnRight},
        kDETEnabled+kDETDynamicSize, kDETPrName,
        EditText {kDETDefaultFont, kDETDefaultFontSize,
            kDETLeft, kDETItalic};
    // Record's type
    {kDETSublistEntryTop, kKindColumnLeft,
            kDETSublistEntryBottom, kKindColumnRight},
        kDETEnabled+kDETDynamicSize, kDETPrKind,
        EditText {kDETDefaultFont, kDETDefaultFontSize,
            kDETLeft, kDETNormal};
    }
};</pre>
<p class="spacer">&nbsp;</p>
<h2>DEFINING THE NEW KEYWORD RECORD TYPE</h2>
<p>
The aspect and information page templates are now defined, adding a new information<br>
page for User records. However, there's still work to do before the user can create<br>
keyword records -- you need to provide aspect and information page templates for this<br>
new record type.
</p>
<p>
<b>MAIN ASPECT TEMPLATE FOR KEYWORD RECORDS</b><br>
Since the new record type appears in a sublist, you need to provide a main aspect<br>
template (as shown in Listing 2). 
</p>
<p>
A main aspect template is similar to the aspect template defined earlier, but it<br>
includes some additional resources:
</p>
<ul>
<li>the menu item text for the Finder's Catalog menu for creating keyword<br>
records</li>
<li>the name the CE should assign to newly created records of this type</li>
<li>an icon family for the icon, the record kind, and the kind of an alias to a<br>
record, as they are to be displayed in a sublist</li>
<li>one or more categories that this record type belongs to</li>
<li>Balloon Help strings for the record and for aliases to the record</li>
</ul><p class="spacer">&nbsp;</p>
<p>
<b>Listing 2. </b>Main aspect template for keyword records
</p>
<pre>resource 'deta' (kKeywordAspect, purgeable) {
    0,                  // Drop-operation order
    dropCheckAlways,    // Drop-check flag
    isMainAspect        // Is the main aspect
};

resource 'rstr' (kKeywordAspect+kDETTemplateName, purgeable) {
    "ACFC Keywords Aspect"
};

resource 'rstr' (kKeywordAspect+kDETRecordType, purgeable) {
    "ACFC Keywords"
};

resource 'rstr' (kKeywordAspect+kDETAspectKind, purgeable) {
    "Keyword"
};

resource 'rst#' (kKeywordAspect+kDETAspectCategory, purgeable) {
    {
    "Miscellaneous"
    }
};

// Icons
include "Keywords.rsrcs" 'ICN#'(128) as
    'ICN#'(kKeywordAspect+kDETAspectMainBitmap, purgeable);
include "Keywords.rsrcs" 'icl4'(128) as
    'icl4'(kKeywordAspect+kDETAspectMainBitmap, purgeable);
include "Keywords.rsrcs" 'icl8'(128) as
    'icl8'(kKeywordAspect+kDETAspectMainBitmap, purgeable);
include "Keywords.rsrcs" 'ics#'(128) as
    'ics#'(kKeywordAspect+kDETAspectMainBitmap, purgeable);
include "Keywords.rsrcs" 'ics4'(128) as
    'ics4'(kKeywordAspect+kDETAspectMainBitmap, purgeable);
include "Keywords.rsrcs" 'ics8'(128) as
    'ics8'(kKeywordAspect+kDETAspectMainBitmap, purgeable);
include "Keywords.rsrcs" 'SICN'(128) as
    'SICN'(kKeywordAspect+kDETAspectMainBitmap, purgeable);

include "KeywordsInfoPageAspect.code" 'code'(1) as
    'detc'(kKeywordAspect+kDETAspectCode, purgeable);

// Drag and drop resources
resource 'rstr' (kKeywordAspect+kDETAspectDragInString, purgeable) {
    "Add &#8220;^3&#8221; to &#8220;^2&#8221;?"
};

resource 'rst#' (kKeywordAspect+kDETAspectRecordDragIn, purgeable) {
    {
    "aoce User", kMemberAttrTypeBody
    }
};

// View menu and Balloon Help resources
resource 'rstr' (kKeywordAspect+kDETAspectNewMenuName, purgeable) {
    "New Keyword"
};

resource 'rstr' (kKeywordAspect+kDETAspectNewEntryName, purgeable) {
    "Untitled Keyword"
};

resource 'rst#' (kKeywordAspect+kDETAspectBalloons, purgeable) {
    {
    "Keyword description", "Keyword description : uneditable because"
    " the record is locked or access controlled."
    }
};

resource 'rst#' (kKeywordAspect+kDETWhatIs, purgeable) {
    {
    "Keyword \n \nA keyword record. Open this icon to see a"
    " description of this keyword and a list of people who have"
    " this job skill."
    }
};

resource 'rst#' (kKeywordAspect+kDETAliasWhatIs, purgeable) {
    {
    "Keyword alias \n \nAn alias to a keyword record. Open this"
    " alias to see a description of this keyword and a list of"
    " people who have this job skill."
    }
};

resource 'detm' (kKeywordAspect+kDETAspectViewMenu, purgeable) {
    kKeywordAspect+kDETAspectViewMenu,
    {
    kDETPrName, "by Name";
    kDETPrKind, "by Kind";
    }
};

// Lookup table
resource 'dett' (kKeywordAspect+kDETAspectLookup, purgeable) {
    {
    {"ACFC Keyword Description"}, typeRString,
        useForInput, useForOutput, notInSublist, isNotAlias,
        isNotRecordRef,
        {'rstr', prDescription, 0};
    {kMemberAttrTypeBody}, typePackedDSSpec,
        notForInput, notForOutput, useInSublist, isAlias,
        isNotRecordRef,
        {};
    }
};</pre>
<p>
<b>INFORMATION PAGE TEMPLATE FOR KEYWORD RECORDS</b><br>
Upon double-clicking a keyword record, the user expects an information page to<br>
appear, as shown in Figure 4. Defining the information page template for the keyword<br>
record is similar to defining the information page template for the User record, as<br>
described earlier. You include signature, name, type, and optional resources along<br>
with the view lists. The resource definitions are provided on this issue's CD. 
</p>
<p>
<img src="img/250.gif" width="600 px"></img>
</p>
<p>
<b>Figure 4. </b>Keyword record information page
</p>
<h2>A CODE RESOURCE TO SYNCHRONIZE SUBLISTS</h2>
<p>
As illustrated earlier in Figure 3, the sublist in the new User record information page<br>
lists the areas of expertise of the employee described by that record. Each area of<br>
expertise is represented by an alias to a keyword record. The sublist in a keyword<br>
record lists all the employees who have expertise in the area described by that<br>
keyword record (as shown in Figure 4). To keep these two lists synchronized, both the<br>
aspect template for the new information page we added to the user template and the<br>
keyword record's aspect template include a code resource. Each time someone adds a<br>
User record to a keyword record's sublist, the keyword record's code resource adds<br>
that keyword to the User record's sublist; each time someone adds a keyword record to<br>
a User record's sublist, the User record's code resource adds that user to the keyword<br>
record's sublist.
</p>
<p>
The code resources of the two templates are exactly the same because the structure of<br>
the attributes in both the records is identical, as described in the lookup table entry of<br>
the two aspect templates. 
</p>
<p>
The following line adds the code resource to the aspect template:
</p>
<pre>include "UserInfoPageAspect.code" 'code'(1) as
    'detc'(kEInfoPageAspect+kDETAspectCode, purgeable);</pre>
<p>
The CE calls code resources when certain events occur, such as a change in an attribute<br>
or a drag and drop action. If the code resource doesn't handle the event, it must return<br>
a kDETDidNotHandle result code; if it successfully handles the event, it returns noErr.<br>
The CE calls the code resource's main routine, passing it a pointer to a parameter<br>
block (see Listing 3). This call block indicates which event occurred and contains<br>
additional parameters specific to the event.
</p>
<p>
<b>DODROPQUERY</b><br>
The CE calls your code routine with a drop-query command (that is, with the<br>
kDETcmdDropQuery selector) when the user drops an object on the object that your<br>
aspect template applies to. If you want your code resource to handle the drop operation,<br>
return a value that's in the developer property-value range (that is,<br>
kDETFirstDevProperty through 249) in the commandID field of the call block.
</p>
<p class="spacer">&nbsp;</p>
<p>
<b>Listing 3. </b>The code resource's main routine
</p>
<pre>#define prChangeRec  kDETFirstDevProperty

/* Entry point called by the CE */
pascal OSErr KeywordsIP (DETCallBlock* callBlockPtr)
{  
    OSErr   err = noErr;

    if (callBlockPtr-&gt;protoCall.target.selector == kDETSelf ||
            callBlockPtr-&gt;protoCall.target.selector ==
            kDETSublistItem)
        switch (callBlockPtr-&gt;protoCall.reqFunction) {
            case kDETcmdInit:
                /* Call-for masks */
                callBlockPtr-&gt;init.newCallFors =
                    kDETCallForCommands + kDETCallForDrops;
                break;
            case kDETcmdDropQuery:
                err = DoDropQuery(callBlockPtr);
                break;
            case kDETcmdPropertyCommand:
                err = DoCommand(callBlockPtr);
                break;
            default:
                err = kDETDidNotHandle;
                break;
            }
    else err = kDETDidNotHandle;
    return err;
}</pre>
<p>
In our example (shown in Listing 4), we accept a record when the user drops it on a<br>
record that the template applies to by checking the commandID parameter provided by<br>
the CE and accepting drops only when the commandID value is kDETAlias. For other<br>
values, we inform the CE that we don't manage these cases by returning the constant<br>
kDETDidNotHandle. When we accept the drop operation, DoDropQuery returns the<br>
value prChangeRec in response to the drop-query command.&nbsp;&nbsp;&nbsp;When it receives a<br>
property number in response to the drop-query command, the CE calls the code<br>
resource again, this time with a property command (that is, with the selector<br>
kDETcmdPropertyCommand).
</p>
<p>
The property command's call block includes the property number specified in<br>
response to the drop- query command. The property-command code can use this<br>
property number as a routine selector. In our example, DoCommand checks to make<br>
sure the property number is prChangeRec. If it is, DoCommand calls DoAddRecord<br>
(more on this in a moment).
</p>
<p>
Most of the time, a resource doesn't handle all the CE events; therefore, to avoid the<br>
overhead resulting from frequent calls to the code resource, each template has a<br>
"call-for" mask that indicates which events to invoke it for. You must return the<br>
call-for mask when the CE calls the code resource with the kDETcmdInit selector. The<br>
kDETcmdInit case of the switch statement in Listing 3 returns a call-for mask that<br>
indicates that the code resource should be called only for property commands and drop<br>
queries. 
</p>
<p>
<b>Listing 4. </b>DoDropQuery and DoCommand
</p>
<pre>/* Called when an object is dropped onto a record. Just set up a
    property number (prChangeRec) to be sent to the target aspect. */
OSErr DoDropQuery (DETCallBlock* callBlockPtr)
{
    DETTargetSelector theDET;
    /* What is the best guess of the CE regarding the dropped */
    /* object? */
    if (((DETDropQueryBlock*)callBlockPtr)-&gt;commandID == kDETAlias) {
        /* Make an alias of the dropped object. */
        ((DETDropQueryBlock*)callBlockPtr)-&gt;copyToHFS = false;
        ((DETDropQueryBlock*)callBlockPtr)-&gt;commandID = prChangeRec;
        return noErr;
        }
    else
        return kDETDidNotHandle;
}

/* Called when the CE sends a property command. We check that it's
    the property we expect. */
OSErr DoCommand (DETCallBlock* callBlockPtr)
{
    OSErr   err = noErr;
    
    /* Check whether called for the prChangeRec command. */
    switch (((DETPropertyCommandBlock*)callBlockPtr)-&gt;property) {
        case prChangeRec:
            err = DoAddRecord(callBlockPtr);
            break;
        default:
            err = kDETDidNotHandle;
            break;
        }
    return err;
}</pre>
<p>
<b>DOADDRECORD</b><br>
When the CE calls DoCommand with the property number prChangeRec, DoCommand<br>
calls DoAddRecord (Listing 5). DoAddRecord needs to add data to a record, so it must<br>
first identify which record is the target of the drop. To do so, it calls the CE's<br>
kDETcmdGetDSSpec callback routine, passing it the kDETSelf target selector.<br>
DoAddRecord then extracts the reference number of the personal catalog and the record<br>
ID from the record's DSSpec that was returned by the callback routine. To find out how<br>
many objects were dropped (that is, for how many dropped objects the drop-query<br>
routine returned the same property number), DoAddRecord calls the CE's<br>
kDETcmdGetCommandSelectionCount callback routine.
</p>
<p class="spacer">&nbsp;</p>
<p>
<b>Listing 5. </b>DoAddRecord
</p><p class="spacer">&nbsp;</p>
<pre>/* When record A is dragged onto record B, this function updates
    record A to store an alias to record B and updates record B to
    store an alias to record A. Updates occur only if records are of
    the required type. */
OSErr DoAddRecord (DETCallBlock* callBlockPtr)
{
    DETCallBackBlock    cbb, cbb1, cbb2;
    short               PABrefNum;
    RecordID            targetRID, receivedRID;
    LocalIdentity       userLocalId;
    PackedDSSpec        *targetDSSpec, *droppedDSSpec;
    DSSpec              dsp, dsp1;
    OSErr               err;
    long                count, i;
    Str255              targetAttrType, droppedAttrType;

#ifdef USER
    Str255              theStr = "ACFC Keywords";
    RString             recType;
    OCECToRString(theStr, smRoman, &amp;recType, kRStringMaxBytes);
#endif

    /* Find out target record DSSpec. */
    cbb.getDSSpec.target.selector = kDETSelf;
    cbb.getDSSpec.reqFunction = kDETcmdGetDSSpec;
    err = CallBackDET(callBlockPtr, &amp;cbb);
    if (err != noErr)
        return err;
   
    HLock((Handle) cbb.getDSSpec.dsSpec);
    targetDSSpec = *(cbb.getDSSpec.dsSpec);
    /* Get record ID. */
    PABrefNum = cbb.getDSSpec.refNum;
    userLocalId = cbb.getDSSpec.identity;
    OCEUnpackDSSpec(targetDSSpec, &amp;dsp, &amp;targetRID);
   
    /* Find out how many records have been dropped. */
    cbb1.getCommandSelectionCount.reqFunction =
        kDETcmdGetCommandSelectionCount;
    err = CallBackDET(callBlockPtr, &amp;cbb1);
    if (err != noErr) {
        DisposeHandle((Handle) cbb.getDSSpec.dsSpec);
        return err;
        }
   
    count = cbb1.getCommandSelectionCount.count;
    for (i = 1; i &lt;= count; i++) {
        /* Get the DSSpec of dropped record. */
        cbb1.getCommandItemN.reqFunction = kDETcmdGetCommandItemN;
        cbb1.getCommandItemN.itemNumber = i;
        cbb1.getCommandItemN.itemType = kDETDSType;
        err = CallBackDET(callBlockPtr, &amp;cbb1);
        if (err == noErr) {
            HLock((Handle) cbb1.getCommandItemN.item.ds.dsSpec);
            droppedDSSpec = *(cbb1.getCommandItemN.item.ds.dsSpec);
            OCEUnpackDSSpec(droppedDSSpec, &amp;dsp1, &amp;receivedRID);
            /* Check type of record. */
#ifdef USER
            if (OCEEqualRString(receivedRID.local.recordType,
                    &amp;recType, kOCERecordType)) {
                strcpy(targetAttrType, kMemberAttrTypeBody);
                strcpy(droppedAttrType, "ACFC Alias keyword");
#else
            if (OCEEqualRString(receivedRID.local.recordType,
                   OCEGetIndRecordType(kUserRecTypeNum),
                   kOCERecordType)) {
                strcpy(targetAttrType, "ACFC Alias keyword");
                strcpy(droppedAttrType, kMemberAttrTypeBody);
#endif
                /* Update target record to set up dropped record as
                   an attribute of this record. */
                AddRecordAsAttribute(userLocalId, droppedDSSpec,
                    &amp;targetRID, PABrefNum, droppedAttrType);
                /* Update dropped record to set up target record as
                   an attribute of the dropped record. */
                AddRecordAsAttribute(userLocalId, targetDSSpec,
                    &amp;receivedRID, PABrefNum, targetAttrType);
                }
            HUnlock((Handle) cbb1.getCommandItemN.item.ds.dsSpec);
            DisposeHandle
                ((Handle) cbb1.getCommandItemN.item.ds.dsSpec);
            }
        else
            break;
        }
       
    if (err == noErr) {
        /* Ask for immediate update. */
        cbb2.requestSync.target =
            ((DETPropertyCommandBlock*)callBlockPtr)-&gt;target;
        cbb2.requestSync.reqFunction = kDETcmdRequestSync;
        err = CallBackDET(callBlockPtr, &amp;cbb2);
        }
    DisposeHandle((Handle) cbb.getDSSpec.dsSpec);
    return err;
}</pre>
<p>
DoAddRecord calls the CE's kDETcmdGetCommandItemN callback routine for each object<br>
dropped. Dropped objects can be of different types, such as catalog items, files, and<br>
letters. In our example, the only kind of objects we want to add to our sublist are<br>
keyword records and User records, so DoAddRecord requests only information of type<br>
kDETDSType to get a packed DSSpec for each dropped record. If the targeted record is a<br>
User record, DoAddRecord checks to make sure the dropped record is a keyword record.<br>
If the targeted record is a keyword record, DoAddRecord checks to make sure the<br>
dropped record is a User record. It uses the AOCE utility routine OCEEqualRString to<br>
check the record type.
</p>
<p>
<b>ADDRECORDASATTRIBUTE</b><br>
If the dropped record is the right type, DoAddRecord calls AddRecordAsAttribute, which<br>
is shown in Listing 6. AddRecordAsAttribute calls the Catalog Manager's<br>
DirAddAttributeValue routine to add the dropped object to the record. The parameter<br>
block for DirAddAttributeValue includes parameters that identify the catalog<br>
containing the record to be modified, the record itself, and the attribute to be added.<br>
The attribute specification includes the attribute type, the attribute value tag, and the<br>
attribute value. 
</p>
<p>
<b>Listing 6. </b>AddRecordAsAttribute
</p>
<pre>/* This routine adds an attribute as a DSSpec to a record. */
void AddRecordAsAttribute(LocalIdentity userLocalId,
         PackedDSSpec* theDSSpec, RecordIDPtr updatedRecord,
         short refNum, Ptr attrType)
{
    OSErr           err;
    Attribute       theAttribute;
    DirParamBlock   dspb;
    AttributeType   kwRType;

    /* Prepare the attribute; set up its type and the data within
       the attribute. */
    OCECToRString(attrType, smRoman, (RString *) &amp;kwRType,
        kAttributeTypeMaxBytes);
    theAttribute.attributeType = kwRType;
    theAttribute.value.tag = typePackedDSSpec;
    theAttribute.value.dataLength =
        theDSSpec-&gt;dataLength+sizeof(theDSSpec-&gt;dataLength);
    theAttribute.value.bytes = (Ptr) theDSSpec;
   
    /* Prepare the parameter block used by the Catalog Manager to
       add an attribute. */
    *(long *)&amp;dspb.addAttributeValuePB.serverHint = nil;
    dspb.addAttributeValuePB.dsRefNum = refNum;
                                   /* refNum of a personal catalog */
    dspb.addAttributeValuePB.identity = userLocalId;
    dspb.addAttributeValuePB.aRecord = updatedRecord;
                                   /* Record to be modified */
    dspb.addAttributeValuePB.attr = &amp;theAttribute;
                                   /* Attribute to be added */
    dspb.addAttributeValuePB.clientData = 0;
    err = DirAddAttributeValue(&amp;dspb, false);
}</pre>
<p>
To maintain the synchronization between the User record and the keyword record, you<br>
also need to update the dropped record, adding the target record as an attribute of the<br>
dropped one. You can use the same routine -- AddRecordAsAttribute -- because the<br>
structure of the attributes in the two records is the same -- the record to be updated<br>
is now the dropped record and the attribute value is the DSSpec of the target record.
</p>
<p>
<b>SUMMARY</b><br>
To summarize what happens when a drag and drop action occurs:
</p>
<ol>
<li>The user drops a bunch of icons on a closed record or an information page.<br>
If the drop is on an information page, that page is the only possible<br>
destination; if it's a closed record, all the information pages are potential<br>
destinations.</li>
<li>For each icon/possible-destination-aspect pair, the CE looks at the<br>
template resources and calls the code resource (if there is one).</li>
<li>Based on the information returned by the code resources and any drag and<br>
drop resources present, the CE decides what operation is desired for each pair.</li>
<li>Based on the drop-operation order number, the CE picks one destination<br>
and one operation for each icon. </li>
<li>For each group of icons with the same destination and operation, the CE<br>
performs that operation at that destination. If the operation is copy, move, or<br>
make alias, the CE handles it. If the operation is a property command (as in<br>
this article), the CE calls the code resource to perform the operation. </li>
</ol>
<h2>USING THE TEMPLATES</h2>
<p>
When you compile the templates, you get a PowerTalk extension that can be installed in<br>
the Extensions folder of the System Folder. Users who install these templates can<br>
display and edit new information about users in User records in their personal<br>
catalogs. The system administrator or anyone who has sufficient access privileges can<br>
use the new keyword records and the new User record information page to maintain<br>
this information for everyone who has a PowerShare account. 
</p>
<p>
The benefit in extending User records is that all the information regarding a person is<br>
stored in the same place and therefore is very easy to retrieve. The work involved in<br>
developing this customized solution is much less than that typically involved in<br>
developing a database. What's more, AOCE catalogs are part of system software -- why<br>
pay more for new database software and servers? 
</p>
<h2>AND NOW LET'S DREAM</h2>
<p>
This article has shown a relatively easy way to extend the templates that come built<br>
into PowerTalk.&nbsp;&nbsp;&nbsp;As you become more familiar with AOCE templates, you'll<br>
undoubtedly think of more complex things you can do with templates and template code<br>
resources. 
</p>
<p>
The next article<i>,</i>&nbsp;&nbsp;"Exploring Advanced AOCE Templates Through Celestial Mechanics,"<br>
describes one imaginative use of templates. Another use might be to define different<br>
kinds of templates for different people, giving them access to different types of data in<br>
the same catalog. 
</p>
<p>
Imagine a traditional library using a catalog to store references to books: A<br>
specializedtemplate could provide information on a book, including keywords related to<br>
the topics in the book. A keyword template would let users browse the catalog and find<br>
all the books available on a specific topic. And to dream a bit further, the catalog could<br>
be a very large database on a distant system that you access by dialing up. It would<br>
contain all the references in the world of existing books, and you could consult it from<br>
your home, just by browsing the catalog through the Finder. The book information page<br>
might even contain a button that could open the electronic version of the book.
</p>
<p>
So go ahead and take advantage of AOCE catalogs. Apply what you've learned about<br>
expanding records through AOCE templates and begin building the world of connectivity<br>
and information sharing that you dream about. 
</p>
<p>
<b>CHRISTINE BUTTIN </b>has worked in Developer Technical Support for Apple since<br>
1989, first for Apple Computer Europe and now for Apple France. At the office, they<br>
call her the talkative woman, not only because she enjoys chatting, but also because<br>
she mainly supports technologies that enable communication (such as AppleTalk,<br>
AppleScript, AOCE). When not talking, she spends most of her time practicing Aikido<br>
or traveling (she has a special love for the Sahara Desert, where she's sure to be far<br>
away from computers). An extra benefit of her job is that she can regularly visit the<br>
U.S., where she has made many good friends. Visiting her American friends might not<br>
be as restful as a trip to the Sahara Desert, but it certainly is a lot of fun.*
</p>
<p>
<b>Thanks </b>to our technical reviewers David Akhond, Paul Black, Harry Chesley, and<br>
Steve Falkenburg. Special thanks to Paul Black for writing the background material on<br>
AOCE catalogs and templates. *
</p>
</body>
</html>
