<html>
<head>
<!-- Article ID: 37 - Extracted from develop-1994 -->
<!-- on 2024-05-24 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by the copyright of its respective owners -->
<title>September 94 - Adding QuickDraw GX Printing to QuickDraw Applications</title>
<link href="../common/styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h2>Adding QuickDraw GX Printing to QuickDraw Applications</h2>
<h1>DAVE HERSEY</h1>
<p>
<img src="img/217.gif" width="180 px"></img>
</p>
<p>
<i>Now that QuickDraw GX has been released, you may be wondering what to do with your</i><br>
<i>older QuickDraw applications. The good news is that by adding a relatively small</i><br>
<i>percentage of code to your existing applications, you can support all the new features</i><br>
<i>of the QuickDraw GX printing architecture and still retain full compatibility with</i><br>
<i>non-QuickDraw GX systems.</i>
</p>
<p class="spacer">&nbsp;</p>
<p>
Compatibility with the existing application base was a primary concern during<br>
thedevelopment of QuickDraw GX; only the most hardened "print criminals" shouldhave<br>
compatibility problems. Since a pre-QuickDraw GX application should work in both<br>
QuickDraw GX and non-QuickDraw GX environments, you may think that leaving your<br>
code as it stands is good enough. Becoming compatible probably doesn't require any<br>
revisions to your existing software, and the fact that your application will perform<br>
with or without QuickDraw GX sounds like a pretty good deal. Where's the catch? 
</p>
<p>
Here it is: A non-QuickDraw GX application doesn't have access to several key features<br>
of QuickDraw GX, so its users can't take advantage of many of the new printing<br>
features. For example, with QuickDraw GX a user can:
</p>
<ul>
<li>Redirect print jobs using the new Print dialog.</li>
<li>Choose page-by-page formatting, so that page 1 prints on US Letter, page<br>
2 prints on #10 envelope, page 3 prints on landscape-oriented US Legal, and<br>
so on, instead of printing the entire document in a single format. </li>
<li>Work with the new QuickDraw GX printing dialogs (shown in Figure 1)<br>
instead of the dialogs provided for compatibility with non-QuickDraw GX<br>
applications.</li>
<li> Use features provided by printing extensions. Printing extensions can add<br>
items to the QuickDraw GX printing dialogs, but not to the compatibility<br>
dialogs. (Added items show up as icons in the column on the left side of each<br>
dialog.)</li>
<li> Print a single copy of a document with the new Print One Copy command. </li>
<li> Print documents by dragging them to desktop printers. </li>
</ul>
<p>
<img src="img/218.gif" width="600 px"></img>
</p>
<p>
Page Setup dialog
</p>
<p>
<img src="img/219.gif" width="600 px"></img>
</p>
<p>
Custom Page Setup dialog
</p>
<p>
<img src="img/220.gif" width="600 px"></img>
</p>
<p>
Print dialog
</p>
<p>
<b>Figure 1. </b>The new QuickDraw GX printing dialogs
</p>
<p class="spacer">&nbsp;</p>
<p>
Users are shut out from all these features if they're using a non-QuickDraw GX<br>
application. In this article, you'll see how to increase an application's level of<br>
QuickDraw GX support. I'll take a QuickDraw application and convert it step by step<br>
into an application that fully supports both the QuickDraw and QuickDraw GX printing<br>
architectures. First, we'll consider some definitions and background information.
</p>
<h2>DIFFERENT LEVELS OF QUICKDRAW GX SUPPORT</h2>
<p>
To begin, let's define the different levels of QuickDraw GX support (from lowest to<br>
highest) that an application can have:
</p>
<ul>
<li><i> QuickDraw GX unaware:</i> The application doesn't implement any<br>
QuickDraw GX code, and QuickDraw GX translates all QuickDraw printing and<br>
drawing calls into QuickDraw GX equivalents. In other words, this is a<br>
non-QuickDraw GX application. </li>
<li><i> QuickDraw GX aware:</i> The application implements a core set of QuickDraw<br>
GX printing features but retains compatibility with documents created with<br>
earlier versions. </li>
<li><i> QuickDraw GX savvy:</i> The application implements full support for<br>
QuickDraw GX graphics, typography, and printing features. It also retains<br>
compatibility with documents created with earlier versions. </li>
<li><i> QuickDraw GX dependent:</i> The application requires the presence of<br>
QuickDraw GX graphics, typography, and printing routines to function. </li>
</ul>
<p>
Applications don't need to implement any code to be QuickDraw GX unaware. Becoming<br>
QuickDraw GX aware requires some coding, but typically not very much. Making your<br>
application QuickDraw GX aware is the<i>minimal</i>&nbsp;&nbsp;level of QuickDraw GX support that<br>
you should set your sights on -- just follow the guidelines in this article. 
</p>
<p>
A QuickDraw GX-aware application is really a non-QuickDraw GX application at heart,<br>
with support for QuickDraw GX printing added. This application still uses its old<br>
QuickDraw commands to represent shapes and text; however, in its print loop, the<br>
application uses the QuickDraw GX graphics translator to translate QuickDraw<br>
commands into QuickDraw GX shapes for printing, if QuickDraw GX is available. 
</p>
<p>
If you're just starting out on a new project, or you're in the process of rewriting an<br>
existing product, you should consider the next level of compatibility: QuickDraw GX<br>
savvy. A QuickDraw GX-savvy application meets the requirements for being<br>
QuickDraw GX aware but also takes advantage of the extensive QuickDraw GX graphics<br>
and typography tools. You may feel that becoming QuickDraw GX savvy, although it<br>
brings with it a wealth of increased capabilities, is too big a leap to take in the short<br>
term. In that case, consider making your existing applications QuickDraw GX aware<br>
and, once they're released, going back and working on QuickDraw GX-savvy versions.
</p>
<h2>A WORD ABOUT COMPATIBILITY</h2>
<p>
It's Apple's hope and goal that no QuickDraw GX-unaware applications will be<br>
incompatible with QuickDraw GX. An existing application can be incompatible only if it<br>
relies on unsupported methods or on unpublished information that breaks under<br>
QuickDraw GX. For printing, this would include things such as trying to access the<br>
Printer Access Protocol (PAP) code from the 'PDEF' 10 resource of the LaserWriter<br>
driver. The QuickDraw GX LaserWriter driver doesn't contain a 'PDEF' 10 resource,<br>
so applications that rely on this approach must be modified to work with QuickDraw<br>
GX.
</p>
<p>
<b>&nbsp;Developers were warned </b>about the disappearance of the 'PDEF' 10 resource in<br>
"Print Hints: Looking Ahead to QuickDraw GX" in <i>develop</i>&nbsp;&nbsp;Issue 13.*
</p>
<p>
If your application has compatibility problems with QuickDraw GX, you probably<br>
already suspect it.&nbsp;&nbsp;&nbsp;You're a candidate for such problems if you're perpetrating any of<br>
the "printing crimes" or shaky methods that Apple has warned about in the past.<br>
Sweaty palms and pangs of guilt whenever your application is tested under new system<br>
software are likely indications that you should get out your development tools and<br>
reform your code now. (If you need the old code to run on non-QuickDraw GX systems,<br>
simply provide alternative code for running with QuickDraw GX.) Delve into the<br>
QuickDraw GX API -- you're sure to find a better way of doing things. 
</p>
<h2>SOME FUNDAMENTALS</h2>
<p>
Before we go into the specifics of how to add QuickDraw GX printing to your existing<br>
applications, we need to cover some fundamental ideas. I'll start with a discussion of<br>
the Collection Manager, which makes its debut with QuickDraw GX, and then briefly<br>
cover overriding messages and the Message Manager. 
</p>
<p>
<b>&nbsp;For a review of QuickDraw GX printing, </b> see "Getting Started With QuickDraw<br>
GX" and "Developing QuickDraw GX Printing Extensions," both in <i>develop</i>&nbsp;&nbsp;Issue 15.<br>
See also <i> Inside Macintosh: QuickDraw GX Printing.</i> *
</p>
<p>
<b>CREATING A FOUNDATION TO BUILD ON: THE COLLECTION MANAGER</b><br>
The Collection Manager is somewhat like a memory-based version of the Resource<br>
Manager. It provides API calls that allow you to create and access<i>collections,</i> which are<br>
amorphous structures that can contain data of different types with different sizes.<br>
Collections are similar to resource files under the Resource Manager except that<br>
collections must be in memory, while resource files are by definition disk based.<br>
Routines exist for "flattening" collections into a series of bytes that can be written to<br>
disk and for "unflattening" them for later use. 
</p>
<p>
Just as a resource file may contain Apple-defined data structures such as 'WIND' and<br>
'MENU' resources, a collection may contain predefined collection items such as 'copy'<br>
and 'rang', which specify the number of copies of a print job and the page range of a<br>
print job, respectively. Like resources, collection items have attributes that are<br>
predefined (for example, the collectionLockMask attribute), but unlike resources,<br>
they also have attributes that can be programmer defined. And, as with resources, you<br>
aren't simply stuck with the core set that's been defined by Apple. Figure 2 illustrates<br>
the similarities, including a programmer-defined resource of type 'USER' and a<br>
programmer-defined collection item, also of type 'USER'. 
</p>
<p>
<img src="img/221.gif" width="600 px"></img>
</p>
<p>
<b>Figure 2. </b>Similarities between resources and collection items
</p>
<p class="spacer">&nbsp;</p>
<p>
Items in a collection are uniquely identified in three different ways. Every item has a<br>
4-character label, or<i>tag</i> , which identifies the type of collection item. In Figure 2,<br>
there are three collection items having the tags 'USER', 'copy', and 'rang',<br>
respectively. In addition to the tag, every collection item has a longword ID. Together,<br>
the tag and ID are one way to uniquely identify a collection item.&nbsp;&nbsp;&nbsp;Each collection item<br>
can be also be referenced by its collection<i>index</i> or by its tag and<i>tag list position.&nbsp;&nbsp;</i>&nbsp;&nbsp;The<br>
index is the relative position of an item in a collection, and the tag list position is the<br>
relative position of a collection item within the item's tag type -- for example, the<br>
first, second, or third 'USER' item in a collection. This gives us three ways to refer to<br>
a specific collection item:
</p>
<ul>
<li>by its tag and ID</li>
<li>by its collection index</li>
<li>by its tag and tag list position</li>
</ul>
<p>
It's important to note that although a collection item's index and tag list position may<br>
change as items are added or removed from a collection, an item's tag and ID will never<br>
change. Therefore, the most common way to refer to collection items is by tag and ID.
</p>
<p>
<b>&nbsp;Collection tag and resource type naming </b>conventions are the same. Apple<br>
reserves tags listed in the printing interface files, as well as those consisting entirely<br>
of lowercase letters. *
</p>
<p>
You can either create a collection with the NewCollection routine or use one of the<br>
three types of collections that QuickDraw GX automatically creates for you during<br>
printing. These types are job collections, format collections, and paper-type<br>
collections. Every time a new gxJob, gxFormat, or gxPaperType object is created, a<br>
collection is also created for that object. These collections contain items specifying the<br>
following types of information:
</p>
<ul>
<li>job collection: number of copies, page range, destination file information<br>
(if printing to a file)</li>
<li>format collection: scaling factor, page orientation, page flipping<br>
information</li>
<li>paper-type collection: paper-type creator, paper-type comment</li>
</ul>
<p>
These predefined collections contain many more collection items than are shown here.<br>
See the QuickDraw GX interface file PrintingManager.h for the complete listing. By<br>
simply changing the contents of the collection items, any application, printing<br>
extension, or printer driver can easily affect how a document will be printed. 
</p>
<p>
<b>&nbsp;Note that all predefined collection items </b>have the ID gxPrintingTagID =<br>
-28672. *
</p>
<p>
Your application can create and use collections for its own purposes. By no means are<br>
you restricted to using collections only within the QuickDraw GX printing<br>
architecture, although that's probably where you'll use them the most. 
</p>
<p>
<b>OVERRIDING MESSAGES FROM AN APPLICATION: THE MESSAGE MANAGER</b><br>
Sam Weiss's article in<i>develop</i> Issue 15, "Developing QuickDraw GX Printing<br>
Extensions," introduced the Message Manager. The QuickDraw GX printing architecture<br>
uses the Message Manager to invoke printing operations, and your application,<br>
printing extension, or printer driver can override messages to change printing<br>
behavior. This process is explained in Sam's article, which is a good reference for<br>
anyone unfamiliar with the Message Manager and how QuickDraw GX uses it.&nbsp;&nbsp;&nbsp;This<br>
article assumes that you already have at least a passing familiarity with the basic<br>
concepts.
</p>
<p>
When you override a message from an application, you're more restricted in what you<br>
can do than if you override a message from a printing extension or printer driver. To<br>
understand why, consider a case where you want to override the QuickDraw GX<br>
printing message GXDespoolPage to add a serial number to the page before it's printed.<br>
You can add this override to a printing extension in a straightforward way that works<br>
regardless of which application prints the document. If, on the other hand, the<br>
override is attempted by an application, the situation becomes more problematic. The<br>
override won't be invoked because it's a despooling-phase message; only<br>
application-phase and spooling-phase messages can be overridden by applications. 
</p>
<p>
To understand a second limitation of application overrides, let's look at how they're<br>
installed in the message handler chain. This is done by passing the routine<br>
GXInstallApplicationOverride a pointer to the override procedure and a reference to<br>
the document's job, like so:
</p>
<pre>GXInstallApplicationOverride(docJob, gxJobPrintDialog,
    MyJobPrintDialogOverride);</pre>
<p>
In this example, the application is overriding the GXJobPrintDialog message with an<br>
override function called MyJobPrintDialogOverride. docJob is the gxJob object for a<br>
document. Because your application has access only to its own gxJob objects, an<br>
application override can be invoked only for the application that installed it. On the<br>
other hand, a message override from a printing extension can affect every document<br>
that's printed, regardless of which application printed it.
</p>
<p>
In summary:
</p>
<ul>
<li> Application overrides are reliable only during the application and<br>
spooling phases of printing, which end once the document has been spooled to a<br>
print file. You should attempt to override only application-phase and<br>
spooling-phase messages from an application. </li>
<li> Application overrides are invoked only for the application installing the<br>
override, and only for the gxJob objects in which the overrides are installed. </li>
</ul>
<p>
Application overrides are best suited for adding features to the printing dialogs and<br>
modifying the print file as a document is being spooled. If you feel limited by either of<br>
the conditions mentioned above, you should move your override out of your application<br>
and into a printing extension. 
</p>
<h2>BECOMING AWARE</h2>
<p>
Now let's look at what an application developer needs to do to support QuickDraw GX<br>
printing.&nbsp;&nbsp;&nbsp;We'll take a QuickDraw application called Simple Sample and convert it into<br>
its QuickDraw GX-aware counterpart, Simple Sample GX. The code for both samples is<br>
on this issue's CD. 
</p>
<p>
The Simple Sample application draws using various QuickDraw commands, including<br>
those for simple objects, bitmaps, and PicComments. It can handle multiple documents<br>
with multiple pages, and although it knows nothing about QuickDraw GX, it is System 7<br>
dependent (I made it that way to save on code and confusion). 
</p>
<p>
Here's a summary of what most QuickDraw GX-aware applications need to do:
</p>
<ul>
<li>Determine whether QuickDraw GX is present, and if so, initialize the<br>
QuickDraw GX managers (and close them down when the application quits). </li>
<li>Create a gxJob object for each document created and dispose of the gxJob<br>
when the document is closed.</li>
<li>Override the GXPrintingEvent message (in order to support the<br>
QuickDraw GX movable modal printing dialogs) while printing dialogs are<br>
displayed. </li>
<li>Update gxJob objects on resume events (in case the characteristics of the<br>
desktop printer you're printing to have changed). </li>
<li>Save and load a document's gxJob object to and from disk and convert print<br>
records to gxJob objects when loading documents created from pre-QuickDraw<br>
GX versions of your application. </li>
<li>Make the Custom Page Setup and Print One Copy menu items available in<br>
the File menu.</li>
<li>Invoke the QuickDraw GX printing dialogs and support custom formatting<br>
by page (each page can have a unique page format, or can share another page's<br>
format). </li>
<li>Store page-to-format correspondences to disk with a document (and load<br>
them again when the document is opened). </li>
<li>Have a print loop that uses QuickDraw GX printing commands and<br>
translates QuickDraw commands to QuickDraw GX shapes for printing. </li>
<li>Implement the Print One Copy feature. </li>
<li>Support the new attribute of the 'pdoc' Apple event to properly support<br>
drag-and- drop printing of documents from the Finder. </li>
</ul>
<p>
Each of these is discussed in order in the rest of this article. 
</p>
<p>
<b>PREPARATION</b><br>
Before you can do anything with QuickDraw GX, you need to determine whether it's<br>
available. You should do this in your initialize routine, after you've determined that<br>
the other managers yourapplication requires are available. The MyInitGXIfPresent<br>
routine in Listing 1 shows one way of doing this. 
</p>
<p>
<b>Listing 1. </b>QuickDraw GX preparation and cleanup
</p>
<pre>void MyInitGXIfPresent()
{
    long            gxVersion, gxPrintVersion;

    gGXIsPresent = false;
    /* Check to see whether QuickDraw GX is available. */
    if (Gestalt(gestaltGXVersion, &amp;gxVersion) == noErr)
        if (Gestalt(gestaltGXPrintingMgrVersion, &amp;gxPrintVersion)
                        == noErr)
            gGXIsPresent = true;
    /* If so, initialize QuickDraw GX. */
    if (gGXIsPresent) {
        gClient = GXNewGraphicsClient(nil, kGraphicsHeapSize,
                        (gxClientAttribute) 0);
        GXEnterGraphics();
        GXInitPrinting();
    }
}

void MyCleanUpGXIfPresent()
{
    if (gGXIsPresent) {
        GXExitPrinting();
        GXDisposeGraphicsClient(gClient);
        GXExitGraphics();
    }
}</pre>
<p>
In MyInitGXIfPresent, we use Gestalt to determine whether the QuickDraw GX graphics<br>
and printing routines are present. If so, we call GXNewGraphicsClient to set aside<br>
memory for QuickDraw GX graphics operations, and we call GXEnterGraphics and<br>
GXInitPrinting to enable the QuickDraw GX functions we'll use. Note that we also set a<br>
global variable, gGXIsPresent, which indicates whether the QuickDraw GX managers<br>
we require are present. We'll check this value whenever we need to make a decision<br>
about whether to use QuickDraw or QuickDraw GX methods. 
</p>
<p>
<i>Important:</i>&nbsp;&nbsp;You cannot intermix Printing Manager and QuickDraw GX printing calls.<br>
Do not call _PrGlue[A8FD] if you have called _InitPrinting. 
</p>
<p>
When the user quits the application, we need to release any memory we allocated and<br>
close down QuickDraw GX printing and graphics. We do this as shown in the<br>
MyCleanUpGXIfPresent routine in Listing 1. 
</p>
<p>
<b>CREATING AND DISPOSING OF GXJOB OBJECTS</b><br>
With the MyInitGXIfPresent and MyCleanUpGXIfPresent routines added to our code,<br>
we're now ready to make our application's documents fit into the QuickDraw GX print<br>
model. We do this by creating a gxJob object whenever we create a document. Our<br>
non-QuickDraw GX application, Simple Sample, contains a routine named<br>
MyCreateDocument that's called whenever the user creates a document. As shown in the<br>
Simple Sample GX application, this routine is modified so that when QuickDraw GX is<br>
present (as indicated by the gGXIsPresent global variable), the application creates a<br>
gxJob for each document, using the GXNewJob routine. If QuickDraw GX is not present,<br>
the application creates a print record handle (THPrint) instead. It's common for an<br>
application to store descriptive information about a document in a private data<br>
structure, and our sample is no exception. The application uses a private structure<br>
called MyDocumentRec that contains information about the number of pages in a<br>
document, the current page being viewed, and so forth. We modify this structure also,<br>
so that we can store a document's job reference and page formatting information with<br>
the document. As seen in Listing 2, we've added the documentJob and pageFormat fields<br>
to the structure. The rest of the fields in this structure were already being managed by<br>
the QuickDraw GX-unaware application, and we'll continue to use them. 
</p>
<p>
<b>Listing 2. </b>MyDocumentRec, modified for QuickDraw GX
</p>
<pre>#define kMaxPages   20            /* Max pages the sample handles. */
typedef struct MyDocumentRec {
    THPrint     documentPrintHdl;  /* Print record for document. */
    gxJob       documentJob;       /* Job for document. */
    gxFormat    pageFormat[kMaxPages];    /* Format for each page. */
                                 /* If nil, we use the job format. */
    long        numPages;          /* Number of pages in document. */
    long        curPage;           /* The current page displayed. */
    FSSpec      documentFSSpec;    /* Document's file spec. */
    Str31       documentTitle;     /* The title of this document. */
    WindowPtr   documentWindow;    /* The window for this document.*/
} MyDocumentRec, *MyDocumentPtr;</pre>
<p>
We also need to modify the application's MyDisposeDocument routine, which is called<br>
whenever a document is closed. In the modified routine, we dispose of the document's<br>
gxJob.
</p>
<p>
The changes that we've made so far are indicative of the approach we'll continue to use<br>
as we make our sample QuickDraw GX aware: adding code that executes only if<br>
QuickDraw GX is present. If the user isn't running QuickDraw GX, our converted<br>
sample will appear and function as the original did.&nbsp;&nbsp;&nbsp;But if QuickDraw GX is present,<br>
all the new functionality will kick in. 
</p>
<p>
<b>OVERRIDING GXPRINTINGEVENT</b><br>
When we added support for gxJobs in the MyCreateDocument routine, we also added the<br>
following line of code:
</p>
<pre>GXInstallApplicationOverride((*createdDocument)-&gt;documentJob,
    gxPrintingEvent, MyPrintingEventOverride);</pre>
<p>
Every application that aspires to be QuickDraw GX aware should include such a line.<br>
Remember, QuickDraw GX has movable modal printing dialogs; the GXPrintingEvent<br>
message is sent whenever a dialog is moved. Unless you override GXPrintingEvent, you<br>
won't have a chance to update your application's windows when the dialogs are moved. 
</p>
<p>
The code to support window updates when the printing dialogs are moved is actually<br>
quite simple.&nbsp;&nbsp;&nbsp;You just need to add a routine that overrides the GXPrintingEvent<br>
message and calls your event- handling routine (Listing 3), and to make sure that<br>
you've disabled the appropriate menu items before displaying the new printing dialogs.<br>
Note that your override should not forward the GXPrintingEvent message, but instead<br>
should perform a total override of it. 
</p>
<p>
<b>Listing 3. </b>MyPrintingEventOverride
</p>
<pre>OSErr MyPrintingEventOverride(EventRecord *anEvent,
    Boolean filterEvent)
{
    /*  Handle events in whatever way is appropriate. MyDoEvent is
        our generic event handler. We don't pass it events that it
        shouldn't handle while printing dialogs are displayed. */
    if (!filterEvent)
        switch (anEvent-&gt;what) {
            case mouseDown:
            case keyDown:
            case autoKey:
                break;
            default:
                MyDoEvent(anEvent);
        }
    return noErr;
}</pre>
<p>
<b>UPDATING GXJOB OBJECTS ON RESUME EVENTS</b><br>
There's another piece of event-handling code that every QuickDraw GX-aware<br>
application should include. To support the reentrant nature of QuickDraw GX, you must<br>
call GXUpdateJob on each gxJob that your application is using whenever you receive a<br>
resume event. (See the code for Simple Sample GX on the CD.) This enables QuickDraw<br>
GX to update the information in the gxJob in case it changed while your application was<br>
in the background. As an example, suppose that a user suspends your application to<br>
change the printing extension setup for the destination desktop printer. Upon<br>
switching back to your application, this user will expect anyopen documents to use<br>
these new settings at print time. Unless you call GXUpdateJobon your gxJob objects,<br>
the new settings won't be there.
</p>
<p>
<b>SAVING AND LOADING A DOCUMENT'S GXJOB</b><br>
Now that we can create gxJob objects for new documents, let's take a look at how we<br>
can save these to disk and later retrieve them when the documents are opened. We want<br>
to save them for the same reason that we want to store print records with documents<br>
under non-QuickDraw GX systems: if a user has gone to the trouble of configuring<br>
print settings for a document, the user-friendly thing to do is to use those settings the<br>
next time the document is opened. 
</p>
<p>
Because the data we want to save is stored in an abstract data structure (gxJob), we<br>
need a way to convert it to a more tangible form. We accomplish this with the<br>
GXFlattenJob or GXFlattenJobToHdl routine. GXFlattenJob passes the converted data as<br>
a stream of bytes, whereas GXFlattenJobToHdl places the flattened data in a handle. You<br>
would typically use GXFlattenJob to store the flattened gxJob in a data fork, but<br>
GXFlattenJobToHdl to save it as a resource. 
</p>
<p>
Since our application stores its print records in resources, we'll store its flattened<br>
gxJob objects in resources as well. To do this, we modify our application's<br>
MySavePrintInfo routine, which is called to save print records to disk. If QuickDraw<br>
GX is present, the routine will instead save our flattened gxJob. 
</p>
<p>
In the following code, we flatten a gxJob into a handle called thePrintData, which can<br>
then be written to the disk as a resource. 
</p>
<pre>thePrintData = NewHandle(0);
GXFlattenJobToHdl(whichDocument-&gt;documentJob, thePrintData);</pre>
<p>
Next, we modify the application's MyLoadPrintInfo routine, which is used to retrieve<br>
print records that were previously saved with MySavePrintInfo. This routine must do<br>
several things, based on whether QuickDraw GX is present and whether a gxJob or<br>
print record has been previously stored with a document. The flow of control is shown<br>
in Listing 4. 
</p>
<p>
As it turns out, some of the steps in Listing 4 can be combined. For example,<br>
regardless of whether QuickDraw GX is present, we may need to retrieve a previously<br>
saved print record. What?!&nbsp;&nbsp;&nbsp;Accessing old-style print records when QuickDraw GX is<br>
present? Sounds strange, doesn't it? We need to do this if QuickDraw GX is available<br>
and the user opens a document that contains a print record but not a gxJob (because it<br>
was created with an older version of the application). We convert the print record to a<br>
gxJob with the GXConvertPrintRecord routine, so that the gxJob has as many of the old<br>
print record's settings as possible.
</p>
<p>
<b>Listing 4. </b>MyLoadPrintInfo flow of control
</p>
<pre>if (gGXIsPresent) {
    if <i>there&#8217;s a previously saved gxJob</i>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unflatten it and use it</i>
    else
        if <i>there's a previously saved print record</i>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;convert that to a gxJob and use it</i>
        else
            <i>use the default gxJob we created in MyCreateDocument</i>
}
else {
    if <i>there's a previously saved print record</i>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use it</i>
    else
        <i>use the default print record we created in MyCreateDocument</i>
}</pre>
<p>
<b>CONFIGURING AND HANDLING MENUS</b><br>
We need to alter our menu routines so that the Custom Page Setup and Print One Copy<br>
commands are available to QuickDraw GX users. We might decide to have two different<br>
File menus, the installation of which would depend on whether QuickDraw GX is<br>
present. Or we might have only one File menu and add or subtract items from it when<br>
it's installed in the menu bar. The approach that's best for a particular application<br>
depends on how the application is structured. (The same choice of approaches applies<br>
to other menus that might need to be modified based on whether QuickDraw GX is<br>
available.)
</p>
<p>
In the sample code, we modify the File menu as follows: the application contains a<br>
'MENU' resource for the QuickDraw GX version of the File menu; if gGXIsPresent is<br>
false, we remove the Print One Copy and Custom Page Setup menu items from this<br>
menu. 
</p>
<pre>fileMenu = GetMHandle(mFile);
DelMenuItem(fileMenu, iPrintOneCopy);
DelMenuItem(fileMenu, iCustomPageSetup);</pre>
<p>
The order of the deletions is very important! If we deleted in the reverse order, the<br>
Custom Page Setup menu item would be deleted, but when we tried to delete Print One<br>
Copy, we would actually delete whatever came<i>after</i> Print One Copy. Why? Because the<br>
menu would be one item shorter, and the index into it would no longer be valid. Just<br>
delete menu items from bottom to top and you'll be fine. 
</p>
<p>
Monkeying around with the placement (and inclusion) of menu items like this will<br>
throw our menu- enabling and menu-selection routines out of whack. We need to make<br>
sure that regardless of whether the Print command is item number 8 or 9 in the<br>
menu, we still treat it as a Print command. Again, the approach to use will depend on<br>
the application. 
</p>
<p>
It's conceivable that you would use macros and would make the same changes to both the<br>
menu- enabling and menu-selection routines, but in the sample I chose to tackle menu<br>
enabling and disabling differently than I did menu handling. For the simple enabling<br>
and disabling of menus in the MyAdjustMenus routine, I check to see whether<br>
QuickDraw GX is present and adjust the item numbers based on that. This is the easiest<br>
approach because it requires only minor changes to the routine. 
</p>
<p>
The menu selection situation is a little different. Typically, applications contain a<br>
routine that uses a switch statement based on the ID of the menu and menu items<br>
chosen. This means that we'd need either two such routines (one for QuickDraw and one<br>
for QuickDraw GX) or a different approach from what we used in MyAdjustMenus. I<br>
opted for a different approach.&nbsp;&nbsp;The sample application's MyDoMenuCommand routine<br>
uses a switch statement (as most applications do) based on the menu ID and menu item<br>
extracted from the result of the MenuSelect and MenuKey routines. When QuickDraw<br>
GX is not present, the Quit menu item will be item 10 in the File menu; otherwise, it<br>
will be at item 12 (see Figure 3). The switch statement in the MyDoMenuCommand<br>
function compares the menu item selected to the items in the QuickDraw GX version of<br>
our File menu. Therefore, it will expect that item 12 will be Quit. Item 10 will be<br>
interpreted as Print One Copy! This would be disastrous -- the application would not<br>
quit, and our QuickDraw GX-specific code would be executed when QuickDraw GX<br>
wasn't around! That's not likely to be a pleasant user experience. 
</p>
<p>
<img src="img/222.gif" width="225 px"></img>
</p>
<p>
<img src="img/223.gif" width="275 px"></img>
</p>
<p>
<b>&nbsp;Figure 3. </b>The File menu without QuickDraw GX and with QuickDraw GX
</p>
<p>
A new routine, MyConvertMenuItem, solves this problem (Listing 5). This routine is<br>
called just before we enter the switch statement in MyDoMenuCommand. If QuickDraw<br>
GX is present, MyConvertMenuItem does nothing; otherwise, it checks to see if the<br>
menu item selected was affected by our deletion of the QuickDraw GX menu items, and<br>
if so adjusts it. How's that for an easy solution? 
</p>
<p>
<b>Listing 5. </b>MyConvertMenuItem
</p>
<pre>void MyConvertMenuItem(short *menuID, short *menuItem)
{
    if (!gGXIsPresent) {
        if (*menuItem == iCustomPageSetup)
            *menuItem = iPrint;             /* Print was selected. */
        else
            if (*menuItem == iPrintOneCopy)
                *menuItem = iQuit;          /* Quit was selected. */
    }
}</pre>
<p>
<b>INVOKING THE PRINTING DIALOGS AND SUPPORTING CUSTOM</b><br>
<b>FORMATTING</b><br>
Earlier, we added code to our application to support window updates when the printing<br>
dialogs are displayed. Now, let's discuss the code required to actually display the<br>
dialogs. 
</p>
<p>
There are now three printing dialogs instead of two (as shown earlier in Figure 1).<br>
The Page Setup dialog now allows users to modify a document's default page format. The<br>
new dialog, Custom Page Setup, provides a way to change page formatting on a<br>
page-by-page basis. If your application creates documents that can have only a single<br>
page, implementing the Custom Page Setup dialog isn'tnecessary; the Page Setup dialog<br>
can be used to configure the document's only page format. The Print dialog is similar to<br>
its non-QuickDraw GX counterpart, although much enhanced.
</p>
<p>
We use GXJobDefaultFormatDialog, GXFormatDialog, and GXJobPrintDialog to display<br>
the Page Setup, Custom Page Setup, and Print dialogs, respectively.
</p>
<p>
We modify our MyDoPageSetup routine to call GXJobDefaultFormatDialog instead of<br>
PrStlDialog when QuickDraw GX is present. In our MyDoCustomPageSetup routine,<br>
which is called only when QuickDraw GX is available, we simply call GXFormatDialog,<br>
passing the current page's gxFormat. 
</p>
<p>
In both of these page setup routines, and in the code for MyPrintDocument that follows,<br>
we call a function named MyAdjustMenusForPrintDialogs, which disables and enables<br>
entire menus (Listing 6). We disable menus before displaying a printing dialog, and<br>
enable them once the dialog goes away.&nbsp;&nbsp;&nbsp;If we didn't disable the menus, users would be<br>
able to select menu items. And, because the GXPrintingEvent override calls our<br>
MyDoEvent routine, any queued-up menu selections would be processed when the<br>
GXPrintingEvent message was sent. The user could be in the Print dialog, then select<br>
Quit from the File menu, and the next time the window was updated, the application<br>
would quit! The only menus a user should have access to are the Edit menu and the<br>
system menus. (Users can open desk accessories from the Apple menu, for example,<br>
while a printing dialog is displayed -- but they should not be able to open the About<br>
item for the application.)
</p>
<p>
<b>Listing 6. </b>MyAdjustMenusForPrintDialogs
</p>
<pre>void MyAdjustMenusForPrintDialogs(Boolean dialogGoingUp)
{
    MenuHandle  appleMenu, fileMenu, editMenu, documentMenu;

    appleMenu = GetMHandle(mApple);
    fileMenu = GetMHandle(mFile);
    editMenu = GetMHandle(mEdit);
    documentMenu = GetMHandle(mDocument);
    if (dialogGoingUp) {
        DisableItem(appleMenu, iAbout);
        DisableItem(fileMenu, 0);
        DisableItem(documentMenu, 0);
        HiliteMenu(0);
    }
    else {
        EnableItem(appleMenu, iAbout);
        EnableItem(fileMenu, 0);
        DisableItem(editMenu, 0);
        EnableItem(documentMenu, 0);
    }
    DrawMenuBar();
    gInPrintDialog = dialogGoingUp;
}</pre>
<p>
<b>&nbsp;The system enables some menus, </b>namely the Help menu, the Application menu,<br>
and the Keyboard menu, even when dialogs are displayed. Your code doesn't need to deal<br>
with them. *
</p>
<p>
The MyPrintDocument routine (Listing 7) displays the appropriate Print dialog and<br>
then branches to our QuickDraw or QuickDraw GX printing routine. Note that we've<br>
been careful to call PrOpen and PrClose only when QuickDraw GX is not present. As<br>
mentioned earlier, you cannot intermix Printing Manager and QuickDraw GX printing<br>
calls. 
</p>
<p>
<b>Listing 7. </b>MyPrintDocument
</p>
<pre>OSErr MyPrintDocument(MyDocumentPtr whichDocument)
{
    OSErr                   err = noErr;
    gxEditMenuRecord    editMenuRec;
    gxDialogResult      result;

    if (gGXIsPresent) {
        /* If GX is present, fill in the location of the
            applications Edit menu items, enable/disable the
            appropriate menu items, and display the Print dialog.
            If the user clicks OK, print. */
        editMenuRec.editMenuID  = mEdit;
        editMenuRec.cutItem     = iCut;
        editMenuRec.copyItem        = iCopy;
        editMenuRec.pasteItem   = iPaste;
        editMenuRec.clearItem   = iClear;
        editMenuRec.undoItem        = iUndo;
        MyAdjustMenusForPrintDialogs(true);
        result = GXJobPrintDialog(whichDocument-&gt;documentJob,
                            &amp;editMenuRec);
        MyAdjustMenusForPrintDialogs(false);
        if (result == gxOKSelected)
            err = MyGXPrintLoop(whichDocument);
    }
    else {
        /* If GX is NOT present, open the printer driver and print
            using the Printing Manager. */
        PrOpen();
        if (PrJobDialog(whichDocument-&gt;documentPrintHdl))
            err = MyQDPrintLoop(whichDocument);
        PrClose();
    }
    return err;
}</pre>
<p class="spacer">&nbsp;</p>
<p>
We've made a few other changes behind the scenes; see the complete code on the CD for<br>
details. The code for repaginating a document has been changed slightly to use the<br>
dimensions of QuickDraw GX page formats, if available, rather than those in the rPage<br>
field of the old print record. We also made minor changes to our MyInsertPage and<br>
MyDisposePage routines in order to manage gxFormats on a page-by-page basis. In the<br>
Simple Sample GX application, we store nil in our MyDocumentRec.pageFormat array<br>
whenever a new page is created. Because nil is an invalid gxFormat reference, we can<br>
use it to tell the application to use our gxJob object's default format for a given page. If<br>
the value stored is non-nil, we can safely assume that it's a valid reference to a custom<br>
page format. Finally, in our MyDisposePage routine, we now call GXDisposeFormat if<br>
the page being removed uses a custom page format. 
</p>
<p>
Since we store gxFormat references on a page-by-page basis, shouldn't we also dispose<br>
of page formats in the MyDisposeDocument routine? Well, we certainly can do that,<br>
but there's really no need. When we dispose of the document's gxJob, QuickDraw GX<br>
automatically disposes of all of the job's page formats. The flip side of this is that you<br>
must not attempt to use any gxFormat references once the format's corresponding job<br>
is disposed of.
</p>
<p>
Continuing with this line of thought, what happens to a document's page formats when<br>
the document is saved to disk and later reopened? As it turns out, flattening a gxJob<br>
causes all of the job's page formats to be flattened also. This means that the code we<br>
wrote earlier to flatten and store a document's gxJob in a resource will also store page<br>
formats. When we later unflatten the job, the page formats will be unflattened as well.
</p>
<p>
<b>STORING THE PAGE-TO-FORMAT CORRESPONDENCES</b><br>
It's easy to fall into the trap of thinking that you don't need to do anything more to<br>
support saving and loading of by-page formats -- but don't. There are still two more<br>
issues to consider. 
</p>
<p>
The first issue is straightforward enough: we haven't stored our page-to-format<br>
correspondences, so the next time we open the document we'll have no idea which<br>
format goes with which page. The second issue requires a bit more explaining. 
</p>
<p>
When QuickDraw GX creates a page format, it returns a format reference that's based<br>
partially on the reference of the job with which the format is associated. Since<br>
reference IDs for gxJob objects differ depending on conditions when the job is created,<br>
a job reference that's valid when a document is saved is unlikely to be correct when<br>
the document is later reopened. Similarly, the format references we have when a<br>
document is saved are unlikely to be correct when the document's job is later<br>
unflattened. 
</p>
<p>
It should now be clear that we can't simply store our page format reference IDs with a<br>
document. To provide the page-to-format information we'll need when we open the<br>
document, we have to find another method. Fortunately, there's a very easy way to do<br>
this via the Collection Manager. 
</p>
<p>
As mentioned earlier, every gxFormat has a collection associated with it. QuickDraw<br>
GX creates these collections automatically when a gxFormat is created. When a format<br>
is flattened, its collection is also flattened. Specifically, any collection items that have<br>
the collectionPersistenceBit attribute set are included in the flattened data stream.<br>
This attribute is set by default when a new collection item is added, so you need to<br>
change it only if you<i>don't</i> want a collection item to be included in the flattened data.
</p>
<p>
To store page-to-format mapping, we'll create a custom collection item. We'll store<br>
this collection item in the default format's format collection. The collection item<br>
consists of an array of long words -- one for each page in the document. In this array,<br>
we store the index of the format to use for each page, in order. Since format<i>indices</i> are<br>
preserved during flattening (unlike format<i>references</i> ), we'll be able to reconstruct<br>
the page-to-format relationships when we reopen the document. The<br>
MySaveFormatRefs routine (Listing 8) saves the format indices. This routine is called<br>
from our MySavePrintInfo routine, just before we flatten the document's gxJob (and<br>
in turn its page formats and format collections).
</p>
<p>
<b>Listing 8. </b>MySaveFormatRefs
</p>
<pre>#define kMyFormatInfoType       'FLST'
#define kMyFormatInfoTagID      1000
OSErr MySaveFormatRefs(MyDocumentPtr whichDocument)
{
    OSErr               err = noErr;
    Handle              theFormatIdxList;
    Collection          fmtCollection;
    gxFormat            defaultFmt;

    if (whichDocument-&gt;numPages &gt; 0) {
        /* Get the job's default format's collection. */
        defaultFmt = GXGetJobFormat(whichDocument-&gt;documentJob, 1);
        fmtCollection = GXGetFormatCollection(defaultFmt);
        /* Create a list of page-to-format correspondences for the
            current document. If there are no errors, add the item
            to the job's default format's collection for later
            retrieval. */
        err = MyCreateFormatIndexList(whichDocument,
            &amp;theFormatIdxList);
        if (err == noErr) {
            HLock(theFormatIdxList);
            err = AddCollectionItem(fmtCollection, kMyFormatInfoType,
                kMyFormatInfoTagID, GetHandleSize(theFormatIdxList),
               *theFormatIdxList);
            DisposeHandle(theFormatIdxList);
        }
    }
    return err;
}</pre>
<p>
Our saved documents now contain information for associating pages with page formats.<br>
The MyAdjustFormats routine (Listing 9) extracts this information from the default<br>
format's format collection when we load the saved document. In effect, the code finds<br>
new format reference IDs for each format we flattened and stores those IDs with the<br>
pages that use them. In this way, we completely avoid relying on the old (and invalid)<br>
format references. 
</p>
<p>
<b>Listing 9. </b>MyAdjustFormats
</p>
<pre>OSErr MyAdjustFormats(MyDocumentPtr whichDocument)
{
    OSErr           err = noErr;
    Handle          theFormatIdxList = nil;
    gxFormat        theFormat, defaultFmt;
    long            pg, numPages, fmtIdx, *idxList, idx, listSize,
                    attribs;
    Collection      fmtCollection;
   
    defaultFmt = GXGetJobFormat(whichDocument-&gt;documentJob, 1);
    fmtCollection = GXGetFormatCollection(defaultFmt);
    err = GetCollectionItemInfo(fmtCollection, kMyFormatInfoType,
         kMyFormatInfoTagID, &amp;idx, &amp;listSize, &amp;attribs);
    if (err == noErr)
        theFormatIdxList = NewHandle(listSize);
    if (theFormatIdxList != nil) {
        HLock(theFormatIdxList);
        err = GetCollectionItem(fmtCollection, kMyFormatInfoType,
            kMyFormatInfoTagID, dontWantSize, *theFormatIdxList);
        numPages = listSize / sizeof(long);
        idxList = (long *) *theFormatIdxList;
        for (pg = 0; (err == noErr) &amp;&amp; (pg &lt; numPages); pg++) {
            fmtIdx = idxList[pg];
            if (fmtIdx != (long) nil) {
                theFormat = GXGetJobFormat
                    (whichDocument-&gt;documentJob, fmtIdx);
                err = GXGetJobError(whichDocument-&gt;documentJob);
            }
            else
                theFormat = nil;
            if  (err == noErr)
                whichDocument-&gt;pageFormat[pg] = theFormat;
        }
        DisposeHandle(theFormatIdxList);
    }
    return err;
}</pre>
<p>
<b>TRANSLATING AND PRINTING QUICKDRAW COMMANDS</b><br>
At long last, we're ready to look at the code that translates our QuickDraw commands to<br>
QuickDraw GX shapes and prints them. To do the translation, we'll use the QuickDraw<br>
GX translator routines. We specify how we would like the translation to be performed<br>
by passing one of the gxTranslationOptions to the translator routines. (The routines<br>
and translation options are listed in<i>Inside Macintosh: QuickDraw GX Environment and</i><br>
<i>Utilities.&nbsp;&nbsp;</i> ) Normally, the default translation options are all you need, and those are<br>
what we use in Simple Sample GX. 
</p>
<p>
The translation routines come in two varieties -- those that take a single QuickDraw<br>
PicHandle and convert it to a QuickDraw GX picture shape, and those that let you<br>
execute QuickDraw commands and create equivalent QuickDraw GX shapes as you do so.<br>
Converting a PicHandle to a gxPicture shape is straightforward; therefore, we're going<br>
to take the second approach. Most applications don't print by simply making a<br>
QuickDraw DrawPicture call, so understanding how to convert individual QuickDraw<br>
commands to QuickDraw GX shapes "on the fly" is probably more useful. If your needs<br>
are different, you can use the GXConvertPICTToShape routine to convert a PicHandle<br>
into a gxPicture shape. 
</p>
<p>
The routines we'll use are GXInstallQDTranslator and GXRemoveQDTranslator.&nbsp;&nbsp;<br>
GXInstallQDTranslator tells QuickDraw GX to begin translating QuickDraw commands<br>
into QuickDraw GX shapes, and GXRemoveQDTranslator tells QuickDraw GX that we've<br>
completed drawing. These routines are used in conjunction with a third routine, called<br>
a gxSpoolProc, which you create. Your gxSpoolProc routine will have the following<br>
format and will be called whenever QuickDraw GX completes a new shape during the<br>
translation:
</p>
<pre>OSErr MyShapeSpoolProc(gxShape currentShape, long refCon);</pre>
<p>
The currentShape parameter contains the QuickDraw GX shape that the translator just<br>
created, and the refCon parameter is a programmer-defined value that you pass to<br>
GXInstallQDTranslator. You needn't use the refCon parameter (you can pass nil), but<br>
as we'll see in a moment, the refCon can be very handy. 
</p>
<p>
The code in Listing 10 shows the basic QuickDraw GX print loop, with support added to<br>
translate QuickDraw commands into QuickDraw GX shapes.
</p>
<p>
<b>&nbsp;The code in Listing 10 </b>contains nrequire, require, nrequire_action, and<br>
require_action macros, which are discussed in the article "Living in an Exceptional<br>
World" in <i> develop</i>&nbsp;&nbsp;Issue 11. These macros, which don't require QuickDraw GX<br>
themselves, are now included in the QuickDraw GX interface file GXExceptions.h.*
</p>
<p>
<b>Listing 10. </b>MyGXPrintLoop
</p>
<pre>OSErr MyGXPrintLoop(MyDocumentPtr whichDocument)
{
    OSErr                   err;
    long                    firstPage, lastPage, numPages, pg;
    short                   oldPage;
    gxViewPort              printViewPort;
    Point                   patStretch = {1,1};
    gxFormat                pageFormat;
    Rect                    everywhereRect;
    gxShape                 pageShape;
    MySpoolDataRec          spoolData;

    oldPage = whichDocument-&gt;curPage;
    /* Determine which pages the user selected to print, and print
        only those pages that are actually in the document. */
    GXGetJobPageRange(whichDocument-&gt;documentJob, &amp;firstPage,
        &amp;lastPage);
    if (lastPage &gt; whichDocument-&gt;numPages)
        lastPage = whichDocument-&gt;numPages;
    /* Calculate the number of pages to print and begin printing. */
    numPages = lastPage - firstPage + 1;
    err = GXGetJobError(whichDocument-&gt;documentJob);
    nrequire(err, PageRangeError);
    GXStartJob(whichDocument-&gt;documentJob,
        whichDocument-&gt;documentTitle, numPages);
    err = GXGetJobError(whichDocument-&gt;documentJob);
    nrequire(err, StartJobFailed);
    /* Create a new view port for printing and set our translator
        rects to "wide open" so that they include all data
        we're drawing. For each page we print, call GXStartPage,
        draw, and call GXFinishPage. */
    SetRect(&amp;everywhereRect, 0, 0, 32767, 32767);
    printViewPort = GXNewViewPort(gxScreenViewDevices);
    for (pg = firstPage; (err == noErr) &amp;&amp; (pg &lt;= lastPage); pg++)
    {
        /* Get the page's format and start printing the page. */
        pageFormat = whichDocument-&gt;pageFormat[pg - 1];
        if (pageFormat == nil)
            pageFormat = GXGetJobFormat
                (whichDocument-&gt;documentJob, 1);
        GXStartPage(whichDocument-&gt;documentJob, pg, pageFormat, 1,
                &amp;printViewPort);                               
        err = GXGetJobError(whichDocument-&gt;documentJob);
        /* If there were no errors, set up the translator, draw
            the QuickDraw data for current page, and remove the
            translator. */
        nrequire(err, StartPageFailed);
        spoolData.printViewPort = printViewPort;
        GXGetFormatDimensions(pageFormat, &amp;spoolData.pageArea, nil);
        GXInstallQDTranslator(whichDocument-&gt;documentWindow,
            gxDefaultOptionsTranslation, &amp;everywhereRect,
            &amp;everywhereRect, patStretch, MyPrintAShape,
            &amp;spoolData);
        whichDocument-&gt;curPage = pg;
        SetPort(whichDocument-&gt;documentWindow);
        MyDrawContents(whichDocument-&gt;documentWindow);  
        GXRemoveQDTranslator(whichDocument-&gt;documentWindow, nil);
        GXFinishPage(whichDocument-&gt;documentJob);
    }
StartPageFailed:
    GXFinishJob(whichDocument-&gt;documentJob);
    err = GXGetJobError(whichDocument-&gt;documentJob);
    GXDisposeViewPort(printViewPort);
    whichDocument-&gt;curPage = oldPage;
StartJobFailed:
PageRangeError:
    return err;
}</pre>
<p class="spacer">&nbsp;</p>
<p class="spacer">&nbsp;</p>
<p>
Several important things are going on in the code in Listing 10. You may recognizethe<br>
basic QuickDraw GX print loop, which consists of everything in MyGXPrintLoopexcept<br>
the view port and translator routines. The first thing we do in the print loop is create<br>
a gxViewPort object, because GXStartPage needs to know which view ports we'll be<br>
drawing to. Only shapes drawn in the specified view ports will be printed. For our<br>
purposes, one view port will suffice, so that's all we create.
</p>
<p>
There are two basic print loop methods for QuickDraw GX: the first uses GXPrintPageto<br>
print a single gxPicture shape; the second method uses the GXStartPage and<br>
GXFinishPage routines. In the second method, the application specifies a list of view<br>
ports, and any QuickDraw GX drawing that occurs in any of these view ports is instead<br>
redirected to a print file. Since our application draws several shapes on a page, it<br>
makes sense to use the GXStartPage and GXFinishPage approach. If we had only one<br>
shape to print (for instance, if we had used GXConvertPICTToShape), or if our<br>
gxSpoolProc collected all the converted shapes into one gxPicture shape, using<br>
GXPrintPage would make more sense. 
</p>
<p>
Notice that the custom page formats that we've added to our application are supported,<br>
and they require only a couple of lines of code. Recall that in this application we've<br>
decided to use nil to represent the default job format. If the current page's format<br>
reference ID is not nil, we pass GXStartPage the reference; otherwise, we pass the<br>
gxJob object's default format. This default format is always positioned as the first<br>
format in a gxJob, so we can obtain it as follows:
</p>
<pre>pageFormat = GXGetJobFormat(whichDocument-&gt;documentJob, 1);</pre>
<p>
Before we can issue our QuickDraw drawing commands, we must call<br>
GXInstallQDTranslator.&nbsp;&nbsp;&nbsp;Because all QuickDraw drawing calls are ignored by the<br>
QuickDraw GX printing routines, we need to translate all QuickDraw commands to<br>
QuickDraw GX shapes for printing. In the GXInstallQDTranslator call, we specify that<br>
we want to use the default translation options, that we don't want to stretch patterns,<br>
and that our shape- handling routine is called MyPrintAShape. Finally, remember the<br>
refCon parameter we discussed earlier? Well, here's where it comes into play. In the<br>
refCon, we pass a pointer to a MySpoolDataRec, which is defined as
</p>
<pre>typedef struct MySpoolDataRec {
    gxRectangle pageArea;       /* Page rectangle. */
    gxViewPort  printViewPort;  /* View port we're printing in. */
} MySpoolDataRec, *MySpoolDataPtr;</pre>
<p>
The MyPrintAShape routine is passed each QuickDraw GX shape that is created as the<br>
result of the QuickDraw translation. We can print each shape because a pointer to our<br>
MySpoolDataRec is passed in the refCon parameter of MyPrintAShape. We print a<br>
shape by attaching the MySpoolDataRec.printViewPort to the current shape, and then<br>
drawing the shape. We use the page rectangle in the MySpoolDataRec to determine<br>
whether a translated shape will appear on the printed page. If the shape isn't on the<br>
page, it doesn't make sense to waste time and disk space spooling it.&nbsp;&nbsp;&nbsp;Listing 11 shows<br>
how cleanly this all fits together.
</p>
<p>
<b>Listing 11. </b>MyPrintAShape
</p>
<pre>OSErr MyPrintAShape(gxShape currentShape, long refCon)
{
    MySpoolDataPtr      spoolData;
    gxShapeType         theShapeType;

    spoolData = (MySpoolDataPtr) refCon;
    theShapeType = GXGetShapeType(currentShape);

    /* Don't waste time spooling the shape if it's being drawn off
        the page. */
    if ((theShapeType == gxEmptyType) ||
         (theShapeType == gxFullType) ||
         (theShapeType == gxPictureType) ||
         GXTouchesBoundsShape(&amp;spoolData-&gt;pageArea, currentShape)) {
        GXSetShapeViewPorts(currentShape, 1,
            &amp;spoolData-&gt;printViewPort);
        GXDrawShape(currentShape);
    }
    return (OSErr) GXGetGraphicsError(nil);
}</pre>
<p>
Back in our print loop, we simply draw our page's QuickDraw representation between<br>
the GXInstallQDTranslator and GXRemoveQDTranslator calls. QuickDraw commands are<br>
translated to QuickDraw GX shapes and printed in one fell swoop.
</p>
<p>
<b>PRINT ONE COPY</b><br>
A soon-to-be-familiar sign of the QuickDraw GX application will be the Print One<br>
Copy command in the application's File menu. The option to print one copy of a<br>
document without any dialogs is a big convenience to the user, and it requires only a<br>
few minutes of coding to support. 
</p>
<p>
In addition to changing the necessary menu setup and handling routines, we need to add<br>
a routine to support Print One Copy (Listing 12). In this routine, we temporarily<br>
reset three of the printing options that the user may have previously changed. First,<br>
we set up the print job so that it prints only one copy. The number of copies last<br>
printed is stored in the gxJob object, and we want to make sure that if the user<br>
previously printed multiple copies of a document, only one copy comes out of the<br>
printer when Print One Copy is chosen. Second, we indicate that we want to print all<br>
pages of the document, rather than the last page range used. Finally, the output<br>
should<i>come out of the printer</i> . If the job was last printed to a file, we'll need to change<br>
the job object's "Print to disk" setting. Once again, we call upon the Collection<br>
Manager, although this time we access the job collection. 
</p>
<p>
<b>Listing 12. </b>MyPrintOneCopy
</p>
<pre>OSErr MyPrintOneCopy(MyDocumentPtr whichDocument)
{
    OSErr                   err;
    Collection              jobCollection;
    gxCopiesInfo            copiesInfo;
    gxFileDestinationInfo   destInfo;
    gxPageRangeInfo         pageRangeInfo;
    Ptr                     oldCopiesInfo = nil,
                            oldPageRangeInfo = nil,
                            oldDestInfo = nil;
    long                    oldCopiesSize, oldPageRangeInfoSize,
                            oldDestInfoSize;

    /* Get the job collection and set it up to print one copy. */
    jobCollection = GXGetJobCollection(whichDocument-&gt;documentJob);
    /* Set number of copies to 1. */
    copiesInfo.copies = 1;
    err = MyReplaceCollectionItem(&amp;copiesInfo, sizeof(gxCopiesInfo),
                gxCopiesTag, gxPrintingTagID, jobCollection,
                &amp;oldCopiesInfo, &amp;oldCopiesSize);
    nrequire(err, ReplaceCopies_error);
    /* Set page range to "all". */
    pageRangeInfo.simpleRange.optionChosen = gxDefaultPageRange;
    pageRangeInfo.minFromPage = 1;
    pageRangeInfo.simpleRange.fromPage = 1;
    pageRangeInfo.maxToPage = whichDocument-&gt;numPages;
    pageRangeInfo.simpleRange.toPage = whichDocument-&gt;numPages;
    pageRangeInfo.simpleRange.printAll = true;
    err = MyReplaceCollectionItem(&amp;pageRangeInfo,
              sizeof(gxPageRangeInfo), gxPageRangeTag,
              gxPrintingTagID, jobCollection, &amp;oldPageRangeInfo,
              &amp;oldPageRangeInfoSize);
    nrequire(err, ReplacePageRange_error);
    /* Set destination to "printer". */
    destInfo.toFile = false;
    err = MyReplaceCollectionItem(&amp;destInfo,
              sizeof(gxFileDestinationInfo), gxFileDestinationTag,
              gxPrintingTagID, jobCollection, &amp;oldDestInfo,
              &amp;oldDestInfoSize);
    nrequire(err, ReplaceDestination_error);
    /* Print one copy of our document. */
    err = MyPrintDocument(whichDocument);
    /* Restore original number of copies, page range, and output
        destination in case anybody uses that info. */
ReplaceDestination_error:
    MyReplaceCollectionItem(oldDestInfo, oldDestInfoSize,
        gxFileDestinationTag, gxPrintingTagID, jobCollection, nil,
        nil);
ReplacePageRange_error:
    MyReplaceCollectionItem(oldPageRangeInfo, oldPageRangeInfoSize,
        gxPageRangeTag, gxPrintingTagID, jobCollection, nil, nil);
ReplaceCopies_error:
    MyReplaceCollectionItem(oldCopiesInfo, oldCopiesSize,
        gxCopiesTag, gxPrintingTagID, jobCollection, nil, nil);
    /* Dispose of pointers that MyReplaceCollectionItem created. */
    if (oldCopiesInfo)
        DisposePtr(oldCopiesInfo);
    if (oldPageRangeInfo)
        DisposePtr(oldPageRangeInfo);
    if (oldDestInfo)
        DisposePtr(oldDestInfo);
    return err;
}</pre>
<p>
The MyReplaceCollectionItem routine, which I created for the Simple Sample GX<br>
application, has the format
</p>
<pre>OSErr MyReplaceCollectionItem(void *newData, long collectionItemSize,
                OSType collectionType, long collectionID, Collection
                whichCollection, Ptr *oldData, long *oldDataSize);</pre>
<p>
This routine replaces a collection item and returns a copy of its old data. It takes a<br>
pointer to the collection data we want to store, and the size, type, ID, and collection to<br>
store it in. In the last two parameters, you pass a reference to a pointer in which to<br>
store the existing data and a reference to a long word in which to store its size. If the<br>
oldData pointer is nil, the existing data is not returned; otherwise, a new pointer is<br>
created in the oldData parameter, and the data is returned there. 
</p>
<p>
MyReplaceCollectionItem allows you to replace a collection item, execute some code,<br>
and then restore the collection item. That's exactly what we do in the MyPrintOneCopy<br>
routine. 
</p>
<p>
<b>DRAG-AND-DROP PRINTING</b><br>
The final thing that a QuickDraw GX-aware application should support is the new<br>
attribute of the 'pdoc' Apple event, enabling users to print documents by dragging their<br>
icons to desktop printers.&nbsp;&nbsp;&nbsp;You need to make only a few changes to your current 'pdoc'<br>
Apple event handler, as you can see from Listing 13. With these changes to the Apple<br>
event handler, our conversion of the QuickDraw sample application to one that's<br>
QuickDraw GX aware is complete.
</p>
<p>
<b>Listing 13. </b>'pdoc' Apple event handler, modified for QuickDraw GX
</p>
<pre>pascal OSErr MyHandlePDOC(AppleEvent *theAppleEvent,
    AppleEvent *reply, long myRefCon)
{
    OSErr           err;
    AEDescList      docList, dtpList;
    FSSpec          myFSS, dtpFSS;
    long            itemsInList, i;
    AEKeyword       theKeyword;
    DescType        typeCode;
    Boolean         draggedToDTP = false;
    Size            actualSize;
    MyDocumentPtr   newDocument;

    /* See if the document was dragged to a desktop printer. */
    err = AEGetAttributeDesc(theAppleEvent, keyOptionalKeywordAttr,
                typeAEList, &amp;dtpList);
    if (err == noErr) draggedToDTP = true;
    /* If we dragged to a desktop printer, get the name of that
        printer and then throw away the description list for it. */
    if (draggedToDTP) {
        err = AEGetNthPtr(&amp;dtpList, 1, typeFSS, &amp;theKeyword,
                    &amp;typeCode, (Ptr) &amp;dtpFSS, sizeof(FSSpec),
                    &amp;actualSize);
        AEDisposeDesc(&amp;dtpList);
    }
    /* Get our document list. */
    err = AEGetParamDesc(theAppleEvent, keyDirectObject, typeAEList,
                &amp;docList);
    nrequire(err, AEError);
    /* Make sure we've accounted for all of the parameters passed,
        and count the number of documents passed in. */
    err = MyCheckAEParams(theAppleEvent);
    nrequire(err, AEError);
    err = AECountItems(&amp;docList, &amp;itemsInList);
    nrequire(err, AEError);
    /* For each entry in the doc list, load it, print it, and */
    /* close it. */
    for (i = 1; i &lt;= itemsInList; i++) {
        err = AEGetNthPtr(&amp;docList, i, typeFSS, &amp;theKeyword,
                    &amp;typeCode, (Ptr) &amp;myFSS, sizeof(FSSpec),
                    &amp;actualSize);
        nrequire(err, AEEntryError);
        /* Load the document. */
        err = MyCreateDocument(kDefaultTitle, &amp;newDocument);
        nrequire(err, CreateDocFailed);
        err = MyFSLoadDocument(newDocument, &amp;myFSS);
        nrequire(err, LoadDocFailed);
        /* If we dragged to a desktop printer, select that as the
            output printer for this job, and print one copy. */
        if (draggedToDTP) {
            GXSelectJobOutputPrinter(newDocument-&gt;documentJob,
                dtpFSS.name);
            err = MyPrintOneCopy(newDocument);
        }
        else
            /* "Print" chosen from Finder. Show dialog and print. */
            err = MyPrintDocument(newDocument);
        /* Close the document once it's printed. */
LoadDocFailed:
        MyDisposeDocument(newDocument);
    }
    /* When we're all done, throw away the document list and exit. */
CreateDocFailed:
AEEntryError:
    AEDisposeDesc(&amp;docList);
AEError:
    if (gQuitAfterPrinting)
        gQuitting = true;
    return err;
}</pre>
<p>
<b>&nbsp;For information on the 'pdoc' Apple event, </b>see <i>Inside Macintosh:</i><br>
<i>Interapplication Communication,</i>&nbsp;&nbsp;Chapter 4.*
</p>
<h2>WHERE TO TAKE IT FROM HERE</h2>
<p>
Now that you know how to add QuickDraw GX printing to a QuickDraw application, go do<br>
it!&nbsp;&nbsp;&nbsp;Think of all the features you'll instantly support by being QuickDraw GX aware.<br>
The time hit to gain this level of compatibility is minimal for most applications, and<br>
well worth it. 
</p>
<p>
Still not convinced? Take the sample applications and print with both versions under<br>
QuickDraw GX. Even this simple program shows that if your applications aren't<br>
QuickDraw GX aware, you (and your users) are really missing out. 
</p>
<h2>RELATED READING</h2>
<ul>
<li><i>Inside Macintosh: QuickDraw GX Printing</i>  and <i>Inside Macintosh:</i><br>
<i>QuickDraw GX Environment and Utilities</i> (Addison-Wesley, 1994).</li>
<li>"Getting Started With QuickDraw GX" by Pete ("Luke") Alexander, <br>
<i>develop </i> Issue 15.</li>
<li>"Developing QuickDraw GX Printing Extensions" by Sam Weiss, <i> develop</i> <br>
Issue 15.</li>
</ul>
<p>
<b>DAVE HERSEY </b>likes the annoying buzzing noise that ImageWriters and ImageWriter<br>
LQs make. He also enjoys listening to Guns N Roses, but only while he's answering<br>
developer e-mail at Apple's Developer Support Center. Dave recently wrote a<br>
QuickDraw GX printer driver for the Apple Color Plotter (which is from an era before<br>
the first Macintosh). When asked why he bothered, he said "Well, it makes this cool<br>
wacka-wacka sound." Clearly, Dave is an audiophile for the '90s. *
</p>
<p>
<b>Thanks </b>to our technical reviewers Pete ("Luke") Alexander, Hugo Ayala, Tom Dowdy,<br>
and Ken Hittleman. *
</p>
</body>
</html>
