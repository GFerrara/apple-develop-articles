<html>
<head>
<!-- Article ID: 32 - Extracted from develop-1991 -->
<!-- on 2024-01-04 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by copyright of their respective owners -->
<title>Summer 91 - QUICKTIME 1.0: "YOU OUGHTA BE IN PICTURES"</title>
<link href="styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h2>QUICKTIME 1.0: "YOU OUGHTA BE IN PICTURES"</h2>
<h1>GUILLERMO A. ORTIZ</h1>
<p>
<img src="img/178.gif" width="224 px"></img>
</p>
<p>
<i>QuickTime is Apple's new architecture for enabling the Macintosh to handle time-</i><br>
<i>based data. The recently introduced QuickTime 1.0 makes it easy for you to add dynamic</i><br>
<i>media like video and sound into your applications--and that's just the beginning. Two</i><br>
<i>sample programs show you how to do the two most basic (and important) QuickTime</i><br>
<i>tasks: playing existing movies and creating new ones.</i>
</p>
<p>
The world isn't standing still--it's moving,<i>fast</i> --and Apple intends to stay at the<br>
front of the race.&nbsp;&nbsp;&nbsp;When Apple came out with the Lisa&#174; and then the Macintosh, the<br>
idea of a document file that mimicked a piece of paper was a big deal. But now it's not.<br>
Users have taken the "paper" metaphor for granted and are now looking for new<br>
metaphors that increase their ability to communicate. One way to do that is to allow<br>
documents and applications to contain and display data that<i>changes</i> . 
</p>
<p>
QuickTimeTM is more than just the ability to record and play back movies--it's a<br>
fundamental addition to the Macintosh Operating System. Just as QuickDrawTM gave<br>
the original Macintosh the edge of sophisticated graphics in 1984, QuickTime will give<br>
the Macintosh another edge over other computers: the<i>built-in</i> ability to handle data<br>
that changes with time. 
</p>
<p>
Until now, the Macintosh Toolbox has not provided a standard way of dealing with<br>
dynamic media, and some developers have come up with their own solutions, especially<br>
in the areas of video and sound. Unfortunately, this has resulted in confusion and a lack<br>
of standards and basic system support for these data types. Apple has created<br>
QuickTime to provide a standard way of dealing with data that changes with time. Even<br>
more important, QuickTime gives you the necessary support software so that you can<br>
spend your time<i>using</i>&nbsp;&nbsp;new data types instead of designing, implementing, and<br>
maintaining them. 
</p>
<p>
QuickTime 1.0 works on all color-capable Macintosh computers running Color<br>
QuickDraw (models with either a 68020 or 68030 processor) and either System<br>
6.0.7 or System 7.0; a later version will add QuickTime support for monochrome,<br>
68000-based Macintoshes. As a result, you, the developer, can take it for granted that<br>
QuickTime will be available on<i>any</i> Macintosh running your software. 
</p>
<p>
QuickTime 1.0 makes it possible for your program to manipulate the audio/video<br>
sequences we call<i>movies</i> . (The size, duration, and quality of the average movie largely<br>
depends on how much disk space you have for movie files.) It also includes routines for<br>
the compression and decompression of still and dynamic images (which should<br>
encourage you to use color images without worrying about how much space they take<br>
up). 
</p>
<p>
The result of all this is something that you'll like very much: applications and<br>
documents that give users a richer experience with your product than they can get<br>
with non-QuickTime Macintosh applications or applications on other platforms.<br>
QuickTime will make possible a new generation of&nbsp;&nbsp;Macintosh software and hardware<br>
solutions that until now have been available only using expensive and narrow-purpose<br>
hardware. 
</p>
<h2>ENOUGH MARKETING STUFF! NOW THE DETAILS . . .</h2>
<p>
QuickTime 1.0 contains the following parts:
</p>
<ul>
<li><i> Movie Toolbox</i> . This contains the calls needed for playing and recording<br>
dynamic media. It communicates with the necessary components for the type of<br>
media being used.</li>
<li><i> Component Manager</i> . Previously called the Thing Manager in internal<br>
circles, this piece of QuickTime provides a high-level interface that allows<br>
applications to communicate during run time with a collection of software<br>
objects. These components, affectionately called Things, provide a variety of<br>
functions. At present, these functions include image compressing and<br>
decompressing, movie data handling, video digitizing, and playback<br>
controlling.</li>
<li><i> Image Compression Manager</i> . This tool handles the interaction among the<br>
components that compress and decompress image data. Its services are<br>
available both for movie making and playing and for the compression and<br>
decompression of still images.</li>
</ul>
<p>
<b>MOVIE TOOLBOX</b><br>
The basic component of QuickTime is the<i>movie</i> . At its highest level, a&nbsp;&nbsp;movie contains<br>
one or more<i> tracks</i> , each of which points to data of one type&nbsp;&nbsp;(see Figure 1). A movie<br>
also includes its time scale, duration, size, location and poster information, current<br>
selection and insertion point (if any), preferred volume, image scaling and positioning<br>
matrix, and other information (more on this later). 
</p>
<p>
<img src="img/179.gif" width="549 px"></img>
</p>
<p>
<b>Figure 1</b> A Movie and Its Tracks
</p>
<p>
A movie contains any number of tracks (it's true that a movie can have zero tracks,<br>
but that's kind of a boring case). Each track has a<i>media</i> associated with it, which points<br>
to the "raw" data that the track draws from when it plays. Other track parameters<br>
include time scale, duration, time offset within the movie, audio volume, and track<br>
type. The<i>track edit list</i> is the list of media subsegments that define the track's output. 
</p>
<p>
&nbsp;Each media references a file that contains its raw data; the file can be any place you<br>
can put a random-access stream of data--it can be in the file containing the movie, a<br>
nearby file, or even a file elsewhere on the network! If more than one media in the<br>
movie references the same data file, the different types of data may be interleaved<br>
within the file. 
</p>
<p>
&nbsp;As Figure 2 shows, each media is associated with exactly one track and vice versa.<br>
Because the track can map nonlinearly to the media (as is the case in Figure 2), you<br>
can edit a movie by simply changing a few pointers rather than having to move large<br>
pieces of data around. Two or more tracks can be members of a movie's<i>alternate group</i><br>
; when the user picks one of these tracks to be active, QuickTime does not use any of<br>
the other alternate tracks.
</p>
<p>
&nbsp;Each media references "raw" data of one type--for QuickTime 1.0, either video or<br>
sound. It also contains its duration, time scale, priority, language, quality, media type,<br>
and handler. The media handler knows how to play back its data at the right time. 
</p>
<p>
&nbsp;The<i> poster</i>&nbsp;&nbsp;is the single frame (in the movie) that the creator of a movie considers as<br>
best conveying the spirit of the movie. You can think of it as the frame you would like<br>
to show if motion were not possible--for example, when printing the document that<br>
contains the movie. The poster is usually a frame from the movie the user sees, but it<br>
can be an arbitrary frame from a video track that is not visible in the normal movie. 
</p>
<p>
<img src="img/180.gif" width="600 px"></img>
</p>
<p>
<b>Figure 2</b> Basic Components of a Movie
</p>
<p class="spacer">&nbsp;</p>
<p>
&nbsp;The<i> preview</i> is a short piece of the movie that best conveys the spirit of the movie.<br>
Note that although a preview is associated with a movie, the data (frames) associated<br>
with the preview may not be part of the movie the user sees. In movie terms, the track<br>
associated with the preview may not be part of the regular movie playback. 
</p>
<p>
&nbsp;Although in the normal situation a movie file contains the data for its tracks (in which<br>
case it's called<i> self-referenced data</i> ), it's possible for the data associated with a media<br>
to reside in a file separate from the movie, anywhere on the network. 
</p>
<p>
&nbsp;Future releases of QuickTime are expected to extend the referencing capabilities of<br>
media to allow for data being acquired as the movie plays along--as, for example, data<br>
coming from a CD player or a video digitizer board. 
</p>
<p>
&nbsp;To recap: A movie may contain any number of tracks. These tracks do not need to be<br>
playing at the same time, and as a matter of fact, a track doesn't need to become active<br>
at all. Several tracks can belong to a movie's alternate group, and only one of them can<br>
play at a time. 
</p>
<p>
<b>COMPONENT MANAGER</b><br>
One very important architectural feature of QuickTime 1.0 is its extensibility. Let's<br>
take a video track as an example. When the Movie Toolbox (the subset of QuickTime<br>
that deals with movies) finds out it needs to play back this track, it calls the video<br>
media handler (which is a component). The handler in turn calls the Image<br>
Compression Manager, telling it the type of compression used. The Image Compression<br>
Manager then calls the Component Manager to find out if a corresponding decompressor<br>
component is available. If so, the Image Compression Manager can use this component<br>
without having to know all the details about the particular decompressor component<br>
needed. Of course, this is just one example; several different compression and<br>
decompression techniques are available, and the Component Manager allows the caller<br>
to choose a certain type of component by supplying additional information about it. 
</p>
<p>
Let's study the decompressor component with subtype 'rpza', which has the following<br>
structure:
</p>
<pre>ComponentResource:
ComponentDescription        /* Registration Parameters */
    componentType:          imdc
    componentSubType:       rpza
    componentManufacturer:  appl
    componentFlags:         0x00000447  /* binary 0100 0100 0111 */
    componentFlagsMask:     0
resourceSpec                /* resource where component code is
                               found */
    type:   cdec            /* the code is in a resource of type
                              'cdec' */
    id:     0x000A          /* with id of 10 */
resourceSpec                /* resource with name string */
    type:   STR             /* 'STR ' resource */
    id:     0x000B          /* with id of 11 */
resourceSpec                /* resource with info string */
    type:   STR             /* 'STR ' resource */
    id:     0x000B          /* with id of 11 */
resourceSpec                /* resource with icon */
    type:   ICON            /* 'ICON' resource */
    id:     0x000B          /* with id of 11 */</pre>
<p>
The registration parameters allow the Component Manager searching for a component<br>
of type 'imdc' (image decompression) to narrow the search to a component of subtype<br>
'rpza', made by 'appl' (Apple Computer, Inc.). The parameters include the<br>
componentFlags and componentFlagsMask fields, which help determine how to search<br>
for a given component. Note that the subtype field can be omitted if no more<br>
information is considered necessary for the type of component in question. 
</p>
<p>
For example, the componentFlags field in the example above indicates that the<br>
decompressor can do the following:
</p>
<p>
bit 0 scale on decompress<br>
bit 1 mask on decompress<br>
bit 2 use matrix for blending on decompress<br>
bit 6 spool (used for compression and decompression)<br>
bit 10 do fast dithering
</p>
<p class="spacer">&nbsp;</p>
<p>
The cleared bits have meaning, too. For example, the cleared bit 3 means that this<br>
component cannot use a matrix for the placement and scaling of the decompressed<br>
image. 
</p>
<p>
The ComponentResource (shown above) also contains the type and ID of the resource<br>
where the code that performs the actual work is located. In addition, it contains the<br>
type and ID for resources containing the name string, info string, and icon associated<br>
with the component. 
</p>
<p>
In short, the Component Manager can help applications access certain services by<br>
function rather than by name; Figure 3 shows how an application can call the<br>
Component Manager to interact with different types of components. When an<br>
application registers a component, it's guaranteeing that the&nbsp;&nbsp;component supports the<br>
basic set of calls defined for the type. This enables applications to find components by<br>
their function without having to know exact names or locations. 
</p>
<p>
<b>&nbsp;COMPRESSION AND DECOMPRESSION</b><br>
Following the basic concepts of the Component Manager, the Image Compression<br>
Manager provides applications with a common interface to compression and<br>
decompression "engines" that's independent of devices and drivers. Figure 4 shows how<br>
the Image Compression Manager interacts with the Movie Toolbox, the Component<br>
Manager, and the application. 
</p>
<p>
&nbsp;The services provided through the Image Compression Manager allow applications to<br>
compress still images as well as sequences of images (such as those found in video<br>
track media). In the case of image sequences, the Image Compression Manager also<br>
provides optional support for the<i>differencing</i> of frames--that is, storing only the<br>
pixels that differ from the previous frame to reduce the size of the movie data. 
</p>
<p>
&nbsp;Given that these compression techniques are tightly coupled to the type of data they're<br>
supposed to handle, the Image Compression Manager does not work for sound, text, or<br>
any type of data other than images. 
</p>
<p>
<img src="img/181.gif" width="600 px"></img>
</p>
<p>
<b>Figure 3</b> Component Manager Interactions
</p>
<p>
&nbsp;The Image Compression Manager accepts the input data as either a PICT or a pixMap;<br>
obviously, the first format is most often used for still images and the second for<br>
sequences of video. Since images can be very large (even when compressed), in both<br>
cases the Image Compression Manager allows for the calling application to provide<br>
spooling routines that feed the Image Compression Manager source data as needed and<br>
write the resulting compressed data to disk. The Image Compression Manager can also<br>
translate between pixMaps of varying bit depth. This simplifies the manipulation of an<br>
image split across monitors of two different bit depths; it also extends a compressor or<br>
decompressor's ability to manipulate images that (because of incompatible pixel bit<br>
depths) it would otherwise not be able to handle. 
</p>
<p>
&nbsp;In the case of pictures, the Image Compression Manager provides a set of high-level<br>
calls that allow applications to compress and play back PICT resources and files.<br>
Although these compression facilities are available to applications that call them, even<br>
applications that know nothing about QuickTime's compression facilities can play back<br>
pictures containing compressed images. (This can occur because QuickTime-unaware<br>
applications calling DrawPicture will automatically invoke the Image Compression<br>
Manager, which will decompress the image automatically and hand the application the<br>
uncompressed PICT image it was expecting.) In other words, when QuickTime is<br>
present, you can use compressed PICTs as part of your application and know that any<br>
PICT-reading application can open them correctly. 
</p>
<p>
<img src="img/182.gif" width="600 px"></img>
</p>
<p>
<b>Figure 4</b><br>
Image Compression Manager Interactions
</p>
<p class="spacer">&nbsp;</p>
<p>
The Image Compression Manager provides a simple and at the same time powerful<br>
system for compressing images. Since the mechanism is based in the workings of the<br>
Component Manager, adding new compression engines is as simple as dropping a 'thng'<br>
file into the Extensions folder of the System Folder (for System 7.0, or into the<br>
System Folder itself for System 6.0.7). Even when the exact decompressor component<br>
is not available to decompress the data, the Image Compression Manager will find a<br>
substitute if any is available. High-level calls are provided for applications to access<br>
these features in a nearly effortless manner. 
</p>
<h2>QUICKTIME SAMPLE CODE</h2>
<p>
We'll now directly explore the QuickTime features that you can immediately put into<br>
your applications. We'll follow two samples, each of which accomplishes one of the two<br>
basic QuickTime functions:<i>playing back</i> a movie (which most applications should be<br>
able to do) and<i>creating</i> a movie (which you'll need to know how to do if your<br>
application creates new movies). 
</p>
<p>
<b>PLAYING BACK A MOVIE</b><br>
To show the basic steps necessary to open movie files and play them back, we'll use the<br>
sample application SimpleInMovie. (You can find the source code for this on the <br>
latest<i>Developer Essentials</i> disc.) This program presents the user with a dialog for<br>
opening a&nbsp;&nbsp;movie and plays the movie back in awindow. SimpleInMovie uses<br>
QuickTime's standard movie controller (which is itself a component) to let the user<br>
start or stop the movie as well as scan back and forth within it. Some commands for the<br>
movie controller are implemented as menu commands to show how a program can<br>
control the controller component. 
</p>
<p>
<b>But first, a few words . . . </b> Before we look at the SimpleInMovie source code, we<br>
need to make several new distinctions. The most important distinction is that of<br>
a<i>public movie</i>&nbsp;&nbsp;versus a<i> playable movie</i> . A playable movie is what the Movie Toolbox<br>
manipulates; it has all the information needed for it to be played or edited. In contrast,<br>
a public movie is used only for data interchange, and it contains all the information<br>
needed to create a playable movie. A playable movie must be converted to a public<br>
movie (which is stored as a resource of type 'moov', pronounced "moo-vee") before it<br>
can be stored to disk or put into the Clipboard. QuickTime provides two calls to convert<br>
between the two forms: GetMoviePublicMovie converts a public movie into a playable<br>
movie, and MakePublicMovie does the opposite. 
</p>
<p>
To summarize, a playable movie is what the Movie Toolbox plays back; it has all the<br>
media handlers instantiated and is ready to go. A public movie is strictly a static<br>
representation used when the movie is to be transferred or copied. 
</p>
<p>
QuickTime gives you wide latitude in choosing the location of the raw data associated<br>
with a media, so we need to look at a few alternatives. A movie file has a file type of<br>
'MooV'. We'll call a movie file "normal" if it contains exactly one 'moov' resource. 
</p>
<p>
A movie file whose data fork contains only the media data referenced by the movie and<br>
no more is called a<i> flattened movie</i> . Specifically, it does<i>not</i>&nbsp;&nbsp;contain media frames that<br>
aren't referenced by the track to which they belong--for example, the unshaded media<br>
frames in Figure 2. A flattened movie is handy for transporting a movie<i>in toto</i>&nbsp;&nbsp;to<br>
another Macintosh computer. QuickTime provides a FlattenMovie call to create such a<br>
movie file. 
</p>
<p>
The<i> single-fork file</i> is another type of movie file. Here, not only the media data but<br>
also the 'moov' resource data are in the file's data fork. (You might use a single-fork<br>
file when exporting to a non- Macintosh computer that doesn't have separate data and<br>
resource forks.) You can make a single-fork file by calling FlattenMovie with the<br>
proper parameters. QuickTime can automatically read these files. 
</p>
<p>
Another possibility is that the movie's media point to data that are not in the movie<br>
file's data fork but in a different file; this is very common when you're about to edit a<br>
movie. Remember that to edit a track, you need only change pointers to the media; if<br>
you had to cut/copy/paste the actual image data (which can be multiple megabytes in<br>
length), editing operations could take an inordinate amount of time and disk space. 
</p>
<p>
<b>Back to the code. </b>We can now proceed to examine SimpleInMovie's source code. Note<br>
that in the listing below, the comments help describe only those calls that have<br>
directly to do with playing movies. The full source code of this program (on<br>
the<i>Developer Essentials</i> disc) contains numerous other comments on the details that<br>
pertain to all normal Macintosh operations. 
</p>
<p>
As is the case with most parts of the Macintosh Toolbox, the Movie Toolbox has to be<br>
initialized. In our sample, the initialization is done as follows:
</p>
<pre>void InitMovieStuff()
{
ComponentDescription    controllerDescriptor;
long                    version;
extern Boolean          DoneFlag;
extern Component        movieControllerComponent;

    /* We have to fill in the fields for the player descriptor in
       order to get the standard movie controller component. */
    controllerDescriptor.componentType = 'play';
    controllerDescriptor.componentSubType = 0;
    controllerDescriptor.componentManufacturer = 0;
    controllerDescriptor.componentFlags = 0;
    controllerDescriptor.componentFlagsMask = 0;

    /* We'll use gMoviesInited as a flag for everything; false means
       that the Movie Toolbox or standard player couldn't be
       initialized. */
    gMoviesInited = false;                  /* so pessimistic */
   
    if (!(Gestalt(gestaltQuickTime, &amp;version)))
        if (!(EnterMovies()))
            if (movieControllerComponent =
                    FindNextComponent((Component)0,
                    &amp;controllerDescriptor))
                    /* No error means we're OK. */
                gMoviesInited = true;           /* Good! */
    if (!gMoviesInited) {
        Alert(rBadMooviesALRT, nil);     
        /* Inform user we're bailing out. */
        DoneFlag = true;
    }
}</pre>
<p>
EnterMovies initializes the Movie Toolbox. In an application, this must be balanced by<br>
ExitMovies (or Bad Things will happen to your application). If you're calling<br>
EnterMovies from a nonapplication environment (such as an XCMD),<i>you</i>&nbsp;&nbsp;must call<br>
ExitMovies to balance the calls and ensure that all memory allocated and all globals are<br>
disposed of.
</p>
<p>
&nbsp;Normally, when an application presents a movie, it also wants to give the user some<br>
basic control over the playing of the movie. QuickTime provides a tool that lets<br>
developers add such control easily: a component called the<i>standard movie controller</i><br>
(the horizontal bar at the bottom of the window in Figure 5). 
</p>
<p>
<img src="img/183.gif" width="183 px"></img>
</p>
<p>
<b>Figure 5</b>The Standard Controller
</p>
<p>
<b>&nbsp;Getting and using the component. </b>To use a component, you first have to get it,<br>
which means you must fill in a ComponentDescription. Our example specifies only the<br>
basic type, but the subtype, manufacturer, and flags fields allow you to specify the<br>
component in greater detail. If, for example, you were looking for a compressor, the<br>
type would be 'imco' for an "image compressor" or 'imdc' for an "image<br>
decompressor." In addition, the subtype could be 'rpza', 'rle ', or 'jpeg' (or others),<br>
each of which specifies a specific implementation of compression or decompression. 
</p>
<p>
&nbsp;Although an application can register components "live" (that is, after the application<br>
has started up), the normal way they get registered is during system startup, at which<br>
time the Component Manager registers all components found in files of type 'thng' in<br>
the Extensions folder of the System Folder (for System 7.0, or in the System Folder<br>
itself for System 6.0.7). Because this happens automatically, the application can find<br>
a specific component by making the following call:
</p>
<pre>FindNextComponent((Component)0, &amp;controllerDescriptor);</pre>
<p>
&nbsp;This call tells the Component Manager to find the component that matches the<br>
descriptor (controllerDescriptor); passing 0 in the first parameter tells the<br>
Component Manager to return thefirst one of this type that it finds.&nbsp;&nbsp;In the case of a<br>
more extensive search, you may want to continue the search; you would then pass the<br>
last component found to get the next in the list that matches the descriptor. 
</p>
<p>
Once you know that the component exists, you have to open it. A component (if it's so<br>
designed) can be accessed multiple times simultaneously. Each time a component is<br>
opened, the calling application receives what is known as an<i>instance</i> of the component.<br>
The instance is what the application uses to maintain communication with the<br>
component. In our sample, we get an instance of the standard movie controller by<br>
calling OpenComponent(movieControllerComponent), where<br>
movieControllerComponent is the value returned by FindNextComponent. So keep in<br>
mind that there's a difference between a component and an instance of the component. 
</p>
<p>
Once we've done the initialization, the user can select a file, and we can then proceed to<br>
set up showing the movie. The code that gets the movie looks like this:
</p>
<pre>if (OpenMovieFile(&amp;(reply.sfFile), &amp;movieResFile,
        fsRdPerm, nil)) {
    DoReportFailure(); 
    return;                 /* and go back */
}
else {
    if (!(err = NewMovieFromFile(&amp;moov, movieResFile, &amp;resID, nil,
            0, &amp;wasChanged))) {
        if (err = GetMoviesError())
            DebugStr("\perror after NewMovieFromFile");
    }
    else {
        DebugStr("\pCould not get the moov ");
        err = -1;           /* err set will make it skip the rest */
    }
    CloseMovieFile(movieResFile);
}</pre>
<p>
Given an FSSpec (which, in this example, is reply.sfFile), the call OpenMovieFile<br>
returns the reference number for the resource fork of the file, once it has been<br>
opened. (In the code above, the reference number is in the parameter movieResFile.)<br>
It can also return the data reference for the movie, but in this example we pass nil,<br>
which indicates that we don't need it; we would need it if we were going to add tracks to<br>
the movie. (Later in this article, the section "Creating a Movie" gives more details on<br>
data references.)
</p>
<p>
Once the resource fork is open, we call NewMovieFromFile, which when successful<br>
returns the<i>playable</i> movie. NewMovieFromFile first gets the 'moov' resource (which<br>
is a public movie), creates a movie, and then resolves its data references. 
</p>
<p>
Apple has provided calls such as OpenMovieFile and NewMovieFromFile to simplify<br>
things for you.&nbsp;&nbsp;&nbsp;Though it is possible for you to make the low-level calls needed to<br>
make a playable movie from a public one, we don't recommend it. You run the risk of<br>
confusing the Movie Toolbox, which may result in incorrect values for the<br>
self-referenced data references (which indicate that the data is in the same file as the<br>
'moov' resource). Both OpenMovieFile and NewMovieFromFile handle this situation<br>
correctly when they resolve the data references. 
</p>
<p>
In our sample, when calling NewMovieFromFile, we pass 0 for the ID, meaning that<br>
we'll take the first 'moov' resource found. We also pass nil for a name pointer, since<br>
we don't plan to display the name or change it. We proceed to close the file by calling<br>
CloseMovieFile. (If we were editing the movie, we would not close the movie file here.)
</p>
<p>
Now that we have a movie, the next step is to adjust the movie box so that the movie<br>
appears in the right place in our GWorld (the window in which the movie appears):
</p>
<pre>GetMovieBox(moov, &amp;moovBox); /* Get the movie box. */
OffsetRect(&amp;moovBox, -moovBox.left, -moovBox.top); /* topleft=0 */
SetMovieBox(moov, &amp;moovBox);</pre>
<p>
<b>What is a movie box? </b> Figure 6 shows how the Movie Toolbox calculates the<br>
rectangle known as the<i>movie box</i>&nbsp;&nbsp;and displays a multitrack movie in an application's<br>
window. 
</p>
<ul>
<li><i> Pieces 1 and 2</i> : For each track, the Movie Toolbox takes the intersection<br>
of the source rect of the track and the track's clip region (both of these<br>
entities share the same coordinate system). The resulting area is transformed<br>
into the movie's coordinate system using the track's matrix. In piece 1, the<br>
track's clip region is smaller than the image. The clip region of piece 2 is the<br>
same size as the track's source rect.</li>
<li><i> Piece 3</i> . The MovieSrcBoundsRgn is the <i>union</i>  of all the clipped track<br>
regions. In this example, there are two regions. Note that the<br>
MovieSrcBoundsRgn includes both the striped and unstriped parts of piece 3.</li>
<li><i> Piece 4.</i>  The MovieSrcClipRgn is the region in which the Movie Toolbox<br>
is to display the movie. It clips the image to the areas marked with diagonal<br>
and vertical stripes.</li>
<li><i> Piece 5, 6, and 7</i>  . Piece 5 is the image resulting from the intersection<br>
of pieces 3 and 4. The MovieBox, piece 7, is the minimum rectangle that<br>
contains piece 5, mapped into the local coordinates of piece 6, the<br>
MovieGWorld (which belongs to the application that's showing the movie).</li>
<li><i> Piece 8.</i>  The MovieDisplayClipRgn is the last clip applied to the movie<br>
before it's displayed.</li>
<li><i> Piece 9</i> . The application displays only the intersection of pieces 7 and 8,<br>
which includes the minimal rectangle enclosing the diagonally and vertically<br>
striped areas.</li>
</ul>
<p>
When QuickTime plays a movie, it doesn't take the GWorld's clip region into account;<br>
the GWorld's clip takes effect at the level of the application running the movie. If your<br>
application draws into the window where a movie is playing, you want to be sure that<br>
the MovieGWorld's clip region<i>excludes</i> the part being drawn by the Movie Toolbox; in<br>
Figure 6, this would be the striped regions within piece 8<i>and</i> the smallest rectangle<br>
that contains them. 
</p>
<p>
The last clip applied by the Movie Toolbox occurs when it applies the<i>movie display clip</i><br>
<i>region</i> (piece 8 in Figure 6). This clipping area is not, in the strict sense of the word,<br>
part of the movie; it is only a run-time option and is not saved in the public movie.<br>
(This allows your application to apply a final clip of the movie within your<br>
application's GWorld.) If, for example, you used a triangular movie display clip region<br>
to clip a larger movie image, the movie would appear in its window as shown in Figure<br>
7. 
</p>
<p>
Now that such an important question has been taken care of, we can go back to the<br>
sample code. The main idea here is that the movie box probably does not have its top<br>
left corner set to (0,0). So if left to chance, the movie may not be visible in the<br>
GWorld (CGrafPort) used to display it, since its coordinate system is the GWorld's.<br>
The code then translates the resulting movie to the top left corner of our window, thus<br>
ensuring that it will be visible. Figure 8 shows how the movie box can also be used to<br>
scale the resulting image. 
</p>
<p>
Our sample application then creates a window for the movie and stores with it the<br>
player instance (obtained by calling OpenComponent(movieControllerComponent)) and<br>
the movie associated with that window. 
</p>
<p>
<b>Adding the controller. </b>Then we call MCNewAttachedController. The objective here<br>
is to put together the movie, the player instance, and the window. Although we<br>
recommend that you use the standard controller, it's not the only way to control<br>
movies; you can do it all "by hand" if you want tighter control--but you must be<br>
careful to do it right. 
</p>
<p>
<img src="img/184.gif" width="590 px"></img>
</p>
<p>
<b>Figure 6</b> Displaying a Multitrack Image in an Application's Window
</p>
<p class="spacer">&nbsp;</p>
<p>
&nbsp;MCNewAttachedController sets the destination window as the GWorld for the movie and<br>
for the drawing of the control, and it attaches the control instance to the movie being<br>
played. 
</p>
<p>
&nbsp;Then we must call SetMovieActive to enable the movie to be serviced by calls to<br>
MoviesTask; StartMovie then sets it in motion. MoviesTask has to be called<br>
periodically (normally as part of the normal idle processing in the event loop) for the<br>
movie to display successive frames without erratic playback. 
</p>
<p>
&nbsp;Since in our sample we're using the standard controller, we call instead<br>
MCIsPlayerEvent, which accomplishes the following: First it calls MoviesTask to keep<br>
the movie (or movies) in motion. Then it performs the tracking of events that belong<br>
to the controller itself (such as button clicks and moving the scroll box as the movie<br>
moves along). 
</p>
<p>
&nbsp;To summarize, the basics of including playback of movies in an application are as<br>
follows:
</p>
<ul>
<li>Get a public movie and convert it into a playable movie.</li>
<li>Associate the movie to the GWorld that will display it.</li>
<li>Set the movie in motion.</li>
<li>Periodically call MoviesTask to keep the movie in motion.</li>
</ul>
<p>
&nbsp;The above is, necessarily, a simplistic description of the process. By reading<br>
QuickTime's documentation, you'll find that the set of calls range from the very<br>
high-level, such as when using the standard controller and the movie file calls, to the<br>
fine-detail calls that allow you to control the movie at the track level, as well as<br>
intermediate-level calls that allow you to control and monitor such movie parameters<br>
as the rate (speed) of the movie and its sound level. 
</p>
<p>
<img src="img/185.gif" width="387 px"></img>
</p>
<p>
<b>&nbsp;Figure 7</b> Movie Clipped by Display Clip Region
</p>
<p>
<img src="img/186.gif" width="387 px"></img>
</p>
<p>
Original movie
</p>
<p>
<img src="img/187.gif" width="387 px"></img>
</p>
<p>
Same movie after
</p>
<pre>InsetRect(&amp;moovBox, 30, 30);
SetMovieBox(moov, &amp;moovBox);</pre>
<p>
<b>Figure 8</b>&nbsp;&nbsp;Changing the Movie Box sample<b>CREATING A MOVIE</b><br>
The sample source code that we'll use to discuss the creation of a movie is called<br>
SimpleOutMovies. This program creates a movie that contains two tracks. The first is a<br>
video track made out of frames that are read in from PICT files (this is what you must<br>
do to create a movie from a sequence put together using a rendering package like<br>
MacRenderMan&#174;). The second track uses the data contained in a 'snd ' resource to add<br>
sound to the movie. 
</p>
<p>
&nbsp;Again, we won't dwell here on the details that aren't pertinent to the creation of<br>
movies. The curious reader is once more invited to check out the source code files on<br>
this issue's<i>Developer Essentials</i> disc for the whole story. I can't help mentioning that<br>
the file-handling part of the code demonstrates how to let the user select a folder and<br>
then access the files in it sequentially; I found writing this an interesting exercise. 
</p>
<p>
SimpleOutMovies first calls the usual initialization stuff, including (since we're<br>
QuickTime savvy) EnterMovies, the call that initializes the Movie Toolbox. Then it<br>
proceeds to prompt the user to indicate where to put the movie file and what to call it,<br>
followed by a prompt to find the folder with the PICT files. The program also creates a<br>
window to display the frames as they're processed, sizes the window according to the<br>
frame of the pictures, and starts the real job. 
</p>
<p>
The code looks like this:
</p>
<pre>theErr = CreateMovieFile(&amp;mySpec, 'TVOD', 0,
    cmfDeleteCurFile);
if (theErr) DebugStr("\pCreateMovieFile Failed");
theErr = OpenMovieFile(&amp;mySpec, &amp;resRefNum, fsRdWrPerm, &amp;mdrh);
if (theErr) DebugStr("\pOpenMovieFile Failed");</pre>
<p>
After calling CreateMovieFile (passing the FSSpec corresponding to the file the user<br>
wants to create), we call OpenMovieFile. Although we discussed this call earlier,<br>
there's an important difference: Now we want to use the media data reference (held, in<br>
the code above, in the parameter mdrh). 
</p>
<p>
A<i> media data reference</i> is what the Movie Toolbox uses to find the location of the data<br>
for a given media. In this part of the example, we want to add the data to the same file<br>
we're creating. That's why it's important that, when the call returns, the parameter<br>
mdrh contains the reference to the file being created. Remember that this type of data<br>
reference is called self-referencing because it points to its data as being in the same<br>
file as the 'moov' resource. In the case where the data for a track resides in a different<br>
file, it's necessary to create a new data reference that points to that file. 
</p>
<p>
Once the file has been opened, we create the movie by calling NewMovie(0, 60). This<br>
creates an empty movie (devoid of tracks) but one that you<i>could</i> play (with, however,<br>
little result). In other words, NewMovie creates what I've been calling a<i>playable</i><br>
movie. The parameters indicate that we want the movie to be created inactive and that<br>
the TimeScale for the movie is 60--in other words, each unit of time in the movie is<br>
1/60th of a second, equivalent to a Macintosh "tick." (I might add that each track has a<br>
TimeScale associated with it, but the Movie Toolbox takes care of synchronizing the<br>
individual times.)
</p>
<p>
Next, we create the video track based on the following two lines of code:
</p>
<pre>gTrack = NewMovieTrack(gMovie, 0, kTimeScale, frameX, frameY);
gMedia = NewTrackMedia(gTrack, VIDEO_TYPE, mdrh, kTimeScale);</pre>
<p>
A track contains bookkeeping information associated with the track's overall data<br>
content. For example, to the new movie track we feed in the following: the movie the<br>
track is part of (in the above code, gMovie), the time offset (0), the scale for the<br>
track (kTimeScale), and the dimensions of the frames as obtained from the PICT frame<br>
(frameX and frameY). kTimeScale in this case is set to 10 (which means that the time<br>
unit for the track is 1/10th of a second). 
</p>
<p>
Then we create the media associated with the track by calling NewTrackMedia. The<br>
parameters establish the type of the media (currently the types defined are<br>
VIDEO_TYPE and SOUND_TYPE; new types will be announced as they're defined) and, of<br>
course, the time scale for the media. For the last parameter in our example we again<br>
pass kTimeScale--same as for gTrack--but this is not required; the media can have a<br>
different rate than the associated track. The Movie Toolbox provides many calls that<br>
allow you to convert between times and rates for those cases when this is necessary. 
</p>
<p>
The next call to the Movie Toolbox is
</p>
<pre>BeginMediaEdits(gMedia);</pre>
<p>
This call is needed here because we're going to add data to the media; in other words,<br>
the data comprising the samples will be moved into the media's data file. We'll see that<br>
when adding samples by reference (when the data doesn't move), BeginMediaEdits is<br>
not necessary. 
</p>
<p>
<b>Capturing the video track. </b>We're now ready to start collecting samples for our<br>
video track; enter the Image Compression Manager, stage left. In most cases it's<br>
desirable to compress the images to minimize both the size of the resulting file and the<br>
amount of data that needs to be moved when playing back the movie. 
</p>
<p>
After we allocate a buffer that can contain the images we want to use, we call
</p>
<pre>GetCompressionSize(&amp;pm, &amp;r, theDepth, theQuality, codecType,
                    codecID, &amp;maxCompressedFrameSize)</pre>
<p>
The purpose of this call is to find out, using the known parameters for the images, an<br>
estimate of the worst-case size for the resulting image. (In the same manner,<br>
GetCompressionTime can return information concerning the<i>time</i>&nbsp;&nbsp;that it would take to<br>
compress the image.)
</p>
<p>
After allocating the buffer for the compressed data, we call
</p>
<pre>CompressSequenceBegin(&amp;seqID, &amp;pm, nil, &amp;r, nil,
                    theDepth, codecType,
                    codecID, theQuality, mQuality, keyFrameRate, ct,
                    codecFlagUpdatePrevious, imageDescriptorH);</pre>
<p>
The parameter seqID points to a variable where the ID of the sequence is stored. This<br>
value is needed to continue adding frames to the sequence. We pass nil for both the<br>
previous pixMap and rectangle; this indicates that the Image Compression Manager<br>
will allocate the GWorld to keep a copy of the image against which the next frame will<br>
be compared. If you wanted to allocate it yourself, you would pass it here. 
</p>
<p>
The overall objective of the code that creates this video sequence is, when going from<br>
frame to frame, to store as little information as possible for each new frame. Instead<br>
of storing a complete image for every frame, we want to add only the difference<br>
between a given frame and the<i>key frame</i> (the most recent frame that contains the<br>
complete image). 
</p>
<p>
The Movie Compressor component has a built-in decision maker that determines when<br>
a new key frame is needed. Nevertheless, based on the expected images, the program<br>
can set the maximum number of frames that can be added before a new key frame is<br>
needed. In our case, we pass a value of 10 for the keyFrameRate, which means that at<br>
least every ten frames a key frame of the entire image has to be added to the sequence.<br>
If you want to force the creation of a new key frame<i>every</i> frame, you can easily do this<br>
by calling SetCSequenceQuality and passing 0 for temporalQuality. 
</p>
<p>
The last parameter to mention is the ImageDescription handle. This handle (which the<br>
calling program has to preallocate) is filled in by the compressor and contains all the<br>
information necessary to reassemble the image. The ImageDescription handle is<br>
required by the media to interpret the data. Later, when we add sound to this movie,<br>
we'll see how this is handled differently.
</p>
<p>
Then our code renders one picture in the off-screen GWorld allocated for this purpose<br>
and calls
</p>
<pre>CompressSequenceFrame(seqID, &amp;pm, &amp;r, codecFlagUpdatePrevious,
        *compressedFrameBitsH, &amp;compressedFrameSize,
        &amp;similarity, nil);</pre>
<p>
followed by
</p>
<pre>AddMediaSample(gMedia, compressedFrameBitsH, 0L, compressedFrameSize,
        (TimeValue)1, (SampleDescriptionHandle)imageDescriptorH,
        1L, similarity?sampleNotSync:0, &amp;sampTime);</pre>
<p>
Very similar to CompressSequenceBegin, CompressSequenceFrame adds more frames<br>
to a sequence.&nbsp;&nbsp;&nbsp;Note that we have to pass the sequence ID, the ImageDescription handle,<br>
and a VAR parameter named "similarity," which tells how close the current frame is to<br>
the previous frame (the values range from 0, which means a key frame was added, to<br>
255, meaning that the two frames are identical). The compressor has one flag,<br>
codecFlagUpdatePrevious, which tells the Image Compression Manager to copy the<br>
current frame to the previous frame's buffer. 
</p>
<p>
This process is repeated for each frame and, when all the PICTs have been processed,<br>
we close the sequence and add the media to the movie:
</p>
<pre>CDSequenceEnd(seqID);
EndMediaEdits(gMedia);
InsertTrackMedia(gTrack, 0L, GetMediaDuration(gMedia), 0L,
                GetMediaDuration(gMedia));</pre>
<p>
The important call here is InsertTrackMedia. This call is the final link in adding<br>
samples to a track.&nbsp;&nbsp;&nbsp;When EndMediaEdits executes, the new data samples are already<br>
part of the media. However, the track does not know about the additions that have just<br>
been made, and the call to InsertTrackMedia takes care of that. There are numerous<br>
implications here, but an interesting one is that a segment of the media can be inserted<br>
into the track more than once. Since the time scale of the media and track are the same,<br>
we can use the value of the media's duration for the track segment's duration, too. 
</p>
<p>
At this point we have completed the creation of a movie and have added a video track to<br>
it, so we end with the following:
</p>
<pre>AddMovieResource(gMovie, resRefNum, &amp;resId, (char *)sfr.fName);
CloseMovieFile(resRefNum);</pre>
<p>
That's it--we have a movie that we can play. But we're missing one thing: sound. This<br>
is not a big deal, since adding sound is very much like what we've just done. In the<br>
paragraphs below, we'll describe what's different. 
</p>
<p>
<b>Adding sound. </b>Before closing the file in our sample program, SimpleOutMovies, we<br>
must include the routine that handles adding the sound. The process is the same as it<br>
was for video. In this case, the user is prompted for a file containing a sound resource.<br>
When selected, the program reads in the 'snd ' resource and, with that data at hand, we<br>
proceed to fill in the sound description record. 
</p>
<p>
In the QuickTime 1.0 release, the Movie Toolbox can deal only with sound data made out<br>
of sampled sounds; any other data will make no sense. Future releases of QuickTime<br>
will most surely have support for other sound formats. This is why most of the fields<br>
in the sound descriptor record have to be filled with zeros; but based on the 'snd ' data,<br>
we enter the number of channels, the sample size (in bits), and the frequency of the<br>
sampled sound. 
</p>
<p>
Then we start again with
</p>
<pre>NewMovieTrack(moov, (TimeValue)0, kTimeScale, 0, 0);</pre>
<p>
Note that for a nonvideo track, the spatial information width and height must be set to<br>
0.&nbsp;&nbsp;Since we're adding sound that has been sampled at a rate of 11 kHz, the constant<br>
kTimeScale has been set to this value. 
</p>
<p>
The call to create the new track is followed by
</p>
<pre>NewTrackMedia(gTrack, SOUND_TYPE, mdrh, kTimeScale);</pre>
<p>
Note that we're still using the same media data reference that we used for the video<br>
track; this means that we want to continue adding samples to the same file, since that's<br>
where the parameter mdrh points.&nbsp;&nbsp;After this we call BeginMediaEdits to start adding<br>
samples, followed by AddMediaSample, EndMediaEdits, and InsertTrackMedia. The<br>
difference in this sequence is that AddMediaSample is called only once; since all the<br>
sound data is in one place, we add it all at once. 
</p>
<p>
Finally, what happens when we don't want to add the data directly--that is, when it's<br>
in a file and we don't want to copy it over to the movie file? In this case we need to add<br>
data by reference and first we need to create a media data reference record. Although<br>
these calls are System 7.0-specific, QuickTime makes sure they work when running<br>
under System 6.0.7. 
</p>
<p>
In this case, our program goes through the same process as before, asking the user to<br>
select a file with sound data in it:
</p>
<pre>SFGetFile(dlgPos, "\pSound file:", nil, 1, &amp;typeList, nil,
     &amp;reply);</pre>
<p>
where "reply" is an old, trusted SFReply. Once the user selects the file, we call
</p>
<pre>FSMakeFSSpec(reply.vRefNum, 0, (unsigned char *)reply.fName, mySpec);</pre>
<p>
passing a pointer to an FSSpec in mySpec. 
</p>
<p>
When we have the FSSpec that describes our sound file, we have to make an alias to it.<br>
We do this by calling
</p>
<pre>NewAlias(nil, &amp;mySpec, &amp;SoundFileAlias);</pre>
<p>
From the alias, we create a media data reference by calling
</p>
<pre>mdrh = NewDataRef(SoundFileAlias);</pre>
<p>
We then use the parameter mdrh to create the media (gMedia) and immediately call
</p>
<pre>AddMediaSampleReference(gMedia, 0, fSize, (TimeValue)1,
(SampleDescriptionHandle)sndDescriptH, nSamples, 0, &amp;sampTime);</pre>
<p>
Note that we pass 0 for the location of the data within the file; fSize is the size of the<br>
samples. If the file cannot be found when opening the movie, the user will be prompted<br>
to locate the missing file.&nbsp;&nbsp;&nbsp;Since we are not adding the sample data directly, it's not<br>
necessary to call BeginMediaEdits and its companion EndMediaEdits. 
</p>
<p>
So now you know how to create a movie file and then the movie itself; you start out<br>
with an empty shell that you must then fill by creating tracks and media. This sample<br>
program also shows how to add media, both directly and by reference. 
</p>
<h2>WHAT'S LEFT?</h2>
<p>
QuickTime comprises over 500 calls, and it was never the intention of this article to<br>
detail them all.&nbsp;&nbsp;&nbsp;We hope that after reading this article, you will see great<br>
possibilities for QuickTime and will continue collecting information about this new and<br>
exciting technology. Who knows, maybe next time "I'll see<i>you</i>&nbsp;&nbsp;in the movies!"
</p>
<h2>QUICKTIME AND THE HUMAN INTERFACE</h2>
<p>
<b>DISTILLED WISDOM FROM THE QUICKTIME HUMAN INTERFACE GROUP</b>
</p>
<p>
The discussions we've had of QuickTime-related human interface issues could fill more<br>
than a thousand books; below are the main recommendations for a good interface. Most<br>
of these guidelines for using movies come from the maxim "put the user in control."<br>
Our user-testing has shown that more often than not you really do need to do the<br>
following things to keep your users happy.
</p>
<ul>
<li>Users should be able to look at the screen and figure out which images are<br>
movies.</li>
<li>A movie should open with its poster showing; if it has no poster, its first<br>
frame should be shown. Upon first playing, the movie should make a visual<br>
transition from the poster state to the movie state. To get back to the poster,<br>
users may reset the movie to the beginning.</li>
<li>If you allow users to resize movies, the movies should by default maintain<br>
their original aspect ratios.</li>
<li>Where it makes sense, make handling movies as much like handling<br>
conventional (static) graphics as possible. For example, in your word<br>
processor, resize movies the same way you do pictures.</li>
<li>Movies should not play when a document is opened.</li>
<li>Users should be able to find the controls for playing any movie easily.</li>
<li>It should be reasonably obvious not only how to turn the movie on, but<br>
also how to turn it off.</li>
<li>There must always be an easy and immediate way to stop a movie that's<br>
playing.</li>
<li>There must be at least a sound mute control, and preferably a volume<br>
control. The sound tracks of different movies will have different sound levels,<br>
and movies will be played back in different environments-- some that can<br>
tolerate loud playback and others that cannot. Also, it's highly desirable that<br>
users have a convenient way to adjust the volume of sounds that accompany the<br>
movies. The Sound Control Panel is not judged to be adequately convenient for<br>
this purpose.</li>
<li>In most applications, single-clicking a movie must select it, not play it.<br>
This allows users to perform operations on the movie such as Cut, Get Info,<br>
"hide controls," "resize," or any number of other operations that your<br>
application might support.</li>
<li>Double-clicking a movie may cause it to play, but only if subsequently<br>
single- or double-clicking stops it (you have to test for and ignore any<br>
immediate second click because many users double-click reflexively).</li>
<li>If you don't need single-clicking to select a movie, single-clicking may<br>
begin the playing of the movie--just as long as single-clicking also stops it<br>
(and you dispose of double clicks, both for starting and stopping).</li>
<li>Don't mix movies that <i>play</i> on single click with movies that <i>select</i> on<br>
single click.</li>
</ul>
<p>
<b>GUILLERMO ORTIZ</b> Instead of giving you details about his life, Guillermo would like<br>
to share with you a passage from a soon to be published book. Some say that his affinity<br>
for this book tells you much more about Guillermo than we ever could.
</p>
<p>
<i>Tired, hungry, and thirsty after a long and arduous trek, DunKennsan, also known</i><br>
<i>after his conversion as "He who seeks the Light," entered Brucewhandra's cave, and,</i><br>
<i>without waiting for the religious man to acknowledge his presence, he posed the</i><br>
<i>question burning in his mind: "Why 'QuickTime'?" As a response, Brucewhandra, the</i><br>
<i>man called the Wisest, kept repeating the mantra now famous among the true</i><br>
<i>followers: "Calls that take a Movie can take a Track or a Media. Calls that take a Track</i><br>
<i>can take a Media. Calls that take a Media can take a Track." After sixty-one nights and</i><br>
<i>sixty days DunKennsan left.</i>
</p>
<p>
From <i>DunKennsan, the Favorite Disciple</i> , by Lord James Batson. Any resemblance to<br>
any real person or event is intentional and should be construed as such. *
</p>
<p>
<b>In the future, QuickTime will </b> be able to do things like control audio-visual<br>
equipment and manipulate custom-defined types of data (such as scientific instrument<br>
data). Also remember that QuickTime will become even more powerful when<br>
compression and decompression hardware becomes cheaper and is found in most users'<br>
computers. *
</p>
<p>
<b>One common use for alternate audio tracks </b> is to let the user watch the movie<br>
in the (human) language of her or his choice--for example, tracks 4 and 5 in Figure<br>
1. A movie could also contain alternate video tracks--for example, tracks to be played<br>
using hardware decompression (for one track) or software decompression (for the<br>
other). In such a case, the video would play on any Macintosh with QuickTime, but it<br>
would play better on one with hardware decompression. *
</p>
<p>
<b>A movie file containing multiple 'moov' resources</b> would be atypical. In such<br>
a case, the application must inform the user of the existence of multiple movies and<br>
give the user a way to choose one of them. The Movie Toolbox can handle such files, but<br>
Apple discourages you from creating them. Most applications will just use the first<br>
'moov' resource found in the movie file. *
</p>
<p>
<b>It's important to note </b>that the time offset is given in movie time; since we want<br>
the track to start from the beginning of the movie, we pass 0 to NewMovieTrack.<br>
Nothing prohibits a track from starting at a time different from 0; if we wanted this<br>
track to start two seconds into the movie, we would pass an offset value of 120. *
</p>
<p>
<b>We did not have to add the sound </b> all at once; it would have been possible to have<br>
added samples in smaller chunks if this had been appropriate. One such example would<br>
have been to allow the Movie Toolbox to play the sound track by reading in parts of it<br>
as needed (instead of all at once). The other side of the coin is that there would be more<br>
accesses to the disk and, in instances when the disk media is slow, this could cause a<br>
performance degradation. It's recommended that when you create movies, you perform<br>
some tests to find the balance that provides the best results. *
</p>
</body>
</html>
