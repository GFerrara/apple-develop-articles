<html>
<head>
<!-- Article ID: 31 - Extracted from develop-1991 -->
<!-- on 2024-01-04 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by the copyright of its respective owners -->
<title>Summer 91 - USING C++ OBJECTS IN A WORLD OF EXCEPTIONS</title>
<link href="../common/styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h2>USING C++ OBJECTS IN A WORLD OF EXCEPTIONS</h2>
<h1>MICHAEL C. GREENSPON</h1>
<p>
<img src="img/175.gif" width="216 px"></img>
</p>
<p>
<i>The ability to derive C++ objects from MacApp's PascalObject classes yields a</i><br>
<i>powerful marriage, but not without some misunderstandings between the two</i><br>
<i>languages. One potentially thorny area crops up in combining exception handling with</i><br>
<i>dynamic object construction for C++ objects. Judicious use of exception handling</i><br>
<i>techniques can simplify the development and maintenance of robust, well-structured</i><br>
<i>applications. But beware: it's easy to get stuck by the undesired interactions of C++</i><br>
<i>features and wind up in some tangled brush indeed.</i>
</p>
<p>
Whereas the C++ language supports dynamic storage management implicitly through<br>
object constructors and destructors, Object Pascal relies on user-defined conventions<br>
such as those provided by TObject and adhered to explicitly by MacApp&#174;. In addition,<br>
MacApp defines conventions for exception handling during object initialization. Here<br>
we explore techniques for incorporating MacApp-style exception handling in C++<br>
objects and strategies for object construction, destruction, and dynamic storage<br>
management that provide MacApp compatibility. The challenge is to retain the power of<br>
C++ features while avoiding some potential pitfalls. 
</p>
<p>
First we examine some basic differences in C++ and Object Pascal semantics and<br>
provide an introduction to C++ objects. Then we review the object construction<br>
mechanism used by MacApp and by C++, and present techniques for implementing<br>
MacApp-compatible exception handling in C++. We also present techniques for using<br>
C++ constructors and destructors with PascalObject- derived classes. Finally we<br>
explore some special difficulties and workarounds for using C++ member objects in<br>
handle-based classes. 
</p>
<h2>NOT ALL OBJECTS ARE CREATED EQUAL</h2>
<p>
Both C++ and Object Pascal rightfully claim to be "object-oriented" languages; yet, in<br>
fact, there are some fundamental differences in expressiveness and meaning between<br>
seemingly similar constructs in the two languages. These differences can be seen by<br>
comparing the object creation process in the two languages:
</p>
<pre>{ Object Pascal: }
Var obj: TObj;
    Begin
        New(obj);       { Allocate heap storage for a TObj instance }
    End;

// C++:
TObj* obj = new TObj;   // Allocate and construct a TObj instance on
                        // the heap</pre>
<p>
<b>PASCAL NEW STATEMENT ALLOCATES STORAGE</b><br>
The Pascal New statement allocates relocatable storage on the heap and places a<br>
reference to the storage in the declared object reference variable. In the MacApp<br>
environment, all Pascal objects are allocated as relocatable heap blocks using<br>
NewHandle, so the reference is a Memory Manager handle. In the example above,<br>
executing the Pascal New statement does not provide a fully constructed object<br>
instance, but merely initializes the storage enough to give the object its class identity.<br>
To become a true object instance, the storage must be initialized explicitly by the<br>
programmer. By convention in MacApp, this is done by calling the method<br>
I&amp;laquo;Classname&amp;raquo;, where &amp;laquo;Classname&amp;raquo; is the class of the object<br>
being instantiated--IObj, for example. Referring to object fields through the object<br>
reference variable before this explicit initialization will probably yield garbage<br>
results, greetings from Mr. Bus Error, or worse. 
</p>
<p>
<b>C++ NEW STATEMENT INSTANTIATES OBJECTS</b><br>
In contrast, the C++ compiler gives a passing <b>new</b> statement much deeper<br>
consideration. In general, a C++ compiler translates the <b>new</b> statement into a call to a<br>
<b>new</b> operator followed by a call to a constructor for the class. The <b>new</b> operator is<br>
similar to the New statement in Pascal: it's a function responsible for allocating<br>
storage for the object instance. A constructor is a function responsible for changing<br>
that raw storage into an instance of the class--a fully constructed object. Both<br>
operator new and a default constructor are provided by the language system or<br>
generated by the compiler and may be redefined, overloaded, and overridden for each<br>
class by the user. 
</p>
<p>
<b>C TRANSLATED CODE</b><br>
MPW C++ and other C++ systems based on the CFront translator instantiate objects<br>
by generating a single call to the appropriate constructor. This constructor calls<br>
operator new explicitly and, if the allocation is successful, constructs the object. For a<br>
class with a trivial user-defined default constructor, the generated C code looks like<br>
this (assuming the TObj class is derived from a HandleObject):
</p>
<pre>struct TObj** obj = __ct__4TObjFv( 0 ); // TObj* obj = new TObj;</pre>
<p>
The trivial constructor itself is spit out by the translator as
</p>
<pre>// Translation of definition TObj::TObj()
                                       { /* user code goes here */ }
struct TObj** __ct__4TObjFv(struct TObj** this) {
    if (this || (this =
        (struct TObj**)__nw__12HandleObjectSFUi
            (sizeof(struct TObj)))) {
    // A nontrivial constructor would have user code here
    }
    return this;
}</pre>
<p>
If you can squint past the mangled function names, you'll see that the <b>new</b> statement<br>
has been translated as an explicit call to the default constructor for the class. The<br>
constructor is named __ct__4TObjFv, which loosely unmangles as "a constructor<br>
function for class TObj taking void (no) arguments." This default constructor (there<br>
can be multiple overloaded constructors for a class) is called without user-supplied<br>
arguments. That's how we declared it, but the translator snuck in another<br>
argument--the <b>this</b> reference for the object being constructed. The constructor is<br>
passed a nil <b>this</b> reference, indicating that no storage is allocated and the constructor<br>
needs to do so by calling operator new. 
</p>
<p>
Looking at the translation of the constructor itself, you'll see that the code tests the<br>
<b>this</b> reference and, if it's nil, then calls the function __nw__12HandleObjectSFUi<br>
(operator new function for class HandleObject taking an unsigned int argument). The<br>
intrinsic HandleObject::operator new just calls NewHandle unless overridden. If<br>
operator new returns a non-nil value, the constructor assumes it's a reference to<br>
storage for the nascent object and executes its body of initialization code.&nbsp;&nbsp;&nbsp;We'll come<br>
back to constructors and translations when we explore constructor implementation for<br>
objects in a multilevel class hierarchy. A clear understanding of the object<br>
instantiation process is needed to use exception handling with dynamic storage<br>
management. For now, just notice that Pascal's New statement provides storage, while<br>
C++'s <b>new</b> statement provides objects. 
</p>
<h2>C++ OBJECT STORAGE CLASSES</h2>
<p>
In MacApp, Pascal objects are allocated only as handles on the heap. In C++, however,<br>
you can specify several ways for the compiler to get storage for an object:
</p>
<ul>
<li>dynamically on the heap with operator new</li>
<li>automatically on the stack in the scope of any code block</li>
<li>in the static data space, courtesy of the linker</li>
</ul>
<p>
For convenience we'll distinguish between<i>heap-based</i> objects that are only accessible<br>
by pointers or handles and auto and static objects, which we'll call<i>stack-based.&nbsp;&nbsp;</i><br>
Regardless of where an object is allocated, a constructor is invoked to create the<br>
instance. This is also true for temporary objects generated by the compiler under<br>
certain circumstances (such as for function arguments and return values). A<br>
constructor is always invoked when a new class object is created, no matter where or<br>
how.&nbsp;&nbsp;&nbsp;This is one of the desirable properties that makes all C++ objects first-class<br>
citizens regardless of storage class. 
</p>
<p>
<b>STATIC POTENTIAL</b><br>
The low run-time overhead needed to allocate storage for stack-based objects makes<br>
them light and suitable for implementations where heap-based objects would be too<br>
inefficient. Further, many objects have limited enough scope to be allocated on the<br>
stack. Thus the ability of C++ to create stack-based first-class objects is a powerful<br>
feature that allows us to make our programs more intensively object-oriented than we<br>
could with only heap-based objects. 
</p>
<p>
For example, consider a dynamic list class like MacApp's TList. A TList is a Pascal<br>
heap object that dynamically adjusts its size to store (typically) handles to other<br>
Pascal heap objects. This is a good arrangement for relatively short lists of things like<br>
windows, documents, and views. But what if you want a list of 50,000 objects that are<br>
small in storage but complex enough operationally to be encapsulated as a class? 
</p>
<p>
Such small but complex objects are common and include things like atoms, strings, and<br>
lists themselves--the nuts and bolts of data structures. Each of these classes owns and<br>
manages dynamic storage, yet instances of them rarely need to be allocated on the heap.<br>
For example, a string class in C++ can be represented statically as a handle to storage<br>
for characters; yet it can have many operators (concatenation, equality, assignment)<br>
defined for it and a constructor and destructor that conspire to count references and<br>
perform garbage collection on the handle. Just treating a string as a typedef synonym<br>
for a handle would lose the encapsulation and notational convenience of the operator<br>
family. A string that derived from a TObject (or other heap-based object) would still<br>
be first-class, but doing something simple, like building a long TList of strings, could<br>
get pretty inefficient. 
</p>
<p>
A possible C++ solution would be to define a StaticList class that manages a single<br>
handle to storage for a list of small static objects, such as strings. Having the list class<br>
manage the allocation of objects in the list (which themselves manage handles to<br>
storage) rather than allocating them as heap-based objects reduces the memory<br>
management overhead for the list by more than half. 
</p>
<p>
However, until the addition of language and compiler support for exception handling,<br>
throwing exceptions from stack-based object constructors is basically a no-no,<br>
because the compiler doesn't generate the needed destructor call. Stack-based objects<br>
are useful anyway, even though their constructors can't throw exceptions; and it's<br>
useful to throw exceptions from heap-based object constructors, as MacApp does for<br>
its Pascal classes. We're going to take a closer look at how exceptions and construction<br>
interact in a moment, but first let's consider member objects. 
</p>
<p>
<b>MEMBERS ONLY</b><br>
In addition to the heap-based, auto, and static storage classes described above, C++<br>
objects can also be allocated as members of an enclosing object. This is different from<br>
the common practice of maintaining an object field with a reference (such as a handle)<br>
to another heap-based object--an owned object allocated separately from the owning<br>
object. Members take their storage from the storage of their enclosing object. Like all<br>
C++ objects, members are first-class in that they can have constructors,<br>
destructors, and all other class properties. Member objects are a powerful feature of<br>
C++, but using them in a handle-based world and in the presence of exceptions<br>
presents some special difficulties. We'll examine these difficulties later and for now<br>
restrict the discussion to heap-based objects<i>without</i>&nbsp;&nbsp;member objects. 
</p>
<h2>EXCEPTIONS DURING OBJECT CONSTRUCTION</h2>
<p>
MacApp and C++ each provide a functionally similar scheme for object instantiation,<br>
and it's important to understand these mechanisms in order to use exception handling<br>
during object construction. During the instantiation process, object fields must be<br>
initialized to a known state before any failures can occur. Then, if a failure does occur,<br>
the exception handler can safely destroy the partially constructed object and free its<br>
storage. 
</p>
<p>
<b>&nbsp;THE MACAPP WAY</b><br>
After the Pascal New statement allocates uninitialized heap storage, an explicit<br>
initialization step is required to instantiate an object in the allocated space. In the<br>
MacApp environment, the root TObject class provides the canonical framework for this<br>
initialization. Figure 1 illustrates this initialization process, showing the flow of<br>
control during construction of a three-class Pascal object hierarchy. 
</p>
<p>
<img src="img/176.gif" width="600 px"></img>
</p>
<p>
<b>Figure 1</b> Flow of Control During Pascal Object Instantiation
</p>
<p>
<b>&nbsp;THE C++ WAY</b><br>
C++ provides implicitly in its language semantics an instantiation scheme<br>
functionally similar to MacApp's conventions. When the CFront translator generates<br>
code for a derived class constructor, it automatically inserts calls to the base class<br>
constructors before executing the user-supplied body.&nbsp;&nbsp;&nbsp;Figure 2 shows an overview of<br>
the C++ object instantiation process.
</p>
<p>
&nbsp;There are several things to notice in Figure 2:
</p>
<ul>
<li> The class hierarchy is derived from class HandleObject, which is a native<br>
C++ class in that it uses the C++ virtual function table dispatching<br>
mechanism.</li>
<li> Each derived class constructor calls its immediate base class constructor<br>
before executing its own body so that the base portions of the object are<br>
constructed before the derived portions. The example class hierarchy has class<br>
CDerived descended from CBase descended from HandleObject.</li>
<li> The virtual function table pointer (vptr) for the object being<br>
constructed is initialized to the constructor's class. This narrows the object's<br>
type to that of the constructor's class. So although we may be constructing an<br>
object of class CDerived, within the constructor CBase::CBase the object is<br>
essentially one of class CBase with respect to virtual function calls.</li>
</ul>
<p>
&nbsp;The user-defined body of each constructor initializes the fields belonging to that class<br>
and performs other constructions, such as allocating owned objects. The narrowing of<br>
type in constructors is important for exception handling, because if a constructor<br>
signals a failure, we want to delete the partially constructed object using a virtual<br>
destructor. Without narrowing, the virtual destructor call would resolve to the<br>
most-derived class's destructor. This destructor would expect to operate on fields of<br>
the derived object, which has not yet been constructed--Heap Check time! With<br>
narrowing, the destructor invoked is of the same class as the constructor signaling the<br>
failure, and only the constructed portions of the object are destroyed. 
</p>
<p>
&nbsp;Since the constructors for each class in the hierarchy typically set fields to 0 in<br>
order to initialize the object to a freeable state, sometimes it's more convenient and<br>
efficient to initialize the entire block of storage to 0 when it's allocated. One way to do<br>
this for native C++ objects is by redefining operator new. (See "ClearHandleObject<br>
Approach for Native C++ Objects.")
</p>
<p>
<img src="img/177.gif" width="600 px"></img>
</p>
<p>
<b>Figure 2</b> Flow of Control During C++ Object Instantiation
</p>
<p>
<b>&nbsp;EXCEPTIONS IN CONSTRUCTORS</b><br>
To implement a simple but convenient MacApp-compatible failure handling mechanism<br>
in C++, we use the<b>try</b> and<b> catch</b> macros (see "Exception-Handling Macros"). In<br>
general, if a constructor does anything that could throw an exception (say, due to<br>
failure of an owned object allocation), it must take responsibility for catching all<br>
exceptions and deleting its object on failure. If the constructor doesn't delete its object<br>
on failure, no other code will have the<b>this</b>reference to do so. This is also true for a<br>
hierarchy of constructors--each base constructor must catch all exceptions it could<br>
generate and delete its object on failure before throwing to the next handler. In a<br>
typical case, each constructor/destructor pair might look like this:
</p>
<pre>CDerived::CDerived : CBase(...), fOwned(nil) (...)
        { // Reference is nil to start
    try {
        fOwned = new TOwned;
        // Other stuff that could fail
    }
    catch delete this;
                    // If failure, destroy and throw to next handler
}

CDerived::~CDerived() {// Virtual destructor
    if (fOwned) delete fOwned;
        // Other cleanup
}</pre>
<h2>USING CONSTRUCTORS AND DESTRUCTORS WITH<br>
PASCALOBJECTS</h2>
<p>
As C++ programmers, we'd like to use constructors and destructors with<br>
PascalObject-derived classes to attain a uniform interface for clients. That is, in C++<br>
programs we'd like to instantiate all objects, whether native or PascalObject-derived,<br>
with a<b>new</b> statement and destroy all objects with a<b>delete</b> statement. In general, we<br>
expect objects to follow language semantics, regardless of their storage class or<br>
implementation, and we want to encapsulate the MacApp initialization scheme so that<br>
our C++ clients don't have to know its details. 
</p>
<p>
This seems straightforward, but there are several difficulties in using constructors<br>
and destructors with C++ classes derived from PascalObjects. Though handle-based,<br>
these classes use the Pascal method dispatcher and not the C++ virtual function table<br>
mechanism. Thus, the native C++ narrowing isn't generated in constructors, making<br>
method calls (such as Free) always virtual to the most-derived class--even if that<br>
part of the object hasn't been constructed yet. Further, as of the E.T.O. #3 release<br>
(C++ 3.1) there's a problem with how MPW C++ translates virtual destructors in<br>
PascalObject hierarchies (see "Virtual Destructors and PascalObjects").
</p>
<p>
These considerations suggest some guidelines for those determined to make use of<br>
object constructors and destructors to attain some consistency between native C++<br>
objects and descendents of PascalObjects: * For C++ classes descended <i> directly</i>&nbsp;&nbsp;from<br>
MacApp classes, define constructors CObj::CObj(...) as you would a MacApp IType<br>
method. That is, the constructor should initialize fields of the object to a known state<br>
and then call inherited::IType before performing any additional construction that could<br>
fail-- for example, before allocating owned objects. * For C++ classes descended <br>
<i>indirectly</i>&nbsp;&nbsp;from MacApp classes, the compiler invokes the base class constructors<br>
(which can fail) <i> before</i>&nbsp;&nbsp;the constructor body can execute to set up a handler.<br>
Therefore, in order for your Free method to operate correctly, you <i>must</i>&nbsp;&nbsp;define a<br>
virtual pascal function Initialize to initialize fields to a known state. MacApp calls this<br>
method before doing anything that could fail. Your constructor can simply call<br>
inherited::IType before performing any initialization that could fail. * If you call any<br>
other virtual member functions in your constructors, make sure that the fields they<br>
depend on are initialized by your Initialize method. Virtual function calls in<br>
PascalObject hierarchies are always instantiated as their most- derived definitions,<br>
even before derived constructors are executed to construct the derived parts. *<br>
Constructors should perform operations that could fail within the scope of an<br>
exception-handling <b>try</b> block. The <b> catch </b>block should, if it can't&nbsp;&nbsp;recover from the<br>
exception, perform any special cleanup and then delete the partially constructed object<br>
by executing the statement <b> delete this</b>.
</p>
<p>
For destruction, we need a workaround because the native virtual destructor<br>
mechanism is inoperative in PascalObject hierarchies. We would like the<b>delete</b><br>
statement to invoke the Free method chain, which functions as the canonical Pascal<br>
virtual destructor (TObject::Free deletes the storage). Here's one possible solution<br>
that may require minor revision with future releases of MacApp:
</p>
<ul>
<li>Do not define any destructors in derived C++ classes. Define a virtual<br>
pascal function Free to perform the cleanup functions you would have put in a<br>
virtual destructor and then call inherited::Free. This method then becomes the<br>
canonical virtual destructor and allows the object to be destroyed and disposed<br>
of by Pascal code.</li>
<li>In order for C++ code to destroy and free the object with a <b> delete</b><br>
statement, redefine PascalObject::operator delete to invoke Free:</li>
</ul>
<pre>       void PascalObject::operator delete(void** h) {
          ((TObject*)h-&gt;Free();  // Invoke canonical virtual
                                    // destructor chain
      }</pre>
<p>
&nbsp;Future versions of MacApp may rely on operator delete to actually dispose of<br>
the object's storage; if this becomes the case, you can modify TObject::Free or<br>
TObject::ShallowFree to do the right thing.
</p>
<p>
If you're using member objects with destructors in PascalObject hierarchies, there<br>
are other problems, as discussed in the next section. 
</p>
<h2>IT'S DIFFERENT WITH MEMBERS AND AUTOS</h2>
<p>
So far we've been discussing classes that do not contain member objects. This covers<br>
all standard MacApp classes, provided your derivatives don't add members. To take<br>
advantage of first-class member objects, which are a powerful feature of C++, we<br>
must face some difficulties. There are problems using member objects with<br>
handle-based classes (both HandleObjects and PascalObjects) and problems with<br>
exceptions in member constructors (common to static/auto objects as well). There are<br>
further complications with PascalObjects due to the lack of virtual destructors.
</p>
<p>
Nevertheless, on balance we think member objects represent a powerful enough<br>
construct to justify exploring these problems and possible workarounds--if we can't<br>
have the compiler support that's really needed. The following sections offer techniques<br>
for overcoming problems encountered with member objects in regard to handle-based<br>
classes and exception handling. 
</p>
<p>
<b>Declare a wrapper class for member objects in handle-based</b><br>
<b>classes.</b>Consider this translation of a constructor for a handle-based class that has a<br>
member object with a constructor:
</p>
<pre>struct foo : public PascalObject {  foo();  Memb  a;
       /* a member object */ };
foo::foo() {}               // Default constructor

// Translation of foo::foo()
struct foo** __ct__3fooFv(struct foo** this) {
    if (this ||
        (this = (struct foo**)__nw__12PascalObjectSFPFv_vUi
            (_foo, sizeof(struct foo)))) {
            __ct__4MembFv(&amp; (*this)-&gt; a) ;
            // Compiler-generated call of member constructor!
    }
    return this;
}</pre>
<p>
See the problem? It's the <b>this</b> reference passed to the member object's constructor<br>
behind our backs by the compiler--it's a dereferenced handle! If the member<br>
constructor does anything interesting (like allocate memory) it could move the<br>
enclosing object, leaving the code with a dreaded dangling pointer. This is true for
</p>
<p>
all nonstatic member functions of member objects (not just constructors). Danger,<br>
Will Robinson! 
</p>
<p>
A general workaround involves locking the enclosing object's handle before calling<br>
member functions that can move memory--the question is who should do the locking.<br>
If you have a library of classes you'd like to use as members in handle-based objects,<br>
you may want to create wrapper declarations for these classes and pass the handle to be<br>
locked (the <b>this</b> reference of the enclosing object). Here's an example of a wrapper<br>
for use by TObjects (which have a Lock method built in). It looks like a lot of code, but<br>
it's all declarations. The run-time overhead is negligible--a trade-off between using<br>
HLock/HUnlock to make the member safe and having a separately allocated heap object.
</p>
<p class="spacer">&nbsp;</p>
<pre>class CObj {
// Some library class we want to use as a member in handle-based
// objects
    public:
                CObj(...);  // Constructor, could move memory
    virtual int Accessor() { return field; }    // Won&#8217;t move memory
    virtual void    Funky(...);                 // Could move memory
   
    private:    int     field;
};

// A utility class with a constructor that locks handles
class Lockit {      // Lock the enclosing handle in constructor chain
                    // before member constructor is called
    public:
                Lockit(TObject* h) { h-&gt;Lock(true); }
                                                   // Lock the handle
// This unfortunately defines a 1-byte structure rather than
// zero-length
};

// A wrapper for the above functional class CObj&#8212;&#8212;reexport via
// private base class.  Also inherit from Lockit so that its
// constructor is called before CObj::CObj(). Member functions
// and locking wrappers must be inline or in a resident segment.
// Otherwise, calling these functions can trigger a segment load
// and heap scramble before we can lock the enclosing object.
class MObj : private Lockit, private CObj {
        // Wrapper for using CObjs in handle-based classes
    public:
// Provide handle-locking wrappers for functions that can move memory
                    MObj(TObject* h,...);
//                  MObj(HandleObject* h,...);
                 // Could overload all to work with HandleObjects too
    virtual void    Funky(TObject* h,...);

// Now we'd like to use the access declaration syntax to republicize
// functions that don't move memory, but unfortunately CFront
// currently miscalculates the 'this' reference! To
// get 'this' right, we have to provide an explicit inline call,
// which is messy in this declaration but doesn't add any run-time
// overhead.
//                  CObj::Accessor;                
// Doesn't work, miscalculates 'this'!
// Workaround:
    virtual int Accessor() { return CObj::Accessor(); }
// Inline call wrapper so 'this' is right
};

// Wrapper function for constructor--lock enclosing handle first
inline MObj::MObj(TObject* h,...) : Lockit(h), CObj(...) {
    h-&gt;Lock(false);
// Unlock enclosing handle now that we've finished with base
// constructors
}

inline void MObj::Funky(TObject* h,...) {
                   // Some memory-moving member function to wrap
    Boolean state = h-&gt;Lock(true);
                   // Lock the handle--preserve its previous state
    CObj::Funky(...);               // Call original function
    h-&gt;Lock(state);              // Put handle back the way it was
}

// Clients can use CObj as a wrapped member like this:
class TFoo : public TObject {
            MObj        fMember;    // Include the wrapped member
    public:
                        TFoo(...) : fMember(this,...), ... { ... }
                        // Be sure to pass 'this' to member
                        // constructor
    virtual void        Func() { fMember.Funky(this,...); }
                        // Pass 'this' to member functions for
                        // HLocking
};</pre>
<p>
Notice that this wrapper scheme has some drawbacks--for example, the requirement<br>
of explicitly passing a <b>this</b> reference as an additional argument. This won't work for<br>
functions such as operator functions that have a fixed number of arguments.<br>
Similarly, there's no way to pass an explicit argument to a destructor. In these cases,<br>
you can get by if you don't refer to any member object fields within member object<br>
functions after doing anything that can move memory. For example:
</p>
<pre>CObj::~CObj() {    
    // Destructor for above example library class that's used
    // as a member in handle-based objects
    // Can use our fields here; our 'this' reference is a
    // dereferenced handle!
    delete fOwned;         
    // Dispose of some storage we were managing--could compact heap?
    // Better not reference any fields here! Our 'this' reference
    // could now be a dangling pointer!</pre>
<p>
If you can't guarantee not referencing member fields after doing anything that can<br>
move memory, then you'll have to explicitly lock and unlock your enclosing objects<br>
before calling member object functions. 
</p>
<p>
<b>Don't throw exceptions from member/auto object constructors. </b> Because<br>
the compiler invokes member object constructors<i>before</i> the body of the calling<br>
constructor can execute to set up an exception handler, it's a bad idea to throw<br>
exceptions from member and auto object constructors. If the member constructor<br>
throws an exception, it's caught outside the scope of the calling constructor. The object<br>
is only partially constructed, but fully allocated, and no code has the <b>this</b> reference to<br>
delete the storage. 
</p>
<p>
Therefore, member objects should<i>not</i>&nbsp;&nbsp;throw exceptions from their constructors. For<br>
similar reasons, it's inadvisable to throw exceptions from constructors for classes<br>
used as auto objects. The exceptions are caught by a calling function in a higher stack<br>
frame, and other autos in the original frame aren't destroyed correctly. 
</p>
<p>
<b>Explicitly test successful initialization of members/auto objects. </b> To<br>
deal with member and auto objects with constructors that may fail, and to avoid<br>
memory leaks and worse, we really need language and compiler support for exception<br>
handling. Such support has been proposed for a while, but it may be a long time<br>
coming. In the interim, we'll fill in with conventions and guidelines for member and<br>
auto objects that manage storage and perform other operations in their constructors<br>
that may not succeed. 
</p>
<p>
Possible conventions include explicitly initializing instead of using constructors<br>
(which we've been trying to avoid) or explicitly testing for successful initialization<br>
(which we prefer). A nice way to test explicitly is to define operator! as a test for<br>
failure. This convention follows the C notion of using ! totest for a nil pointer<br>
indicating an allocation failure. For example, consider a constructor for a class that<br>
has a member object:
</p>
<pre>TObj::TObj() : memb(this,...) {    
    // Initialize members with member initialization syntax
    try {
        if (!memb) Failure(err,msg);    // Test explicitly for member
                                        // initialization failure
        // Do other construction that could fail
    }
    catch delete this;          // Destroy object if failure occurs
}</pre>
<p>
Here&#8217;s code for the member class constructor and operator! :
</p>
<pre>TMemb::TMemb(...) {
    fOwned=nil;
    try fOwned=new TOwned;// Don't throw exceptions if failure occurs
    catch break;          // Just exit from handler chain--i.e.,
                          // recover
}

TMemb::operator!() {
    return fOwned==nil ||
        (other init failure);
                         // Return *true* if initialization failed
}</pre>
<p>
<b>Call destructors explicitly for auto objects in exception handlers.</b> A final<br>
convention for using auto objects allocated within code blocks that can generate<br>
exceptions (either themselves, or by calling things that can fail) is to explicitly<br>
destroy these autos in your exception handler. This can be done by calling the<br>
destructor function directly using the static call syntax obj.TObj::~TObj( ). 
</p>
<p>
Normally, the compiler knows to destroy autos when they go out of scope.<br>
Unfortunately, the compiler doesn't yet know about exceptions and stack unwinding, so<br>
it doesn't know that a call to Failure is blasting us out of scope. This can cause memory<br>
leaks and worse, so always be careful with auto objects that manage storage in the<br>
presence of exceptions. In particular, don't declare autos that require destruction<br>
within the scope of a <b>try</b> block. For example:
</p>
<pre>MapFile(TFile* aFile) {
    String s(10000);    // Construct a 10K dynamic string on the heap
    // Be sure to catch all exceptions now so we can free our autos
    try {  
        // Don't declare autos needing destruction within this block!
        FailInit(!s);   // Throw memFullErr if initialization failed
        aFile-&gt;ReadIntoString(s);       // Do our work--could fail
    }
    catch s.String::~String();
    // Destroy auto explicitly and throw to next handler frame
}</pre>
<p>
<b>Be aware of implications of no PascalObject virtual destructors for</b><br>
<b>members. </b> Previously we recommended using operator delete to invoke Free instead<br>
of defining destructors in PascalObject hierarchies. But, if you include member<br>
objects with destructors in your classes, the compiler generates calls to these<br>
destructors<i>before</i>&nbsp;&nbsp;Free is invoked. That is,<i>all</i>&nbsp;&nbsp;member objects in the hierarchy are<br>
destroyed before any of their enclosing objects are destroyed. This is not a problem as<br>
long as your Free methods don't try to access the member objects. Finally, because<br>
there's no declared virtual destructor, the <b>delete</b> statement won't operate<br>
polymorphically with respect to the members. Be sure to delete the derived class and<br>
not a base class. 
</p>
<h2>AN EXAMPLE</h2>
<p>
Finally, here's some sample code that illustrates all the techniques mentioned above:
</p>
<pre>// A fictitious example illustrating the techniques described above
// Let's declare this mess once and for all
typedef pascal void (*DoToField)(StringPtr fieldName, Ptr fieldAddr,
        short fieldType void *DoToField_StaticLink);

class Lockit;           // Declared earlier in article
inline void FailInit(Boolean t) { t? Failure(memFullErr,0) : ; }

class TMyEvtHandler : public TEvtHandler {
    // Derived directly from a MacApp class
    public: // Constructors and destructors
            TMyEvtHandler(TMyCommand* aCmd=nil,TMyDocument* aDoc=nil);
            // ~TMyEvtHandler(); // No C++ virtual destructors for
                                 // PascalObjects yet!
                                 // Override operator delete instead
        virtual pascal void     Free(void);
           // Canonical Pascal virtual destructor

                                    // Other methods
#if     qInspector
        virtual pascal void     Fields(DoToField,
                                void* DoToField_StaticLink);
#endif
        virtual pascal Boolean  DoIdle(IdlePhase idlePhase);
    // ...
    private:
        TMyDocument*    fDocument;     
                // References to objects owned by someone else
        TMyCommand*     fCommand;
        TMyOwned*       fOwned;        
                // Reference to an object we own
        MStaticList     fStringList;       
                // A wrapped member object--must take special care
                // in its destructor to not access fields after
                // moving memory
};

class TMySpecialEvtHandler : public TMyEvtHandler {
    // Derived indirectly from a MacApp class
    public: // Constructors and destructors
                                TMySpecialEvtHandler();
                                // Default constructor
        virtual pascal void     Initialize(void);
                                // Pascal-style constructor
                                // No C++ destructor
        virtual pascal void     Free(void);
                                // Pascal-style virtual destructor
                                // Other methods
};

// Use member initialization syntax to pass arguments to our member
// object constructors
TMyEvtHandler::TMyEvtHandler(TMyCommand* itsCmd,
        TMyDocument* itsDocument) :
        fStringList(this,sizeof(String),
        String::CopyConstructor,String::~String) {

    // Initialize fields to a known state
    fDocument = itsDocument;
    fCommand = itsCmd;
    fMyOwned = nil;
    // So we won't try to delete it until we allocate it!
   
    // Call IType chain to init MacApp classes
    IEvtHandler(nil);
    // Initialize inherited MacApp classes
   
    try {
        // Do rest of initialization in the context of a failure
        // handler Make sure our member objects initialized
        // themselves OK
        FailInit(!fStringList);
        // Make sure MStaticList member was initialized OK
       
        // Do the rest of our construction (e.g., allocate owned
        // objects)
        FailNIL(fMyOwned = new TMyOwned);               // . . .

        // Do anything else that could perhaps fail
        gApplication-&gt;InstallCohandler(this,true);
        // Install ourselves in the idle chain
    }
    catch delete this;
    // Oops, something failed, so just Free ourselves
}

pascal void TMyEvtHandler::Free(void) {
    gApplication-&gt;InstallCohandler(this,false);
    // Get us out of the idle chain
    DeleteIfNotNil(fMyOwned);
    // Delete our owned objects if they were allocated
    try fDocument-&gt;Notify();
    // Try something that could fail Just recover--destructors
    // can't throw exceptions!!
    inherited::Free();
    // Tell bases to destroy themselves
    // TObject::Free will delete the storage
}

// Use base initialization syntax
TMySpecialEvtHandler::TMySpecialEvtHandler() :
        // Derived indirectly from a MacApp class
        TMyEvtHandler(gSomeCommand,gSomeDoc) {
       
    // By the time we get here, all base and member constructor
    // and IType chains have executed
    // without failure
   
    try {
    // Initialization that could fail
    }
    catch delete this;
};
pascal void TMySpecialEvtHandler::Initialize(void) {
    inherited::Initialize();
    // Initialize inherited fields to a known state
    // Initialize our fields to a known state here!
}

pascal void TMySpecialEvtHandler::Free(void) {
    // Delete owned objects and perform other cleanup here
    inherited::Free();
    // Let base classes destroy themselves
}</pre>
<h2>SUMMARY</h2>
<p>
Here's a summary of the various techniques we've discussed for successfully using<br>
C++ objects in a world of exceptions:
</p>
<ul>
<li>Use exception-handling macros to make code more reliable and easier to<br>
maintain.</li>
<li>Throw exceptions from heap-based object constructors only after deleting<br>
the object being constructed.</li>
<li>Don't use destructors in PascalObject-derived hierarchies; instead<br>
redefine PascalObject::operator delete to invoke the Free chain.</li>
<li>Don't throw exceptions from member object or auto object constructors;<br>
instead use explicit tests of successful initialization (such as operator!).</li>
<li>Remember to explicitly destroy auto objects before exiting their scope by<br>
throwing an exception.</li>
<li>Use a wrapper class or other technique to lock enclosing object handles<br>
when using member object functions that can move memory within<br>
handle-based objects.</li>
<li>If you're brave enough to use members with destructors within<br>
PascalObjects, be aware of the implications of not having virtual destructors.</li>
<li>When in doubt, compile with -c -l0 and check the translated C code.</li>
</ul>
<h2>CONCLUSION</h2>
<p>
As an evolutionary outgrowth of the C language, C++ adds the basic features needed to<br>
support object-oriented programming and, to a limited extent, user-defined language<br>
extensions. Coupled with a powerful class library such as that supplied by MacApp,<br>
C++ is a sensible platform for serious development where reliability,<br>
maintainability, reusability, and efficiency are primary considerations.&nbsp;&nbsp;&nbsp;However,<br>
it's also important to consider that C++ is essentially an immature language subject to<br>
future growth and mutation. Because C++ was not specifically designed for the<br>
Macintosh environment, the integration of language features is not yet seamless, as<br>
we've seen. 
</p>
<p>
With the advent of object-oriented programming and higher-level languages like C++<br>
comes the desire of applications programmers to work at as abstract a level as<br>
possible, insulated from the often arbitrary details of a particular platform's memory<br>
architecture, operating system, or toolbox. With C++ you have the freedom to work<br>
closer to the design level, but not without first making an investment in understanding<br>
the depths of the language implementation. That is, we think it is<i>always</i> important to<br>
know what the compiler is doing behind your back. The return on this initial time<br>
investment comes in applications that are better designed, more reliable, and easier to<br>
upgrade and migrate. This article was written in hopes of reducing some of the pain in<br>
this initial time investment, so that you can concentrate on the more enjoyable and<br>
productive aspects of developing in C++. 
</p>
<h2>CLEARHANDLEOBJECT APPROACH FOR NATIVE C++ OBJECTS</h2>
<p>
Here's a simple technique that redefines operator new for HandleObject to call<br>
NewHandleClear, so that on entry to derived constructors, all object fields are<br>
initialized to 0 (references to nil, flags to false). This saves you the trouble of<br>
explicitly initializing these fields to 0 with constructor code before doing anything<br>
that could fail. 
</p>
<pre>class ClearHandleObject : public HandleObject {
// Provides HandleObjects preinitialized to zero
    public:
                    void** operator new(size_t theSize)
                     { return NewHandleClear(theSize); }

// Could declare some other useful handle-oriented functions
// here (or in a superclass)
//                  Boolean Lock(Boolean);
                    // Lock/unlock object and return previous
                    // state, like TObject
//                  void        MoveHigh();
                    // Move object handle out of the way to top
                    // of heap etc.
};</pre>
<h2>EXCEPTION-HANDLING MACROS</h2>
<p>
Here we present a derivative of Andy Shebanow and Andy Heninger's excellent<br>
UFailure-compatible exception handling scheme for C and C++ that was distributed<br>
with Sample Code #14, CPlusTESample, on the <i>Developer Essentials</i>&nbsp;&nbsp;disc. The basic<br>
scheme is the same, but we've tweaked the macros so that they follow C block<br>
structuring conventions more closely. This produces code that's easier to read and<br>
more compatible in form with proposed C++ language extensions for exception<br>
handling. Now we can write:
</p>
<p class="spacer">&nbsp;</p>
<p class="spacer">&nbsp;</p>
<pre>try {
    // stuff that might throw an exception
}
catch {
    // do stuff to recover
    break;      // Exit handler, recovered
}</pre>
<p>
This establishes a failure handler within the scope of the <b> try {}</b> block. If any code<br>
within this block generates an exception (by calling Failure) the exception will be<br>
caught by the code in the <b> catch {}</b> block. Since we're following C structuring<br>
conventions, for simple statements you can omit the { }.
</p>
<p>
Normally, falling through the end of the <b>catch</b> block will throw the exception to the<br>
next handler in the chain by calling Failure again. If you want to recover from the<br>
exception, you can execute an explicit goto out of the catch or simply execute a <b>break</b><br>
statement. For example,
</p>
<pre>try CouldFail();
catch break;</pre>
<p>
would recover from all exceptions in CouldFail without further checking. Also, you can<br>
do a <b> break</b> in a <b>try</b>block that just exits the try. The <b>catch</b> block is executed only if<br>
something in the <b>try</b> block throws an exception.
</p>
<p>
The following caveats apply:
</p>
<ul>
<li> You can only have one try/catch pair per code block. If you want more<br>
than one, enclose each try/catch pair in its own block. But you'll find that<br>
when you have multiple <b> try</b> blocks in a function, they often occur within a<br>
block already (if, while), so this is not really a big deal.</li>
<li> CFront is thought to have problems with macro expansions in<br>
constructors. Sometimes macro expansions are positioned incorrectly relative<br>
to code the compiler inserts for calling operator new and base class<br>
constructors! If you're getting weird results, be sure to look at the generated C<br>
code to see what's really going on. As MacApp would say, "You Are<br>
Warned"--which makes it OK, right?</li>
</ul>
<p>
MPW C does a good job of optimizing out the loops, making the generated code<br>
comparable to the previous versions.
</p>
<p>
Here are the macro definitions to replace the previous version:
</p>
<pre>#define try \
    jmp_buf errorBuf; \
    if (! setjmp(errorBuf) ) { \
        FailInfo fi; \
        CatchFailures(&amp;fi, StandardHandler, errorBuf); \
        do {

#define catch \
        } while (0); \
        Success(&amp;fi); \
    } \
    else \
        for(; (1); Failure(gFailError, gFailMessage))</pre>
<h2>VIRTUAL DESTRUCTORS AND PASCALOBJECTS</h2>
<p>
MPW C++ 3.1 uses a Pascal method dispatch instead of a static call for the base class<br>
destructor calls it generates at the end of a derived destructor that is declared virtual<br>
in a PascalObject-derived class. The Pascal method dispatch resolves (virtually) to<br>
the most-derived class's destructor, which is the caller--in other words, death by<br>
infinite recursion. Oops.Without virtual destructors, the <b>delete</b> statement won't<br>
operate polymorphically. In other words, you can get bitten by this:
</p>
<pre>funfun() {              // TBase has a nonvirtual
                                // destructor
TBase* anObj = new TDerived;    // Create a new TDerived
delete anObj;                   // But delete a TBase! Ugh!
delete (TDerived*) anObj;       // This works correctly but what
                                // a pain--error prone, too
}</pre>
<p>
Until the C++ compiler is updated, you should adopt the convention of using the Free<br>
method as the virtual destructor chain, and redefine PascalObject::operator delete to<br>
invoke it.
</p>
<h2>REFERENCES</h2>
<ul>
<li>Andy Shebanow: "C++ Objects in a Handle-Based World," <i>develop</i> , Issue<br>
2, April 1990.</li>
<li>David Goldsmith and Jack Palevich: "Unofficial C++ Style Guide," <i>develop</i><br>
, Issue 2, April 1990.</li>
<li>Margaret A. Ellis and Bjarne Stroustrup: <i>The Annotated C++ Reference</i><br>
<i>Manual</i> , Addison-Wesley, 1990.</li>
<li>Waldemar Horwat: "The Power of C++," MacHack Conference<br>
Proceedings, 1990.</li>
<li><i>MacApp 2.0 Cookbook, Beta Draft</i> , APDA #M0299LL/C.</li>
<li>Macintosh Technical Note #88, Signals.</li>
<li>Macintosh Technical Note #281, Multiple Inheritance and HandleObjects.</li>
</ul>
<p>
<b>MICHAEL GREENSPON</b> is the principal noisemaker for Integral Information<br>
Systems, a Berkeley, California software engineering and consulting group<br>
(AppleLink: Integral). When he's not breaking compilers by trying to use all of their<br>
features at once, he's busy designing next-generation solutions for clients. His<br>
interest in the evolution of information systems goes beyond silicon--as a<br>
neurobiology undergrad at Cal Berkeley he developed visualization tools for neural<br>
network dynamic modeling using a Macintosh workstation linked to the school's Cray<br>
supercomputer. "People think the brain's a computer, but it's really an aquarium."<br>
(Ask him about his lava lamp representation of the mind.) A native Californian, he<br>
says he "prefers UV to ELF, any day." In fact, when the sun's out you're likely to find<br>
him swimming, mountain biking in Wildcat Canyon, or backpacking in the High Sierra.<br>
In between, he's working to promote telecommuting, car-free days, and CRT-free<br>
spaces.<b>*</b>
</p>
<p>
<b>Reading the intermediate C code </b>can save you a lot of MacsBug time. The C code<br>
can be dumped into a file by using the -c option on the compilation command line and<br>
redirecting the output with &gt; <i> file</i>&nbsp;&nbsp;(for example, cplus foo.cp - c - l0 &gt; foo.c).<br>
Including the -l0 (el zero) option prevents the generation of #line directives. *
</p>
<p>
<b>For an example </b>of a garbage-collecting string class see "The Power of C++," by<br>
Waldemar Horwat, MacHack Conference Proceedings, 1990. *
</p>
<p>
<b>For more information </b>on object initialization in MacApp see the<i> MacApp 2.0</i><br>
<i>Cookbook, Beta Draft</i> , APDA #M0299LL/C, Chapters 1 and 7. *
</p>
<p>
<b>For more information</b> on object initialization in C++ see <i> The Annotated C++</i><br>
<i>Reference Manual</i> , by Margaret A. Ellis and Bjarne Stroustrup, Addison-Wesley,<br>
1990, &amp;sect;12.6.2 (on base/member initialization syntax) and &amp;sect;10.9c (on<br>
virtual function instantiation). *
</p>
<p>
<b>For more information</b> on proposed C++ exception handling see <i> The Annotated C++</i><br>
<i>Reference Manual</i> , by Ellis andStroustrup, &amp;sect;15. *
</p>
<p>
<b>For more information </b>on member access declaration syntax see<i>The Annotated C++</i><br>
<i>Reference Manual</i> , by Ellis and Stroustrup, &amp;sect;11.3.&nbsp;&nbsp;*
</p>
<p>
<b>Thanks to Our Technical Reviewers</b> Dave Radcliffe, Larry Rosenstein, Kent<br>
Sandvik, Brad Silen<b> *</b>
</p>
</body>
</html>
