<html>
<head>
<!-- Article ID: 14 - Extracted from develop-1991 -->
<!-- on 2024-01-04 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by copyright of their respective owners -->
<title>Spring 91 - QUICKDRAW'S COPYBITS PROCEDURE: BETTER THAN EVER IN SYSTEM 7.0</title>
<link href="styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h2>QUICKDRAW'S COPYBITS PROCEDURE: BETTER THAN EVER IN<br>
SYSTEM 7.0</h2>
<h1>KONSTANTIN OTHMER</h1>
<p>
<img src="img/141.gif" width="377 px"></img>
</p>
<p>
<i>With System 7.0 comes a major revision of QuickDraw. The CopyBits procedure,</i><br>
<i>QuickDraw's image-processing workhorse, has had some bugs fixed and some features</i><br>
<i>added. This article gives a brief overview of changes to QuickDraw and then brings you</i><br>
<i>up to speed on changes to CopyBits.</i>
</p>
<p class="spacer">&nbsp;</p>
<p>
We're seeing some impressive examples of computer image processing at the movies<br>
these days. Special effects in movies such as <i> Star Trek III</i> , <i>Willow</i> , <i>Back to the</i><br>
<i>Future</i> , <i>Arachnophobia</i> , <i>Ghost</i> , and<i>The Abyss</i>&nbsp;&nbsp;were either assisted or completely<br>
generated by computer. While QuickDraw TM does not have the built-in ability to<br>
perform the highly specialized image processing necessary to produce the types of<br>
effects seen in those movies, producing such effects is not beyond the capability of the<br>
Macintosh. You can write custom routines to perform such operations as rotation,<br>
warping, and advanced filtering.
</p>
<p>
Before you get to that advanced stuff, though, you need to be familiar with QuickDraw's<br>
basic image-processing capabilities, which provide the starting point for an effects<br>
toolbox. With QuickDraw's CopyBits procedure, you can perform several standard<br>
image-processing operations, such as resizing (by stretching, shrinking, or clipping<br>
the image), colorizing, or changing the pixel depth.
</p>
<p>
CopyBits is better than ever in System 7.0. Improvements to transfer operations and<br>
colorizing mean enhanced results. And it's now easier to use a search procedure to<br>
alter colors. We'll look at these improvements in detail and will see samples of<br>
CopyBits in action after a brief overview of how QuickDraw has evolved.
</p>
<h2>A BRIEF HISTORY OF QUICKDRAW</h2>
<p>
There have been a number of QuickDraw&nbsp;&nbsp;versions since the introduction of the<br>
Macintosh in 1984. Table 1 summarizes the major QuickDraw versions. Many minor<br>
revisions and bug fixes have also occurred along the way, of course.
</p>
<p>
<b>&nbsp;Table 1</b> A Summary of Major QuickDraw Versions
</p>
<p><table border="0"><tr><td><b>Date</b></td><td><b></b><b>Version</b></td><td><b></b><b>Where Documented</b></td></tr>
<tr><td>January 1984</td><td>Original B&amp;W QuickDraw</td><td><i> Inside Macintosh</i></td></tr>
<tr><td></td><td>(Macintosh 128K)</td><td>Volume I</td></tr>
<tr><td>January 1986</td><td>B&amp;W QuickDraw</td><td><i> Inside Macintosh</i></td></tr>
<tr><td></td><td>(Macintosh Plus)</td><td>Volume IV</td></tr>
<tr><td>March 1987</td><td>Color QuickDraw</td><td><i> Inside Macintosh</i></td></tr>
<tr><td></td><td>B&amp;W QuickDraw</td><td>Volume V</td></tr>
<tr><td></td><td>(Macintosh II)</td><td></td></tr>
<tr><td>May 1989</td><td>32-Bit QuickDraw v. 1.0</td><td><i> Inside Macintosh</i></td></tr>
<tr><td></td><td></td><td>Volume VI</td></tr>
<tr><td>September 1989</td><td>32-Bit QuickDraw v. 1.1</td><td><i> Inside Macintosh</i></td></tr>
<tr><td></td><td>(System 6.0.4,</td><td>Macintosh Volume VI</td></tr>
<tr><td></td><td>IIci, IIfx, IIsi, and LC)</td><td></td></tr>
<tr><td>March 1990</td><td>32-Bit QuickDraw v. 1.2</td><td><i> Inside Macintosh</i></td></tr>
<tr><td></td><td>(System 6.0.5)</td><td>Volume VI</td></tr>
<tr><td>April 1991</td><td>Color QuickDraw</td><td><i> Inside Macintosh</i></td></tr>
<tr><td></td><td>B&amp;W QuickDraw</td><td>QuickDraw Volume VI</td></tr>
<tr><td></td><td>(System 7.0)</td><td></td></tr></table></p>
<p class="spacer">&nbsp;</p>
<p class="spacer">&nbsp;</p>
<p>
&nbsp;Note: QuickDraw is revised for system releases and, in the past, major revisions have<br>
coincided with hardware releases. In the future, it's likely that major system releases<br>
will be independent of hardware releases.
</p>
<p>
The version of black-and-white QuickDraw that accompanied the Macintosh Plus<br>
system added the SeedFill, CalcMask, and CopyMask calls. The Macintosh II revision<br>
introduced Color QuickDraw (which supported indexed devices only) and revised the<br>
existing black-and-white QuickDraw (which is still used on 68000-based machines)<br>
to display pictures (data of type 'PICT') created in the color version.
</p>
<p>
Version 1.0 of 32-Bit QuickDraw, released as an INIT at the Developers Conference in<br>
1989, added direct-color capability to QuickDraw. No black-and-white QuickDraw<br>
update was provided. Version 1.1 of 32-Bit QuickDraw is in ROM on the Macintosh<br>
IIci, IIfx, IIsi, and LC. Version 1.2 of 32-Bit QuickDraw, released as an INIT with<br>
System 6.0.5 and patched by the system on machines that have version 1.1 in ROM,<br>
added the OpenCPicture call and the capability of recording font names into pictures.
</p>
<p>
The System 7.0 version of Color QuickDraw integrates the functionality of 32-Bit<br>
QuickDraw into all Color QuickDraw machines and adds a variety of new features and<br>
bug fixes. In addition, System 7.0 has a new version of black-and-white QuickDraw<br>
that includes some of Color QuickDraw's functionality. (See "QuickDraw Features New<br>
in System 7.0" on the next page for more information.)
</p>
<h2>ABOUT COPYBITS</h2>
<p>
The CopyBits procedure, along with the CopyMask and CopyDeepMask calls, is the core<br>
of QuickDraw's image-processing capability. CopyBits transfers a bit image from one<br>
bitmap to another and clips the result to a specified area. With CopyBits you can<br>
perform such image- processing operations as resizing (by stretching, shrinking, or<br>
clipping the image), colorizing, and changing the pixel depth. You can use it to display<br>
on-screen the contents of an off-screen buffer.
</p>
<p>
In the System 7.0 version of QuickDraw, as in previous versions, the CopyBits<br>
procedure is defined as
</p>
<pre>PROCEDURE CopyBits (srcBits,dstBits: BitMap;srcRect,dstRect: Rect;
      mode: INTEGER; maskRgn: RgnHandle);</pre>
<p>
In the original black-and-white QuickDraw, CopyBits used six explicit parameters<br>
(srcBits, dstBits,srcRect, dstRect, mode, and maskRgn) and one global variable<br>
(thePort). The introduction of Color QuickDraw required an additional global variable,<br>
theGDevice, which is used to determine color information for the destination. 
</p>
<p>
Although the number of variables used by CopyBits hasn't changed from earlier<br>
QuickDraw versions, several things <i>have</i>&nbsp;&nbsp;changed:
</p>
<ul>
<li> The way transfer operations specified by the mode parameter are<br>
performed has changed to make their results predictable regardless of<br>
whether the destination device uses indexed or direct color.</li>
<li> The way the notCopy transfer operation is performed has changed to<br>
improve the quality of color inversions.</li>
<li> Dithering has been extended to improve the quality of images resulting<br>
from depth conversion, color mapping, or resizing.</li>
<li> The way colorizing is performed has changed to make the results<br>
predictable for all pixel depths.</li>
<li> The use of search procedures has been extended and now provides an<br>
easier mechanism for altering colors.</li>
</ul>
<p>
In the following sections we'll take a closer look at each of these improvements. We'll<br>
then watch CopyBits in action as we stretch and colorize a gray ramp, and perform<br>
RGB and CMY color separations.
</p>
<h2>IMPROVEMENTS TO TRANSFER OPERATIONS</h2>
<p>
The appearance of the result of the CopyBits procedure is determined by the mode<br>
parameter. This parameter specifies which source transfer mode is to be used and<br>
whether or not dithering should occur during transfer operations. Improvements to<br>
CopyBits in System 7.0 make the results of transfer operations independent of<br>
whether the destination device uses indexed or direct color. The new CopyBits also<br>
improves the results of color inversions and extends the use of dithering.
</p>
<p>
<b>RESULTS INDEPENDENT OF DESTINATION DEVICE</b><br>
Before System 7.0, the transfer mode specified in CopyBits' mode parameter was<br>
implemented directly by one of eight transfer operations: Copy, Or, Xor, Bic, notCopy,<br>
notOr, notXor, and notBic. For each bit in the source bitmap to be drawn, QuickDraw<br>
found the corresponding bit in the destination bitmap, performed the transfer<br>
operation on the pair of bits, and stored the resulting bit into the bit image.
</p>
<p>
This method extended naturally to the use of indexed devices in Color QuickDraw. But<br>
with the introduction of 32-Bit QuickDraw, which supported both indexed and<br>
direct-color devices, the results of the Or, Bic, and Xor transfer operations became<br>
dependent on the type of destination device. Using the Or operation with direct<br>
color--where 0 represents black and $FF represents white--resulted in pixels that<br>
went toward white, while using the Or operation on indexed pixels-- where indexes<br>
typically range from 0 (white) to $FF (black)--had a result that went toward black.<br>
Bic and Xor had similar problems.
</p>
<p>
For example, many applications use the srcXor transfer mode--defined in <i> Inside</i><br>
<i>Macintosh</i>&nbsp;&nbsp;Volume I as inverting destination pixels that are black in the<br>
source--when dragging a selection. In the original Color QuickDraw, this operation<br>
was performed correctly. In 32-Bit QuickDraw, on the other hand, destination pixels<br>
that were <i> white</i>&nbsp;&nbsp;in the source were inverted on direct-color devices.
</p>
<p>
In the new Color QuickDraw, the transfer modes srcOr, srcBic, and srcXor are still<br>
undefined for color pixel values, but behave correctly--that is, as documented in <br>
<i>Inside Macintosh</i>&nbsp;&nbsp;Volume I--with respect to black and white regardless of whether the<br>
destination device uses indexed or direct color. The way these modes work now as<br>
compared to the way they worked in 32-Bit QuickDraw version 1.0 for direct sources<br>
copied to a direct-color device is shown in Figure 1.
</p>
<p>
<img src="img/142.gif" width="500 px"></img>
</p>
<p>
<b>&nbsp;Figure 1</b> Results of Transfer Modes for Direct Source to Direct Destination
</p>
<p>
&nbsp;For all devices now, the srcOr transfer mode produces a black result where the source<br>
is black. The srcXor transfer mode inverts destination pixels where the source is<br>
black. And srcBic (which stands for "bit clear" but may be easier to remember as<br>
"black is changed") produces a white result where the source is black. All three modes<br>
leave the destination pixels under the white part of the source unchanged. (Note that<br>
using these transfer modes for colored sources, while legal, does not always produce<br>
well-defined results.)
</p>
<p>
<b>&nbsp;INVERSIONS IN COLOR SPACE</b><br>
Before System 7.0, notCopy was performed by inverting source index values. In<br>
System 7.0, the inversion takes place in color space, giving a much more pleasing<br>
result. Note that the trade-off for higher quality in this case is reduced speed: this<br>
operation is somewhat slower than in previous versions.
</p>
<p>
&nbsp;Using notSrcCopy mode to highlight items when they've been selected produces good<br>
results on screens of all depths, although it suffers from gray mapping to gray.
</p>
<p class="spacer">&nbsp;</p>
<p>
&nbsp;Figure 2 shows a button ("Squishy") highlighted using notSrcCopy mode.
</p>
<p>
<img src="img/143.gif" width="488 px"></img>
</p>
<p>
<b>&nbsp;Figure 2</b> Button Highlighted Using notSrcCopy Mode
</p>
<h2>EXTENSIONS TO DITHERING</h2>
<p>
32-Bit QuickDraw version 1.0 introduced the dither flag. In that version of<br>
QuickDraw, setting the dither flag (bit 6 of the mode, called ditherCopy) caused<br>
dithering to occur when direct pixMaps were copied to indexed destinations.
</p>
<p>
&nbsp;In System 7.0, setting the dither flag in QuickDraw causes dithering to occur during<br>
any depth conversion or color mapping. For example, you can get a dither when<br>
converting an 8-bit image to a 4-bit image or a 1-bit image, or when copying between<br>
two 4-bit pixMaps that have different color tables. Figure 3 shows the effect of<br>
dithering when depth conversion occurs.
</p>
<p>
<img src="img/144.gif" width="600 px"></img>
</p>
<p>
<b>&nbsp;Figure 3</b> Depth Conversion With and Without Dithering
</p>
<p class="spacer">&nbsp;</p>
<p>
&nbsp;In addition, setting the dither flag now affects how images are resized. In 32-Bit<br>
QuickDraw, only 32-bit pixMaps used a technique of pixel averaging in RGB space<br>
when they were shrunk. All other pixMaps were shrunk using a technique that<br>
maximizes pixel value and tends to turn shrunk pixMaps to black. In System 7.0,<br>
setting the dither flag causes pixMaps of all depths to be averaged when shrunk. Figure<br>
4 shows the effect of dithering when shrinking a 1-bit image and an 8-bit image.<br>
Notice that the dithered result for the 1-bit image includes shades of gray as well as<br>
black and white.
</p>
<p>
&nbsp;Because dithering is a relatively slow process, setting the dither flag tells CopyBits<br>
that quality is more important than speed. Note, however, that direct pixMaps are<br>
always averaged when shrunk, regardless of the state of the dither flag.
</p>
<h2>IMPROVEMENTS TO COLORIZING</h2>
<p>
When CopyBits transfers an image from one bitmap to another, it refers to the<br>
foreground and background color fields of the global variable thePort. The foreground<br>
color specified there is applied to black pixels in the source and the background color<br>
is applied to white pixels. This is known as <i>colorizing</i> .
</p>
<p>
&nbsp;Before System 7.0, colorizing with CopyBits was performed on the indexes of the<br>
colors rather than on the color values. This meant that the results depended on the<br>
organization of the color look-up table (CLUT) of the destination GDevice. Thus, the<br>
results for multicolor images were unpredictable. This problem is illustrated in<br>
Figure 5. This was the basis for the common knowledge that the foreground and<br>
background color in the current grafPort must be set to black and white respectively<br>
or unpredictable results would occur when using CopyBits.&nbsp;&nbsp;In System 7.0, colorizing<br>
occurs in color space, not index space. Thus, colorizing now works as predictably for<br>
deep source pixMaps as it always has for 1-bit source pixMaps.
</p>
<p>
<img src="img/145.gif" width="600 px"></img>
</p>
<p>
<b>Figure 4</b> Resizing With and Without Dithering
</p>
<p>
<img src="img/146.gif" width="600 px"></img>
</p>
<p>
<b>&nbsp;Figure 5</b> Colorizing
</p>
<p>
&nbsp;Colorizing is logically the last step in the CopyBits procedure. It modifies the<br>
destination pixel color as follows: all bits that are off in the source pixel are given the<br>
value of the corresponding bit in the foreground color, and all bits that are on are<br>
given the value of the corresponding bit in the background color. This is illustrated for<br>
a 16-bit pixel in Figure 6. For a foreground color of black<b> 6</b> (all components 0) and a<br>
background color of white (all components $FFFF) this operation does not change the<br>
pixel color value. The formula that performs this operation (in color space) is
</p>
<p>
&nbsp;result = (src AND bkColor) OR ((not src) AND fgColor)
</p>
<p><table border="0"><tr><td><b><code>f15</b></td><td><b><code>f14</code></b></td><td><b><code>f13</code></b></td><td><b><code>f12</code></b></td><td><b><code>f11</code></b></td><td><b><code>f10</code></b></td><td><b><code>f9</code></b></td><td><b><code>f8</code></b></td><td><b><code>f7</code></b></td><td><b><code>f6</code></b></td><td><b><code>f5</code></b></td><td><b><code>f4</code></b></td><td><b><code>f3</code></b></td><td><b><code>f2</code></b></td><td><b><code>f1</code></b></td><td><b><code>f0</code></b></td><td><b><code>fgColor</code></b></td></tr>
<tr><td><b><code>b15</b></td><td><b><code>b14</code></b></td><td><b><code>b13</code></b></td><td><b><code>b12</code></b></td><td><b><code>b11</code></b></td><td><b><code>b10</code></b></td><td><b><code>b9</code></b></td><td><b><code>b8</code></b></td><td><b><code>b7</code></b></td><td><b><code>b6</code></b></td><td><b><code>b5</code></b></td><td><b><code>b4</code></b></td><td><b><code>b3</code></b></td><td><b><code>b2</code></b></td><td><b><code>b1</code></b></td><td><b><code>b0</code></b></td><td><b><code>bkColor</code></b></td></tr>
<tr><td><b><code>1</b></td><td><b><code>0</code></b></td><td><b><code>1</code></b></td><td><b><code>0</code></b></td><td><b><code>1</code></b></td><td><b><code>1</code></b></td><td><b><code>1</code></b></td><td><b><code>1</code></b></td><td><b><code>0</code></b></td><td><b><code>0</code></b></td><td><b><code>0</code></b></td><td><b><code>0</code></b></td><td><b><code>1</code></b></td><td><b><code>1</code></b></td><td><b><code>0</code></b></td><td><b><code>0</code></b></td><td><b><code>source</code></b></td></tr>
<tr><td><b><code>b15</b></td><td><b><code>f14</code></b></td><td><b><code>b13</code></b></td><td><b><code>f12</code></b></td><td><b><code>b11</code></b></td><td><b><code>b10</code></b></td><td><b><code>b9</code></b></td><td><b><code>b8</code></b></td><td><b><code>f7</code></b></td><td><b><code>f6</code></b></td><td><b><code>f5</code></b></td><td><b><code>f4</code></b></td><td><b><code>b3</code></b></td><td><b><code>b2</code></b></td><td><b><code>f1</code></b></td><td><b><code>f0</code></b></td><td><b><code>result</code></b></td></tr></table></p>
<p class="spacer">&nbsp;</p>
<p class="spacer">&nbsp;</p>
<p>
<b>Figure 6</b> How Colorizing Works in System 7.0
</p>
<p>
&nbsp;This operation may seem convoluted at first, but it turns out to be quite useful. For<br>
example, you can invert an image by changing the foreground color to white and the<br>
background color to black. Figure 7 shows some of the variations on one image that can<br>
be obtained simply by changing the foreground and background colors. The code<br>
samples later in this article use CopyBits colorizing to perform CMY and RGB color<br>
separation.
</p>
<p>
<img src="img/147.gif" width="564 px"></img>
</p>
<p>
Figure 7 Colorized Versions of the 32-Bit QuickDraw Icon
</p>
<h2>AN EASIER WAY TO ALTER COLORS</h2>
<p>
In Color QuickDraw, destination color information comes from the current GDevice.<br>
You can attach a search procedure to a GDevice to determine how colors will appear on<br>
that device.
</p>
<p>
Before System 7.0, search procedures were used only when the source and destination<br>
pixMaps had different depths or color tables. In System 7.0, search procedures can be<br>
used in any case--for example, to alter the colors of a pixMap. In addition, the<br>
RGBColor parameter that the search procedure receives is now always a VAR<br>
parameter. (This was not true in 32-Bit QuickDraw for direct-color destinations.)
</p>
<p>
In System 7.0, a search procedure is defined as
</p>
<pre>FUNCTION SearchProc(VAR rgb: RGBColor; VAR position: LongInt)
         : Boolean;</pre>
<p>
On entry, the RGBColor parameter contains the color QuickDraw is trying to represent<br>
on the current device. The search procedure can do one of three things:
</p>
<ul>
<li> It can return the index or the direct-color value (depending on the<br>
device) in the position parameter and a result of TRUE. In this case,<br>
QuickDraw draws using the color returned in the position parameter.</li>
<li> It can modify the RGBColor parameter and return a result of FALSE. In<br>
this case, QuickDraw ignores the position parameter and uses its default color<br>
look-up mechanism on the returned color to find the value to draw with. For<br>
indexed devices, QuickDraw uses an inverse look-up table (ILUT) to<br>
determine which index to represent a given color with. For direct-color<br>
devices, QuickDraw merely truncates each component of the RGBColor<br>
parameter to the desired size: 5 bits for 16-bit color, 8 bits for 32-bit<br>
color.</li>
<li> It can leave the RGBColor parameter unchanged, return FALSE, and still<br>
let QuickDraw do the job using the default algorithm above. </li>
</ul>
<p>
Using a search procedure in this way provides an easy mechanism for altering colors.<br>
For example, to darken an image you simply attach a search procedure that reduces the<br>
RGBColor parameter to a GDevice and then call CopyBits with that device as the<br>
current GDevice.
</p>
<h2>COPYBITS IN ACTION</h2>
<p>
The following code samples show how to do some useful things with the improved<br>
CopyBits found in Color QuickDraw in System 7.0. Example 1 shows how to stretch and<br>
colorize a gray ramp. Although the example is trivial, a number of pitfalls associated<br>
with directly accessing a GWorld's pixMap are addressed.
</p>
<p>
Example 2 shows how to do RGB and CMY color separation with CopyBits, and how to<br>
expand the source picture by a factor of 1.5. It's fairly easy to do RGB and CMY color<br>
separation using CopyBits with the correct foreground and background colors. Note<br>
that CMYK color separation (which removes gray components before separating the<br>
cyan, magenta, and yellow) is generally more useful than the simple CMY separation<br>
performed here. CMYK color separation is usually accomplished by using a search<br>
procedure.
</p>
<p>
<b>EXAMPLE 1: STRETCHING AND COLORIZING A GRAY RAMP</b><br>
The goal in this first example is to produce a red-scale ramp that fills the current<br>
window. The code merely allocates a one-pixel-wide gray-scale line and then uses<br>
CopyBits colorizing to stretch this line to the size of the window.
</p>
<p>
The first thing the code does is allocate a 32-bit off-screen GWorld to hold the<br>
one-pixel- wide line. If the allocation fails, the routine does nothing.Next,<br>
GetGWorldPixMap is used to get a handle to the GWorld's pixMap. Note that this call did<br>
not work in pre-System 7.0 versions of QuickDraw. In those versions you could get<br>
the pixMap handle directly from the GWorld. On black-and-white QuickDraw<br>
machines, you must use GetGWorldPixMap. Note that on these machines you get the<br>
functional equivalent of a pixMap as far as GWorlds are concerned, but you do not get a<br>
true PixMapHandle.
</p>
<p>
The code then locks the pixels. This is necessary since CopyBits can move memory.<br>
Here's what we've got so far:
</p>
<pre>void
DoColorizedCopyBits()
{
    Rect            srcRect;
    long            * bitsPtr;
    short           iii;
    long            jjj;
    RGBColor        myrgb, savergb;
    GDHandle        oldGD;
    GWorldPtr       oldGW;
    GWorldPtr       myOffGWorld;
    PixMapHandle    myPixMapHandle;
    unsigned short  myRowBytes;
    char    mode;

    SetRect( &amp;srcRect, 0, 0, 1, 256 ); 
                                    /* Left, top, right, bottom. */
    if( NewGWorld( &amp;myOffGWorld, 32, &amp;srcRect, 0, 0, 0 ) == noErr)
    {
        myPixMapHandle = GetGWorldPixMap( myOffGWorld ); 
                                                     /* 7.0 only. */
/*      myPixMapHandle = myOffGWorld-&gt;portPixMap;     pre-7.0. */
        LockPixels( myPixMapHandle );</pre>
<p>
Next the code gets the base address of the pixels using the GetPixBaseAddr call. This<br>
call returns a base address that's good in 32-bit addressing mode, so the code saves the<br>
current mode and switches to 32-bit addressing mode. This is necessary to support<br>
accelerators that might keep the GWorld data cached on a card requiring 32-bit<br>
addressing. See "About 32- Bit Addressing" on the next page for more information.
</p>
<pre>/* Get baseAddr good in 32-bit mode. */
        bitsPtr = (long *) GetPixBaseAddr( myPixMapHandle );   
        myRowBytes = (**myPixMapHandle).rowBytes &amp; 0x3fff;
        mode = true32b;     /* Switch to 32-bit mode. */

/* Go to 32-bit addressing mode to access pixels. */
        SwapMMUMode( &amp;mode );</pre>
<p>
Then the code fills the GWorld with a gray ramp. Note that you cannot make other<br>
system calls after you switch the addressing mode, since system calls expect to be<br>
made in the addressing mode the machine was booted in.
</p>
<pre>        for( jjj = 256-1; jjj &gt;= 0; jjj-- )
        {
            *bitsPtr = jjj | (jjj<<8) | (jjj<<16);
            bitsPtr = (long *)((char *)bitsPtr + myRowBytes);
        }</pre>
<p>
Next the code switches back to the prior addressing mode, sets the foreground color to<br>
red, and uses CopyBits to stretch the line to the size of the current port and colorize it<br>
to red. Finally, the foreground color is restored and the GWorld is disposed of.
</p>
<pre>/* Back to old addressing. */
        SwapMMUMode( &amp;mode );
        GetForeColor( &amp;savergb );
        myrgb.red = 0xFFFF;
        myrgb.green = 0;
        myrgb.blue = 0;
        RGBForeColor( &amp;myrgb );
        CopyBits( *myPixMapHandle, &amp;thePort-&gt;portBits, &amp;srcRect,
            &amp;thePort-&gt;portRect, srcCopy, 0 );
        RGBForeColor( &amp;savergb );
        UnlockPixels( myPixMapHandle );
        DisposeGWorld( myOffGWorld );
    }
}</pre>
<p>
<b>EXAMPLE 2: DOING RGB AND CMY COLOR SEPARATIONS AND SCALING A</b><br>
<b>SOURCE PICTURE</b><br>
In addition to doing RGB and CMY color separation, the following code expands the<br>
source picture by a factor of 1.5. When QuickDraw stretches an image, it simply<br>
replicates pixel values. Thus, if you scale an image up by a factor of 3 in both the<br>
horizontal and vertical dimensions, each pixel appears in nine places in the result. But<br>
if you scale an image by a factor of 1.5, only every other pixel is repeated, so source<br>
pixels do not contribute equally to the result.
</p>
<p>
Fortunately, this problem is easy to rectify. Since CopyBits averages when shrinking<br>
with the ditherCopy flag set, you can first scale the image up by a factor of 3 and then<br>
shrink it by a factor of 2. It's easiest to visualize this process by thinking of the<br>
horizontal and vertical dimensions independently. In the vertical direction, each<br>
source pixel is first expanded to three destination pixels. Then, when the image is<br>
shrunk by a factor of 2, CopyBits averages two scanlines to produce each pixel of the<br>
result. The outcome is that each source pixel contributes equally to the result.
</p>
<p>
The following code sample produces CMY color separations that are scaled by 1.5. The<br>
first section of code draws the picture into a GWorld three times the size of the<br>
picture's bounding box.
</p>
<pre>void
CMYColorSeparation()
{
    Rect            dstRect;
    long            * bitsPtr;
    RGBColor        myrgb, savergb;
    GDHandle        oldGD;
    GWorldPtr       oldGW;
    GWorldPtr       myOffGWorld;
    PixMapHandle    myPixMapHandle;

    Rect            bounds;
    PicHandle       myPicHandle;

    #define         PICTResID   1000

    myPicHandle = GetPicture( PICTResID );
    if( !myPicHandle )
        return; /* Failed -&gt; exit. */
    bounds = (*myPicHandle)-&gt;picFrame;
    /* Home the rect (top, left at 0, 0). */
    OffsetRect(&amp;bounds, -bounds.left, -bounds.top);
    dstRect = bounds;
    dstRect.right *=1.5;   
                     /* Final image = 1.5 times size of src image. */
    dstRect.bottom *=1.5;
    OffsetRect( &amp;dstRect, 20, 20 );

    bounds.right *=3;   /* Expand by factor of 3. */
    bounds.bottom *=3;

    if( NewGWorld( &amp;myOffGWorld, 32, &amp;bounds, 0, 0, 0 ) == noErr)
    {
        GetGWorld(&amp;oldGW,&amp;oldGD);
        GetForeColor( &amp;savergb );
        SetGWorld(myOffGWorld,nil);

        EraseRect( &amp;bounds );       /* Clear the GWorld. */
       
        myPixMapHandle = GetGWorldPixMap( myOffGWorld ); 
                                                       /* 7.0 only*/
/*      myPixMapHandle = myOffGWorld-&gt;portPixMap;     pre-7.0. */
        LockPixels( myPixMapHandle );
        DrawPicture( myPicHandle, &amp;bounds );</pre>
<p>
The GWorld now contains the picture blown up three times in both directions. Next it's<br>
copied four times to the window to a dstRect 1.5 times the size of the original picture.<br>
The first three times, the GWorld is color-separated to yellow, magenta, and cyan;<br>
then the original image is drawn.
</p>
<pre>       SetGWorld(oldGW,oldGD);     /* Copy to window. */

/* Get the yellow component. */
        myrgb.red = 0xFFFF;
        myrgb.green = 0xFFFF;
        myrgb.blue = 0;
        RGBForeColor( &amp;myrgb );
        CopyBits( *myPixMapHandle, &amp;thePort-&gt;portBits, &amp;bounds,
            &amp;dstRect, ditherCopy + srcCopy, 0 );
        OffsetRect( &amp;dstRect, 220, 0 );

/* Get the magenta component. */
        myrgb.red = 0xFFFF;
        myrgb.green = 0;
        myrgb.blue = 0xFFFF;
        RGBForeColor( &amp;myrgb );
        CopyBits( *myPixMapHandle, &amp;thePort-&gt;portBits, &amp;bounds,
            &amp;dstRect, ditherCopy + srcCopy, 0 );
        OffsetRect( &amp;dstRect, -220, 220 );

/* Get the cyan component. */
        myrgb.red = 0;
        myrgb.green = 0xFFFF;
        myrgb.blue = 0xFFFF;
        RGBForeColor( &amp;myrgb );
        CopyBits( *myPixMapHandle, &amp;thePort-&gt;portBits, &amp;bounds,
            &amp;dstrect, ditherCopy + srcCopy, 0 );
        OffsetRect( &amp;dstRect, 220, 0 );

/* Copy original image. */
        myrgb.red = 0;
        myrgb.green = 0;
        myrgb.blue = 0;
        RGBForeColor( &amp;myrgb );
        CopyBits( *myPixMapHandle, &amp;thePort-&gt;portBits, &amp;bounds,
            &amp;dstRect, ditherCopy + srcCopy, 0 );
        RGBForeColor( &amp;savergb );
        UnlockPixels( myPixMapHandle );
        DisposeGWorld( myOffGWorld );
    }
}</pre>
<p>
Getting the RGB components is similar. Simply replace the previous four CopyBits<br>
calls with the following:
</p>
<pre>/* Get the red component. */
        myrgb.red = 0;
        myrgb.green = 0;
        myrgb.blue = 0;
        RGBForeColor( &amp;myrgb );
        myrgb.red = 0xFFFF;
        myrgb.green = 0;
        myrgb.blue = 0;
        RGBBackColor( &amp;myrgb );
        CopyBits( *myPixMapHandle, &amp;thePort-&gt;portBits, &amp;bounds,
            &amp;dstRect, ditherCopy + srcCopy, 0 );
        OffsetRect( &amp;dstRect, 220, 0 );

/* Get the green component. */
        myrgb.red = 0;
        myrgb.green = 0xFFFF;
        myrgb.blue = 0;
        RGBBackColor( &amp;myrgb );
        CopyBits( *myPixMapHandle, &amp;thePort-&gt;portBits, &amp;bounds,
            &amp;dstRect, ditherCopy + srcCopy, 0 );
        OffsetRect( &amp;dstRect, -220, 220 );

/* Get the blue component. */
        myrgb.red = 0;
        myrgb.green = 0;
        myrgb.blue = 0xFFFF;
        RGBBackColor( &amp;myrgb );
        CopyBits( *myPixMapHandle, &amp;thePort-&gt;portBits, &amp;bounds,
            &amp;dstRect, ditherCopy + srcCopy, 0 );
        OffsetRect( &amp;dstRect, 220, 0 );

/* Original. */
        myrgb.red = 0xffff;
        myrgb.green = 0xffff;
        myrgb.blue = 0xffff;
        RGBBackColor( &amp;myrgb );
        CopyBits( *myPixMapHandle, &amp;thePort-&gt;portBits, &amp;bounds,
            &amp;dstRect, ditherCopy + srcCopy, 0 );</pre>
<p>
&nbsp;The result of these color separations is shown in Figure 9.
</p>
<p>
<img src="img/148.gif" width="600 px"></img>
</p>
<p>
<b>&nbsp;Figure 9</b> CMY and RGB Color Separations Generated Using CopyBits
</p>
<h2>LATER, DUDE</h2>
<p>
CopyBits is the workhorse at the core of QuickDraw's image-processing capabilities.<br>
As you've learned in this article, it's better than ever in System 7.0. CopyBits<br>
transfer operations now give higher-quality images and produce reliable results for<br>
all pixel depths and regardless of whether the destination device uses indexed or direct<br>
color. The GDevice's search procedure provides an easy way to alter colors. Color<br>
separations have become fairly easy to do. Can Hollywood-style special effects be far<br>
behind?
</p>
<h2>QUICKDRAW FEATURES NEW IN SYSTEM 7.0</h2>
<p>
<b>NEW IN COLOR QUICKDRAW</b>
</p>
<p class="spacer">&nbsp;</p>
<p>
<b>Custom drawing for specific screen depths.</b> The DeviceLoop call lets<br>
applications do custom drawing for specific screen depths rather than having<br>
QuickDraw do the color translation. (If QuickDraw does the translation,&nbsp;&nbsp;a picture of a<br>
color wheel may turn out solid black when drawn on a black-and-white screen.) With<br>
DeviceLoop, you pass a drawing region, flags, and a pointer to a callback procedure<br>
that DeviceLoop will call for each different device that intersects the drawing region.
</p>
<p>
<b>Picture Utilities.</b> The Picture Utilities package ('PACK' 15) provides an easy way<br>
to profile the contents of a picture. It can tell you which fonts are used inside a picture<br>
so you can warn the user if one of the fonts is not available. It can also calculate the<br>
optimal color table or palette (using a predefined color pick method, or you can write<br>
your own) for displaying the picture.
</p>
<p>
<b>Any bit depth for a mask. </b> Before System 7.0, CopyMask's mask parameter could<br>
be only 1 bit deep. This caused the mask to be used very much like a region, selecting<br>
whether or not to copy a specific source pixel. In 7.0, the mask can be any bit depth. It<br>
specifies a blending value for merging the source and destination: black selects the<br>
source, white selects the destination,&nbsp;&nbsp;and gray provides a blend between the source<br>
and destination. Color masks can be used to blend only specific color components.
</p>
<p>
<b>New version of the CopyMask call.</b> The new CopyDeepMask call is an extension of<br>
CopyMask that includes a mode parameter and a region parameter. CopyDeepMask<br>
enables a blend of the source and destination to be applied to the destination using any<br>
transfer mode (not just srcCopy). Like previous versions&nbsp;&nbsp;of CopyMask, CopyMask and<br>
CopyDeepMask calls are not saved in pictures and do not print in System 7.0.&nbsp;&nbsp;(The<br>
resulting image can be printed, of course!) This&nbsp;&nbsp;may change in a future version.
</p>
<p>
<b>NEW IN BLACK-AND-WHITE QUICKDRAW</b>
</p>
<p class="spacer">&nbsp;</p>
<p>
<b>New calls.</b> The calls RGBForeColor, RGBBackColor, GetForeColor, GetBackColor, and<br>
QDError are now available in B&amp;W QuickDraw.
</p>
<p>
<b>Font names in pictures.</b> Font names, rather than just font IDs (which may be<br>
different on different machines), are recorded into pictures, as in 32-Bit QuickDraw<br>
v. 1.2.
</p>
<p>
<b>Custom drawing for specific screen depths.</b> The DeviceLoop call, as described<br>
for Color QuickDraw, exists on all 7.0 machines, but because B&amp;W QuickDraw<br>
supports only one screen device, the call is trivial.
</p>
<p>
<b>Native resolution.</b> OpenCPicture enables you to specify a picture's native<br>
resolution. This makes it easy to create pictures with resolutions other than 72 dpi.<br>
This feature was first available in 32-Bit QuickDraw v. 1.2.
</p>
<p>
<b>Picture Utilities.</b> See description for Color QuickDraw.&nbsp;&nbsp;In B&amp;W QuickDraw, the<br>
Picture Utilities will not return a palette when you request color information.
</p>
<p>
<b>Version 2 pictures.</b> B&amp;W QuickDraw previously could display version 2 pictures<br>
created on color machines, but could create only version 1 pictures. In 7.0, pictures<br>
created with OpenCPicture are version 2.<b>Display of 16- and 32-bit PICTs. </b><br>
Before System 7.0, B&amp;W QuickDraw could display only PICTs containing indexed<br>
pixMap data; in 7.0, it can display pictures containing direct-color data.
</p>
<p>
<b>1-bit GWorlds.</b> In 7.0, 1-bit GWorlds are available&nbsp;&nbsp;in B&amp;W QuickDraw. You must<br>
access the data with GetGWorldPixMap. You cannot dereference the GWorldPtr directly.<br>
On black-and-white machines, GetGWorldPixMap returns a handle to an extended<br>
bitmap (only 1 bit is supported), rather than a pixMap. You can then call<br>
GetPixBaseAddr to access the pixels.
</p>
<h2>ABOUT 32-BIT ADDRESSING</h2>
<p>
If your application needs to directly access the memory in a GWorld, you need to know<br>
some things about 32-bit addressing.
</p>
<p>
<b>A tour through slot space. </b> Slot space, and thus video memory, is at the top of the<br>
memory map, as shown in Figure 8, and sometimes requires 32-bit addressing.
</p>
<p>
In 24-bit mode, slot space ranges from $900000 to $EFFFFF, with 1 MB per slot<br>
($s00000 to $sFFFFF where s = slot number $9 to $E). In 32-bit mode, slot space<br>
ranges from $F9000000 to $FEFFFFFF, with 16 MB per slot ($Fs000000 to<br>
$FsFFFFFF where s = $9 to $E). Super slot space, accessible only in 32-bit mode,<br>
ranges from $90000000 to $EFFFFFFF, with 256 MB per slot ($s0000000 to<br>
$sFFFFFFF where s = $9 to $E).
</p>
<p>
QuickDraw versions before 32-bit QuickDraw always use 24-bit slot space. But<br>
24-bit slot space doesn't permit access to more than 1 MB of video memory, easily<br>
outgrown with 32-bit-per-pixel displays. Thus, video cards with more than 1 MB of<br>
video memory must be addressed in 32-bit mode. 32-Bit QuickDraw always accesses<br>
the screen in 32-bit mode, using either the 32-bit slot space or the super slot space<br>
baseAddr as given by the video ROM. 
</p>
<p>
Let's look at some examples of how cards use slot space&nbsp;&nbsp;if 32-Bit QuickDraw is<br>
running:
</p>
<ul>
<li>The original Macintosh High-Resolution Video Card uses 24-bit slot<br>
space, with a baseAddr of $Fss00000. In 24-bit mode, the stripped address is<br>
$s00000, which maps to slot s in 24-bit slot space. That address also works<br>
with 32-Bit QuickDraw because if it's used in 32-bit mode, it happens to map<br>
to 32-bit slot space as well.</li>
<li>The 8*24 card uses $Fs000000 (32-bit slot space) with 32-Bit<br>
QuickDraw and $Fss00000 (24-bit slot space) with earlier versions. The<br>
8*24 GC card uses $s0000000 (super slot space!) with 32-Bit QuickDraw<br>
and $Fss00000 with earlier versions.</li>
</ul>
<p>
32-Bit QuickDraw correctly handles pixMaps it creates--that is, pixMaps belonging<br>
to GDevices in the DeviceList and to GWorlds. However, if you create your own pixMap<br>
with your own baseAddr, the address is assumed to be good in 24-bit mode. If you pass<br>
QuickDraw a 32-bit base address, you must explicitly indicate that the address is<br>
32-bit by setting bit 2 of the pixMap's pmVersion field.
</p>
<p>
<b>The plot thickens. </b> The issue of 24-bit versus 32-bit addressing becomes<br>
important when you use the GWorld calls to create a GWorld and then access the<br>
GWorld's pixels directly. To get the baseAddr of such a pixMap, you should call<br>
GetPixBaseAddr. This call returns a baseAddr that's good for certain cards only in<br>
32-bit mode. Thus, you should always assume that the address is 32-bit and that you<br>
have to call SwapMMUMode.
</p>
<p>
If you forget to switch to 32-bit mode by calling SwapMMUMode, you've got problems.<br>
But the bug will not appear until you use an 8*24 GC card with a 2 MB DRAM upgrade<br>
kit or any other card that implements GWorlds. Thus, to access the data at the address<br>
returned by GetPixBaseAddr you must switch to 32-bit mode with SwapMMUMode,<br>
call StripAddress on any handle that you dereference, and switch back to the original<br>
mode when you've finished accessing the pixels. Example 1 in this article shows how to<br>
correctly access a GWorld's pixels. Note that you can't make any other system calls<br>
after you've switched from 24- to 32-bit mode, since calls expect to be made in<br>
whatever mode the Macintosh was started up in. 
</p>
<p>
<b>The upshot. </b> To access the pixels of an off-screen GWorld in System 7.0, call<br>
GetPixBaseAddr and switch to 32-bit mode. And test your application with an<br>
accelerator card that implements GWorlds. If you don't want your GWorlds to go out on<br>
a card, you can set the keepLocal flag in NewGWorld--but then you won't get the<br>
benefits of graphics acceleration.
</p>
<p>
<img src="img/149.gif" width="560 px"></img>
</p>
<p>
<b>Figure 8</b>Macintosh II Memory Map in 24-Bit and 32-Bit Mode
</p>
<h2>THE LOW-DOWN ON IMAGE COMPRESSION</h2>
<p>
<b>BY FORREST TANAKA</b>
</p>
<p>
As you know, when pixel data is included in a PICT, the data is usually packed. Pixel<br>
maps that are 8 or fewer bits deep pack fairly well using straight run-length encoding<br>
of bytes (that is, the PackBits routine), but compressing direct pixels using<br>
run-length encoding doesn't work very well.&nbsp;&nbsp;Here's what QuickDraw does with direct<br>
pixels in PICTs:
</p>
<p>
If the packType field contains 1, no compression is done at all. The complete pixel<br>
image is saved in the PICT. If the packType field contains 2 and the pixel map is 32<br>
bits per pixel, all that's done is that the alpha channel byte is removed. So this
</p>
<pre>00 FF FF FF 00 FF FF FF</pre>
<p>
is compressed to this
</p>
<pre>FF FF FF FF FF FF</pre>
<p>
If the packType field contains 3 and the pixel map is 16 bits per pixel, run-length<br>
encoding is done, but not through PackBits. Instead, a run-length encoding algorithm<br>
private to QuickDraw is used. This algorithm is very similar to PackBits, but where<br>
PackBits compresses runs of bytes, this routine compresses runs of words. The format<br>
of the resulting data is exactly the same as described in Technical Note #171, Things<br>
You Wanted to Know About _PackBits, but you'll get words instead. For example, let's<br>
say the 16-bit pixel image begins with these pixel values:
</p>
<pre>AAAA AAAA AAAA 0000 2A2A AAAA AAAA AAAA
AAAA F0F0 0101 2A2A 4F4F AAAA AAAA AAAA</pre>
<p>
After being packed by QuickDraw's internal compression routine, this becomes
</p>
<pre>FEAA AA01 0000 2A2A FDAA AA03 F0F0 0101
*      *            *      *
2A2A 4F4F FEAA AA
          *</pre>
<p>
where the asterisks mark the flag counter bytes. Notice that you can't assume the pixel<br>
values are word-aligned.&nbsp;&nbsp;&nbsp;PackBits packs data 127 bytes at a time, for up to 32,767<br>
total bytes; similarly, the internal compression routine packs data 127 words at a<br>
time. 
</p>
<p>
If the packType field contains 4 and the pixel map is 32 bits per pixel, run-length<br>
encoding via PackBits is done, but only after some preprocessing. QuickDraw first<br>
rearranges the color components of the pixels so that each color component of every<br>
pixel is consecutive. So the following three pixels
</p>
<pre>00 FF FF FF 00 FF C0 00 00 FF 80 00
a0 r0 g0 b0 a1 r1 g1 b1 a2 r2 g2 b2</pre>
<p>
are rearranged to become
</p>
<pre>FF FF FF FF C0 80 FF 00 00
r0 r1 r2 g0 g1 g2 b0 b1 b2</pre>
<p>
In the row below the pixel values a = alpha channel, r = red, g = green, b = blue, and<br>
the number is the pixel offset. The first three bytes are the red components of the<br>
three pixels, the next three bytes indicate the green components of the three pixels,<br>
and so on. The alpha channel isn't included unless the cmpCount field contains 4 rather<br>
than the normal 3. If cmpCount contains 4, all the alpha channel bytes are placed<br>
before the red bytes. Once this is done, PackBits is called to compress the rearranged<br>
data. 
</p>
<p>
These are the only four compression schemes (including no compression) that are<br>
supported for direct pixel maps in PICTs. As always, reading PICTs yourself puts you<br>
in danger of not being able to read PICTs generated by future versions of QuickDraw.<br>
However, for compatibility reasons, these compression algorithms as described here<br>
probably won't change in the future. It's possible that new values for packType could<br>
be implemented, though. 
</p>
<p>
<b>KONSTANTIN OTHMER</b> is a wild man. He whips out books,<i>develop</i>&nbsp;&nbsp;articles, and ski<br>
vacations in less time than it takes most of us to find our keys. We're not sure what<br>
position he plays on the soccer field--maybe it's "guy with the ball." He is, however, a<br>
team player. He works on QuickDraw in the system software group and helps people<br>
out all over the place. The kind of music he likes is from famous bands you haven't yet<br>
heard of. The baby picture here is just a trade show disguise; if you want a hint about<br>
what Konstantin really looks like, check out the Berlin Wall illustration in this<br>
article--if you look carefully you'll find him and Bruce Leak peeking out at you. *
</p>
<p>
<b>FOR MORE INFORMATION</b> The usual sources (<i>Inside Macintosh, </i> Tech Notes) will<br>
soon be augmented by a new QuickDraw book by David Surovell, Frederick Hall, and<br>
Konstantin Othmer in the Macintosh Inside Out series from Addison-Wesley. <br>
<i>Debugging Macintosh Software With Macsbug</i>&nbsp;&nbsp;by Konstantin Othmer and Jim Straus<br>
(Addison-Wesley, 1991) contains a great deal of information on debugging<br>
QuickDraw-related (as well as other) problems. *
</p>
<p>
<b>Thanks to Our Technical Reviewers</b>Rich Biasi, Jean-Charles Mourey, Guillermo<br>
Ortiz, Forrest Tanaka *
</p>
</body>
</html>
