<html>
<head>
<!-- Article ID: 7 - Extracted from develop-1991 -->
<!-- on 2024-01-04 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by copyright of their respective owners -->
<title>Winter 91 - THE POWER OF MACINTOSH COMMON LISP</title>
<link href="../common/styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h2>THE POWER OF MACINTOSH COMMON LISP</h2>
<h1>RUBEN KLEIMAN</h1>
<p>
Macintosh Common Lisp (MCL) is a powerful implementation of the Lisp language as<br>
well as a dynamic development environment. This article describes major aspects of<br>
the MCL language and environment. It provides essential information for non-Lisp<br>
programmers who are unaware of the power of this language or of the MCL<br>
development environment, as well as for Lisp programmers who are unaware of MCL<br>
features or performance.
</p>
<p>
As the price of memory plummets and powerful computers become as cheap as&nbsp;&nbsp;sand,<br>
developers are beginning to look afresh at the positive aspects of dynamic<br>
programming environments, like Lisp and Smalltalk, that once seemed too slow and<br>
memory-hungry. These environments offer the proven ability to generate and run<br>
large-scale applications, easily access the toolbox, and call MPW C, Pascal, or<br>
Assembler programs. With comprehensive and elegant class libraries for defining<br>
user interfaces, these environments promise to significantly improve programmer<br>
productivity over traditional languages.
</p>
<p>
Many Lisp environments are available for the Macintosh. We'll focus here on&nbsp;&nbsp;what one<br>
particular dynamic programming environment, Apple's own Macintosh Common Lisp<br>
(MCL), has to offer. We'll compare it to the programming environment provided by<br>
MPW in conjunction with MacApp, Apple's&nbsp;&nbsp;object-oriented application framework<br>
based on Pascal. We'll take a close look&nbsp;&nbsp;at its key advantages, and will illustrate them<br>
with fragments from a sample program. The entire sample program plus a<br>
step-by-step description of its development can&nbsp;&nbsp;be found on the Developer Essentials<br>
disc that accompanies this issue.
</p>
<h2>WHAT IS MCL?</h2>
<p>
MCL is a powerful implementation of the Lisp language. (If you 're new to Lisp, take a<br>
look at the sidebar "A Mini Lisp Tutorial" for a quick overview of how it differs from<br>
Pascal.) MCL provides full compatibility with the Common Lisp standard, an extensive<br>
object-oriented system, and a rapid prototyping development environment.
</p>
<p>
MCL 2.0 supports Common Lisp and the Common Lisp Object System&nbsp;&nbsp;(CLOS). This<br>
extension of the Common Lisp standard offers an object-oriented programming<br>
paradigm for Lisp, within which MCL implements a class library for developing user<br>
interfaces. The MCL environment includes a syntax-oriented text editor for Lisp; a<br>
direct way to navigate through sources; a tracer, stepper, and backtracer; and the<br>
ability to disassemble code just in case you want to shave off a microsecond.
</p>
<p>
The key advantages of MCL are its interactivity, the inherent power of symbolic<br>
processing in Lisp, the overall consistency of its object library, and its abstraction<br>
away from the Macintosh event-loop style of programming. We'll take a closer look at<br>
these advantages as we compare MCL with MacApp/MPW.
</p>
<h2>A COMPARISON OF MCL AND MACAPP/MPW</h2>
<p>
MCL and MacApp/MPW are both object-oriented programming environments available<br>
from Apple. We'll compare four different aspects of these environments:
</p>
<ul>
<li> Their language bases</li>
<li> Their class libraries and event systems</li>
<li> Their strong points as development environments</li>
<li> Their size and performance specifications</li>
</ul>
<p>
<b>LANGUAGE BASES</b><br>
MacApp is based on ObjectPascal, a set of object-oriented extensions to Pascal<br>
somewhat on a par with the C++ extensions to C. MCL is based on the Common Lisp<br>
standard (ANSI X3J13 Committee), which includes the Common Lisp Object System<br>
(CLOS), an object-oriented extension to Lisp. Table 1 gives an overview of what these<br>
languages offer.
</p>
<p>
The most striking differences in the languages are (1) their syntax (described in&nbsp;&nbsp;the<br>
sidebar "A Mini Lisp Tutorial"), (2) the ability of Common Lisp to deal with typeless<br>
variables, and (3) Common Lisp's automatic garbage collection. Let's turn our<br>
attention to the latter two differences.
</p>
<p>
<b>&nbsp;Table 1</b> Features of ObjectPascal Versus Common Lisp
</p>
<p><table border="0"><tr><td><b>Feature</b></td><td><b></b><b>ObjectPascal</b></td><td><b></b><b>Common Lisp</b></td></tr>
<tr><td>Instance variables</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Class variables</td><td>No</td><td>Yes</td></tr>
<tr><td>Multiple inheritance</td><td>No</td><td>Yes</td></tr>
<tr><td>Inheritance types</td><td>One</td><td>One standard,</td></tr>
<tr><td></td><td></td><td>user-redefinable</td></tr>
<tr><td>Method combination</td><td>Not applicable</td><td>Yes</td></tr>
<tr><td>Before/after methods</td><td>No</td><td>Yes</td></tr>
<tr><td>Methods on instances</td><td>No</td><td>Yes</td></tr>
<tr><td>Method discrimination</td><td>On single argument</td><td>On all arguments</td></tr>
<tr><td>Toolbox interface</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Variable typing</td><td>Required</td><td>Optional</td></tr>
<tr><td>Garbage collection</td><td>Manual</td><td>Automatic</td></tr>
<tr><td>Foreign language interface</td><td>Yes (MPW object files)</td><td>Yes (MPW object files)</td></tr>
<tr><td>Error handling</td><td>Yes</td><td>Yes</td></tr></table></p>
<p class="spacer">&nbsp;</p>
<p class="spacer">&nbsp;</p>
<p>
In Lisp, you need not declare a variable's type. You can assign to a Lisp variable&nbsp;&nbsp;any<br>
type of object, or many types of objects at different times, within a lexical scope. The<br>
type information is associated with the data objects themselves rather than with the<br>
variables. However, declaration statements are available for optimal compilation. A<br>
common practice is not to type variables until the program is thoroughly debugged,<br>
and then to use typing only in the most crucial parts of the code. For better<br>
performance, you can require the run-time system to forego type checking.
</p>
<p>
Common Lisp does automatic garbage collection of inaccessible values (for example,<br>
objects, strings, arrays)--that is, values that are implicitly deallocated. A key<br>
advantage of this is simplification of your code. For example, the following statement<br>
allocates an instance of the class<code>Window</code> and binds it to the variable<code>myWindow:</code>
</p>
<pre>(setq myWindow (make-instance 'Window))</pre>
<p>
If thereafter you set<code> myWindow </code>to a different value, say,
</p>
<pre>(setq myWindow (make-instance 'Dialog))</pre>
<p>
Common Lisp will free up the space occupied by the<code> Window </code>instance (unless,&nbsp;&nbsp;of<br>
course, you've bound it to a different variable or the window is still open). Much of the<br>
power of Lisp derives from the ability to implicitly allocate and deallocate,as well as<br>
to easily access,&nbsp;&nbsp;simple data structures like lists, or complex objects. In contrast,<br>
MacApp requires explicit method calls to allocate, initialize, and deallocate objects. In<br>
both cases, you must explicitly dispose of space that you've allocated from the<br>
Macintosh heap via Memory Manager calls. However, Common Lisp allocates space for<br>
its own objects and other data structures in its own heap area managed by the garbage<br>
collector.
</p>
<p>
We can compare the key features of ObjectPascal and Common Lisp object systems by<br>
inspecting the code needed to define two classes of objects,<code> Beeper </code>and<code> LongBeeper.</code><br>
These classes have a<code> BeepMe </code>method that causes them to beep a number of times<br>
specified by an instance variable.<code>LongBeeper </code>inherits from<code> Beeper. Beeper </code>makes<br>
three short beeps, and<code> LongBeeper</code>makes four long beeps followed by the number of<br>
short beeps<code> Beeper </code>makes. In the ObjectPascal code, we abrogate specifications<br>
otherwise required by the ObjectPascal compiler that don't concern us.
</p>
<p>
Here's the ObjectPascal code:
</p>
<pre>TYPE
    TBeeper = OBJECT
        fBeeps: integer;
        PROCEDURE TBeeper.IBeeper;
        PROCEDURE TBeeper.BeepMe;
        END;

    TLongBeeper = OBJECT(TBeeper)
        fLongBeeps: integer;
        PROCEDURE TLongBeeper.IBeeper;
        PROCEDURE TLongBeeper.BeepMe;
        END;

PROCEDURE TBeeper.IBeeper;
    BEGIN
        SELF.fBeeps := 3;
    END;

PROCEDURE TLongBeeper.IBeeper;
    BEGIN
        INHERITED IBeeper;
        SELF.fLongBeeps := 4;
    END;
PROCEDURE TBeeper.BeepMe;
    VAR Count:  integer;
    BEGIN
        For Count := 1 to SELF.fBeeps do
            SysBeep(30);
    END;

PROCEDURE TLongBeeper.BeepMe;
    VAR Count:  integer;
    BEGIN
        For Count := 1 to SELF.fLongBeeps do
            SysBeep(120);
        INHERITED BeepMe;
    END;

{A function that uses the LongBeeper class}

FUNCTION UseBeeper;
    VAR myBeeper:   TLongBeeper;
    BEGIN
        NEW(myBeeper);
        FailNil(myBeeper);
        myBeeper.ILongBeeper;
        myBeeper.BeepMe;
        UseBeeper := myBeeper;
    END;</pre>
<p class="spacer">&nbsp;</p>
<p>
The same sequence in Common Lisp looks like this:
</p>
<pre>(defclass Beeper ()
    ((Beeps :initform 3)))

(defclass LongBeeper (Beeper)
    ((LongBeeps :initform 4)))

(defmethod BeepMe ((me Beeper))
    (dotimes (count (slot-value me 'Beeps))
        (_SysBeep :word 30)))
(defmethod BeepMe ((me LongBeeper))
    (dotimes (count (slot-value me 'LongBeeps))            
        (_SysBeep :word 120))
    (call-next-method))

;;; A function that uses the LongBeeper
(defun UseBeeper ()
    (let ((myBeeper (make-instance 'LongBeeper)))
       (BeepMe myBeeper)
       myBeeper))</pre>
<p>
Although Common Lisp object system may at first sight seem to have more features<br>
than any particular programmer would need, in fact these capabilities are normally<br>
used by Lisp programmers.
</p>
<p>
Multiple inheritance is an instructive example. If you are trying to define classes with<br>
complementary behavior, multiple inheritance is the most elegant and economical<br>
solution. For example, you can define two classes called<code> ReadStream </code>and<br>
<code>WriteStream </code>that support read-only and write-only behavior for streams,<br>
respectively. This gives you the option of basing a class of read-write streams on<br>
inheritance from these classes:
</p>
<pre>(defclass ioStream (ReadStream WriteStream) ())</pre>
<p>
Since<code> ReadStream </code>and<code> WriteStream </code>are independent, you can also define a class of<br>
windows that act like write-only streams by inheriting from both the<code> Window </code>and<br>
<code>WriteStream </code>classes:
</p>
<pre>(defclass StreamWindow (Window WriteStream) ())</pre>
<p>
Using single inheritance to define<code> ioStream </code>and<code> Window </code>would result in redundant<br>
and unmodular code--one of the problems object-oriented programming tries to solve.
</p>
<p>
As you use multiple inheritance more seriously, however, you may have to deal&nbsp;&nbsp;with<br>
cases where you inherit multiple definitions of the same method. From the viewpoint<br>
of your class's semantics, you will probably want to do one of the following: (1)<br>
inherit all or some of the methods in any order or in a specific order, or (2) inherit<br>
none of the methods. Common Lisp allows you to deal with any of these possibilities.<br>
For example, to avoid inheriting a method, you simply redefine the method for the<br>
class you are defining without making a call to<code>call-next-method.</code> The latter is a<br>
generalization of ObjectPascal's<code> INHERITED </code>(compare above the<code> BeepMe </code>methods for<br>
the<code> LongBeeper </code>class in ObjectPascal and Common Lisp). Method combination is a<br>
feature that enables you to specify the order in which methods of a given name will be<br>
invoked.
</p>
<p>
"Before" and "after" methods enable you to specify behavior that should execute just<br>
before or after your method is invoked. This provides you with flexibility in method<br>
combination in subtle cases because the before and after methods are not embedded in<br>
the code of the primary method. But more interesting is the manner in which Common<br>
Lisp methods are dispatched. Whereas most object- oriented systems dispatch on the<br>
class of the first argument, Common Lisp bases the method dispatch on the class of each<br>
argument passed to a method call. One example of a case in which you may want to<br>
dispatch on two arguments is when you have a<code> Print </code>method that can print on a<br>
variety of media. If you have a class<code> Document </code>that you want to be able to print into<br>
a<code>ColorLaser </code>stream or into an<code> ImageWriter </code>stream, you can define<code> Print </code>as<br>
follows:
</p>
<pre>(defmethod Print ((thingToPrint Document) (stream ColorLaser))
    ;; Code to print to a ColorLaser goes here
)</pre>
<pre>(defmethod Print ((thingToPrint Document) (stream ImageWriter))
    ;; Code to print to an ImageWriter goes here
)</pre>
<p>
This generalizes object-oriented programming's idea that you shouldn't have to <br>
special-case your methods: the appropriate method will be called by the system on&nbsp;&nbsp;the<br>
basis of the type of all passed arguments. In particular, if the second argument<br>
(stream) is a ColorLaser, then the first method above will be called; if the stream is<br>
an ImageWriter, then the second method will be called. The alternative would be to<br>
check what kind of stream you are writing to within a monolithic<code> Print </code>method.
</p>
<p>
<b>CLASS LIBRARIES AND EVENT SYSTEMS</b><br>
Class libraries, which are provided with the language (some third parties sell <br>
alternative libraries or extensions), impose a model of how Macintosh events are<br>
handled, what kinds of Macintosh components (such as menus, dialog boxes) are<br>
available, and how these interact.
</p>
<p>
Both MacApp and MCL offer a set of classes to easily instantiate menu bars, menus,<br>
menu items, pull-down and pop-up menus, windows, dialogs, buttons, check boxes,<br>
static and editable text, lists, and spreadsheet tables. MacApp features extensive <br>
printer (via the<code> TPrintHandler </code>class) and undo (via the<code> TCommand </code>class) support.<br>
MCL features easy installation and handling of view objects, including&nbsp;&nbsp;menus and<br>
menu items.
</p>
<p>
Both systems support views as well as dialog and regular window classes. A view is an<br>
abstract way of defining rectangular drawing areas on the screen that are<br>
hierarchically related to other views. User interface objects, such as windows and<br>
buttons, inherit from the<code> view </code>class to get their scrolling behavior as well as their<br>
own coordinate system's origin. Scrolling a view scrolls its subviews within it, while<br>
the coordinate system of a view has its origin relative to the origin of its superview's<br>
coordinate system. Most useful toolbox controls and dialog items are predefined in both<br>
systems and are integrated with the view system. A set of event-handling methods<br>
defined on all views (for example,<code> activate</code>,<code> draw)</code>are automatically called by the<br>
event system, as necessary; the user need not be involved with the Macintosh inner<br>
event loop.
</p>
<p>
Table 2 compares the most important classes in MacApp and MCL.
</p>
<p>
You'll see examples of the use of some of these MCL classes in the later section "Now<br>
for an Example." For now, a note about the event system.
</p>
<p>
The MacApp class<code> TApplication </code>enables you to modify the handling of the Macintosh<br>
inner event loop. Instead of providing a comparable class, MCL enables you to<br>
optionally specify a function to which all events are passed. Your function can take any<br>
course of action; it can also override the regular MCL event-handling mechanism.
</p>
<p class="spacer">&nbsp;</p>
<p>
<b>&nbsp;Table 2</b> A Comparison of Key Classes in MacApp and MCL
</p>
<p><table border="0"><tr><td><b>MacApp Class</b></td><td><b></b><b>MCL Class</b></td></tr>
<tr><td>TObject</td><td>Standard-Class</td></tr>
<tr><td>TAssociation</td><td>association list</td></tr>
<tr><td>TCommand</td><td>not applicable</td></tr>
<tr><td>TList</td><td>list1</td></tr>
<tr><td>TApplication</td><td>not applicable</td></tr>
<tr><td>TPrint</td><td>Handler not available</td></tr>
<tr><td>TDocument</td><td>not available</td></tr>
<tr><td>TView</td><td>view</td></tr>
<tr><td>TWindow</td><td>window</td></tr>
<tr><td>TDialogView</td><td>dialog</td></tr>
<tr><td>TTEView</td><td>dialog</td></tr>
<tr><td>TDialogTEView</td><td>dialog</td></tr>
<tr><td>TScroller</td><td>scroller-dialog-item2</td></tr>
<tr><td>TDeskScrapView</td><td>scrap-handler</td></tr>
<tr><td>TGridView</td><td>table-dialog-item</td></tr>
<tr><td>TTextGridView</td><td>table-dialog-item</td></tr>
<tr><td>TTextListView</td><td>sequence-dialog-item</td></tr>
<tr><td>TListView</td><td>sequence-dialog-item3</td></tr>
<tr><td>TClassListView</td><td>sequence-dialog-item3</td></tr>
<tr><td>TObjectView</td><td>sequence-dialog-item3</td></tr>
<tr><td>TControl</td><td>control-dialog-item</td></tr>
<tr><td>TCluster</td><td>view</td></tr>
<tr><td>TStaticText</td><td>static-text-dialog-item</td></tr>
<tr><td>TEditText</td><td>editable-text-dialog-item</td></tr>
<tr><td>TNumberText</td><td>editable-text-dialog-item</td></tr>
<tr><td>TIcon</td><td>icon-dialog-item</td></tr>
<tr><td>TPattern</td><td>not available</td></tr>
<tr><td>TPopup</td><td>pop-up-dialog2</td></tr>
<tr><td>TPicture</td><td>pict-dialog-item2</td></tr>
<tr><td>TCtlMgr</td><td>control-dialog-item</td></tr>
<tr><td>TButton</td><td>button-dialog-item</td></tr>
<tr><td>TRadio</td><td>radio-button-dialog-item</td></tr>
<tr><td>TCheckBox</td><td>check-box-dialog-item</td></tr>
<tr><td>TScrollBar</td><td>scroll-bar-dialog-item</td></tr>
<tr><td>TStream</td><td>stream</td></tr>
<tr><td>TFile</td><td>pathname</td></tr>
<tr><td>notavailable</td><td>fred-window</td></tr>
<tr><td>not available</td><td>menu</td></tr>
<tr><td>not available</td><td>menu-item</td></tr></table></p>
<p class="spacer">&nbsp;</p>
<p class="spacer">&nbsp;</p>
<p>
<b>Notes:</b><br>
1.&nbsp;&nbsp;MacApp includes a variety of list classes: these are&nbsp;&nbsp;required because of static<br>
language constraints. The&nbsp;&nbsp;regular Lisp list covers these cases.<br>
2.&nbsp;&nbsp;These classes are distributed in example files with&nbsp;&nbsp;MCL.<br>
3.&nbsp;&nbsp;These MacApp variations are due to static&nbsp;&nbsp;language constraints: they are handled<br>
within the&nbsp;&nbsp;sequence-dialog-item.
</p>
<p>
Macintosh OS events are regularly dispatched by MCL, even between the invocation of<br>
Lisp functions. Every few ticks (the number may vary with the version of MCL that<br>
you are using, but it usually is five ticks), MCL checks the event queue and if there's<br>
an event (including a null one), interprets the event and takes the appropriate action<br>
(for example, sends a<code> mouseDown </code>event to a view). Your functions can act as if they<br>
have full control of the Macintosh, since the event handling is opaque to the user.<br>
However, a macro called<code> without-interrupts </code>helps you to protect critical code<br>
segments, such as an operation on a Mac heap data structure (for instance, a window<br>
record) that might be disposed of by the code dispatched by an interrupting event<br>
(such as a click on the window's close box).
</p>
<p>
On the other hand, MacApp's<code> TView </code>class inherits its event-handling capability from<br>
the<code>TEvtHandler </code>class. For mouse event handling, since views are nested within each<br>
other, the most specific affected view will receive the mouse event: for example, the<br>
<code>HandleMouseDown </code>method of the most specific view under the mouse would be invoked<br>
on that view when the<code> mouseDown</code>event takes place. Events are processed by MacApp<br>
methods (primarily for<code> TApplication</code>,<code>TWindow</code>,<code> TDocument</code>, and certain view<br>
classes) until completion, blocking any other event handling.
</p>
<p>
In MacApp, one can generate<code> TCommand </code>objects, which can be created by menu or<br>
keyboard events. These objects will not only have methods that handle the event, but<br>
also conveniently store state information necessary to support<code> Redo </code>and<code> Undo</code>, which<br>
are necessarily associated with the event they represent. This provides a nice<br>
framework for<code> Undo </code>support, at the cost of generating and maintaining these objects.<br>
In addition, event chains can be specified within MacApp: this enables you to specify a<br>
chain of event-handling objects that are candidates for handling specific types of<br>
events. MacApp will cycle through the chain to find an object that can handle that event<br>
and invoke the appropriate method on that object. Similarly, "target chains" allow you<br>
to specify hierarchies of objects that are candidates for handling events.
</p>
<p>
In general, the MacApp event-handling system is far more articulated than MCL's. The<br>
cost of this articulation is increased complexity and some reduced flexibility. Once you<br>
understand the MacApp event system and find its constraints acceptable for your<br>
application, you may find that your workload is reduced.
</p>
<p>
Note also that menus and menu items are handled in MacApp via special menu<br>
resources. At run time, MacApp invokes the<code> DoMenuCommand </code>method on the<br>
<code>TApplication </code>instance; the latter must interpret what to do on the basis of the<br>
chosen menu item.
</p>
<p>
<b>STRONG POINTS OF THE DEVELOPMENT ENVIRONMENTS</b><br>
Both MacApp (in conjunction with MPW) and MCL offer excellent development<br>
environments. Still, each has its strong points, which we'll focus on here.
</p>
<p>
The primary advantage of the MCL environment is the ability it gives you to<br>
incrementally compile your code: you can recompile one function (or even a single<br>
expression or statement) at a time. This fact has far-reaching implications for how<br>
you develop your program.
</p>
<p>
Once you compile a function, it is automatically linked to the rest of your code. This<br>
means that you can immediately test your function. If it does not work, you either (1)<br>
go to the source code of another function and change it, recompile it, and retry your<br>
original function, or (2) modify, recompile, and retry your function. The MCL (and<br>
every other Lisp-based) debugging and browsing environment is geared to this kind of<br>
activity. Jumping from one function's source text to another one, perhaps in different<br>
files in different directories or volumes, is a simple matter. And you are not required<br>
to execute your program from a "main" but can try out each function as a separate<br>
module.
</p>
<p>
MCL provides you with the following powerful debugging tools:
</p>
<ul>
<li> Inspector--Enables you to inspect any value of any instance variable of<br>
any instance and also to change that value at any time. You can inspect any Lisp<br>
structure, class, or class instance. For functions or methods, the Inspector<br>
will provide you with disassembled code. Information about devices, files,<br>
packages,&nbsp;&nbsp;and other system objects can be conveniently obtained via the<br>
Inspector.</li>
<li> Backtracer--Enables you to examine the execution state of your program<br>
by looking at the program as a set of frames (like a movie's frames). Each<br>
frame is usually a function or method invocation, with information about the<br>
state of all local variables and objects last referenced. You can move through<br>
these frames backward or forward to the point where the error or user break<br>
occurred and can change any state in a frame.</li>
<li> List of definitions--Provides you with a list of definitions of variables,<br>
functions, methods, and macros within your text files. You can go to any<br>
specific entry by double-clicking on it.</li>
<li> Apropos--Allows you to search for information about any object in the<br>
system based on its name.</li>
<li> Error handling--Gives the ability to signal errors and general<br>
conditions. Dead- end and continuable errors are supported. Continuable<br>
errors enable the user to change the environment so that the error state is<br>
reset and processing can restart.</li>
</ul>
<p>
See the sidebar "Evaluating and Navigating the Code in MCL" for key details about the<br>
MCL development environment.
</p>
<p>
In contrast, although in MacApp you can separately compile a class definition&nbsp;&nbsp;(an<br>
ObjectPascal Unit file), to actually test it you must link it to the rest of your program.<br>
Debugging support must be explicitly requested from the compiler and linker;<br>
debugging code is embedded in your running code. Fortunately, the MacApp browser<br>
provides an excellent browsing facility, though it can only read, not write, due to the<br>
absence of incremental compilation. MacApp does provide a debug transcript window<br>
and a debug menu, and Inspector windows when you've compiled your MacApp program<br>
with debug and inspect code, respectively. The Inspector window enables you to<br>
examine the values of fields of class instances. To support the Inspector window you<br>
must write methods for each class you define that know how to supply the necessary<br>
information-- that is, field names and values for any instance--to the Inspector.
</p>
<p>
MacApp and MCL both provide tools to directly manipulate the user interface: ViewEdit<br>
TM and the MCL Interface Tools (IFT), respectively. ViewEdit works mostly by<br>
allowing you to create views and put objects into the views, as necessary: the result is<br>
a set of resources that can be saved for your MacApp application. IFT currently does<br>
not let you define views, but only dialogs and menus. You can create new and modify<br>
existing menu, menu item, dialog, and dialog item objects: the result is actual Lisp<br>
code that can regenerate those objects.
</p>
<p>
The reason ViewEdit generates resources is that the architecture of some parts of<br>
MacApp rely onthe coordination with existing resources (for example, menus),<br>
whereas IFT considers resources as optional additions. IFT can be used for<br>
instructional purposes: for instance, just to see how to program the user interface<br>
objects you create via direct manipulation. Since IFT does not, like PrototyperTM,<br>
build a complete application for you, one tends to use IFT to assist the creation of user<br>
interface code rather than as a replacement for doing the main work.
</p>
<p>
Although both MCL and MacApp/MPW encourage the use of existing class libraries<br>
rather than low- level system access, substantial applications invariably require<br>
direct access either to build new kinds of objects or to increase overall performance.<br>
The MCL toolbox interface can be accessed from two levels: (1) as regular low-level<br>
toolbox register or stack traps, and (2) through predefined higher-level methods<br>
available with the class library (for example, a QuickDraw library). Pascal-style<br>
record definitions, with variant capability like PL/I's, can be used to define any<br>
toolbox handle or pointer-based records. For example, a rect would be defined like<br>
this:
</p>
<pre>(defrecord Rect
    (variant ((top integer 0)
         (left integer 0))
        ((topleft point)))
    (variant ((bottom integer 0)
         (right integer 0))
        ((bottomright point))))</pre>
<p>
This variant specification enables us to describe the rect in any reasonable<br>
combination of top, left, bottom, right, top-left, or bottom-right points. We use&nbsp;&nbsp;the<br>
following code to create a rect and bind it to the variable
</p>
<pre> myRect:

(setq myRect (make-record :rect :top 0 :left 0
                :bottom 100
                :right 100))</pre>
<p>
This calls the Macintosh Memory Manager. A call to the toolbox trap
</p>
<pre> invalrect</pre>
<p>
would look like this:
</p>
<pre>(_InvalRect :ptr myRect)</pre>
<p>
The only argument to this stack trap is the pointer to the rect.
</p>
<p>
Similarly, to allocate a handle:
</p>
<pre>(_NewHandle :check-error :d0 80 :a0)</pre>
<p>
The<code> :check-error </code>parameter tells MCL to signal an error, with error information,<br>
if the trap returns an error. Here,<code> :d0 </code>and<code> :a0 </code>specify the 68000 registers to be<br>
used in this register trap. 80 bytes are requested in<code> :d0</code>, whereas the trap call is<br>
asked to return the value in<code> :a0 </code>(that is, for<code>NewHandle</code><b>,</b> this is the address of the<br>
handle).
</p>
<p>
The MCL foreign function interface will read any MPW-format object file and&nbsp;&nbsp;load any<br>
specific or all entrypoints into MCL. Then, MCL will link the loaded procedures with<br>
the required MPW libraries. From the viewpoint of MCL, the foreign function is<br>
accessed as if it were a Lisp function. For example, if we've compiled a C function<br>
called<code> StringToNumber </code>into the file myProgram.o,&nbsp;&nbsp;we can load and link its code by<br>
evaluating the following form:
</p>
<pre>(ff-load "ff;myProgram.o"
        :ffenv-name 'sample-of-linking-to-mpw
        :libraries '("clib;StdCLib.o"
                "clib;CInterface.o"
                "mpwlib;interface.o"))</pre>
<p>
Now, to define a Lisp function that acts as if it were the C function, we evaluate the<br>
following definition:
</p>
<pre>(deffcfun (StrToNumb "StringToNumber") (string)
    :long)</pre>
<p>
This creates a Lisp function called<code> StrToNumb </code>that takes a string as its input and<br>
returns a long integer. Hereafter, we can call it as follows:
</p>
<pre>    (StrToNumb "198")</pre>
<p>
<b>SIZE AND PERFORMANCE SPECIFICATIONS</b><br>
The price of MCL's flexibility and ease of use becomes apparent when we&nbsp;&nbsp;compare its<br>
size and performance specifications to those of MacApp. While a small MacApp<br>
program might require as little as 40 KB, at press time, MCL 2.0 requires a<br>
minimum of more than 2MB. (Please consult APDA for specific information on the size<br>
requirements for the released product.) A long-term goal of MCL is to reduce this size<br>
by not loading functions you don't use.
</p>
<p>
Insofar as speed is concerned, at the time of this writing the method lookup for MCL is<br>
16 microseconds on a Mac IIcx or 8 microseconds on a Mac IIfx when dispatching on<br>
one argument. The method dispatch in MCL depends somewhat on the number of a<br>
method's arguments, whereas MacApp dispatches on the class of the object only. But<br>
while the speed of MCL is certainly inferior to that of compiled Pascal, with faster<br>
machines and better compiler technology speed is no longer critical for real<br>
applications.
</p>
<p>
The other major disadvantage of MCL is the ubiquitous interference of the garbage<br>
collector. The mark-and-copy garbage collector can freeze the system for up to ten<br>
seconds in its current implementation. This can be inconvenient, to say the least, to<br>
your application's user. Fortunately, work is under way to provide an ephemeral<br>
garbage collector that will incrementally work in the background under the virtual<br>
memory feature of System 7.0. One way to postpone garbage collection (and,<br>
incidentally, often to speed up your code) is to minimize consing--that is, to write<br>
code that uses arrays instead of the commonplace list structures, or, better yet, code<br>
that uses its own memory management by keeping a private pool of free objects. Of<br>
course, the advantages of garbage collection (for example, no memory leaks, no need to<br>
worry about allocating and deallocating memory) should not be forgotten. Since
</p>
<p>
vectors and lists can be treated as<code> Sequence </code>data types, it is possible to write code<br>
that can deal with either data structure.
</p>
<h2>NOW FOR AN EXAMPLE</h2>
<p>
You'll find an example of a program developed in MCL in the LISP folder on the<br>
Developer Essentials disc that accompanies this issue. This sample application<br>
combines some of the features of programs like MacDraw &#174; and HyperCard. Its main<br>
components are as follows:
</p>
<ul>
<li>Windows in which the user can build graphics</li>
<li>Palettes from which tools can be selected and from which graphic objects<br>
can be dragged out</li>
<li>A variety of graphic objects (for example, buttons, fields) that can be<br>
dragged from the palettes to build something in the windows</li>
<li>Menus to simplify the user interface</li>
<li>An event system that approximates HyperCard application's, including the<br>
ability to write scripts for objects--albeit in Lisp</li>
</ul>
<p>
In the same folder, you'll also find "All About the MiniLisp Application," an article that<br>
takes you step by step through the development of the application, in case you really<br>
want to learn the details of how to program using MCL.
</p>
<p>
In the remainder of this article, I'll show selected fragments from that example<br>
program to illustrate some of the features and advantages of MCL mentioned earlier.
</p>
<p>
<b>BUILDING A MENU</b><br>
In our sample application, our File menu has New, Close, and Quit menu items. We<br>
start building the File menu like this:
</p>
<pre>(defvar *mini-application-file-menu*
    (make-instance 'menu :menu-title "File"))</pre>
<p>
First,<code> defvar </code>is the Lisp function we use to define and initialize a global variable: we<br>
have thus initialized the variable<code> *mini-application-file-menu* </code>to contain the<br>
menu instance. Note that Lisp identifiers can be of any length and can consist of any<br>
character; by convention, names of global variables start and end with an asterisk. The<br>
method<code> make-instance,</code>which is similar to<code>New </code>in Smalltalk and in MacApp, enables<br>
us to create an instance from a class, and to optionally initialize some of its slots. (The<br>
term slot is synonymous with instance variable in other object- oriented languages.)<br>
The first argument to<code> make-instance </code>is the name of the class, and the subsequent<br>
arguments are keyword-value pairs with optional initializations that depend on the<br>
class. The predefined MCL class<code> menu </code>is instantiated and the<code> :menu-title </code>keyword<br>
option is initialized with the name
</p>
<p>
of the menu. (The name<code> menu </code>is preceded with a single quotation mark to indicate that<br>
we are referring to the symbol<code> menu </code>rather than to the variable menu.)
</p>
<p>
To test this instance, we invoke the<code> menu-install </code>method on it:
</p>
<pre>(menu-install *mini-application-file-menu*)</pre>
<p>
The menu bar now includes a new File menu. To define a menu item, we evaluate the<br>
following:
</p>
<pre>(defvar *file-new-menu-item*
        (make-instance 'menu-item
                :menu-item-title "New"
                :command-key #\N
                :menu-item-action 'new-menu-item-action))</pre>
<p>
The predefined MCL class<code>menu-item</code> supports, among other things, an optional<br>
command-key character (characters in Lisp are represented by prefixing the<br>
character with #\) and a menu item action. The latter is a function that will be called<br>
when the menu item is selected. In this example, we define the keystroke<br>
combination<code>Command-N</code> to be equivalent to selecting the menu item. We have also<br>
given<code> new-menu-item-action</code>as the name of the function that should be called when<br>
this menu item is selected. The additional keywords<code>:disabled</code>,<code> :menu-item-color</code>,<br>
<code>:menu-item- checked</code>, and<code> :style</code> (none of which are used here) enable us to<br>
specify whether the menu item should be disabled, the color of the parts of the menu<br>
(such as background, text), whether the item should be checked, and its style. 
</p>
<p>
We install the new menu item on the File menu by typing and evaluating the following<br>
in a text window:
</p>
<pre>(add-menu-items *mini-application-file-menu*
        *file-new-menu-item*)</pre>
<p>
<code>add-menu-items </code>is a predefined MCL method for menus that allows us to add one or<br>
more menu items to a menu--whether the menu is installed or not. <b>CUSTOMIZING</b><br>
<b>OUR WINDOW</b>
</p>
<p class="spacer">&nbsp;</p>
<p>
We customize the MCL window for our application by creating a subclass of the<br>
predefined<code>window </code>class. Our new class includes a slot<code> my-items </code>that will hold a list<br>
of all the graphic objects that we draw into the window, remembering their<br>
back-to-front ordering. We start by creating a subclass of the<code> window </code>class named<br>
<code>draw-dialog</code>.<code> defclass </code>is the CLOS function for defining a class:
</p>
<pre>(defclass draw-dialog (window)

    ((my-items :initarg my-items :initform NIL) ; Items in window
     (item-last-under-mouse :initarg item-last-under-mouse
                    :initform NIL)          ; Item under the mouse
     (browse-mode :initarg browse-mode:initform NIL) ; Window mode
     (selections :initarg selections :initform NIL))
                        ; Item(s) now selected
    (:documentation "This class defines our windows"))</pre>
<p>
Our class<code> draw-dialog </code>adds four slots named<code> my-items</code>,<code>browse-mode</code>,<br>
<code>item-last-under-mouse</code>, and<code> selections</code>to its superclass,<code> window</code>. The first<br>
argument to<code> defclass </code>is the name of the class,<code> draw-dialog</code>, followed&nbsp;&nbsp;by a list<br>
with the names of all classes, if any, from which we want to inherit (that is, that we<br>
want our class to be a subclass of)--in our case, just the<code> window </code>class. As mentioned<br>
earlier, multiple inheritance is supported and although things are, by default,<br>
inherited in the order in which they appear in this list, protocols are available in the<br>
CLOS specification for controlling this. (This "meta-object" protocol is not yet<br>
supported in MCL.) The third and fourth arguments shown here are a list of<br>
descriptors for each new slot that we want to define and documentation text,<br>
respectively.
</p>
<p>
A descriptor is a list that starts with the name of the slot followed by a set of<br>
keyword-value pairs that represent options concerning how the slots get initialized<br>
when an instance of this class is created. We used the<code>:initform</code> keyword followed by<br>
the the expression NIL. This means that when an instance of<code>draw-dialog</code> is created,<br>
the<code>my-items</code> slot will by default be set to whatever the following expression evaluates<br>
to--that is, NIL. The<code>:initarg</code>keyword, on the other hand, is followed by the name by<br>
which this slot will be recognized in future slot accesses--in particular, how the slot<br>
will be referenced within a call to<code>make-instance.</code>
</p>
<p>
The<code> draw-dialog </code>class will inherit slots from the<code> window </code>class and from the<br>
classes it inherits from. We can verify that this new subclass definition works by<br>
creating an instance of it:
</p>
<pre>(setq my-window (make-instance 'draw-dialog))</pre>
<p>
One way to check whether the slot<code> my-items </code>has been added and initialized to NIL is to<br>
get its value directly, via the expression
</p>
<pre>(slot-value my-window 'my-items)</pre>
<p>
Another way to check this slot is by using the Lisp Inspector to viewthe object<br>
instance. The Inspector provides us with a description of any object (this includes<br>
constants, variables, and functions) that we want to look at. In addition the Inspector<br>
will allow us to directly edit values. To inspect the instance in<code>my-window</code>, we evaluate<br>
<code>(inspect my-window)</code>, which brings up a screen that looks like Figure 3.
</p>
<p>
<img src="img/130.gif" width="600 px"></img>
</p>
<p>
<b>Figure 3</b>Viewing an Instance of the draw-dialog Class in the Inspector
</p>
<p class="spacer">&nbsp;</p>
<p>
The items following<code>Local slots:</code>are slots of the object bound to<code>my-window</code>. The slots<br>
that we added should be at the top, as shown; the remaining slots have been inherited<br>
from the<code>window</code>class.&nbsp;&nbsp;For example, the slot<code>wptr</code> contains the pointer to the Macintosh<br>
window definition block, and<code>view-size</code> is the point (that is, a long used as a point) for<br>
the window's size. To inspect the window block itself, we can double-click on the line<br>
in Figure 3 with the<code>wptr</code> to get the display shown in Figure 4. 
</p>
<p>
<img src="img/131.gif" width="558 px"></img>
</p>
<p>
<b>Figure 4</b> Viewing the Window Record for Our Instance of draw-dialog in the Inspector
</p>
<p>
&nbsp;We could continue this process indefinitely--for example, looking next at the<br>
rectangle records in the window record. This illustrates a point made earlier: although<br>
Lisp is a very high-level language, you can still access the system as if writing in<br>
assembler language. This clarifies toolbox access considerably when compared with C<br>
and Pascal.
</p>
<p>
&nbsp;The complete source code goes on to define the behavior of our window,&nbsp;&nbsp;including<br>
making the window handle events in the way that HyperCard does.&nbsp;&nbsp;See the CD-ROM if<br>
you are interested in details.
</p>
<p>
<b>CREATING OUR PALETTE</b><br>
Our palette has two kinds of objects in it:
</p>
<ul>
<li> Tools to select what should be done</li>
<li> Objects that can be dragged into our windows</li>
</ul>
<p>
The<code> draw-dialog </code>class can do most of the work for us, so we define a subclass of it<br>
called<code>palette </code>as follows:
</p>
<pre>(defclass palette (draw-dialog)
    ((my-tools :initarg :tools)
     (my-draw-items :initarg :draw-items))
    (:documentation "Palettes used in our application"))</pre>
<p>
The<code> my-tools </code>slot will contain all the items in the palette that can be viewed as tools,<br>
whereas the<code> my-draw-items </code>slot will contain all the items that can be dragged out of<br>
the palette into other windows. These slots will be initialized with instances of tools<br>
and graphic items that will be used in any one session of our application. Once a palette<br>
is created and initialized, a layout method (in CD ROM sources) will look at these slots<br>
to figure out how to lay out the items--for example, tools first and draggable items<br>
next. These are convenience slots, since graphic items themselves know whether they<br>
are tools or not.
</p>
<p>
We have to enforce the following differences between our<code> palette </code>and<code>draw-dialog</code><br>
classes:
</p>
<ul>
<li> Since tools are not accessible to users, a convenient place to put the code<br>
that does the tool's work when it is clicked is the tool's<code> mouse-down </code>event<br>
handler.</li>
<li> Items in our palette cannot be moved within or resized in the palette.</li>
<li> Tools cannot be dragged out of the palette.</li>
</ul>
<p>
First, we want to make sure that a palette's tools get the<code> mouse-down </code>event whether<br>
or not we are in author mode. We redefine<code>view-click-event-handler </code>this way:
</p>
<pre>(defmethod view-click-event-handler ((palette palette) where)
    (let ((item (find-view-containing-point palette where)))
        (if (slot-value item 'tool)
            (mouse-down item where))    ; dispatch the
                                        ; mouse-down event
        (call-next-method)))            ; proceed with the
                                        ; usual behavior</pre>
<p>
If an item is selected and if it is a tool, we force the<code> mouse-down </code>and then&nbsp;&nbsp;call the<br>
<code>draw-dialog</code>'s<code> view-click-event-handler </code>method using<code>8call-next-method.</code> The<br>
check<code> (slot-value item 'tool) </code>anticipates that the tool slot of an item tells it<br>
whether it is a tool or not.
</p>
<p>
Finally, since the resizing and dragging is done by the items themselves, items that<br>
know themselves to be in the palette should not allow themselves to be dragged&nbsp;&nbsp;or<br>
resized around a palette (but they should let themselves be dragged to other windows!).<br>
Similarly, items that are tools will know better than to drag themselves out of a<br>
palette!
</p>
<p>
<b>CREATING DRAW ITEMS</b><br>
In our application, the graphic items have been delegated most of the work by the other<br>
classes. We define one basic class of graphic items from which tools and other kinds of<br>
user interface objects will derive.
</p>
<pre>(defclass draw-item (dialog-item)
    ((rectangle :initarg :rect :initform nil)
     (tool :initarg :tool :initform nil)
     (selected :initform nil)
     (name :initarg :name :initform ""))
    (:documentation "The user interface objects"))</pre>
<p>
&nbsp;We call our class<code> draw-item.</code>It will be a subclass of MCL's<code> dialog-item </code>class. The<br>
latter class supports a variety of specializations for typical Macintosh user interface<br>
items, like radio and round buttons, check boxes, and static text. Since&nbsp;&nbsp;we don't want<br>
to duplicate that functionality, we subclass from<code> dialog-item.</code> Since<code> dialog- item</code><br>
itself inherits from the class<code> view </code>(actually, from<code> simple-view</code>--but let's not<br>
split hairs here), we get all the functionality we need without using multiple<br>
inheritance! We can verify this provenance by inspecting&nbsp;&nbsp;the class object for<br>
<code>draw-item </code>using the Inspector, as shown in Figure 5.
</p>
<p>
<img src="img/132.gif" width="600 px"></img>
</p>
<p>
<b>&nbsp;Figure 5</b> The Class Precedence List for draw-item
</p>
<p>
&nbsp;You will notice that our<code> draw-item </code>not only inherits from<code> simple-view</code>,&nbsp;&nbsp;&nbsp;but also<br>
from<code> stream.</code> The latter class allows one to apply<code> format</code>,&nbsp;&nbsp;<code> print</code>, and other<br>
<code>stream</code> (input/output) methods to our items!
</p>
<p>
<code>&nbsp;draw-item</code>'s<code> rectangle </code>slot will be used to keep the bounds of the<br>
<code>draw-item.</code>These bounds will be the same as one would obtain by using the methods<br>
<code>view- position </code>and<code> view-size </code>when applied to the item, but will be much more<br>
efficient than making two method calls. The<code> tool </code>slot tells us whether the item is a<br>
tool or not.&nbsp;&nbsp;The<code> selected </code>slot tells us whether the item is selected (note that this<br>
information is redundant since it is also maintained in the window's<code>selections </code>slot).<br>
Finally, a<code> name </code>for the draw item.
</p>
<p>
Our code goes on to define the behavior of the draw item. We won't take the space to<br>
discuss it here, but do want to show the<code> resize </code>and<code> drag </code>methods.
</p>
<p>
The<code> resize </code>method looks like this:
</p>
<pre>(defmethod resize ((item draw-item) current-mouse-loc)
         (let* ((resize-direction (get-resize-direction
                        item current-mouse-loc))
         (topleft (view-position item))
         (size (view-size item))
         (bottomright (add-points topleft size))
         (top (point-v topleft))
         (left (point-h topleft))
         (bottom (point-v bottomright))
         (right (point-h bottomright))
         new-mouse-loc new-mouse-h new-mouse-v
         ;; Two regions to produce inverted effect:
         (old-resize-region (new-region))
         (new-resize-region (new-region))
         ;; The rectangle enclosing the window
         (window-rectangle (rref (wptr item)
            :window.portrect))
         ;; The rectangle enclosing the draw-item:
         (item-rectangle (slot-value item 'rectangle))
         (window (view-container item)))
    (_inverrect :ptr item-rectangle)
    (unwind-protect
      (loop ; until the mouse is released
        (if (not (mouse-down-p))
          (return nil)) ; We're through!
  ;; Update the location of the mouse in window coordinates
        (setq new-mouse-loc (view-mouse-position window)
              new-mouse-h (point-h new-mouse-loc)
              new-mouse-v (point-v new-mouse-loc))
        ;; Do resize graphics if mouse is within the window:
        (when (point-in-rect-p window-rectangle new-mouse-loc)
          (_RectRgn :ptr old-resize-region
                    :ptr item-rectangle)
          (case resize-direction
            (:top (and (&lt; new-mouse-v bottom)
                       (rset item-rectangle
                    :rect.top new-mouse-v)))
            (:bottom (and (&gt; new-mouse-v top)
                          (rset item-rectangle
                    :rect.bottom new-mouse-v)))
            (:left (and (&lt; new-mouse-h right)
                        (rset item-rectangle
                    :rect.left new-mouse-h)))
            (:right (and (&gt; new-mouse-h left)
                         (rset item-rectangle
                    :rect.right new-mouse-h)))
            (:topleft (and (&lt; new-mouse-v bottom)
                           (&lt; new-mouse-h right)
                           (rset item-rectangle
                    :rect.topleft new-mouse-loc)))
            (:topright (when (and (&lt; new-mouse-v bottom)
                                  (&gt; new-mouse-h left))
                         (rset item-rectangle
                    :rect.right new-mouse-h)
                         (rset item-rectangle
                    :rect.top new-mouse-v)))
            (:bottomleft (when (and (&gt; new-mouse-v top)
                                    (&lt; new-mouse-h right))
                           (rset item-rectangle
                    :rect.left new-mouse-h)
                           (rset item-rectangle
                    :rect.bottom new-mouse-v)))
            (:bottomright (and (&gt; new-mouse-v top)
                               (&gt; new-mouse-h left)
                           (rset item-rectangle
                :rect.bottomright new-mouse-loc))))
     (_RectRgn :ptr new-resize-region :ptr item-rectangle)
     (_xorrgn :ptr new-resize-region :ptr old-resize-region
                   :ptr old-resize-region)
          (_inverRgn :ptr old-resize-region)
          ))
      (_inverrect :ptr item-rectangle)
      (set-view-size item (subtract-points
                        (rref item-rectangle
                        :rect.bottomright)
                            (rref item-rectangle
                            :rect.topleft)))
(set-view-position item (rref item-rectangle :rect.topleft))
(dispose-region old-resize-region)
(dispose-region new-resize-region))))</pre>
<p>
The<code> resize</code> method illustrates the use of direct stack-based toolbox calls: these are<br>
the functions whose names are prefixed by the underscore (_) character,<br>
like<code>_inverrect</code>. In these calls, you can only pass a pointer, a single word, or a<br>
double word. You must take all the precautions you would if you were calling the traps<br>
from assembler. As a matter of fact, you are at assembler level when you make these<br>
calls: you can pass pointers or handles or a long number in a double word: you're the<br>
boss. 
</p>
<p>
Another important feature of Common Lisp to observe in<code> resize</code>is the<br>
<code>unwind-protect </code>construct.&nbsp;&nbsp;This enables you to protect an expression (in this case,<br>
the long expression enclosed within the<code>loop)</code>in case there's an error during its<br>
execution. The<code> unwind- protect </code>guarantees that the expressions following the<br>
protected expression will be executed despite the error. We thus ensure that all the<br>
regions created for<code> resize </code>will be disposed of even if the routine crashes.
</p>
<p>
Here's the<code> drag </code>method:
</p>
<pre>(defmethod drag ((item draw-item) current-mouse-loc)
  (let ((start-position (view-position item)); Start of the drag
        (end-position nil)                   ; End of drag
        (item-region (new-region))           ; What are we dragging?
        (window (view-container item))       ; Where are we dragging?
        (destination-window nil)             ; Where did drag end?
        (drag-offset nil))                   ; Drag offset

    (unwind-protect ; dispose regions despite errors
      (progn
 
        ;; Define the region that we want to drag:
        (open-region window)
        (with-port (wptr item)
          (_framerect :ptr (slot-value item 'rectangle)))
        (close-region window item-region)
       
        ;; Do the drag and get the offset of the drag:
        (setq drag-offset
              (drag-inverted-region (view-container item)
            item-region :start current-mouse-loc))
       
        ;; Find out in which window the item landed:
        (setq end-position (add-points start-position drag-offset)
              destination-window (find-draw-dialog-in-point
                        (add-points end-position
                                            (view-position window))))
       
        (when destination-window    ; Do nothing if it lands nowhere
          (if (eq window destination-window)
            ;; Move within this window:  set the item's
            ;; position at the end of the drag:
            (unless (eq (type-of window) 'PALETTE)  
                                           ; No drags within PALETTE
              (set-view-position item end-position))
            ; Move to another window: drop it there
            (move-item-to-window item end-position window
                                                destination-window))
          (view-draw-contents item)))
     
      (dispose-region item-region))))</pre>
<p>
&nbsp;The<code> drag </code>method creates a region around the bounds of the thing to be&nbsp;&nbsp;dragged and<br>
calls the function<code> drag-inverted-region</code>, which enables drags&nbsp;&nbsp;to occur between as<br>
well as within windows and returns an offset to where the item was dragged. If the<br>
destination window is the same as the window where the drag&nbsp;&nbsp;started and the window is<br>
a palette, we want to do nothing since we can't have&nbsp;&nbsp;a drag within a palette. Otherwise,<br>
we adjust the position of the item using<code> set-view-position</code>. If the move is to another<br>
window, then we use<code> move-item-to-window</code>. The latter will interpret a drag as a<br>
clone of the item if the drag started on a palette and ended in a<code> draw-dialog</code> window,<br>
or else it will interpret it as a simple drag.<code> move-item-to-window </code>uses the MCL<br>
<code>view </code>methods<code> add-subviews </code>and<code> remove- subviews </code>to add and remove the items<br>
from the source and destination windows. If there's a clone, the function<code> clone-draw-</code><br>
<code>item </code>is called and the item is added to the destination window.<code> move-item-to-window</code><br>
ends by selecting the destination window.
</p>
<p>
<b>&nbsp;CREATING A DOUBLE-CLICKABLE APPLICATION</b><br>
&nbsp;You can create a double-clickable version of your application using&nbsp;&nbsp;the MCL function<br>
<code>save-application</code>. This allows you to&nbsp;&nbsp;distribute your final application for run-time<br>
use, without the rest of&nbsp;&nbsp;the MCL development environment.
</p>
<h2>TO SUM UP</h2>
<p>
&nbsp;Macintosh Common Lisp offers many advantages that are beginning to look more<br>
attractive to developers as faster machines and cheaper memory minimize its<br>
drawbacks. Advantages like multiple inheritance; typeless variables; abstraction away<br>
from Macintosh event-loop style of programming; the ability to implicitly allocate and<br>
deallocate, as well as to easily access, simple data structures like lists or complex<br>
objects; a large and consistent class library; and the ability to incrementally compile<br>
code outweigh MCL slower speed and larger memory requirements. If this taste of MCL<br>
has made you want to learn more, see the Developer Essentials disc and the following<br>
list of recommended reading.
</p>
<p>
<b>A MINI LISP TUTORIAL</b>
</p>
<p>
This tutorial gives a quick overview of Lisp, but it omits many things, like macros and<br>
other intimidating nested monsters. Excellent books on Lisp are available to suit most<br>
tastes: see the list of recommended reading at article's end.
</p>
<p>
Lisp belongs to the Functional Programming Language family. A key point is that every<br>
Lisp function or expression always returns a value--whether you want it to or not! It<br>
is thus difficult to talk about Lisp "programs" because there is no preferred "entry<br>
point" or "main."
</p>
<p>
Lisp functions differ from, say, Pascal functions in that in Lisp the function name is<br>
enclosed in parentheses along with its arguments:
</p>
<p><table border="0"><tr><td><b>Pascal</b></td><td><b></b><b>Lisp Equivalent</b></td></tr>
<tr><td><code>SysBeep(120);</code></td><td><code></code><code>(SysBeep 120)</code></td></tr>
<tr><td><code>ResError;</code></td><td><code></code><code>(ResError)</code></td></tr></table></p>
<p class="spacer">&nbsp;</p>
<p class="spacer">&nbsp;</p>
<p>
To assign a value to a global variable, you must declare the variable as global before<br>
using it and then use the assignment function<code> setq:</code>
</p>
<p><table border="0"><tr><td><b>Pascal</b></td><td><b></b><b>Lisp Equivalent</b></td></tr>
<tr><td><code>VAR x: integer;</code></td><td><code></code><code>(defvar x nil)</code></td></tr>
<tr><td><code>...</code></td><td></td></tr>
<tr><td><code>x := 2;</code></td><td><code></code><code>(setq x 2)</code></td></tr></table></p>
<p class="spacer">&nbsp;</p>
<p class="spacer">&nbsp;</p>
<p>
Control statements like<code> IF </code>and<code> CASE </code>are available:
</p>
<p><table border="0"><tr><td><b>Pascal</b></td><td><b></b><b>Lisp Equivalent</b></td></tr>
<tr><td><code>if x = 2</code></td><td><code></code><code>(if (= x 2)</code></td></tr>
<tr><td><code>then SysBeep(30)</code></td><td><code></code><code>(SysBeep 30)</code></td></tr>
<tr><td><code>else x := 0;</code></td><td><code></code><code>(setq x 0))</code></td></tr></table></p>
<p class="spacer">&nbsp;</p>
<p class="spacer">&nbsp;</p>
<p class="spacer">&nbsp;</p>
<p><table border="0"><tr><td><code>case x of</code></td><td><code></code><code>(case x</code></td></tr>
<tr><td><code>1: Sysbeep(30);</code></td><td><code></code><code>(1 (SysBeep 30))</code></td></tr>
<tr><td><code>2: x := 10;</code></td><td><code></code><code>(2 (setq x 10))</code></td></tr>
<tr><td><code>3: x := 20;</code></td><td><code></code><code>((3 4) (setq x 20 )))</code></td></tr>
<tr><td><code>4: x := 20;</code></td><td></td></tr></table></p>
<p class="spacer">&nbsp;</p>
<p class="spacer">&nbsp;</p>
<p>
The simplest use of Common Lisp's powerful repeat control structure, called<code> loop,</code> is<br>
as follows:
</p>
<p><table border="0"><tr><td><b>Pascal</b></td><td><b></b><b>Lisp Equivalent</b></td></tr>
<tr><td><code>x := 0;</code></td><td></td></tr>
<tr><td><code>repeat</code></td><td><code></code><code>(loop for x from 1 to 5</code></td></tr>
<tr><td><code>x = x + 1;</code></td><td><code></code><code>do (SysBeep 30))</code></td></tr>
<tr><td><code>SysBeep(30);</code></td><td></td></tr>
<tr><td><code>until x = 5</code></td><td></td></tr></table></p>
<p class="spacer">&nbsp;</p>
<p class="spacer">&nbsp;</p>
<p>
Function arguments are evaluated from left to right<i> before </i> they are actually passed to<br>
the function. The&nbsp;&nbsp;only exception to this is the function<code> defmacro </code>(and related ones)<br>
used to create macros.
</p>
<p>
The function<code> quote </code>helps you to pass a symbol or&nbsp;&nbsp;a list instead of passing whatever<br>
the symbol or list evaluates to. For example, if the symbol<code> x </code>is bound to 19 and<code> foo</code><br>
is some function, then evaluating<code> (foo x) </code>will result in<code> foo </code>being passed the value<br>
19, but<code>(foo (quote x)) </code>will be passed the symbol<code> x.</code>A short form for<code> quote </code>is a<br>
single quotation mark: for example,<code> (foo (quote x)) </code>=<code> (foo 'x)</code>.
</p>
<h2>EVALUATING AND NAVIGATING THE CODE IN MCL</h2>
<p>
&nbsp;When you first open an MCL application, you see the window known as the Lisp<br>
Listener. The Listener serves the same purpose as the message box does for HyperCard.<br>
It reads whatever you type into it, evaluates it as a Lisp expression, and prints out the<br>
value returned by the evaluation (remember that<i>all</i> Lisp expressions return a value).<br>
This process is called the read-eval-print loop. 
</p>
<p>
&nbsp;When you evaluate expressions in the Listener or in&nbsp;&nbsp;text windows (which you get by<br>
choosing New from the File menu), you get immediate feedback without having to<br>
explicitly compile or link the expressions you enter. Similarly, evaluating a function<br>
you've just coded means that the function is already compiled and linked: you are ready<br>
to use it!
</p>
<p>
&nbsp;Navigating the code in MCL is also a simple matter. If you are looking for the source of<br>
a function but are not sure what it is called, you can use the Apropos dialog. You<br>
suggest name fragments, and get back the names of variables, functions, methods, or<br>
other defined symbols that contain the fragment. If you find what you're looking for<br>
there, you need only double-click on the returned name for the system to bring up the<br>
file containing the desired definition and to position the cursor at the beginning of it. 
</p>
<p>
&nbsp;When you are studying the code of the function and you see functions it calls that you<br>
want to inspect, you need only click on the function name with the Command and Option<br>
keys pressed, and its definition will be shown to you in a text window.
</p>
<p>
&nbsp;If you want to optimize your function, you can inspect it by using the Inspector--for<br>
example,<code> (inspect (fboundp 'my-function-name))</code>. The Inspector window<br>
includes the disassembled code of the function. Or you can more directly examine its<br>
assembler code by using the disassembler--for example,<code> (disassemble</code><br>
<code>'my-function-name)</code>.
</p>
<p>
<img src="img/133.gif" width="588 px"></img>
</p>
<p>
<b>&nbsp;Figure 1</b> A Sample Backtrace
</p>
<p class="spacer">&nbsp;</p>
<p>
&nbsp;When an error is signaled, you can use a Backtrace window to check how you got<br>
there--for example, to see which functions were called before this one, which<br>
parameters were assigned to them, and to inspect the values of local variables. (Figure<br>
1 shows a backtrace for a division by zero error.) You can automatically invoke the<br>
Inspector on any value in the Backtrace window by double-clicking on that value. If<br>
you want to get documentation for a function, you&nbsp;&nbsp;can click on the name of the function<br>
and choose the Documentation menu item, or press Control-X followed by Control-D to<br>
get it. If you'd like to get the formal
</p>
<p>
&nbsp;argument list for it, you can click on its name and press Control-X followed by<br>
Control-A.
</p>
<p>
&nbsp;Once you're inside a text window (officially called a Fred* window), you can do<br>
incremental searches backward and forward without the need of dialogs. In addition,<br>
you can easily skip around nested expressions, transpose expressions, words, or<br>
characters, and skip forward or backward through definitions.&nbsp;&nbsp;&nbsp;A window containing a<br>
list of the definitions in the Fred window can be selected from the menu: this allows<br>
you to directly go to a definition by double-clicking on the definition's name. (Figure 2<br>
shows a Fred window accompanied by a window with list of definitions.) And if you<br>
can't find a way to do something, you can always extend the programmable Fred Editor .<br>
. . and send the extension to me! 
</p>
<p>
&nbsp;* Fred is an acronym for "Fred resembles Emacs deliberately."
</p>
<p>
<img src="img/134.gif" width="600 px"></img>
</p>
<p>
<b>Figure 2</b> A Sample Fred Window
</p>
<h2>RECOMMENDED READING</h2>
<p>
<b>REFERENCES</b>
</p>
<p class="spacer">&nbsp;</p>
<p>
<i>&nbsp;Common Lisp: The Language</i> , 2nd ed., by Guy Steele (Digital Equipment Corporation,<br>
1990). This is the language book of last resort not only for programmers but also for<br>
implementors of the Common Lisp standard. A must for any serious programmer, it is<br>
nevertheless too lengthy and detailed to serve as a quick reference guide: at 1,029<br>
pages, it makes the Old Testament look inviting. The second edition contains changes and<br>
extensions to the standard, including the addition of the Common Lisp Object System<br>
(CLOS).
</p>
<p>
<i>&nbsp;Common Lisp: The Reference</i>&nbsp;&nbsp;by Franz, Inc. (Addison-Wesley, 1988). This is a<br>
useful alphabetically ordered reference book on Common Lisp. Unfortunately, at the<br>
time of this writing there is no revised version of it that matches Steele's second<br>
edition.
</p>
<p>
<i>Object-Oriented Programming in Common Lisp: A Programmer's Guide to CLOS</i>&nbsp;&nbsp;by<br>
Sonya E. Keene (Addison- Wesley, 1989). After you've waded through the 1,029 pages<br>
of Steele's book, this will quickly land you on Mother Earth. This book does much to<br>
disentangle the complexity of the Common Lisp Object System. Keene's book will be a<br>
companion to your Common Lisp reference.
</p>
<p>
<i>Macintosh Common Lisp 2.0 Reference</i> (Apple Computer, 1990). This is Apple's<br>
reference for MCL. It describes all user interface classes, the event system, and the<br>
development environment, and gives you everything you need to get started--except<br>
for the application.
</p>
<p>
<b>TUTORIALS</b><br>
Lisp tutorial books vary in quality. There is no substitute for going to a well-stocked<br>
technical bookstore and taking the time to select the book that appeals most to you.<br>
However, you should not miss the following three:
</p>
<p>
<i>Lisp</i> , 3rd ed., by P. H. Winston and B. K. P. Horn (Addison-Wesley, 1989).&nbsp;&nbsp;If you<br>
enjoyed college coursework, you'll love this book. It is replete with problem sets and<br>
includes an instructive and interesting variety of examples. The essentials of the Lisp<br>
language and of Lisp thinking are covered quite nicely--if you have the stamina to<br>
systematically work your way through it all.
</p>
<p>
<i>Common LISPcraft </i> by Robert Wilensky (Norton, 1986). Ranking in serviceability<br>
midway between the other two tutorial books listed here, this one manages to avoid the<br>
tedium of the one and the shallowness of the other. Its examples are short and direct. It<br>
contains lucid explanations of some subtle issues (for example, funargs and binding)<br>
that in other contexts could appear alien to you.
</p>
<p>
<i>LISP: A Gentle Introduction to Symbolic Computation</i>&nbsp;&nbsp;by David S. Touretzky (Harper &amp;<br>
Row, 1984). If you are intimidated by Lisp, this may be the book for you. Touretzky<br>
takes great pains to make sure that you understand every point he sets out to<br>
make--particularly about the fundamentals of the language (for example, "what is a<br>
list?"). The only problem with this is that the only place to go from here is to another,<br>
more thorough tutorial book. But we all must begin somewhere!
</p>
<p class="spacer">&nbsp;</p>
<p>
<b>RUBEN KLEIMAN</b> was hired as a Senior Research Scientist at Apple because of his<br>
proven ability to withstand large amounts of pain, function well after sleepless nights,<br>
and sincerely worry about things that don't need to be worried over. He studied physics<br>
and comparative literature during a college career that he likens to the Harrad<br>
Experiment; he was never totally convinced that his coed college in Florida&nbsp;&nbsp;(which had<br>
no nudity rules in the dorms or swimming pool areas) wasn't backed by the CIA. The<br>
experience drove him to Cambridge, Massachusetts, where he studied linguistics<br>
(Hittite, Sanskrit) at Harvard. He then began researching the universe (that is, the<br>
unified theory of quantum mechanics and relativity) while being remunerated by MCC,<br>
Computervision, and MITRE. Down to his last five dollars, he joined Apple three years<br>
ago. In his spare time he plays together with his wife, sculpts, photographs,<br>
skateboards, is writing the Great Argentinian Novel (he's a native of Buenos Aires),<br>
and tries to cycle at least once a week. But he's a little worried that it might not make<br>
any difference until his next life. *
</p>
<p>
<b>A beta release</b> of Macintosh Common Lisp 2.0 should be available from APDA by the<br>
time you read this. See the inside back cover for information on how to contact APDA. <br>
*
</p>
<p>
<b>Thanks to Our Technical Reviewers</b>Yu-Ying Chow, Bill St. Clair, Sarah Smith, <br>
Jim Spohrer, Steve Weyer *
</p>
</body>
</html>
