<html>
<head>
<!-- Article ID: 38 - Extracted from develop-1991 -->
<!-- on 2024-01-04 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by the copyright of its respective owners -->
<title>Autumn 91 - MACINTOSH HYBRID APPLICATIONS FOR A/UX</title>
<link href="../common/styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h2>MACINTOSH HYBRID APPLICATIONS FOR A/UX</h2>
<h1>JOHN MORLEY</h1>
<p>
<img src="img/196.gif" width="242 px"></img>
</p>
<p>
<i>&nbsp;Apple's A/UX operating system is unique among UNIX systems in that it merges the</i><br>
<i>Macintosh user interface and application environment with the multitasking UNIX</i><br>
<i>operating system. Developers can take advantage of this combination by creating a</i><br>
<i>class of applications called hybrids. This article describes the techniques necessary to</i><br>
<i>create Macintosh hybrid applications and demonstrates some of the benefits of these</i><br>
<i>applications.</i>
</p>
<p>
&nbsp;The UNIX&#174; operating system began some 20 years ago as a personal project<br>
undertaken by a couple of engineers at AT&amp;T Bell Laboratories. For a number of<br>
technical and business reasons, UNIX emerged as the leading software platform for a<br>
phenomenon called Open Systems. Although this buzzword is batted around in many<br>
different and confusing contexts, it basically refers to systems that adhere to<br>
multivendor industry standards, thus protecting their owner's investment in<br>
software, training, and so on. 
</p>
<p>
&nbsp;At Apple we recognized the growing importance of the UNIX system in many segments<br>
of the marketplace, particularly for government, higher education, and large<br>
corporate customers. We also understood that the UNIX system's principal weakness<br>
was its lack of ease of use at both the system and application level. By grafting the<br>
Macintosh user interface onto a full-featured UNIX operating system, and supporting<br>
the bulk of popular Macintosh application software as well, we hoped to meet the<br>
requirements of the Open Systems marketplace and retain all the joys of working on a<br>
Macintosh. 
</p>
<p>
&nbsp;Release 2.0 of the A/UX operating system was the realization of this effort. When<br>
using a Macintosh running A/UX, you can treat it purely as a Macintosh or dive into<br>
whatever level of sophistication with the UNIX system your expertise and/or bravado<br>
allow. 
</p>
<p>
&nbsp;For the developer, A/UX opens up some new possibilities due to the presence of both<br>
the UNIX system and Macintosh programming paradigms. Macintosh developers can use<br>
A/UX as a gateway from their Macintosh application into the world of UNIX system<br>
services. UNIX system developers can use A/UX to deliver UNIX system applications<br>
that incorporate the benefits of the Macintosh user interface. 
</p>
<h2>&nbsp;HYBRID APPLICATIONS</h2>
<p>
&nbsp;As the name implies, a hybrid application combines two distinct programming models<br>
within a single application program. In the case of the A/UX operating system, the two<br>
available programming models are the Macintosh Toolbox interface and the UNIX<br>
system call interface.&nbsp;&nbsp;In addition to the two programming models present in A/UX,<br>
there are two distinct executable file formats: the UNIX executable file format known<br>
as Common Object File Format (COFF) System V.2, and the Macintosh executable file<br>
format known as Object Module Format (OMF). 
</p>
<p>
The term <i>Macintosh hybrid application</i> refers to an application that's represented in<br>
Macintosh OMF, primarily uses the Macintosh Toolbox interface, but also accesses the<br>
A/UX operating system via the UNIX system call interface. 
</p>
<p>
Alternatively, the term <i>UNIX hybrid application</i> refers to an application that's<br>
represented in COFF, primarily uses the UNIX system call interface, but also accesses<br>
the functions provided by the A/UX Macintosh Toolbox. 
</p>
<p>
<b>A/UX MACINTOSH TOOLBOX</b><br>
The Macintosh Toolbox as it is supported under A/UX is documented in<i>Inside Macintosh</i><br>
Volumes I- V and in <i>A/UX Toolbox: Macintosh ROM Interface</i> . The interface mechanism<br>
that's used to access the Macintosh Toolbox is the set of A-line trap instructions<br>
reserved for this purpose in the Motorola 680x0 architecture. The high-level<br>
languages supporting Macintosh programming contain features that allow the<br>
programmer to use traditional procedure call notation to access the Macintosh Toolbox.<br>
The compiler then translates those procedure calls into the actual A-line trap<br>
instructions to access the Toolbox. 
</p>
<p>
<b>A/UX SYSTEM CALLS</b><br>
The UNIX system call interface is documented in the <i>A/UX Programmer's Reference</i> ,<br>
Section 2. The interface mechanism that's used to access the UNIX system calls is a CPU<br>
trap instruction that causes a context switch between the application program, which<br>
runs in user mode, and the UNIX system kernel, which runs in supervisor mode. The<br>
A/UX C runtime library contains procedures to access each of the UNIX system calls<br>
supported by A/UX. 
</p>
<p>
Macintosh applications running on A/UX may also access the UNIX system calls. An<br>
MPW library (libaux_sys.o) that contains procedures for each UNIX system call,<br>
analogous to the ones in the A/UX C runtime library, is included on the <i>Developer CD</i><br>
<i>Series</i> disc for this issue. By calling routines from this library a Macintosh<br>
application becomes a Macintosh hybrid application with access to the capabilities<br>
provided by the UNIX system. 
</p>
<h2>WHY CREATE MACINTOSH HYBRID APPLICATIONS?</h2>
<p>
There are several reasons why you might want to create a Macintosh hybrid<br>
application. Here are some examples:
</p>
<ul>
<li>to create a Macintosh style front-end interface for an existing<br>
character-based UNIX system application</li>
<li>to access UNIX system networking from a Macintosh application</li>
<li>to execute UNIX system applications and utilities from a Macintosh<br>
application</li>
</ul>
<p>
The class of applications that act as front ends to existing UNIX system programs is of<br>
particular interest. The UNIX operating system has been around for two decades and a<br>
large body of software exists that can be ported easily from one UNIX system to<br>
another. The problem with these applications is that they were designed to work with<br>
character-oriented display devices. 
</p>
<p>
Most people who are familiar with the Macintosh user interface are reluctant to<br>
sacrifice the ease of use that applications designed for the Macintosh provide. One way<br>
to "dress up" these older UNIX system applications is to provide a Macintosh- style<br>
user interface via an application that acts as a front end to the existing<br>
character-based application. While not as elegant a solution as redesigning the<br>
application with the new user interface in mind, the front-end approach can usually<br>
be implemented in less time and at less expense. 
</p>
<h2>MULTITASKING AND THE MACINTOSH</h2>
<p>
A developer creating a Macintosh hybrid application needs some understanding of<br>
Macintosh multitasking and how it's implemented by A/UX. If not properly designed, a<br>
Macintosh hybrid application can easily cause the Macintosh Toolbox environment<br>
within A/UX to become deadlocked. Following the guidelines given here can keep the<br>
number of catastrophic failures during development to a minimum. 
</p>
<p>
The Macintosh was designed to be a personal computer. This resulted in emphasis on<br>
the interaction between a single user and the computer while performing a single task.<br>
With the advent of MultiFinder the Macintosh became capable of switching between two<br>
or more active applications as well as performing some limited processing in the<br>
background while the user interacts with any application. 
</p>
<p>
To avoid major incompatibilities with the existing base of application software,<br>
MultiFinder was cleverly designed to implement multitasking on top of the existing<br>
Macintosh programming model.&nbsp;&nbsp;&nbsp;This style of multitasking is called <i>cooperative</i><br>
<i>multitasking.&nbsp;&nbsp;</i> The name conveys the requirement that applications must provide the<br>
system with a cue indicating when it's reasonable to interrupt them. 
</p>
<p>
The UNIX operating system, on the other hand, was designed to control minicomputers<br>
that normally support many users at once. These computers require the operating<br>
system to preemptively schedule tasks for execution using a well-defined scheduling<br>
algorithm. A/UX fully implements this style of <i>preemptive multitasking</i> for all UNIX<br>
processes. 
</p>
<p>
To implement the MultiFinder method of cooperative multitasking within the<br>
preemptive multitasking model of the UNIX system, a special thread of control is<br>
defined for all processes that access the A/UX Macintosh Toolbox. The A/UX kernel<br>
associates one and only one process at a time with the<i>token of control</i> for the Macintosh<br>
Toolbox. The token of control is passed in the same way that applications are activated<br>
under MultiFinder. 
</p>
<p>
<b>THE PERILS OF MULTITASKING</b><br>
An unsuspecting programmer creating a Macintosh hybrid application can easily be<br>
tripped up by lack of knowledge about the multitasking environment. Consider the<br>
following program:
</p>
<pre>#include &lt;StdIO.h&gt;
main()
{
    char buf[100];
    int len;
   
    write(1,"Type Something\n",15);
    len = read(0,buf,100);
    write(1,"You Typed: ",11);
    write(1,buf,len);
    write(1,"\n",1);
}</pre>
<p>
This rather primitive piece of code can be compiled with MPW C and linked to produce<br>
an MPW tool. When run, it writes a prompt to the active MPW window and waits for<br>
keyboard input terminated by the Enter key. The program then echoes the input to the<br>
window and terminates.&nbsp;&nbsp;&nbsp;During the time that the program is waiting for keyboard<br>
input, you can switch MultiFinder layers by clicking in a different application window<br>
or choosing from the Apple menu or MultiFinder application icon in the menu bar. 
</p>
<p>
This same program can be compiled and linked with the A/UX C compiler (cc or c89)<br>
to produce a native COFF application. When run within a CommandShell window it<br>
exhibits the same behavior as when compiled with MPW C, including the ability to<br>
switch MultiFinder layers while waiting for input from the keyboard.&nbsp;&nbsp;The program<br>
can be modified so that when compiled with MPW it becomes a Macintosh hybrid<br>
application. (See "Compiling and Linking Macintosh Hybrid Applications" for some<br>
useful tips.) This is done by substituting calls to the A/UX system call routines in<br>
place of the standard MPW C runtime routines, as follows:
</p>
<pre>#include &lt;StdIO.h&gt;
#include &lt;LibAUX.h&gt;
#include &lt;/:usr:include:fcntl.h&gt;
main()
{
    char buf[100];
    int len, fd;

    fd = auxopen("/dev/ttyC1",O_RDWR);
    (void) auxwrite(fd,"Type Something\r",15);
    len = auxread(fd,buf,100);
    (void) auxwrite(fd,"You Typed: ",11);
    (void) auxwrite(fd,buf,len);
    (void) auxwrite(fd,"\r",1);
    (void) auxclose(fd);
}</pre>
<p>
The program now opens the device associated with the window CommandShell 1 and<br>
performs the I/O to that window. However, this program contains a serious flaw--the<br>
call to auxread will result in a deadlock situation, because as yet there is no data<br>
available to be read from the file descriptor associated with the CommandShell<br>
window, and the A/UX read system call blocks when data is not available. As a result,<br>
the entire MultiFinder environment running on A/UX is suspended. This makes it<br>
impossible to switch to CommandShell 1 and enter data via the keyboard. 
</p>
<p>
In this example it's not too difficult to solve the problem of blocking. The A/UX system<br>
call interface allows you to perform I/O that's nonblocking, otherwise referred to<br>
as<i>asynchronous I/O</i> . You can use the A/UX system call fcntl to change the blocking<br>
status of a UNIX system file descriptor. Here's how to modify the previous example so<br>
that the deadlock situation is avoided:
</p>
<pre>#include &lt;StdIO.h&gt;
#include &lt;CursorCtl.h&gt;
#include &lt;LibAUX.h&gt;
#include &lt;/:usr:include:fcntl.h&gt;
main()
{
    char buf[100];
    int len, fd, flags;

    /* Open the device associated with CommandShell 1's window.*/
    fd = auxopen("/dev/ttyC1",O_RDWR);
    /* Get the current flags for this file descriptor.*/
    flags = auxfcntl(fd,F_GETFL,0);
    /* Add the O_NDELAY flag to the flags that are already set.*/
    (void) auxfcntl(fd,F_SETFL,flags | O_NDELAY);
    (void)auxwrite(fd,"Type Something\r",15);
    while ( (len = auxread(fd,buf,100)) &lt; 1)
        SpinCursor(1);
    (void)auxwrite(fd,"You Typed: ",11);
    (void)auxwrite(fd,buf,len);
    (void)auxwrite(fd,"\r",1);
    /* Reset the flags to their original state.*/
    (void)auxfcntl(fd,F_SETFL,flags);  
    (void)auxclose(fd);
}</pre>
<p>
The A/UX system call fcntl is used first to get the file descriptor flags associated with<br>
the CommandShell window and then to set the O_NDELAY bit in the flags word. The<br>
O_NDELAY bit determines whether reads from the file descriptor will block if data is<br>
not available. With this bit set, when data is not available the value returned by the<br>
read system call is 0. The call to the MPW library routine SpinCursor creates idle<br>
time for the layer switch to occur. The last call to auxfcntl resets the flags to their<br>
original state. 
</p>
<p>
If you want to try this example hybrid application, open a CommandShell window<br>
under A/UX, type "sleep 1000" in the window, and then run the example from the<br>
MPW shell. 
</p>
<h2>HELPFUL UTILITY FUNCTIONS</h2>
<p>
For many types of potential Macintosh hybrid applications, particularly the front-end<br>
variety, the only UNIX system functionality necessary is the ability to execute a UNIX<br>
process and communicate with it. Toward this end I've included in the system call<br>
library several utility routines that are at a higher level than the basic system calls.<br>
A description of these utility routines follows. 
</p>
<p>
<b>AUXFORK_PIPE</b><br>
The auxfork_pipe function executes several system calls to create a new UNIX process.<br>
In UNIX system parlance, the new process is the child and the process that created it is<br>
the parent. The definition for this function is
</p>
<pre>Handle auxfork_pipe(int toparent, int tochild, void (*childtask)(),
void *childarg);</pre>
<p>
The parameters toparent and tochild are flags that indicate whether or not to establish<br>
a communication pipe in either direction between the parent and child processes. A<br>
zero value signifies that no pipe should be created and a nonzero value signifies that a<br>
pipe should be created. 
</p>
<p>
The parameter childtask is a function pointer used to identify a function to be called by<br>
the child process when the child process is first created. The parameter childarg is a<br>
generic pointer passed to the function pointed to by childtask so that you can vary the<br>
behavior of that function. Typically, the function pointed to by childtask executes one<br>
of the variants of the exec system call and uses the childarg pointer to identify the<br>
filename of the program to be executed. 
</p>
<p>
The value returned by this function is either a handle to a structure that holds some<br>
global information about the child process or a null pointer if the call was<br>
unsuccessful. The definition for this structure is as follows:
</p>
<pre>struct childinfo {
    /* file descriptor for parent-&gt;child communication pipe */
    int tochild;
    /* file descriptor for child-&gt;parent communication pipe */
    int toparent;
    /* process ID of the child process */
    int pid;
};</pre>
<p>
The file descriptor for the toparent communication pipe has the O_NDELAY bit set in<br>
its flags word so that reading from this file descriptor won't cause a block when data is<br>
not available. 
</p>
<p>
<b>AUXCLEANUP_FORK_PIPE</b><br>
An additional utility function is used to clean up after the child process<br>
terminates--the auxcleanup_fork_pipe function. Its definition is
</p>
<pre>int auxcleanup_fork_pipe(Handle globals);</pre>
<p>
It takes one parameter, which is the handle returned previously by the auxfork_pipe<br>
function. You must be sure that the child process has terminated or is about to<br>
terminate before calling auxcleanup_fork_pipe. If you're not sure that the child<br>
process will terminate, you can call auxkill to send the child process a termination<br>
signal. 
</p>
<p>
<b>AUXFGETS</b><br>
The auxfgets function uses the read system call to read a string of characters from an<br>
open UNIX system file descriptor. The definition for this function is
</p>
<pre>char *auxfgets(char *buf, int count, int file, int timeout);</pre>
<p>
The buf parameter is a pointer to space in which to store the characters read. The<br>
count parameter specifies the maximum number of characters to read. The file<br>
parameter is the UNIX system file descriptor from which to read. (The auxfgets<br>
function described here differs from the standard fgets function in that it uses a file<br>
descriptor rather than a stream pointer.) The timeout parameter indicates the<br>
maximum number of times to retry the read system call when data is not available.
</p>
<p>
This function reads characters until one of the following conditions occurs:
</p>
<ul>
<li>A newline character (0x10) is read. </li>
<li>The number of characters specified in the count is reached (reserving<br>
room for a null character to mark the end of the string). </li>
<li>The retry count specified in the timeout parameter is reached without any<br>
new data being available to read. If the value of timeout is 0, auxfgets retries<br>
indefinitely. </li>
</ul>
<p>
The newline character, if any, is stored at the end of the character string. In any case,<br>
a null character is appended after the last character stored to mark the end of the<br>
string. 
</p>
<p>
<b>AUXSYSTEM</b><br>
The auxsystem function works much like the UNIX library routine named<i>system.&nbsp;&nbsp;</i> To<br>
use this function in a Macintosh hybrid application, the application must either be<br>
linked as an MPW tool or linked with the Simple Input/Output Window (SIOW)<br>
package, which implements standard I/O streams for Macintosh applications. The<br>
definition for this function is
</p>
<pre>int auxsystem(char *command);</pre>
<p>
The parameter is a pointer to a character string that contains a valid UNIX system<br>
shell command (Bourne shell syntax). This function executes the given command and<br>
redirects any output that the command produces on the standard output or standard<br>
error streams to the SIOW standard output and standard error streams. 
</p>
<p>
The MPW tool Unixcmd included on the<i>Developer CD Series</i> disc is an example of a tool<br>
that uses the auxsystem function. This tool executes the UNIX command given on the<br>
command line for Unixcmd. The standard output and standard error streams produced<br>
by the UNIX command are sent to the MPW window from which Unixcmd was executed,<br>
or they can be individually redirected using the MPW shell's redirection syntax. The<br>
Unixcmd tool also sets the MPW variable {Status} to the exit status of the UNIX<br>
command, so that MPW scripts can test the exit status. 
</p>
<h2>THE UNIX MAIL READER</h2>
<p>
To demonstrate some of the techniques used to create Macintosh hybrid applications,<br>
we'll look at an example front-end application for the Berkeley UNIX system mail<br>
reading program, mailx. The application is implemented using a HyperCard stack with<br>
HyperTalk&#174; scripts that access HyperCard XFCNs.&nbsp;&nbsp;The interface for the mail reader<br>
consists of two cards in a HyperCard stack. The first card is called<i>headers</i> and is used<br>
to display a list of header lines identifying the available mail messages. The second<br>
card is called<i>message</i>&nbsp;&nbsp;and is used to display the content of a selected message. 
</p>
<p>
The UNIX Mail Reader example is provided solely to illustrate the technical issues<br>
involved in creating an A/UX Macintosh hybrid application. It is<i>not</i>&nbsp;&nbsp;an example of good<br>
user interface design, since it was written by a UNIX hacker (yours truly) with little<br>
knowledge of Macintosh user interface guidelines (a little knowledge is a dangerous<br>
thing). 
</p>
<p>
<b>HYPERCARD XFCNS</b><br>
A HyperCard XFCN is a code segment that the HyperCard application calls to perform a<br>
function that can't be accomplished with the standard HyperCard commands. By<br>
providing HyperCard with XFCNs to access UNIX system calls, you can create<br>
Macintosh hybrid applications that are implemented by HyperTalk scripts. Five<br>
different XFCNs are used by the UNIX Mail Reader to create a HyperCard front end to<br>
the UNIX mail reading program. The XFCNs used are as follows:
</p>
<ul>
<li>forkpipexfcn, which calls the auxfork_pipe utility function</li>
<li>fgetsxfcn, which calls the auxfgets utility function</li>
<li>fgetfxfcn, which makes multiple calls to the auxfgets utility function</li>
<li>writexfcn, which calls the auxwrite utility function</li>
<li>cleanupxfcn, which calls the auxcleanup_fork_pipe utility function</li>
</ul>
<p>
The source code for these XFCNs is included on the<i>Developer CD Series</i> disc to serve as<br>
a model for other XFCNs you may create.
</p>
<p>
<b>THE ENTRY SCRIPT</b><br>
When the UNIX Mail Reader stack is opened, the HyperTalk script associated with the<br>
headers card is executed. 
</p>
<pre>on openStack
    global global_handle, linecount
    put empty into cd field one
    put empty into global_handle
    put forkpipexfcn("/usr/bin/mailx") into global_handle
    - - A real application would give an error message here.
    if global_handle is empty then go to home
    - - Call fgetsxfcn to read first line of mailx output.
    put fgetsxfcn(global_handle,2500) into buf
    - - Check if any mail is available.
    if word 1 of buf is "No" then
        - - Inform user there's no mail.
        put cleanupxfcn(global_handle) into status
        put empty into global_handle
        Beep 1
        answer "Sorry, no mail"
        go to home
    else
        - - Inform user there's mail.
        play "mail.sound"
        - - Discard 2nd line of mailx output.
        put fgetsxfcn(global_handle,2500) into buf
        - - Read available mail headers.
        repeat with linecount = 1 to 9999
            put fgetsxfcn(global_handle,250) into buf
            - - Check if done.
            if length(buf) = 0 then exit repeat
            put buf into line linecount of cd field one
        end repeat
        - - Calculate number of messages.
        subtract 1 from linecount
    end if
end openStack</pre>
<p>
After some initialization, the XFCN forkpipexfcn is called to start execution of the<br>
Berkeley UNIX system mail reader located in the file /usr/ucb/mailx. Then, the XFCN<br>
fgetsxfcn is called to read the first line of output from the mailx program into the<br>
HyperTalk variable buf. 
</p>
<p>
Notice that the second parameter to fgetsxfcn is the value 2500. This parameter is the<br>
timeout count described in the definition of auxfgets. The value 2500 was derived by<br>
observing the longest time it normally takes for the mail program to begin execution<br>
and produce the first line of output. 
</p>
<p>
The script tests the string that was just read to see if it's the special message that<br>
indicates no mail messages. If it is, the script notifies the user and exits. 
</p>
<p>
If the first message is other than the no-mail message, the script reads the header for<br>
each message and places it sequentially in the message headers field on the headers<br>
card. The message headers begin with the third line of output from the mailx program,<br>
so the script reads and discards the second line of output from the mailx program.<br>
After the final message is read, the global HyperTalk variable linecount is set to the<br>
total number of messages. The final message header is identified by checking to see if<br>
the last fgetsxfcn call returned no data, indicating a timeout. 
</p>
<p>
Figure 1 shows the headers card of the UNIX Mail Reader example. 
</p>
<p>
<img src="img/197.gif" width="600 px"></img>
</p>
<p>
<b>Figure 1</b>Headers Card With Sample Mail Headers
</p>
<p class="spacer">&nbsp;</p>
<p>
<b>THE EXIT SCRIPT</b><br>
When the user clicks the Home button, the UNIX Mail Reader stack exits and the<br>
following script associated with the headers card executes:
</p>
<pre>on closeStack
    global global_handle
    if global_handle is not empty then
        answer "Update Message Queue?" with "Yes" or "No"
        if It is "No" then
            put writexfcn(global_handle,("x" &amp; lineFeed))
                into writecount
        else
            play "empty trash (flush)"
            put writexfcn(global_handle,("q" &amp; lineFeed))
                into writecount
        end if
        put cleanupxfcn(global_handle) into status
        put empty into global_handle
    end if
    put empty into cd field one
    play "bye.sound"
end closeStack</pre>
<p>
This script asks if the user wants to update the message queue, which permanently<br>
deletes any messages marked for deletion. Depending on the user's response, the script<br>
sends either the exit command (indicated by the letter<i>x)</i>&nbsp;&nbsp;or the quit command<br>
(indicated by the letter<i>q)</i>&nbsp;&nbsp;to the mailx program to terminate the session. The<br>
commands are sent to the mailx program by writing to the communication pipe with<br>
the XFCN writexfcn. The special character lineFeed is appended to the command to<br>
simulate the user pressing the Return key. 
</p>
<p>
The script then calls cleanupxfcn to perform the termination processing. This is safe<br>
now, since the mailx program will be terminating as a result of the exit or quit<br>
command just sent. 
</p>
<p>
<b>THE SELECTION SCRIPT</b><br>
When the user clicks one of the message headers displayed in the first card of the<br>
stack, the following script is executed to display the selected message in the second<br>
card of the stack. Figure 2 shows a message card with a sample message. 
</p>
<pre>on mouseUp
    global global_handle, linecount, vline
    put (item 2 of the clickLoc) + (the scroll of cd field one)
        into vline
    divide vline by the textHeight of cd field one
    put trunc(vline+.6) into vline
    if vline &lt;= linecount then
        select line vline of cd field one
        if the textStyle of the selectedLine is italic then
            beep 1
        else
            put writexfcn(global_handle,(vline &amp; lineFeed))
                into writecount
            play "ZoomUp"
            go to card 2
            put fgetfxfcn(global_handle,250) into cd field msgx
        end if
    else
        beep 1
    end if
    select empty
end mouseUp</pre>
<p>
This script computes the line number of the selected message, checks to see that it's a<br>
valid message number, and then sends this value to the mailx program, causing that<br>
message to be displayed. The call to fgetfxfcn reads multiple lines of output into a field<br>
with one XFCN call. This is much faster than calling fgetsxfcn several times and<br>
inserting each line into the field.&nbsp;&nbsp;&nbsp;
</p>
<p>
<img src="img/198.gif" width="600 px"></img>
</p>
<p>
<b>Figure 2</b>Message Card With a Sample Message
</p>
<p>
<b>THE DELETE BUTTON SCRIPT</b><br>
Users viewing the content of a message in the second card of the stack have the option of<br>
marking the message for deletion by clicking the Delete button. That causes the<br>
following script to be executed:
</p>
<pre>on mouseUp
    global global_handle, vline
    play "Cash Register"
    put writexfcn(global_handle,("d" &amp; lineFeed))
        into writecount
    put empty into cd field msgx
    go to card 1
    select line vline of cd field one
    set textStyle of the selectedLine to italic
end mouseUp</pre>
<p>
This script sends the delete command (the letter<i>d)</i> to the mailx program, clears the<br>
message field on the second card, and then changes the text style of the header for that<br>
message to italic. This is an indication to the user that the message has been marked for<br>
deletion. The text style is checked in the selection script to prevent access to a deleted<br>
message. 
</p>
<h2>PARTING THOUGHTS</h2>
<p>
I hope this article has given you some insight into the possible uses of programming<br>
Macintosh hybrid applications for A/UX, as well as some helpful techniques for doing<br>
this on your own.&nbsp;&nbsp;&nbsp;Although HyperCard was used to quickly implement the UNIX Mail<br>
Reader, the same techniques apply to using UNIX system calls from a Macintosh<br>
application written without HyperCard. 
</p>
<p>
The<i> A/UX Developer's Tools</i> set of CD-ROM discs (APDA #B0596LL/A) contains more<br>
tools for dealing with both UNIX and Macintosh hybrid applications on A/UX.<br>
Developers interested in exploring this programming technique in depth may want to<br>
acquire that product to supplement the library and examples from this article. 
</p>
<h2>COMPILING AND LINKING MACINTOSH HYBRID APPLICATIONS</h2>
<p>
There are a few things you should know in order to compile and link a Macintosh<br>
hybrid application:
</p>
<ul>
<li>Use the include file LibAUX.h to define the system calls and their<br>
prototypes (especially if you're using C++). For example:&nbsp;&nbsp;&nbsp;&nbsp;</li>
</ul>
<pre>      #include &lt;LibAUX.h&gt;</pre>
<ul>
<li>You may need to include A/UX system header files for some of the system<br>
calls. These must be specified using the complete pathname in the Macintosh<br>
file system format. You must include LibAUX.h before including any A/UX<br>
system header files. For example:</li>
</ul>
<pre>      #include &lt;LibAUX.h&gt;
      #include &lt;/:usr:include:fcntl.h&gt;</pre>
<p>
For information on when to include header files refer to A/UX Programmer's<br>
Reference, Section 2, and A/UX Development Tools, Chapter 2.
</p>
<ul>
<li>The meanings of the special characters \n and \r are reversed between<br>
MPW C and A/UX C. In general,&nbsp;&nbsp;use \r within strings that are passed to A/UX<br>
system calls.</li>
<li>It's a good idea to have the application test to see that A/UX--not the<br>
Macintosh operating system--is running. To do this, call function<br>
AUXisRunning, which returns a nonzero value if A/UX is running or a zero<br>
value if it's not.</li>
<li>You must link with the library libaux_sys.o to access the system call<br>
routines. The default filename for this library is</li>
</ul>
<pre>       {MPW}Libraries:AUX System Calls: libaux_sys.o</pre>
<p>
This library name should be included in addition to any other library names<br>
and options you usually include with your Link command.
</p>
<p class="spacer">&nbsp;</p>
<p>
<b>REFERENCES</b>
</p>
<ul>
<li>A/UX Programmer's Reference, Section 2, Apple Computer, 1990.</li>
<li>A/UX Development Tools, Chapter 2, Apple Computer, 1991.</li>
<li>A/UX Toolbox: Macintosh ROM Interface, Apple Computer, 1990.</li>
<li>Apple HyperCard Script Language Guide: The HyperTalk Language,<br>
Addison-Wesley, 1988.</li>
<li><i>Inside Macintosh, </i> Volumes I-V, Addison-Wesley, 1986.</li>
</ul>
<p>
<b>JOHN MORLEY</b> is the manager for development tools in Apple's A/UX engineering<br>
group. John has been hacking code for so long (20 years) that he remembers the "good<br>
old days" when the mark of a good programmer was being able to sight- read punched<br>
paper tape. When asked about the future of software engineering, he is quick to praise<br>
the virtues of object-oriented programming and his work on the design of a new<br>
language called "Add 1 to COBOL giving Object COBOL." In his spare time John loves to<br>
ride his Harley-Davidson motorcycle, plan trips to the Hawaiian island of Kauai, and<br>
visit with the fish underwater. John's dream is to work at an Apple engineering<br>
facility on Kauai so that the blurry line dividing work and play will finally be<br>
dissolved altogether. *
</p>
<p>
<b>The MPW library libaux_sys.o</b> is also on the <i>A/UX Developer's Tools</i>&nbsp;&nbsp;set of<br>
CD-ROM discs (APDA #B0596LL/A). *
</p>
<p>
<b>In Macintosh System 7, MultiFinder</b> is integrated into the system as the<br>
Process Manager. This article refers to MultiFinder, since A/UX is currently based on<br>
Macintosh System 6 software. *
</p>
<p>
<b>Blocking </b>is the suspension of a process pending completion of some external<br>
event--for example, data becoming available.*<b>For details on the read system</b><br>
<b>call</b> see <i>A/UX Programmer's Reference,</i>&nbsp;&nbsp;Section 2. *
</p>
<p>
<b>For more information about HyperTalk and XCMDs </b> refer to the<i> Apple</i><br>
<i>HyperCard Script Language Guide: The HyperTalk Language.</i> *
</p>
<p>
<b>THANKS TO OUR TECHNICAL REVIEWERS</b> Kent Sandvik, Joe Sokol, John<br>
Sovereign, Kristin Webster *
</p>
</body>
</html>
