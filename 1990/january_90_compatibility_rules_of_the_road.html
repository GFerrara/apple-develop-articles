<html>
<head>
<!-- Article ID: 3 - Extracted from develop-1990 -->
<!-- on 2023-12-27 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by the copyright of its respective owners -->
<title>January 90 - COMPATIBILITY-RULES OF THE ROAD</title>
<link href="../common/styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h2>COMPATIBILITY-RULES OF THE ROAD</h2>
<h1>DAVE RADCLIFFE</h1>
<p>
<i>Apple's System Software Version 7.0 provides the most important&nbsp;&nbsp;test of</i><br>
<i>compatibility since the introduction of the Macintosh II.&nbsp;&nbsp;This article should help you</i><br>
<i>prepare for the release of System 7.0.&nbsp;&nbsp;For an overview of the most critical</i><br>
<i>compatibility issues and how to address them, read on.</i>
</p>
<p>
If you've already read too many stuffy articles full of dire warnings about<br>
compatibility, you've probably decided this one will be best suited for lining the<br>
bottom of your filing cabinet.&nbsp;&nbsp;But before doing that, consider the case of Johnny<br>
Appledweeb.
</p>
<p>
Ace Macintosh programmer for Cliff Grazer Enterprises, Johnny is currently putting<br>
in the long hours to get a spread-processor-terminal-graphics-emulator out the door.<br>
He doesn't have time to read an article like this because Cliff Grazer, his boss and<br>
President of CGE, is all over his case.&nbsp;&nbsp;Four months ago, the company began accepting<br>
prepayment from customers who can't wait for Johnny's program to reach their local<br>
stores.&nbsp;&nbsp;Those customers are now beating down the doors.
</p>
<p>
Although Cliff is desperate to get the product out, he has required certain levels of<br>
performance.&nbsp;&nbsp;The application must be kept under the 1megabyte limit, for example,<br>
and must keep up at 19.2 kbaud through the modem port.&nbsp;&nbsp;Finally, at the last minute,<br>
legal decides to require copy protection.&nbsp;&nbsp;Once the application ships, reviews are<br>
excellent, customers are happy, and sales are good.&nbsp;&nbsp;Cliff is ecstatic and gives Johnny a<br>
big raise.&nbsp;&nbsp;Johnny has time to relax a bit and maybe even catch up on some reading. <br>
But this article doesn't interest him because he's a crack programmer, and his<br>
application works fine.&nbsp;&nbsp;Bottom of the filing cabinet time.
</p>
<p>
Six months later, Johnny comes back from his well-earned vacation to find that Apple<br>
has introduced new machines and released a new version of the system software. <br>
Cliff's hopping mad because of reports of compatibility problems and complaints from<br>
angry customers.&nbsp;&nbsp;As Johnny begins to look into the problems, he has a vague<br>
recollection of some article he saw on compatibility.&nbsp;&nbsp;He rummages around, finds the<br>
article, and quickly discovers it addresses his problems.&nbsp;&nbsp;But it's too late for the<br>
customers.&nbsp;&nbsp;They don't understand compatibility, but they do understand that the<br>
application they have been using every day no longer works.&nbsp;&nbsp;Cliff doesn't really<br>
understand compatibility either. What he understands is he now has the expense of<br>
shipping updated versions to keep his customers happy. 
</p>
<p>
Johnny might have saved himself and others a lot of trouble if he'd spent a few minutes<br>
with this article right away.&nbsp;&nbsp;Sure, it probably would have meant a delay in the first<br>
release of the application, but it might also have made a second release unnecessary. <br>
Johnny's a good programmer, and he's aware of almost everything in this article, but<br>
if a single sentence had helped avoid problems, the article would have been worth<br>
Johnny's time.
</p>
<p>
It may be worth your time as well to check out the compatibility of your current<br>
application's features with System 7.0.&nbsp;&nbsp;The road gets a little dry and dusty from here<br>
on, so grab a cold one and we'll get down to business.&nbsp;&nbsp;This article focuses on specific<br>
areas of Macintosh programming where compatibility might trip you up today or in<br>
the future.&nbsp;&nbsp;It isn't meant to be a guide to Macintosh programming, so if you need<br>
additional information on a topic, such as implementation details, refer to Inside<br>
Macintosh, volumes I-V, and the Macintosh Technical Notes.
</p>
<h2>DEFENSIVE PROGRAMMING</h2>
<p>
Murphy was clearly a computer engineer.&nbsp;&nbsp;If anything can go wrong with your<br>
application, it will, as most of us learn the hard way.&nbsp;&nbsp;Once you recognize that users<br>
always stress your program in ways you never thought possible, you acquire defensive<br>
programming habits.
</p>
<p>
<b>TESTING</b><br>
Always test return values for possible errors because you never know when some<br>
unusual situation will arise.&nbsp;&nbsp;Assume that data structures will change.&nbsp;&nbsp;The Memory<br>
Manager is an example of a manager whose data structures are changing, as described<br>
later in this article.&nbsp;&nbsp;Avoid any portion of a data structure marked "Unused"--its use<br>
is reserved for Apple.
</p>
<p>
<b>MEMORY ALLOCATION</b><br>
If you treat the Memory Manager with a little courtesy and respect, your application<br>
will live a long and happy life.&nbsp;&nbsp;Keep in mind the strengths as well as the limitations of<br>
the Memory Manager and listen to what it tells you.&nbsp;&nbsp;Believe it when it returns a nil<br>
handle to tell you of memory allocation failure.&nbsp;&nbsp;Every application's memory needs are<br>
different, and as you design your application, think about how memory you allocate<br>
will be used.&nbsp;&nbsp;A little planning can ease the Memory Manager's task by reducing the<br>
number of Memory Manager calls and minimizing fragmentation and thrashing. 
</p>
<p>
You should ask yourself a few simple questions about the memory you allocate in the<br>
heap.&nbsp;&nbsp;Is this memory you will need frequently?&nbsp;&nbsp;Rather than frequently allocating and<br>
releasing the memory, wouldn't it be better to allocate it once at the start of your<br>
application if it is a handle, move it high in the heap with MoveHHi and simply reuse it<br>
when necessary? 
</p>
<p>
Is it memory that shouldn't move?&nbsp;&nbsp;If so, consider the use of NewPtr instead. 
</p>
<p>
Is this a large block of memory used for a very short period of time?&nbsp;&nbsp;Judicious use of<br>
MultiFinder temporary memory can satisfy such needs and reduce overall heap usage,<br>
allowing you to shrink your MultiFinder size partition. 
</p>
<p>
Is this memory you are willing to let the Memory Manager dispose of at its discretion,<br>
such as for a resource?&nbsp;&nbsp;Then you should consider making it purgeable.&nbsp;&nbsp;But if you've<br>
made it purgeable, be sure to check for empty handles. 
</p>
<p>
Once you have your application working, be sure to stress test your use of the Memory<br>
Manager.&nbsp;&nbsp;You can do this by using your debugger to force heap scrambling and<br>
purging.&nbsp;&nbsp;You can also simulate low memory conditions by running your application in<br>
a small MultiFinder partition.
</p>
<h2>32-BIT CLEANLINESS</h2>
<p>
Another way to treat the Memory Manager with kindness and respect is to practice<br>
32-bit cleanliness.&nbsp;&nbsp;Being 32-bit clean may be the single most important<br>
compatibility issue facing developers.&nbsp;&nbsp;To understand what 32-bit cleanliness means,<br>
let's take a closer look at Macintosh memory management.&nbsp;&nbsp;The Memory Manager<br>
maintains free-form memory structures called heap zones.&nbsp;&nbsp;It allocates memory<br>
blocks of various sizes within these zones to satisfy memory allocation requests by the<br>
system and applications.&nbsp;&nbsp;Occasionally, heaps will become full or fragmented and the<br>
Memory Manager will need to rearrange or purge blocks in a zone to create enough<br>
contiguous space to satisfy a memory allocation request.&nbsp;&nbsp;To minimize confusion that<br>
could occur when blocks are rearranged, the Memory Manager uses indirect<br>
references called handles to refer to relocatable blocks in the heap. 
</p>
<p>
The Memory Manager maintains a series of master pointers referring to blocks in<br>
memory.&nbsp;&nbsp;A handle is a pointer to a master pointer, as shown in the following<br>
illustrations.
</p>
<p>
In the example in the first illustration, two independent handles refer to the same heap<br>
block at address $20000 via the master pointer at address $1000.&nbsp;&nbsp;Only the master<br>
pointer should be referring to the heap block.&nbsp;&nbsp;Now, suppose the system needs to<br>
relocate the heap block to address $30000.&nbsp;&nbsp;The second illustration shows the state of<br>
the system after relocating the block.
</p>
<p>
The master pointer is now correctly set to point to the new block.&nbsp;&nbsp;The master pointer<br>
is the only thing the Memory Manager had to update.&nbsp;&nbsp;The original handles 1 and 2 still<br>
correctly refer to the heap block because they refer to the master pointer, which has<br>
the correct location of the heap block.
</p>
<p>
The classic Macintosh has what is referred to as a 24-bit memory management<br>
system.&nbsp;&nbsp;To the hardware, only the lower 24 bits of a 32-bit address are significant. <br>
The upper 8 bits are always ignored in a hardware address reference.&nbsp;&nbsp;The Memory<br>
Manager maintains certain information about heap blocks, such as whether they are<br>
locked in memory and cannot be moved or whether they can be purged from memory to<br>
free up space in the heap.&nbsp;&nbsp;The original Macintosh Memory Manager took advantage of<br>
the unused upper 8 bits of the address in a master pointer to maintain flags about heap<br>
blocks.&nbsp;&nbsp;The illustration shows the master pointer structure of the 24-bit Memory<br>
Manager.
</p>
<h2>AVOIDING COMMON PROBLEMS</h2>
<p>
The most common violation of 32-bit cleanliness involves direct manipulation of<br>
Memory Manager flags.&nbsp;&nbsp;In a 32-bit system, all 32 bits of an address are valid, and in<br>
the case of a master pointer, the flags bits are stored elsewhere.&nbsp;&nbsp;The system provides<br>
traps for setting and cleaning these flags: HLock/HUnlock, HPurge/HNoPurge and<br>
HSetRBit/HClrRBit.&nbsp;&nbsp;There are also traps for getting and setting all the flags at once:<br>
HGetState and HSetState.&nbsp;&nbsp;Some applications have taken advantage of knowledge of the<br>
master pointer structure to set and clear the flag bits directly.&nbsp;&nbsp;Setting flag bits<br>
directly on a 32-bit system means you are not changing the flags, but changing the<br>
address itself, and suddenly your master pointer is pointing to a completely different<br>
location in memory.
</p>
<p>
The issue of 32-bit cleanliness is not limited to proper use of master pointer flags. <br>
Every address reference must assume all 32-bits are valid.&nbsp;&nbsp;If you have used any of<br>
the upper 8 bits of pointers or handles for anything other than part of an address, you<br>
must find an alternate representation for that information. 
</p>
<p>
Two other places you can be bitten by 32-bit violations are in window definition<br>
functions (WDEFs) and control definition functions (CDEFs).&nbsp;&nbsp;The original Macintosh<br>
Window Manager stored the window variation code in the upper 8 bits of the handle to<br>
the window definition procedure.&nbsp;&nbsp;If you are using custom WDEFs and need to access the<br>
window variation code, use the GetWVariant trap.&nbsp;&nbsp;Similarly, use GetCVariant to<br>
retrieve the variant control value for a control that was formerly stored in the high<br>
bits of the control defproc handle.
</p>
<p>
Using pre-System 7.0 software, including A/UX 1.1, it is impossible to write a<br>
strictly clean CDEF.&nbsp;&nbsp;The problem with custom CDEFs is that the calcCRgns message<br>
uses the high bit of the region handle as a flag.&nbsp;&nbsp;Inside Macintosh, volume I, page 331<br>
incorrectly advises you to "clear the high byte (not just the high bit) of the region<br>
handle before attempting to update the region." Rather, you should clear only the high<br>
bit (not the high byte).&nbsp;&nbsp;This makes the reasonable assumption, given the current<br>
system software, that the handle represents only a 31-bit address and clearing the<br>
high bit is not harmful.
</p>
<p>
With System 7.0, the Control Manager has a new way of telling your CDEF to calculate<br>
control regions. Two new messages have been defined, calcCntlRgn and calcThumbRgn,<br>
with values of 10 and 11 respectively.&nbsp;&nbsp;With a 32-bit Memory Manager in operation,<br>
the Control Manager, which previously would have used calcCRgns, will now use one of<br>
the new messages.&nbsp;&nbsp;With a 24-bit Memory Manager operating, calcCRgns will still be<br>
used, so you must continue to support that method.
</p>
<p>
<b>CREATING VALID HANDLES</b><br>
Just as the master pointer structure will change in System 7.0, other Memory<br>
Manager structures will be subject to change.&nbsp;&nbsp;As a precaution, you should not access<br>
Memory Manager data structures directly or attempt to "walk the heap" yourself.
</p>
<p>
Since a handle is a pointer to a pointer, it is possible for an application to create a<br>
handle itself, a so-called fake handle. If you pass a fake handle to any Memory Manager<br>
routine, the Memory Manager will assume it is a valid handle under its control and<br>
may try to relocate or dispose of it.&nbsp;&nbsp;You should never pass a fake handle to any<br>
Macintosh trap, because you never know when that trap may itself call the Memory<br>
Manager.
</p>
<p>
Prior to System 7.0, handles allocated with MFTempNewHandle trap were not true<br>
handles and could not be passed, directly or indirectly, to Memory Manager traps. <br>
They were to be treated as fake handles.&nbsp;&nbsp;Under System 7.0, this is no longer true the<br>
Memory Manager knows how to manage such memory.
</p>
<p>
Remember that MultiFinder temporary memory is just that, temporary.&nbsp;&nbsp;It should be<br>
allocated, used, and released as quickly as possible, preferably within one event loop<br>
cycle.&nbsp;&nbsp;With System 7.0, you can use the HPurge Memory Manager trap to mark<br>
handles as purgeable.&nbsp;&nbsp;You can continue to use the memory as long as MultiFinder does<br>
not need it for another application.&nbsp;&nbsp;But be sure to check for empty handles to ascertain<br>
if your memory has been purged.
</p>
<p>
<b>USING STRIPADDRESS</b><br>
One of the keys to 32-bit cleanliness is proper use of the StripAddress trap.<br>
StripAddress is necessary because handle flags in master pointers can create dirty<br>
address references.&nbsp;&nbsp;When a 24-bit Memory Manager is operating, StripAddress<br>
clears the high byte of the address, and returns a clean address. The operation of<br>
StripAddress is simple enough.&nbsp;&nbsp;What is not always so clear is when use of<br>
StripAddress is necessary or even appropriate.
</p>
<p>
To understand the operation of StripAddress, consider, again, the second illustration. <br>
Imagine that a 24-bit Memory Manager is in operation and you've called HLock to lock<br>
the handle.&nbsp;&nbsp;The value of the master pointer will now be $80030000 because HLock<br>
has set the lock bit in the master pointer as indicated in the third illustration.&nbsp;&nbsp;In<br>
normal operation, you never need to concern yourself with that high byte because the<br>
hardware ignores it.&nbsp;&nbsp;In other words, the hardware quietly strips the address for you. <br>
But suppose you are writing a driver that needs to access a NuBus board.&nbsp;&nbsp;To do that,<br>
you need to switch the hardware to 32-bit addressing mode using SwapMMUMode. <br>
Now, suddenly, the hardware is no longer ignoring that high byte, so to access the<br>
address properly you first need to call StripAddress to clean up the address.
</p>
<p>
Another situation in which StripAddress is necessary is comparing master pointers. <br>
In the previous example, comparing the value of the master pointer before and after<br>
calling HLock would lead you to conclude the master pointer is now pointing to a<br>
different block because the comparison looks at all 32 bits. To be sure you are<br>
comparing the relevant portions, namely the addresses, call StripAddress before<br>
comparing master pointers.
</p>
<p>
If a 32-bit Memory Manager is in operation, StripAddress will return the address<br>
unchanged, because all 32 bits of the address are valid.&nbsp;&nbsp;If you have used StripAddress<br>
correctly, you need never worry whether a 24-bit or 32-bit Memory Manager is<br>
operating, because StripAddress does the right thing.
</p>
<p>
Finally, do you need to call StripAddress on other addresses, such as handles? No,<br>
because there should be no extraneous bits set in the high byte of handles. If you are<br>
using the high byte of handles for your own purposes, go directly to the beginning of<br>
this section on 32-bit cleanliness.&nbsp;&nbsp;Do not pass Go do not collect $200.
</p>
<p>
<b>FILE ACCESS</b><br>
Use the File Manager for all your file access.&nbsp;&nbsp;Avoid assumptions about the underlying<br>
file and directory structure.&nbsp;&nbsp;Not only has the Macintosh file system changed in the<br>
past, but you might not even be accessing a Macintosh volume. Foreign file systems<br>
such as DOS, ProDOS&#174;, High Sierra ISO 9660, and Unix are all supported.&nbsp;&nbsp;If your<br>
application is running under A/UX, there may be no Macintosh volumes.&nbsp;&nbsp;These file<br>
system differences create many subtle problems.&nbsp;&nbsp;For example, Unix filenames are<br>
case-sensitive, whereas Macintosh names are not.&nbsp;&nbsp;Unix uses '/' as a pathname<br>
delimiter, while Macintosh uses ':'. Different file systems may have different<br>
restrictions on the length of filenames. Always use SFGetFile and SFPutFile.&nbsp;&nbsp;Not only<br>
will this ensure maximum compatibility across file systems, but it will be comforting<br>
to your users that your application looks and behaves like other Macintosh<br>
applications.
</p>
<h2>PRINTING</h2>
<p>
Apple is working to make printing easier for Macintosh programmers in the near<br>
future.&nbsp;&nbsp;Meanwhile, we can offer some help in two areas that often cause problems<br>
when printing: handling print records and using PostScript. 
</p>
<p>
<b>HANDLING PRINT RECORDS</b><br>
Some applications set fields in the print record to change the default settings of items<br>
in the print dialogs.&nbsp;&nbsp;Rather than modify these fields, applications should just save the<br>
print record after the user has configured it.&nbsp;&nbsp;The best method for saving the record is<br>
to save it as a resource in your document's resource fork. Since a valid handle already<br>
points to the print record, creating a resource is easy:
</p>
<pre>/*  This is an example of saving a print record into a resource    */
/* file.  Saving the print record in document resource files       */
/* provides a method of retaining the user setting from the last   */
/* print job.  For example, if a user elects to print a document   */
/* using landscape orientation, that information is stored in the  */
/* print record.  If the record is saved with the document, the    */
/* orientation information will be available for the next time the */
/* document is printed.  When the 'Page Setup' dialog is           */
/* presented, the user&#8217;s choices from the last time the document   */
/* was printed will be displayed as defaults.  This provides a     */
/* convenient, device independent method for saving print job      */
/* information.                                                    */
/*                                                                 */
/*  NOTE: Information from the Page Setup dialog is saved into     */
/*  the print record. Information from the Print dialog (i.e. # of */
/*  copies, page range...) is considered to be per job             */
/* information, and is not saved.  This method will not allow you  */
/* to provide new defaults for the PrJobDialog.                    */
/*                                                                 */
/*  Version When    Who     What                                   */
/*  1.0 7/18/89 Zz      First release.                             */
/*                                                                 */

#include &lt;Values.h&gt;
#include &lt;Types.h&gt;
#include &lt;Resources.h&gt;
#include &lt;QuickDraw.h&gt;
#include &lt;Fonts.h&gt;
#include &lt;Events.h&gt;
#include &lt;Windows.h&gt;
#include &lt;Menus.h&gt;
#include &lt;TextEdit.h&gt;
#include &lt;Dialogs.h&gt;
#include &lt;Desk.h&gt;
#include &lt;ToolUtils.h&gt;
#include &lt;Memory.h&gt;
#include &lt;SegLoad.h&gt;
#include &lt;Files.h&gt;
#include &lt;OSUtils.h&gt;
#include &lt;OSEvents.h&gt;
#include &lt;DiskInit.h&gt;
#include &lt;Packages.h&gt;
#include &lt;Printing.h&gt;
#include &lt;Traps.h&gt;

/* POPT = Print OPTions.  This type can be anything */
/* but to avoid confusion with Printing Manager     */
/* resources, the following types should NOT be     */
/* used: PREC, PDEF, &amp; POST...                  */
#define gPRResType  'POPT'

/* This can also be any value.  Since there should  */
/* only be one print record per document, the ID is */
/* a constant.                                      */
#define gPRResID    128

/* Resource name. */
#define gPRResName  "\pPrint Record"

/* Define the globals for this program... */
THPrint gPrintRecordHdl;
short       gTargetResFile;


/* ReportError              */
/*                              */
/* This procedure is responsible for reporting an error to the */
/* user.  This is done by first converting the error code passed */
/* in theError into a message that can be displayed for the user. */
/* See Technical Note #161, "When to call PrOpen and PrClose" */     
*/
void ReportError(theError)
OSErr   theError;
{
    /* Real programs handle errors by displayed comprehensible */
    /* error messages.      */
    /* This is NOT a real program...                                */
    if (theError != noErr)
        SysBeep(10);
}


/* InitializePrintRecord                                */
/*                                                          */
/* This procedure is responsible for initializing a newly created */
/* print record.  It begins by calling PrintDefault to fill in */
/* default values, and then presents the standard 'Page Setup' */
/* dialog allowing the user to specify page setup options. The */
/* modified print record is then returned.                        */
void InitializePrintRecord(thePrintRecord)
THPrint thePrintRecord;
{
    Boolean ignored;

    PrOpen();
    if (PrError() == noErr) {
        PrintDefault(thePrintRecord);
        ignored = PrStlDialog(thePrintRecord);
    }
    PrClose();
}
/* SavePrintRecord                                      */
/*                                                          */
/* This procedure is responsible for saving a print record into a */
/* resource file. On entry, the print record should be */
/* initialized, and the resource file should be open with */
/* permission to write.                            */

void SavePrintRecord(thePrintRecord, theResFile)
THPrint thePrintRecord;
short   theResFile;
{
    short   currentResFile;
    Handle  existingResHdl;
    Handle  newResHdl;
    OSErr   theError;

    /* First save the currently selected resource file (before */
    /* calling UseResFile).     */
    currentResFile = CurResFile();
   
    /* Now select the target resource file.                        */
    UseResFile(theResFile);
    theError = ResError();
    if (theError == noErr) {
        existingResHdl = GetResource(gPRResType, gPRResID);
        if (existingResHdl != NULL) {
    /* There is already a print record resource in this file, so  */
    /* we need to delete it before adding the new one.     */
            RmveResource(existingResHdl);
            theError = ResError();
            if (theError == noErr) {
            /* If the resource was successfully removed, dispose */
            /* of its memory and update the resource file.  */
                DisposHandle(existingResHdl);
                UpdateResFile(theResFile);
            }
        }
        if (theError == noErr) {
        /* Okay, now we have successfully opened the file, and */
        /* deleted any previously saved print record resources. */
        /*  Finally we can add the new one...                    */
        /* Since the Resource Manager is going to keep the handle */
        /* we pass it, we need to make a copy before calling */
        /* AddResource.  We&#8217;ll let the  system do it for us by */
        /* calling HandToHand.                   */
           
            newResHdl = (Handle)thePrintRecord;
            theError = HandToHand(&amp;newResHdl);
            if (theError == noErr) {
                AddResource(newResHdl, gPRResType, gPRResID,
                    gPRResName);
                theError = ResError();
                if (theError == noErr)
                    UpdateResFile(theResFile);
                theError = ResError();
            }
        }  
    }
    if (theError != noErr)
        ReportError(theError);
   
    /* Be polite and restore the original resource file to the top */
    /* of the chain.    */
    UseResFile(currentResFile);
}


/* GetPrintRecord                                   */
/*                                          */
/*  This function is responsible for loading a resource containing */
/* a valid print record.  On entry theResFile should be open with */
/* permission to read.         */
THPrint GetPrintRecord(theResFile)
short   theResFile;
{
    short   currentResFile;
    Handle  theResource;
    OSErr   theError;
    currentResFile = CurResFile();
    UseResFile(theResFile);
    theError = ResError();
    if (theError == noErr) {
        theResource = GetResource(gPRResType, gPRResID);
        theError = ResError();

        if (theError == noErr) {
            PrOpen();
            theError = PrError();
            if (theError == noErr) {
                if (PrValidate((THPrint)theResource)) ;
            }
            PrClose();
        }
    }
    if (theError != noErr)
        ReportError(theError);
    UseResFile(currentResFile);
    return((THPrint)theResource);
}
/* TestPrintRecord                                                */
/*                                                                */
/*  This procedure is used to test a print record.  It will print */
/* a line of text using the options specified in thePrintRecord */
/* passed.  On exit, a line of text  will have been printed.  */
void TestPrintRecord(thePrintRecord)
THPrint thePrintRecord;
{
    GrafPtr currentPort;
    TPPrPort    thePMPort;
    OSErr   theError;
    TPrStatus   thePMStatus;
    GetPort(&amp;currentPort);
    PrOpen();
    if (PrError() == noErr) {
        if (PrJobDialog(thePrintRecord)) {
            thePMPort = PrOpenDoc(thePrintRecord, NULL, NULL);
            if (PrError() == noErr) {
                PrOpenPage(thePMPort, NULL);
                if (PrError() == noErr) {
                    SetPort(&amp;thePMPort-&gt;gPort);
                   
                    MoveTo(100, 100);
                    DrawString("\pThis is a test...");
   
            }
                PrClosePage(thePMPort);
            }
            PrCloseDoc(thePMPort);
            if (((*thePrintRecord)-&gt;prJob.bJDocLoop == bSpoolLoop)
                    &amp;&amp; (PrError() == noErr))
                PrPicFile(thePrintRecord, NULL, NULL, NULL,
                    &amp;thePMStatus);            
        }
    }
    theError = PrError();       /* Any errors?                  */
    PrClose();          /* Close the Printing Manager before */
                        /* attempting to report the error.      */
    if (theError != noErr)      /* If there was an error during */
                                /* printing...*/
        ReportError(theError); /* ...report the error to the user. */
    SetPort(currentPort);
}
main()
{
    InitGraf(&amp;qd.thePort);
    InitFonts();
    InitWindows();
    InitMenus();
    TEInit();
    InitDialogs(NULL);
    InitCursor();

    /* Get the ID of our resource file.  Since we were just */
    /* opened, the CurResFile() will be ours.  In a real */
    /* application, the resource file ID would be the ID  */
    /* of your application&#8217;s document file.                  */
    gTargetResFile = CurResFile();
   
    /* Create a valid print record                              */
    gPrintRecordHdl = (THPrint)NewHandle(sizeof(TPrint));
    if (gPrintRecordHdl != NULL) {
        /* Okay, we got a print record, now initialize it.    */
        InitializePrintRecord(gPrintRecordHdl);
       

        /* Now save the print record into the resource file.    */
        SavePrintRecord(gPrintRecordHdl, gTargetResFile);
       
        /* Now that it&#8217;s saved, kill it off.  We&#8217;ll restore it by */
        /* calling GetPrintRecord.                  */
        DisposHandle((Handle)gPrintRecordHdl);
        gPrintRecordHdl = NULL;
       
        /* Now get the print record from the file.  Since the  */
        /* record will be loaded as a resource handle anyway,  */
        /* let GetPrintRecord allocate the handle.              */
        gPrintRecordHdl = GetPrintRecord(gTargetResFile);
        if (gPrintRecordHdl != NULL) {
            /* Now use the print record to see if the information */
            /* we saved was preserved...                   */
            TestPrintRecord(gPrintRecordHdl);
        } else
            ReportError(MemError());
    } else
        ReportError(MemError());
   
    /* Kill the print record (if it was created) and go home...    */
    if (gPrintRecordHdl != NULL)
        DisposHandle((Handle)gPrintRecordHdl);
}</pre>
<p>
There are several points to remember when using this technique.&nbsp;&nbsp;Use a resource type<br>
not used by the Printing Manager so it doesn't become confused. Types to avoid include<br>
'PREC', 'PDEF' and 'POST'.&nbsp;&nbsp;Remember that lowercase resource types are reserved for<br>
use by Apple.&nbsp;&nbsp;You also should not make assumptions about the size of the record.&nbsp;&nbsp;Use<br>
GetHandleSize if you really need to know.&nbsp;&nbsp;This allows for the record to grow in size in<br>
the future.&nbsp;&nbsp;Finally, when rereading the record from your document, be sure to pass it<br>
to PrValidate before using it in case the user has changed printers or print drivers<br>
since last printing the document.
</p>
<p>
<b>USING POSTSCRIPT</b><br>
Some applications prefer to bypass QuickDraw and print using PostScript instead. <br>
This often results in poor or nonexistent support for printers such as the<br>
ImageWriter and LaserWriter II SC.&nbsp;&nbsp;It also means relying on a method for<br>
determining which printer is in use, such as checking the wDev field in the TPrStl<br>
record. 
</p>
<p>
One method for printing PostScript without relying on the type of printer being used<br>
is using the TextIsPostScript PicComment:
</p>
<pre>PicComment (PostScriptBegin, 0, NIL);
PicComment (TextIsPostScript, 0, NIL);
DrawString (ThePostScript);
PicComment (PostScriptEnd, 0, NIL);</pre>
<p>
The problem with this technique is that because non-PostScript printers ignore the<br>
TextIsPostScript PicComment, DrawString, which is a QuickDraw procedure, literally<br>
sends ThePostScript to the printer, resulting in garbage being printed.&nbsp;&nbsp;A better<br>
technique is using the PostScriptHandle PicComment. Because this comment is only<br>
understood by PostScript drivers, it avoids the QuickDraw/ PostScript interaction<br>
just described:
</p>
<pre>PicComment (PostScriptBegin, 0, NIL);
PicComment (PostScriptHandle, GetHandleSize (ThePostScript),
ThePostScript);
PicComment (PostScriptEnd, 0, NIL);</pre>
<p>
Further problems occur with applications that never print using QuickDraw but only<br>
use PostScript.&nbsp;&nbsp;Some versions of the LaserWriter&#174; driver assume that if they see no<br>
QuickDraw, nothing was printed on the page and no output occurs. This can be avoided<br>
by embedding some nonprinting QuickDraw in your code. Immediately after calling<br>
PrOpenPage, issue the following calls:
</p>
<pre>PenSize (0,0);
MoveTo (10, 10);
Line (0,0);
PenSize (1,1);</pre>
<p>
This technique also solves a problem with background printing.&nbsp;&nbsp;In this case, the<br>
Printing Manager starts off each page with an empty default clipping region. Without<br>
seeing any valid QuickDraw calls, this region is never altered and your nice PostScript<br>
output is clipped entirely off the page.&nbsp;&nbsp;For more details on printing, see the article on<br>
"The Perils of PostScript" in this issue.
</p>
<h2>FONTS</h2>
<p>
System 7.0 will introduce an alternate way of dealing with fonts.&nbsp;&nbsp;While this new<br>
technology won't cause problems for most applications, you should be aware of a few<br>
issues.&nbsp;&nbsp;Any application that allows user font selection will be affected by the new<br>
outline font technology.&nbsp;&nbsp;The most obvious feature is that any size font is now available.<br>
That means a list of point sizes in a menu is no longer sufficient.&nbsp;&nbsp;If you currently<br>
combine font selection and font size selection in a dialog box, be sure to include an<br>
editable field that allows the user to type in any point size.&nbsp;&nbsp;If you now have a list of<br>
common sizes in a menu, include an "Other..." menu item that displays a similar dialog<br>
box with an editable field.
</p>
<p>
Since Apple introduced the LaserWriter, there has been a problem about where to get<br>
font metrics.&nbsp;&nbsp;The most compatible method is simply to call FontMetrics and read the<br>
metrics from the width table.&nbsp;&nbsp;For one reason or another, however, applications have<br>
seen fit to read metrics directly from the 'FOND' resource. The addition of outline fonts<br>
adds another layer of complexity.&nbsp;&nbsp;Outline fonts will store metric information in the<br>
'sfnt'.&nbsp;&nbsp;Accessing metrics in the 'FOND' could give invalid data.&nbsp;&nbsp;If you are currently<br>
accessing the 'FOND' directly, you will have to revise to take advantage of 'sfnt's.
</p>
<h2>INTERNATIONAL SUPPORT</h2>
<p>
You can greatly expand the market for your product if you do not make assumptions<br>
about your user's language.&nbsp;&nbsp;Following a few simple rules can make your application<br>
much easier to localize.&nbsp;&nbsp;Don't simply assume, like many C programmers, that a<br>
character is one byte.&nbsp;&nbsp;Using the C routine strcmp, for example, to sort strings can<br>
give completely wrong results in languages other than English.&nbsp;&nbsp;Use IUCompStr<br>
instead.&nbsp;&nbsp;Determine the local conventions for decimal point, thousands separator, list<br>
separator, and time cycle from the appropriate international resource when<br>
performing input and output.&nbsp;&nbsp;Script Manager 2.0 routines, if available, can make this<br>
even easier by doing the right thing for you automatically.&nbsp;&nbsp;For example, the<br>
Str2Format routine can take input in one language and convert it to a canonical form<br>
that can be used by Format2Str to output the string for a user in a completely<br>
different country.
</p>
<h2>LOWER-LEVEL ISSUES</h2>
<p>
Higher-level issues, such as the ones just discussed, are likely to affect all<br>
applications.&nbsp;&nbsp;But a lot of code that gets written needs to work at a lower level-- either<br>
accessing memory in strange ways or depending on tricks in assembly language, for<br>
example.&nbsp;&nbsp;The remainder of this article will take a look at some of those issues.
</p>
<p>
<b>LOW MEMORY GLOBALS</b><br>
Applications should avoid reliance on low-memory globals.&nbsp;&nbsp;In particular,<br>
undocumented low-memory globals must be avoided since they are most likely to<br>
change.&nbsp;&nbsp;But even dependence on well-known globals can be avoided.&nbsp;&nbsp;For example, the<br>
TickCount trap returns the same value as the low memory global Ticks.&nbsp;&nbsp;TickCount is<br>
supported under A/UX, while Ticks is not, so use of the trap guarantees compatibility.<br>
In general, if a trap is available, always use it.&nbsp;&nbsp;And if a glue routine is available, you<br>
should use it as well.&nbsp;&nbsp;Then if a change is necessary, you need only update your<br>
development system and recompile to implement the change.&nbsp;&nbsp;For the same reason, use<br>
of glue routines is also good advice for assembly-language programming.
</p>
<p>
There is an exception to this rule.&nbsp;&nbsp;The Journaling Driver (see IM I-261) patches key<br>
Event Manager traps : GetMouse, Button, GetKeys, and TickCount. The Journaling<br>
Driver is now used exclusively by MacroMakerTM, and unfortunately the driver's<br>
patches are not reentrant.&nbsp;&nbsp;This means you cannot safely use these traps in interrupt<br>
or VBL code.&nbsp;&nbsp;If you experience strange system hangs only when MacroMaker is<br>
installed, this is probably the cause and your code should instead reference the<br>
appropriate low-memory globals for the information you need.
</p>
<p>
<b>SELF-MODIFYING CODE</b><br>
Applications that use self-modifying code can present serious compatibility issues. <br>
There are two kinds of self-modifying code.&nbsp;&nbsp;The first kind involves actually changing<br>
machine instructions on the fly.&nbsp;&nbsp;Such code, popular in copy protection schemes,<br>
crashes and burns on Macintoshes that use an instruction cache.&nbsp;&nbsp;For example, after a<br>
sequence of instructions has been executed and cached by the Macintosh II, some code<br>
comes along, modifies the original instructions, and tries to execute them again.&nbsp;&nbsp;But<br>
the CPU says, "Ah ha!&nbsp;&nbsp;I already know what these instructions are" and tries to execute<br>
the cached instructions, which is not what the programmer originally intended. <br>
Fortunately, the Macintosh II and natural selection have made such self-modifying code<br>
virtually extinct. 
</p>
<p>
A second, subtler form of self-modifying code keeps variables in the code segment<br>
itself.&nbsp;&nbsp;A typical example is the use of DC.W or DC.L directives to allocate variables in<br>
the same segment as the actual code.&nbsp;&nbsp;Such code avoids the earlier problem because it is<br>
not actually modifying instructions.&nbsp;&nbsp;The catch is that future operating systems may<br>
make 'CODE' segments read-only, and when that code tries to write to its variables, it<br>
will fail.&nbsp;&nbsp;Of course, read-only use of such data, such as storing string constants<br>
within code segments, is valid. It's fine to do this when no alternative is available.&nbsp;&nbsp;You<br>
won't crash in the foreseeable future.
</p>
<p>
A variety of small tasks, such as VBL tasks and completion routines, run<br>
asynchronously on the Macintosh.&nbsp;&nbsp;Because they are executed asynchronously, they<br>
cannot be assured that register A5, which by convention points to the application's<br>
global variables, is valid when they are called.&nbsp;&nbsp;A common technique used in this case<br>
was to store a copy of A5 in with the code so these routines could use the saved value to<br>
access global variables. 
</p>
<p>
It's possible to avoid such self-modifying code, as the following MPW sample code<br>
illustrates.&nbsp;&nbsp;The trick here is that in creating a VBL task you must pass a record<br>
describing the task to the system.&nbsp;&nbsp;When the VBL task is invoked, the system sets up<br>
register A0 to point to the start of this record.&nbsp;&nbsp;While the record itself does not contain<br>
storage for A5, it's simple to embed the VBL task record into a larger record, or in<br>
this case a C struct, that does have room for A5, or anything else you deem important,<br>
such as a handle.&nbsp;&nbsp;An inline function called at the start of the VBL task converts A0 into<br>
a pointer to the record.&nbsp;&nbsp;Then the task can access anything it needs.
</p>
<pre>#include &lt;Events.h&gt;
#include &lt;OSEvents.h&gt;
#include &lt;OSUtils.h&gt;
#include &lt;Dialogs.h&gt;
#include &lt;Packages.h&gt;
#include &lt;Retrace.h&gt;
#include &lt;Traps.h&gt;

#define INTERVAL    6
#define rInfoDialog 140
#define rStatTextItem   1

/*
 *  These are globals which will be referenced from our VBL Task
 */
long    gCounter;   /* Counter incremented each time our VBL gets */
                    /* called */

/*
 *  Define a struct to keep track of what we need.  Put theVBLTask
 *  into the struct first because its address will be passed to our
 *  VBL task in A0
 */
struct VBLRec {
    VBLTask theVBLTask; /* the VBL task itself */
    long    VBLA5;  /* saved CurrentA5 where we can find it */
};
typedef struct VBLRec VBLRec, *VBLRecPtr;

/*
 *  GetVBLRec returns the address of the VBLRec associated with
 *  our VBL task.  This works because on entry into the VBL task,
 *  A0 points to the theVBLTask field in the VBLRec record, which
 *  is the first field in the record and is the address we return.
 *  Note that this method works whether the VBLRec is allocated
 *  globally, in the heap (as long as the record is locked in memory)
 *  or if it is allocated on the stack as is the case in this
 *  example.  In the latter case this is OK as long as the procedure
 *  which installed the task does not exit while the task is running.
 *  This trick allows us to get to the saved A5, but it could also
 *  be used to get to anything we wanted to store in the record.
  */

VBLRecPtr GetVBLRec ()
    = 0x2008;           /* MOVE.L   A0,D0 */

/*
 *  DoVBL is called only by StartVBL ()
 */
void DoVBL (VRP)
VBLRecPtr   VRP;
{
    gCounter++;         /* Show we can set a global */
    VRP-&gt;theVBLTask.vblCount = INTERVAL;
                                /* Set ourselves to run again */
}

/*
 *  This is the actual VBL task code.  It uses GetVBLRec to get
 *  our VBL record and properly set up A5.  Having done that, it
 *  calls DoVBL to increment a global counter and sets itself to
 *  run again.  Because of the vagaries of MPW C 3.0 optimization,
 *  it calls a separate routine to actually access global variables.
 *  See Tech Note #208 - "Setting and Restoring A5" for the
 *  reasons for this, as well as for a description of SetA5.
 */
void StartVBL ()

{
    long        curA5;
    VBLRecPtr   recPtr;
   
    recPtr = GetVBLRec ();  /* First get our record */
    curA5 = SetA5 (recPtr-&gt;VBLA5);   /* Get the saved A5 */
   
                /* Now we can access globals */
    DoVBL (recPtr);     /* Call another routine to do actual work */
   
    (void) SetA5 (curA5);   /* Restore old A5 */
}

/*
 *  InstallVBL creates a dialog just to demonstrate that the global
 *  variable is being updated by the VBL Task.  Before installing
 *  the VBL, we store our A5 in the actual VBL Task record, using
 *  SetCurrentA5 described in Tech Note #208.  We&#8217;ll run the VBL,
 *  showing the counter being incremented, until the mouse button
 *  is clicked.  Then we remove the VBL Task, close the dialog, and
 *  remove the mouse down events to prevent the application from
 *  being inadvertently switched by MultiFinder.
 */
void InstallCVBL ()
{
    VBLRec  theVBLRec;
    DialogPtr   infoDPtr;
    DialogRecord    infoDStorage;
    Str255  numStr;
    OSErr   theErr;
    Handle  theItemHandle;
    short   theItemType;
    Rect    theRect;

    gCounter = 0;   /* Initialize our global counter */
    infoDPtr = GetNewDialog (rInfoDialog, (Ptr) &amp;infoDStorage,
        (WindowPtr) -1);
    DrawDialog (infoDPtr);
    GetDItem (infoDPtr, rStatTextItem, &amp;theItemType, &amp;theItemHandle,
        &amp;theRect);

    /*
     *  Store the current value of A5 in the MyA5 field.  For more
     *  information on SetCurrentA5, see Tech Note #208 - "Setting
     *  and Restoring A5".
     */
    theVBLRec.VBLA5 = SetCurrentA5 ();
    /* Set the address of our routine */
    theVBLRec.theVBLTask.vblAddr = (VBLProcPtr) StartVBL;
    theVBLRec.theVBLTask.vblCount = INTERVAL; /* Frequency of task,
                                                 in ticks */
    theVBLRec.theVBLTask.qType = vType;  /* qElement is a VBL task */
    theVBLRec.theVBLTask.vblPhase = 0;
   
    /* Now install the VBL task */
    theErr = VInstall ((QElemPtr)&amp;theVBLRec.theVBLTask);
   
    if (!theErr) {
        do {
            NumToString (gCounter, numStr);
            SetIText (theItemHandle, numStr);
        } while (!Button ());
        theErr = VRemove ((QElemPtr)&amp;theVBLRec.theVBLTask);
                /* Remove it when done */
    }
   
    /* Finish up */
    CloseDialog (infoDPtr); /* Get rid of our dialog */
    FlushEvents (mDownMask, 0); /* Flush all mouse down events */
}</pre>
<p>
<b>PRIVILEGED INSTRUCTIONS</b><br>
Under the current Macintosh operating system, the CPU operates in the supervisor<br>
state and applications are allowed to use any and all 680x0 instructions, with the lone<br>
exception of the Test And Set (TAS) instruction, which is not supported by the<br>
hardware.&nbsp;&nbsp;The .A/UX operating system forces applications to run in the user state, and<br>
applications that use privileged instructions reserved for the supervisor state will<br>
fail.&nbsp;&nbsp;Examples of such instructions are MOVE, ANDI, and EORI instructions with the<br>
status register (SR) as either the source or the destination.&nbsp;&nbsp;Typically, these<br>
instructions are used to alter the condition code register (CCR), which is the low byte<br>
of the SR. Using these instructions with the CCR as the source or destination instead of<br>
the SR will accomplish the same thing without causing your application grief. Certain<br>
floating point instructions such as FSAVE and FRESTORE are also privileged and should<br>
be avoided.&nbsp;&nbsp;As we mentioned, A/UX does not allow the use of privileged instructions<br>
and is a good test of compatibility in this case.
</p>
<p>
<b>DIRECT HARDWARE ACCESS</b><br>
If you think you need direct access to hardware, let Apple know.&nbsp;&nbsp;It may be acceptable<br>
on other personal computers to access hardware directly, but it is decidedly<br>
anti-social on the Macintosh and absolutely verboten under operating systems with<br>
multi-user protection like A/UX.&nbsp;&nbsp;Beware of schemes for copy protection or<br>
performance enhancement that rely on direct hardware access. Macintosh hardware<br>
has changed in the past, and it will change in the future. Each new machine may mean<br>
yet another revision of your application.
</p>
<p>
<b>TRAP PATCHING</b><br>
Trap patching is very useful for overriding or enhancing system trap handling.&nbsp;&nbsp;It is<br>
used by the system, for example, to correct errors in the Macintosh ROM. Many<br>
applications also use it to provide additional functionality.&nbsp;&nbsp;Because it is very difficult<br>
to anticipate all the possible side effects of your patch, maintaining compatibility is<br>
difficult, too.&nbsp;&nbsp;Before writing a patch, you should decide if it's absolutely essential. <br>
Often the results you need can be achieved without the patch. 
</p>
<p>
Suppose, for example, you decide to patch ExitToShell.&nbsp;&nbsp;This may sound like an<br>
excellent way for your program to get one last chance at closing files or doing<br>
whatever other cleanup is necessary before exiting.&nbsp;&nbsp;Whether ExitToShell is called in<br>
response to a user's Quit command or because of some fatal error condition, your patch<br>
would always have a chance to clean up.&nbsp;&nbsp;But rather than having ExitToShells all over<br>
your code, you could achieve the same result by calling a single, common exit routine<br>
that performed the cleanup and then called ExitToShell.
</p>
<p>
If you absolutely must trap patch, here are some general guidelines.&nbsp;&nbsp;Don't make<br>
assumptions about the format of the trap dispatch table.&nbsp;&nbsp;In particular, don't try to<br>
read or write entries in the trap dispatch table directly--use GetTrapAddress and<br>
SetTrapAddress instead.&nbsp;&nbsp;If your patch only applies to your application, install it in<br>
your application heap.&nbsp;&nbsp;Otherwise, install it in the system heap.&nbsp;&nbsp;Application heap<br>
patches will be swapped out by MultiFinder when your application is switched out. <br>
Because system heap patches will apply to all applications that use the trap, use them<br>
only when absolutely necessary.
</p>
<p>
You cannot assume that a valid A5 world exists when your patch is invoked. Register<br>
A5 points to the base of an application's global variables, and A5 world refers to an<br>
application's global address space.&nbsp;&nbsp;MultiFinder maintains different A5 worlds for each<br>
running application.&nbsp;&nbsp;Your patch cannot assume when it is called that A5 points to your<br>
application's global variables.&nbsp;&nbsp;If it needs access to global variables, you must save a<br>
copy of A5 before installing your patch.&nbsp;&nbsp;Then the patch needs to preserve the current<br>
value of A5, set the saved value, and restore the original A5 on exit.&nbsp;&nbsp;(See Technical<br>
Note #208.) Your patch should avoid use of the Memory Manager if the trap could be<br>
invoked at interrupt time or if memory could move during your patch.
</p>
<p>
Finally, you must not tail patch.&nbsp;&nbsp;In a normal patch, your code completes its task and<br>
then invokes the standard trap code to complete the patch.&nbsp;&nbsp;In a tail patch, your code<br>
regains control after the standard trap code completes.&nbsp;&nbsp;The problem with this<br>
technique is that many of the ROM patches are themselves tail patches, and they rely<br>
on knowledge of the caller to accomplish their task.&nbsp;&nbsp;If the ROM patch expects to be<br>
called from a ROM address, but is instead called by your patch code, it can become<br>
confused.&nbsp;&nbsp;If you JSR to invoke the standard trap code, then you are tail patching.&nbsp;&nbsp;The<br>
correct way is to JMP to the starting address of the code.
</p>
<h2>IN CONCLUSION</h2>
<p>
It may be useful to know that Apple's implementation of Unix, A/UX, offers a major<br>
test for compatibility with System 7.0.&nbsp;&nbsp;A/UX provides a very different environment<br>
for Macintosh applications, but applications that follow the compatibility guidelines<br>
work without alteration under A/UX.&nbsp;&nbsp;If your application works correctly under A/UX,<br>
it stands a very good chance of working correctly under System 7.0.
</p>
<p>
If you've gotten this far, you are likely to avoid Johnny Appledweeb's fate.&nbsp;&nbsp;You<br>
obviously are seriously concerned for your customers and willing to go that extra step<br>
to minimize future compatibility problems.&nbsp;&nbsp;It may seem at times that Apple goes out<br>
of its way to stretch its own rules, but that is not the case.&nbsp;&nbsp;It is simply impossible to<br>
foresee all future hardware and software changes. Incompatibility is unfortunately an<br>
ongoing battle.&nbsp;&nbsp;Your part of that battle goes beyond this article and requires you to<br>
keep abreast of changes as Apple announces them.
</p>
<p>
<b>Dave Radcliffe</b>, "Technical Sherpa," has been with Apple about a year and a half,<br>
putting his chemistry degree from Washington University to work in A/UX&#174; and MPW<br>
technical support.&nbsp;&nbsp;Actually, he discovered his true calling while working with the<br>
computers in the UCLA chemistry research labs.&nbsp;&nbsp;When asked how he's changing the<br>
world one person at a time, Dave replied, "home-brewed beer." In addition to home<br>
concoctions, he's into hiking, backpacking, and photography.&nbsp;&nbsp;*
</p>
</body>
</html>
