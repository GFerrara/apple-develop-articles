<!DOCTYPE html>
<html>
<head>
<!-- Article ID: 13 - Extracted from develop-1990 -->
<!-- on 2023-12-27 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by the copyright of its respective owners -->
<title>October 90 - WRITING A DEVICE DRIVER IN C++ (WHAT? IN C++?)</title>
<link href="../common/styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h2>WRITING A DEVICE DRIVER IN C++ (WHAT? IN C++?)</h2>
<img src="img/129.gif" width="176 px"></img><br>
<h1>TIM ENWALL</h1>
<p>
<i>Most developers write device drivers in assembly language, rarely considering a</i><br>
<i>higher level, object-based language such as C++ for such&nbsp;&nbsp;a job. This article describes</i><br>
<i>some of the advantages of higher level languages over assembly and warns of some of</i><br>
<i>the gotchas you may encounter if you write a driver in C++. An example of a device</i><br>
<i>driver written in C++ follows a brief discussion of drivers in general.</i>
</p>
<p>
When you think of writing a device driver, your first reaction may be, "But I haven't<br>
brushed up on assembly language in some time." After taking a deep breath, you think<br>
of another approach: "Why can't I use a high-level language?" You can. One such<br>
language is C++.
</p>
<p>
In comparison with standard C, C++ offers some definite advantages, including ease of<br>
maintenance, portability, and reusability. You can encapsulate data and functions into<br>
classes, giving future coders an easier job of maintaining and enhancing what you've<br>
done. And you can take advantage of most (but not all) of the powerful features of C++<br>
when you write stand-alone code.
</p>
<p>
You will run into a few gotchas, including the fact that polymorphism is available only<br>
if you do some extra work (for a definition of polymorphism, seedevelop,Issue 2, page<br>
180).&nbsp;&nbsp;Because the virtual tables (vTables) reside in the jump-table segment, a<br>
stand- alone code resource can't get at the vTables directly (more on this topic later).<br>
You also have to deal with factors such as how parameters are passed to methods, how<br>
methods are called, how you return to the Device Manager, how you compile and link<br>
the DRVR resource, and how the DRVR resource is installed when the machine starts<br>
up. We'll tackle some of these obstacles as we work through the sample device driver<br>
presented later in this article.
</p>
<p>
<b>WHY C++?</b>
</p>
<p>
When someone suggests writing a device driver in anything other than assembly<br>
language, the common reaction is, "But you're talking to a <i> device! </i> Why would you<br>
want to use C++?"
</p>
<p>
For communication with devices, assembly language admittedly gets the job done in<br>
minimal time, with maximum efficiency. But if you're writing something where code<br>
maintenance, portability, and high-level language functionality are just as important<br>
as speed and efficiency, a higher level language is preferable. Not all device drivers<br>
actually communicate with physical devices. Many device drivers have more esoteric<br>
functions, such as interapplication communication, as&nbsp;&nbsp;in the sample driver in this<br>
article. (In fact, DAs are of resource type DRVR and behave exactly the same way<br>
device drivers behave. DAs are even created the same way.) For these kinds of device<br>
drivers, C++ is a great language to use because you can take advantage of all the<br>
features of a high- level language, plus most of the object-based features of C++.<br>
Finally, device drivers have some nice features that make them appealing for general<br>
usage:
</p>
<ul>
<li> They can remain in the system heap, providing a common interface for<br>
any&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;application to easily call and use.&nbsp;&nbsp;&nbsp;&nbsp;</li>
<li> They get periodic time (if other applications are not hogging the CPU).</li>
</ul>
<p>
Good examples of nondevice drivers are the .MPP (AppleTalk &#174;) driver and the .IPC<br>
(A/ROSETMinterprocess communication) driver. Both these drivers provide pretty<br>
high-level functionality, but neither directly manipulates a device as such (except for<br>
the very low-level AppleTalk manipulations of communication ports). Of course, if<br>
you were writing code to communicate quickly and efficiently to a modem, for example,<br>
assembly language might be the better choice, depending on your need for efficiency<br>
and timing. For the purposes of this article, any reference to a device driver includes<br>
both types of drivers.
</p>
<p>
Clearly, higher level languages have a place, but what about object-based languages?<br>
Object-based languages provide a great framework for encapsulation of data and<br>
functions and hence increase the ease of maintenance and portability (if used<br>
elegantly). One question still remains: Why C++?
</p>
<p>
Notables such as Bjarne Stroustrup and Stanley Lippman have pointed out some of the<br>
advantages C++ offers over conventional high-level languages. C++ offers great<br>
extensions, such as operator and function overloading, to standard C. C++ is much<br>
more strongly type checked than C, so it saves us programmers from ourselves.&nbsp;&nbsp;C++<br>
classes offer a way to encapsulate data--and functions that operate on the<br>
data--within one unit. You can make different elements and functions "private" to<br>
objects of only one class or "public" to objects of every type. The private and public<br>
nature of data and member functions allows you to accomplish real encapsulation.
</p>
<h2>COMPARING C++ AND ASSEMBLY LANGUAGE</h2>
<p><table border="0"><tr><td></td><td><b>C++</b></td><td><b></b><b>Assembly Language</b></td></tr>
<tr><td><b>Pros</td><td></b>Portable</td><td>Fast</td></tr>
<tr><td></td><td>Reusable</td><td>Efficient</td></tr>
<tr><td></td><td>Easy to maintain</td><td>Compact</td></tr>
<tr><td></td><td>Object-based design</td><td>Direct access to CPU</td></tr>
<tr><td></td><td>High-level language features</td><td></td></tr>
<tr><td></td><td>Data encapsulation</td><td></td></tr>
<tr><td><b>Cons</td><td></b>Three separate source files</td><td>Not portable</td></tr>
<tr><td></td><td>&nbsp;&nbsp;multiple compiles</td><td>Hard to maintain</td></tr>
<tr><td></td><td>Speed inefficient</td><td>Lacking high-level language</td></tr>
<tr><td></td><td>Polymorphism difficult</td><td>features such as loops</td></tr>
<tr><td></td><td>in stand-alone code</td><td>and IF-THEN-ELSE</td></tr></table></p>
<p class="spacer">&nbsp;</p>
<p class="spacer">&nbsp;</p>
<h2>SOME LIMITATIONS</h2>
<p>
As noted, one valuable feature of C++, polymorphism, is not readily available when<br>
you write a device driver in C++. Other limitations involve working with assembly<br>
language, possible speed sacrifices, work-arounds for intersegment calls, and mangled<br>
procedure names.
</p>
<p>
<b>POLYMORPHISM</b>
</p>
<p class="spacer">&nbsp;</p>
<p>
Because a device driver is a stand-alone code resource, there is no "global" space or<br>
jump table. C++'s virtual function tables (vTables), which are the means to the<br>
polymorphism end, live in an application's global space. The loss of virtual tables is a<br>
limitation of stand-alone code, not a limitation of C++. Patrick Beard's article,<br>
"Polymorphic Code Resources in C++" (this issue), shows one way to work around<br>
this limitation. The work-around takes some extra work and is dependent on the<br>
current implementation of CFront, which may make future compatibility a problem.<br>
In the interests of clarity and compatibility, I have chosen not to use polymorphism<br>
for the example in this article.
</p>
<p>
<b>ASSEMBLY-LANGUAGE MUCK</b><br>
Another difficulty is that we have to get our hands assembly-language dirty. The<br>
Device Manager is going to call the device driver with a few registers pointing to<br>
certain structures, and we'll have to put those on the stack so the C++ routines can get<br>
to them. Specifically,<code> A0 </code>points to the parameter block that is being passed, and <code>A1</code><br>
has a handle to the Device Control Entry for the driver.&nbsp;&nbsp;Having to do some assembler<br>
work is a limitation of the operating system; the toolbox doesn't push the parameters<br>
onto the stack (now if there were glue to do that--).
</p>
<p>
These registers must somehow make their way onto the stack as parameters to our<br>
routines because procedures take their parameters off the stack. When we've finished,<br>
we also have to deal with jumping to<code> jIODone </code>or plain<code> RTSing</code>, depending on the<br>
circumstances. For the simple driver shown in the example, we will in reality almost<br>
always jump via<code> jIODone </code>when finished with our routines. But, for drivers that<br>
wish to allow more than one operation at a time, the<code> Prime</code>,<code>Control</code>, and<code> Status</code><br>
calls must return via an<code> RTS </code>to signal the Device Manager that the request has not<br>
been completed. The driver's routines should jump to<code> jIODone </code>only when the request<br>
is complete.
</p>
<p>
We must also decide whether or not to call a C++ method directly from the assembly<br>
language "glue." If we call the method directly, we have to put the "this" pointer on the<br>
stack because it's passed implicitly to all object methods. We also have to use the<br>
"mangled" name generated by the compiler and used by the linker. (If you haven't had<br>
the opportunity to see mangled names, you'll find they're a joy to figure out without<br>
the help of our friend Mr. Unmangle.) So, if we choose to call extern C functions, as<br>
the example does, we run into yet another level of "indirection" before we get to the<br>
real meat of the matter.
</p>
<p>
<b>SPEED</b><br>
Some might say we sacrifice speed as well as efficiency--and they're correct. In<br>
general, compilers can't generate optimally speed-efficient code. They can come close,<br>
but nothing even approaches how the human mind tackles some tricky machine-level<br>
issues. Thus, we're at the mercy of the compiler--the loss of speed is the result of the<br>
compiler's inefficiency.
</p>
<p>
You'll probably find the sample driver presented in this article pretty inefficient. But<br>
the trade-off is acceptable because speed isn't important in this case, and you can use<br>
all the features of an object-based language. In fact, in most instances you can limit<br>
assembly language to a few routines, which must be tightly coded, and use C++ for the<br>
rest. 
</p>
<p>
<b>MANGLED IDENTIFIERS</b><br>
If you're familiar with C++, you've undoubtedly seen the visions of unreadability<br>
created by CFront. But, if you're still unfamiliar with C++ in practice, here's an<br>
explanation. CFront is simply a preprocessor that creates C code, which is passed to<br>
the C compiler. So CFront has to somehow take a function of the form
</p>
<pre>TDriver::iacOpen(ParmBlkPtr aParmBlkPtr)</pre>
<p>
and create a C function name the C compiler can understand. The problem is that when<br>
the linker complains, it will use the <i> mangled </i> name, which is hard to decipher.
</p>
<p>
Here's how it looks:<br>
<b>from MPW Shell document</b>
</p>
<pre>unmangle iacOpen__7TDriverFP13ParamBlockRec
Unmangled symbol: TDriver::iacOpen(ParamBlockRec*)</pre>
<p>
It's clear why these names are referred to as mangled and unmangled. Fortunately, the<br>
unmangle tool provided with MPW allows you to derive the unmangled name from the<br>
mangled.
</p>
<h2>A SAMPLE C++ DRIVER</h2>
<p>
The sample driver that follows illustrates some of the issues involved in writing a<br>
device driver in general, and specifically in C++. The code is in the folder labeled C++<br>
Driver on the<i> Developer Essentials</i> disc.
</p>
<p>
<b>INTERAPPLICATION COMMUNICATION</b><br>
The sample driver performs one basic function--interapplication communication<br>
(IAC)--under System 6. Under System 7 the services of this sample driver aren't<br>
necessary because IAC is built into the system. But the concepts presented here are<br>
still sound, and the driver works as well under System 7 as it does under System 6.<br>
The driver is installed at Init time with code that walks through the unit table looking<br>
for a slot.
</p>
<p>
<b>CLASS STRUCTURE</b><br>
The classes are fairly straightforward, serving as an example of how to use C++ to<br>
encapsulate data with methods without getting into some gnarly class hierarchies that<br>
would only obfuscate the point (and that aren't yet possible with stand-alone code).<br>
Two classes suffice:<code>TDriver </code>and<code> TMessage</code>.<code> TDriver </code>handles all the driving; it<br>
responds to each control and status call defined and handles opening and closing the<br>
driver. It keeps two simple data structures--an array of application names that have<br>
registered and an array of<code> TMessage</code>pointers that need to be received. <code>TMessage</code><br>
handles the messages--who they're from, who they're addressed to, and what the<br>
message is. I think you'll find the declarations easy reading.
</p>
<p>
<b>from TDriver.h</b>
</p>
<pre>class TDriver: public HandleObject {
public:
        // Constructor and destructor.
        TDriver();
        ~TDriver();

    /* Generic driver routines. These are the only public interfaces
     * we show to the world.                                */
    OSErr   iacOpen(ParmBlkPtr oParmBlock);
    OSErr   iacPrime(ParmBlkPtr pParmBlock);
    OSErr   iacControl(ParmBlkPtr cntlParmBlock);
    OSErr   iacStatus(ParmBlkPtr sParmBlock);
    OSErr   iacClose(ParmBlkPtr cParmBlock);
   
private:
    // Control Routines.
    /* RegisterApp takes the string in iacRecord.appName and finds
     * a slot in the array for the name (hence it "registers"
     * the application). SendMessage sends a message from one
     * application to another (as specified by the iacRecord fields).
     * ReceiveMessage puts the message string into the
     * iacRecord.msgString field if there's a message for the
     * requesting application.  UnregisterApp removes the
     * application's name from the array (hence the application is
     * "unregistered").                                 */
    short       RegisterApp(IACRecord   *anIACPtr);
    short       SendMessage(IACRecord   *anIACPtr);
    short       ReceiveMessage(IACRecord    *anIACPtr);
    short       UnregisterApp(IACRecord *anIACPtr);
   
    // Status Routines
    /* WhosThere returns the signature of other applications that
     * have registered.
     * AnyMessagesForMe returns the number of messages waiting for
     * the requesting application in iacRecord.actualCount.     */
    void        WhosThere(IACRecord *anIACPtr);
    Boolean AnyMessagesForMe(IACRecord  *anIACPtr);
   
    // Message array handling routines.
    /* GetMessage gets the TMessPtr in fMessageArray[signature].
     * SetMessage sets the pointer in fMessageArray[signature] to
     * aMsgPtr.                                 */
    TMessPtr    GetMessage(short signature);
    void        SetMessage(short index, TMessPtr    aMsgPtr);
   
    // AppName array handling routines.
    /* GetAppName gets the application name in
     * fAppNameArray[signature].  SetAppName sets the application
     * in fAppNameArray[signature] to anAppName.            */
    char        *GetAppName(short signature);
    void        SetAppName(short signature, char *anAppName);
   

    /* We keep an array of applications that can register with the
     * driver. I've arbitrarily set this at 16. We also keep an array
     * of TMessage pointers to be passed around. This is also
     * arbitrarily set at 16. In the future, I'd probably implement
     * this as a list of messages.                                */
    char        fAppNameArray[kMaxApps] [255];
    TMessPtr    fMessageArray[kMaxMessages];
};</pre>
<p>
<b>from TMessage.h</b>
</p>
<pre>class TMessage {
public:
        /* Constructor and destructor. Constructor will build the
         * message with the appropriate data members passed in.    */
        TMessage(char *message, short senderSig, short receiverSig);
        ~TMessage();
               
        /* Two Boolean functions that simply query the message to see
         * if the message is destined for the signature of the
         * Requestor. Nice example of function overloading&#8212;in the
         * one case I just wanted to return true or false; in the
         * other case I wanted to return who the message was from and
         * the actual message string. This is also nice because we
         * have only one public member function returning any private
         * information.                                            */
    Boolean IsMessageForMe(short sigOfRequestor);
    Boolean IsMessageForMe(short sigOfRequestor, short *senderSig,
                     char *messageString);
   
private:
    /* GetSenderSig returns fSenderSig.
     * SetSenderSig sets fSenderSig to signature.           */
    short       GetSenderSig();
    void        SetSenderSig(short signature);
   
    /* GetReceiverSig returns fReceiverSig.
     * SetReceiverSig sets fReceiverSig to signature.       */
    short       GetReceiverSig();
    void        SetReceiverSig(short signature);
   
    /* GetMessageString returns fMessageString.
     * SetMessageString sets fMessageString to msgString.   */
    char        *GetMessageString();
    void        SetMessageString(char *msgString);
   


    // Private data members. Again, we keep storage for the string
    // here.
    short       fSenderSig;
    short       fReceiverSig;
    char        fMessageString[255];
};</pre>
<p>
The only remaining structure worthy of note is the<code> IACRecord</code>structure.&nbsp;&nbsp;This<br>
structure is passed in the<code> csParam </code>field of the parameter block pointers passed to the<br>
driver. Essentially the<code> IACRecord</code> structure contains all the&nbsp;&nbsp;control information, or<br>
returns all the status information, the application needs to communicate--the<br>
signatures of the sender and receiver, the message and application name strings, and a<br>
couple of other control fields.
</p>
<p>
<b>from IACHeaders.h</b>
</p>
<pre>struct IACRecord    {
    // Signature number of application sending/receiving.
    short   mySignature;

    // Signature of app that's either sent a message or        
    // of app to which the current app is sending.
    short   partnerSig;
                   
    // Index to cycle through the apps that have registered.
    short   indexForWhosThere;

    // Nonzero if messages there for recipient.
    short   actualCount;

    // Message string being sent or received.
    char*   messageString;

    // String to register as.
    char    *appName;
};</pre>
<p>
<b>REGISTERING WITH THE DRIVER</b><br>
To use the driver, an application registers itself with the driver, thus signifying that<br>
the application is able to receive and send messages. The driver returns a unique<br>
signature for the application to use throughout the communication session. A second<br>
(or third, or fourth) application also registers and communicates with other<br>
applications by sending and receiving messages using the correct signature. When an<br>
application is finished, it simply unregisters itself. Here are four of the methods that<br>
do most of the work:<b>from TDriver.cp</b>
</p>
<pre>/*********************************Comment**************************
* TDriver::RegisterApp looks to see if there's an open "slot".
* If so, it sets the new AppName for that "slot" and
* returns the "slot" as the signature.  If it couldn't find any
* open "slots" then it returns the kNoMore error.
 *********************************End Comment*********************/
short
TDriver::RegisterApp(IACRecord *anIACPtr)
{
short       i = 0;
short       canDo = kNoMore;

while ((i &lt; kMaxApps) &amp;&amp; (canDo == kNoMore))
    {
    if((this-&gt;GetAppName(i))[0] == kZeroChar)
        {
        canDo = kNoErr;
        anIACPtr-&gt;mySignature = i;
        this-&gt;SetAppName(i,anIACPtr-&gt;appName);
        }
    i++;
    }
return (canDo);
} //  TDriver::RegisterApp

/*********************************Comment**************************
* TDriver::SendMessage has to instantiate a new message object.  It
* also has to remember that message for later when someone tries to
* receive it.  To remember it, the TDriver object places it in the
* message pointer array.  If it couldn't find an open "slot" in
* the array, it returns the error kMsgMemErr, meaning it has no
* memory to store the pointer to the message and hence the message
* didn't get sent. Since the TDriver object is creating a new
* TMessage, it will destroy the TMessage when the time comes.
 *********************************End Comment*********************/
short
TDriver::SendMessage(IACRecord *anIACPtr)
{
TMessPtr    aMsgPtr;
short       canDo = kNoMore;
short       i = 0;

aMsgPtr = new TMessage(anIACPtr-&gt;messageString,
        anIACPtr-&gt;mySignature, anIACPtr-&gt;partnerSig);

if(aMsgPtr)
    {
    while ((i &lt; kMaxMessages) &amp;&amp; (canDo == kNoMore))
        {
        if(this-&gt;GetMessage(i) == nil)
            {
            this-&gt;SetMessage(i, aMsgPtr);
            canDo = kNoErr;
            }
        i++;
        }
    if (canDo == kNoMore)
        delete aMsgPtr;
    } // if aMsgPtr
else
    canDo = kMsgMemErr;
return (canDo);    
} //  TDriver::SendMessage

/**********************************Comment***************************
* TDriver::ReceiveMessage finds any messages for the application
* whose signature is mySignature. It first checks to see if there
* are any  messages. If so, it gets the message and asks the TMessage
* object to return the message string. Then it copies the message
* string to the calling application's message buffer, puts the
* sender's signature in "partnerSig", and puts the sender's
* application name in appName. It then sets the "slot" in the
* message array to nil and disposes of the TMessage object. If there
* were messages, it returns the kYesMessagesForMe value; otherwise it
* returns kNoMore.
 **********************************End Comment*********************/
short
TDriver::ReceiveMessage(IACRecord *anIACPtr)
{
TMessPtr        aMsgPtr;
short           sender;
char            *bufP = nil;

if(this-&gt;AnyMessagesForMe(anIACPtr))
    {
    aMsgPtr = this-&gt;GetMessage(anIACPtr-&gt;actualCount);
    (void) aMsgPtr-&gt;IsMessageForMe
        (anIACPtr-&gt;mySignature,&amp;sender,bufP);  
    anIACPtr-&gt;partnerSig = sender;
    tseStrCpy(anIACPtr-&gt;messageString,bufP);
    tseStrCpy(anIACPtr-&gt;appName,
        this-&gt;GetAppName(anIACPtr-&gt;partnerSig));
    this-&gt;SetMessage(anIACPtr-&gt;actualCount,nil);

        delete aMsgPtr;
        return (kYesMessagesForMe);
        }
else
        return(kNoMore);
} // TDriver::ReceiveMessage

/************************Comment***************************
* TDriver::UnregisterApp receives all the messages for the
* application that is unregistering. Those messages will
* just get thrown away. So, all the messages destined for
* it are disposed of, and then it sets the name to '\0' so
* others can play.
 ***********************End Comment***********************/
short
TDriver::UnregisterApp(IACRecord *anIACPtr)
{
char        zeroChar = kZeroChar;

// Gotta delete those suckers.
while (this-&gt;ReceiveMessage(anIACPtr) == kYesMessagesForMe) ;
// Zero the name so others can play.
this-&gt;SetAppName(anIACPtr-&gt;mySignature,&amp;zeroChar);
return (kNoErr);
} // TDriver::UnregisterApp</pre>
<p>
<b>ASSEMBLY WRAPPED AROUND EXTERN "C", WRAPPED AROUND C++</b><br>
When you open the C++ Driver folder <i> (Developer Essentials </i> disc), you see many<br>
source files, including the files DriverGlue.a and DriverWrapper.cp.&nbsp;&nbsp;The assembly<br>
glue performs three main functions:
</p>
<ul>
<li> Pushing the appropriate registers onto the stack.</li>
<li> Returning to the Device Manager in the proper manner.</li>
<li> Setting up the DRVR resource with the appropriate routine offsets in the<br>
offset fields.</li>
</ul>
<p>
&nbsp;The first two functions were covered earlier, but the third deserves some further<br>
note.
</p>
<p>
&nbsp;If you just glance at the MPW&#174; manual, creating the DRVR resource seems like a<br>
breeze. There's an entire section on it, right? Wrong. The section on building DRVRs is<br>
a good excursion into how to compile and link a DA (how they got to be DRVRs we'll<br>
never know), but only serves to mislead when it comes to "real" DRVR resources.
</p>
<p>
MPW provides a great run-time library for DAs called DRVRRuntime.o, and it also<br>
provides a resource template that<code> rez</code>can use to create the final DRVR resource. The<br>
DRVW resource template included in MPWTypes.r even provides a nice programming<br>
description of the DRVR resource, but falls short when you&nbsp;&nbsp;delve into specifying the<br>
routine offsets every "device driver" needs to its<br>
<code>Open/Prime/Control/Status/Close </code>routines. The DRVRRuntime.o library simply<br>
provides jump statements to the appropriate pc-relative address for the<code> DRVROpen</code>,<br>
<code>DRVRPrime</code>,<code>DRVRControl</code>,<code> DRVRStatus</code>, and <code>DRVRClose </code>routines. Hence, the offsets<br>
are only 4 bytes apart, and right there the DRVR is hosedbecause the Device Manager<br>
has no way to jump to, say, the device driver's control routine.
</p>
<p>
For example, say an<code> Open </code>routine is 48 bytes long. If you use the DRVW template, the<br>
DCE header will contain 0 as the offset for the<code>Open </code>routine, 4 as the offset for the<br>
<code>Prime </code>routine, 8 as the offset for the<code> Control </code>routine, and so on. When the Device<br>
Manager goes to call the<code> Control </code>routine, it will jump 8 bytes into the<code>Open </code>routine<br>
and start executing there--<i> not </i> what you had intended. The only recourse is to use<br>
DriverGlue.a as an entry point and define the offsets at the beginning of the assembly<br>
file (calculating the offsets appropriately). So much for having<code> rez </code>help out; maybe<br>
the assembler will be more helpful.
</p>
<p>
The "main" procedure, created to compensate for<code> rez</code>'s ineffectiveness,&nbsp;&nbsp;looks like<br>
this:
</p>
<p>
<b>from DriverGlue.a</b>
</p>
<pre>HEADERDEF   PROC    EXPORT                                         
            IMPORT  TSEPrime           
            IMPORT  TSEOpen
            IMPORT  TSEControl         
            IMPORT  TSEStatus          
            IMPORT  TSEClose   
TSEStartHdr DC.W    $5F00       ; Turn the proper bits on
                          ; dNeedLock&lt;6&gt;, dNeedGoodbye&lt;4)
                          ; dReadEnable&lt;3&gt;, dWritEnable&lt;2&gt;
                          ; dCtlEnable&lt;1&gt;, dStatEnable&lt;0&gt;
            DC.W  $12C    ; 5 seconds of delay (if dNeedTime = True)
            DC.W  0       ; DRVREMask (for DAs only)
            DC.W  0       ; DRVRMenu (for DAs only)
            DC.W  TSEOpen-TSEStartHdr    ; Offset to open routine.
            DC.W  TSEPrime-TSEStartHdr   ; Offset to prime routine.
            DC.W  TSEControl-TSEStartHdr ; Offset to control routine.
            DC.W  TSEStatus-TSEStartHdr  ; Offset to Status routine.
            DC.W  TSEClose-TSEStartHdr   ; Offset to Close routine.

DC.B        '.TimDriver'    ; Driver name.
ALIGN       4               ; Align to next long word.
ENDP</pre>
<p>
&nbsp;It would be ideal to jump straight from the assembly language glue to the C++<br>
<code>TDriver </code>methods and let the object do the work. Unfortunately, it's not that easy.<br>
First, we would have to allocate the<code> TDriver </code>object's space and put it into the<br>
<code>dCtlHandle </code>slot in the DCE. Second, we would have to do additional work in the glue<br>
code because each method implicitly expects that a pointer to the "this" object (the<br>
this pointer) will be passed on the stack. We would also have to stuff the<code> dCtlStorage</code><br>
field into the "this" pointer address register.
</p>
<p>
&nbsp;The assembler isn't smart enough to figure out a directive like<code> JMP</code><br>
<code>TDRIVER::IACOpen</code>. We could use the mangled name of the method and import that<br>
name at the start of the glue code, but all that seems a little too much for our<br>
assembly-naive minds. Apparently, then, the assembler isn't of much help either.
</p>
<p>
&nbsp;Instead, we'll resort to calling regular global C++ functions. We'll declare the<br>
functions as extern "C" functions so the compiler won't mangle the names, but will<br>
still compile them as regular C++ functions (because C++ is backward compatible<br>
with regular C). We end up with the following:
</p>
<p>
<b>from DriverGlue.a</b>
</p>
<pre>***************************** TSEOpen *******************************
* This routine (and all like it below) performs three basic
* functions
* 1. Pushing the parameter block (A0) and the pointer to the DCE (A1)
* on the stack.
* 2. Testing to see whether the immediate bit was set in the trap
* word and, if so, RTSing.
* 3. Testing the result in D0. If it's 1, the operation hasn't
* completed yet so we just want to RTS. If it's NOT 1, then we'll
* jump through jIODone.
* I put the standard procedure header in just so you'd see another
* example of it in use. I found Sample.a to be most helpful in much
* of what I did here.
********************************************************************/
TSEOpen     PROC    EXPORT    ; Any source file can use this routine.

StackFrame  RECORD  {A6Link},DECR ; Build a stack frame record.
Result1     DS.W    1         ; Function's result returned to caller.
ParamBegin  EQU     *            ; Start parameters after this point.
ParamSize   EQU     ParamBegin-* ; Size of all the passed parameters.
RetAddr     DS.L    1            ; Placeholder for return address.
A6Link      DS.L    1            ; Placeholder for A6 link.



LocalSize  EQU         *         ; Size of all the local variables.
           ENDR                  ; End of record definition.

           WITH    StackFrame    ; Cover our local stack frame.
           LINK    A6,#LocalSize ; Allocate our local stack frame.
               
           MOVEM.L D1-D3/A0-A4,-(A7)   ; Save registers (V1.1A).
           MOVE.L  A1,-(A7)      ; Put address of DCE onto stack.
           MOVE.L  A0,-(A7)   ; Put address of ParamBlock onto stack.
           JSR     TSDRVROpen    ; Call our routine.
           ADDQ.W  #$8,A7        ; Take off A0 and A1 we pushed.
           ADDA.L  #ParamSize,SP ; Strip all the caller's parameters.
           MOVEM.L (A7)+,D1-D3/A0-A4 ; Restore registers (V1.1A).
           SWAP    D0            ; Save result in MostSig Word.
           MOVE.W  ioTrap(A0),D0 ; Move ioTrap into register to test.
           SWAP    D0            ; Back again.
           BTST    #(noQueueBit+16), D0    ;Test the bit.
           BNE.S   OpenRTS       ; If Z = 0, then noQueueBit.
                                 ; Set &#8212; branch.
           CMP.W   #$1,D0        ; Compare result with 1.
           BEQ.S   OpenRTS       ; Not equal to zero so RTS.
           UNLK    A6            ; Destroy the link.
           MOVE.L  jIODone,-(A7) ; Put jIODone on the stack.
           RTS                   ; Return to the caller.

OpenRTS UNLK      A6         ; Destroy the link.
        RTS                  ; Return to the caller.
        DbgInfo   TSEOpen    ; This name will appear in the debugger.
        ENDP                 ; End of procedure.</pre>
<p>
These global functions will do only some minor work that amounts to getting a pointer<br>
to the driver and calling the appropriate method. The<code> Open </code>routine does have to<br>
instantiate the object and install it into the<code> dCtlHandle </code>field of the DCE for<br>
subsequent retrieval. And the<code> Close </code>routine has to reverse these effects and dispose<br>
of the memory allocated by the<code> Open </code>procedure. All in all, however, the code is<br>
straightforward and, again, easy to follow.
</p>
<p>
<b>from DriverWrapper.cp</b>
</p>
<pre>/********************************Comment***********************
* TSDRVROpen is called by the assembly TSEOpen routine. It in turn
* will simply turn around and call the TDriver::IACOpen method after
* some setup. This routine must instantiate the TDriver object.
* We'll be good heap users and move the object (handle) hi. If we
* get an error, we'll return MemErr, mostly for debugging purposes.
* Declared as extern "C" in DriverWrapper.h
 *******************************End Comment*******************/

OSErr  
TSDRVROpen(ParmBlkPtr oParmBlock,DCtlPtr tsDCEPtr)
{
TDrvrPtr    aDrvrPtr;
OSErr       err;
// Create TDriver object.
aDrvrPtr = new(TDriver);
       
// Make dCtlStorage point to it.
tsDCEPtr-&gt;dCtlStorage = (Handle) aDrvrPtr;  
if(tsDCEPtr-&gt;dCtlStorage)
    {
    MoveHHi(tsDCEPtr-&gt;dCtlStorage);
    HLock(tsDCEPtr-&gt;dCtlStorage);
    aDrvrPtr = (TDrvrPtr) tsDCEPtr-&gt;dCtlStorage;
    err = aDrvrPtr-&gt;iacOpen(oParmBlock);
                                 // Call the iacOpen() method.
    HUnlock(tsDCEPtr-&gt;dCtlStorage);     
    return(err);                       
    }
else
    return MemError();
}

/*********************************Comment***************************
* TSDRVRControl is called by the assembly TSEControl routine. It in
* turn simply turns around and calls the TDriver::IACControl method
* after locking the object. This essentially just locks the handle
* whose master pointer points to the object and then calls the
* appropriate method. When done, TSDRVRControl unlocks the handle.
********************************End Comment***********************/
OSErr      
TSDRVRControl(ParmBlkPtr cntlParmBlock,DCtlPtr tsDCEPtr)
{
TDrvrPtr    aDrvrPtr;
OSErr       err;

HLock(tsDCEPtr-&gt;dCtlStorage);         // Lock the storage handle.
aDrvrPtr = (TDrvrPtr) tsDCEPtr-&gt;dCtlStorage;
                                         // Object pointer = master
                                         // pointer.
err = aDrvrPtr-&gt;iacControl(cntlParmBlock);
                                    // Call the iacControl() method.
HUnlock(tsDCEPtr-&gt;dCtlStorage);       // Unlock the handle.
return(err);
}</pre>
<p>
We now have three "kinds" of source files: (1) the assembly language glue, (2) the<br>
global C++ functions declared as extern "C" so the names will be normal (our driver<br>
"wrapper" functions), and (3) the C++ object methods. Having an assembly routine<br>
call a global C++ function, which calls a C++ method, seems like quite a hassle, but<br>
avoiding having to do the whole thing in assembly language is well worth the effort,<br>
especially with our friend Mr. Linker to put everything together.
</p>
<p>
<img src="img/130.gif" width="600 px"></img>
</p>
<p>
<b>Figure 1</b>Using the Linker to Create the DRVR Resource
</p>
<h2>CREATING THE DRVR RESOURCE ITSELF</h2>
<p>
The linker handles the entire task of creating the DRVR resource in the driver<br>
resource file. Here, again, there are some caveats about usage. First, you need to make<br>
sure that the first elements in a DRVR are the flags and offsets, so the first procedure<br>
in the assembly language file just defines these with<code> DC.W </code>instructions. Second, you<br>
have to tell the linker where the first procedure is, so you specify the
</p>
<p>
&nbsp;name with the <code>-m </code>option (in this case <code>-m HeaderDef)</code>. Third, you have to give the<br>
DRVR resource the name you want the resource to have, so you use the <code>-sn </code>option to<br>
define this. Finally, you want to specify the resource attributes at link time, so you<br>
specify the DRVR resource as being locked, in the system heap, and preloaded. The link<br>
line looks like this:
</p>
<p>
<b>from iacDriver.make</b>
</p>
<pre>Link -rt DRVR=75 -m HEADERDEF -sn"Main=.TimDriver" &#8706;
    -c 'TSEN ' -t 'DRVR' &#8706;
    -ra ".TimDriver"=resSysHeap,resLocked,resPreLoad &#8706;
    {CPOBJECTS} &#8706;
    "{Libraries}Interface.o" &#8706;
    -o iacDriver.DRVR</pre>
<p>
Sometimes the compiler (or CFront) does things behind your back that are completely<br>
frustrating, even if you're a careful programmer. The first time I tried&nbsp;&nbsp;to link the<br>
driver together, the linker complained that data initialization code had not been called.<br>
I knew there was no "data initialization" code being called because&nbsp;&nbsp;I had compiled a<br>
stand-alone code resource. I scratched my head because I knew I didn't have any globals<br>
anywhere in my code. Then I remembered, "Oh yeah, the compiler puts string<br>
constants in the global segment." The MPW manual explains the<code> -b </code>option, and<br>
eventually that option worked to solve the problem. I say "eventually" because I ran<br>
into another case where the compiler helped me out without my knowing.
</p>
<p>
Definitions for<code> new </code>and<code> delete </code>are included in the CPlusLib.o library. In this case,<br>
CFront calls these functions for every constructor. Even if you define your own<code> new</code><br>
and<code> delete</code>functions, the linker still will include the CPlusLib.o versions of the<br>
functions in the global segment. The linker then <i> still</i>&nbsp;&nbsp;thinks it has global data that<br>
hasn't been initialized.
</p>
<p>
The solution to the problem is to define your own external "C" functions (an indicator<br>
to the compiler to use regular C calling conventions, but still part of your C++ code)<br>
with the mangled names for<code> new </code>and<code> delete</code>. You'll have to declare the functions as<br>
returning a void pointer or handle. The declarations look like this:
</p>
<p>
<b>from iacGlobalNewDel.cp</b>
</p>
<pre>/* unmangle __nw__FUi
 * Unmangled symbol: operator new(unsigned int)
 * We return a void * because new returns a pointer.  */
void *__nw__FUi(unsigned int size)/* unmangle __dl__FPv
 * Unmangled symbol: operator delete(void *)
 * We return void just for clarity. */
void __dl__FPv(void *obj)

/* unmangle __nw__12HandleObjectSFUi
 * Unmangled symbol: static HandleObject::operator new(unsigned int)
 * We return a void ** because this version of new should return
 * a handle. */
void **__nw__12HandleObjectSFUi(unsigned int size)

/* unmangle __dl__12HandleObjectSFPPv
 * Unmangled symbol: static HandleObject::operator delete(void **) */
void __dl__12HandleObjectSFPPv(void **aHandle)</pre>
<p>
You have to use the mangled names because that's how they were compiled into the<br>
CPlusLib.o library. Fortunately, you can now eliminate the CPlusLib.o library from<br>
your list of libraries. Once past these two global obstacles--string constants placed in<br>
the global segment and<code> new/delete </code>operators called from constructors--the linker<br>
passes the sample code through with flying colors.
</p>
<p>
<b>BUILDING THE 'INIT' TO INSTALL THE DRIVER</b><br>
Now that the DRVR resource and code are finished, how do you use it? The first order<br>
of business is to install the driver into the UnitTable. The listing for the code that does<br>
the installation appears on the next page. This code opens the resource file where the<br>
DRVR resides, looks for an open "slot" in the UnitTable starting from the rear of the<br>
UnitTable, opens the resource, changes the resource ID to match the UnitTable slot,<br>
calls<code> OpenDriver</code>, detaches the resource, and changes the DRVR resource ID back to<br>
what it was before beginning. The few steps that need explanation are finding the slot<br>
in the UnitTable, calling<code> DetachResource</code>, and calling<code>OpenDriver</code>.
</p>
<p>
Why do you have to find an open slot in the UnitTable? You want to make sure the<br>
driver gets installed. If there's a resource ID conflict (and hence a slot conflict in the<br>
UnitTable), you can't be sure whether the driver will clobber the existing one or<br>
won't get installed at all. Thus, you could rely on just calling<code> OpenDriver </code>with the<br>
DRVR resource ID, but that wouldn't be very cooperative of you. So you look for an<br>
open slot, which boils down to looking for a nil address in the UnitTable, starting at the<br>
back of the UnitTable where open slots are most likely to exist (the system uses up<br>
slots at the beginning of the UnitTable). If the contents of the address are nil, you can<br>
install the driver into that slot.
</p>
<p>
<b>&nbsp;from installDriver.c</b>
</p>
<pre>short
lookForSlotInUnitTable()
{
short   slot;
Ptr     theBass;
long    *theVoidPtr;
Boolean foundSlot = false;

/* Set up variables based on contents of low-memory global
 * locations.  DTS tells people not to rely on low-memory
 * globals, but we really need these two low-memory
 * globals to do our work. So, there is a compatibility
 * risk we have to be aware of.
 */

slot = *((short *)(UnitNtryCnt)) - 1;
theBass = (Ptr) (*((long *) (UTableBase)));

// We step back to 48 because 0-47 are taken.
while(slot&gt;48 &amp;&amp; !foundSlot)
    {
    theVoidPtr = (long *)(theBass + (4L * slot));

    if(*theVoidPtr == nil)
         foundSlot = true;

        slot -= 1;
    }

slot += 1;
if(!foundSlot)
    slot = 0;
return slot;
}</pre>
<p>
&nbsp;Why do you call<code> DetachResource</code>? <i>Inside Macintosh, </i> volume V, page 121, says,<br>
"<code>DetachResource </code>is also useful in the unusual case that you don't want a resource to<br>
be released when a resource file is closed." The example is such a case. When the Init<br>
is loaded and executed by the Init 31 mechanism, the resource file in which the Init<br>
resides is opened. When the Init has been executed, the resource file is closed, and the<br>
Resource Manager goes around and cleans up any of the resources in the resource map<br>
that are known to be allocated.<code> DetachResource </code>replaces the handle in the resource<br>
map with nil, so the Resource Manager thinks it doesn't have to clean up that handle.
</p>
<p>
Why do you call<code> OpenDriver </code>instead of<code> _DrvrInstall</code>? Essentially that's because<br>
<code>OpenDriver </code>does the correct thing and<code>_DrvrInstall </code>doesn't. When you call<br>
<code>_DrvrInstall </code>with a handle to the driver,<code> _DrvrInstall </code>does most of the work, but<br>
it forgets to put the handle to the driver into the<code> dCtlDriver </code>field of the DCE and<br>
effectively makes the driver unreachable.<code>_OpenDriver </code>has no such problem, and it<br>
works correctly. Alternatively, you could use<code> _DrvrInstall </code>and then put the handle<br>
to the driver into the DCE.&nbsp;&nbsp;The installation code looks like this:
</p>
<p>
<b>from installDriver.c</b>
</p>
<pre>void
changeDRVRSlot(short slot)
{
Handle      theDRVR;
short       err, refNum;
char        *name, DRVRname[256];
short       DRVRid;
ResType     DRVRType;

name = "\p.TimDriver";

if(slot != 0) {
    theDRVR = GetNamedResource('DRVR', name);
    GetResInfo(theDRVR, &amp;DRVRid, &amp;DRVRType, &amp;DRVRname);
    SetResInfo(theDRVR, slot, 0L);
   
    err = OpenDriver(name, &amp;refNum);
    if(err == noErr)
        {
        /* Detach the resources from the resource map. */
        DetachResource(theDRVR);
       
        }
    /* Restores the previous resource attributes so they don't change
     * from start-up to start-up. We just want the in-memory copy to
     * have a different ID--not our resource in the file. */
    theDRVR = GetNamedResource('DRVR', name);
    SetResInfo(theDRVR, DRVRid, nil);
    }
}</pre>
<p>
This code needs to be compiled with the<code> -b </code>option as well because it's a stand-alone<br>
code resource like the DRVR, and you have to have everything in one resource. For the<br>
example, we chose to make the installation code an Init so that the driver will install at<br>
system start- up time and so that any application can access it. You also <i> must </i> make<br>
sure that the resource has the resource attribute<code> resLocked</code>. The Init must be locked<br>
at start-up time in case anything in the Init code moves memory. If anything in the<br>
Init does move memory, you come back to some random place in the system heap<br>
because the Init resource has been moved. This is a particularly painful (and time-<br>
consuming) gotcha.
</p>
<p>
<b>PUTTING IT ALL TOGETHER</b><br>
The final goal is to have one file that contains all the necessary resources. At this point<br>
you have all the code resources you need: the Init and the DRVR. You may need one<br>
additional resource, depending on how large the driver is and how much of the system<br>
heap you need. If you need more than 16K, you have to create the<code>sysz </code>resource and<br>
put that in the file. Fortunately, the<code> sysz</code>resource is simple to define; it looks like<br>
this:
</p>
<p>
<b>from iacDriver.r</b>
</p>
<pre>include "iacDriver.DRVR"; /* Include the DRVR resource. */
include "installDriver";  /* Include the INIT resource. */

type 'sysz' { /* This is the type definition. */
    longint; /* Size requested (see IM V, page 352).*/
};

resource 'sysz' (0,"",0) { /* This is the declaration. */
    0x00008000 /* 32 * 1024 bytes for sysz resource. */
};</pre>
<p>
Now that you have all the components, you let<code> rez </code>do the work of moving the Init and<br>
DRVR resources into one file. Fortunately you can include resources from other<br>
resource files with the "include" directive (see chapter 11, page 309, in the MPW<br>
manual for a discussion of<code> rez)</code>.
</p>
<p>
<b>from iacDriver.make</b>
</p>
<pre>rez iacDriver.r -c TSEN -t INIT -a -o iacDriver</pre>
<p>
<b>CALLING THE DRIVER FROM AN APPLICATION</b><br>
The example also includes several routines you might run from a client application to<br>
use the sample driver. <i>Developer Essentials </i> contains two sample applications that use<br>
these routines to register and send or receive messages. (Don't get your hopes up,<br>
though. This is just Sample.c modified, so the light will turn off and on via control<br>
from a second application.)
</p>
<h2>DESIGN DECISIONS</h2>
<p>
Now that you've learned about this "device driver" in particular, and more about<br>
drivers in general, we can discuss some of the trade-offs required.
</p>
<p>
<b>WHAT TO DO WITH JIODONE, AND WHEN</b><br>
Most of the time, the device driver should jump to<code> jIODone </code>so the Device Manager<br>
will handle the housekeeping tasks of marking the driver as "unbusy" and calling the<br>
completion routine. However, a few exceptions are noted throughout the chapter on the<br>
Device Manager (<i> Inside Macintosh,</i>&nbsp;&nbsp;volume II, chapter 6). You <i> don't </i> want to jump to<br>
<code>jIODone </code>(just RTSing instead) in these situations:
</p>
<ul>
<li> When an operation you started is not yet complete (that is, an operation<br>
that will interrupt you when it <i> is </i> complete).</li>
<li> When you get a<code> KillIO </code>request.</li>
<li> When you get called immediately (that is, bit #9, the<code> noQueueBit</code>, is<br>
set in the<code> ioTrap </code>word and calls usually look like<code> _Read, IMMED)</code>.</li>
</ul>
<p>
Speaking of the immediate bit, you'll find that most drivers don't guard against<br>
reentrancy. This is a problem when callers try to make<code> Immediate </code>calls to the<br>
driver. If you don't want people making<code>Immediate </code>calls to the driver, you have to<br>
specify in the documentation that callers may not call this device driver immediately;<br>
otherwise, the results will be indeterminate. On the other hand, if you do want to allow<br>
<code>Immediate </code>calls, one simple way to guard against most types of reentrancy problems<br>
is to set some flag within the driver and then either (1) return without performing<br>
the immediate action requested or (2) save the state of the other operation, perform<br>
the<code> Immediate</code>call, and return. In either event, remember to return via an<code> RTS </code>for<br>
all<code> Immediate </code>calls.
</p>
<p>
<b>MULTIPLE OUTSTANDING REQUESTS</b><br>
You may want a driver to be able to handle many<code> _Read </code>and<code> _Write </code>requests at the<br>
same time, and not one at a time. This driver can handle only one request at a time. If<br>
no messages are waiting<i>when requested, </i> for example, the caller is told there are no<br>
messages. In many cases, however, you want to keep that request around until there<i> is</i><br>
a message. To handle this case, you have to do some more work. Essentially, you have to<br>
dequeue the request from the Device Manager's queue, queue it up in some internal list<br>
of your own, and then satisfy the requests when they are finished. You have to perform<br>
the functionality of<code> jIODone </code>yourself as well, because you'll be handling the<br>
operations yourself. You're also operating behind the Device Manager's back to some<br>
extent because you're dequeueing requests from the I/O queue yourself.
</p>
<p>
<b>_READ AND _WRITE OR _CONTROL OPERATIONS</b><br>
If you use<code> _Read</code> and<code> _Write</code>, you can't pass in<code>csParam</code>. The trade-off we made in the<br>
example was that<code>csParam</code> would point to a structure that gave us more control over,<br>
and a more elegant solution to, sending and receiving messages to and from the proper<br>
place. If you use<code>_Read/_Write</code>, you have to format the<code>ioBuffer</code> to contain all the<br>
information for the messages, and that means encoding the sender and receiver<br>
signatures in with the actual message. One disadvantage of this trade-off is that the<br>
method may fail in the future in the world of virtual memory.&nbsp;&nbsp;&nbsp;Virtual memory<br>
watches the<code>_Read</code> and<code> _Write</code> traps and makes sure the memory addressed<br>
by<code>ioBuffer</code> stays in physical memory, but it neglects to do the same for<code>csParam</code>. <br>
Hence, the<code>IACRecord</code> structure (and pointers within that structure) may or may not<br>
be in physical RAM at the time of the call. If this happens at interrupt time and a page<br>
fault occurs, you're completely hosed. 
</p>
<p>
<b>TMESSAGE OBJECTS</b><br>
Finally, the sample driver isn't very space friendly. The<code> TMessage </code>objects are<br>
allocated by<code>NewPtrSys</code>, and hence will fill up the system heap with locked pointers. <br>
The good news is that<code>TMessage</code> objects probably don't live for very long. The bad news<br>
is that the heap may still become fragmented. So, another design decision you could<br>
make would be to derive from<code> HandleObject</code>and take into consideration dereferences<br>
of handles. You may want to try that as an exercise.
</p>
<h2>SUMMING UP</h2>
<p>
To summarize: C++<i> can </i> be used to write a device driver that operates under some<br>
basic restrictions. We successfully built a couple of stand-alone classes that can be<br>
modified and kept up separately. The classes present a clear definition of roles and hide<br>
data as cleanly as possible. We chose not to use polymorphism in the code, although we<br>
certainly could have done so--with a little extra work and the possibility of future<br>
incompatibilities (again, see "Polymorphic Code Resources in C++," by Patrick<br>
Beard, in this issue).
</p>
<p>
Because of limitations of the operating system and development system, we have to<br>
incorporate some assembly language, and some global C++ functions, into whatever we<br>
write. We discussed some of the design trade-offs you must inevitably make and went<br>
into some depth on several of the trickier aspects of writing a device driver--what to<br>
do with<code> jIODone</code>, how to use the assembler to best advantage, compiling and linking<br>
the stand-alone code so it does the right thing, creating an Init that installs the driver<br>
at system start-up time, and using<code> rez </code>to create the eventual resource file.
</p>
<p>
C++ allows you to encapsulate data with functions, thus making it easier to maintain<br>
code and port the code to other platforms. Some nifty language features, such as<br>
function overloading and strong type checking, come with C++. If you're writing a<br>
device driver that doesn't depend on speed and efficiency, C++ is a good choice of<br>
languages.
</p>
<p>
<b>TIM ENWALL, </b> DTS engineer, is a four-year Apple veteran. He's done stints in<br>
Technical Resources and data base applications, and has answered the A/UX&#174; hotline.<br>
Now his primary job purportedly revolves around IBM connectivity (although no one<br>
ever seems to ask him about it). The rest of his time is spent with networking and<br>
lower-level device managers. A Rocky Mountain native, he came to Cal Berkeley for an<br>
EE/CS degree. He likes bike riding, cooking, playing softball, and long talks with<br>
friends. Two Burmese cats--Bella and GBU (for the Good, the Bad, and the Ugly,<br>
pronounced "Boo")--guard him during his off hours. Two favorite books have helped<br>
shape his outlook: <i> Light in August</i>&nbsp;&nbsp;by William Faulkner and <i>Native Son</i>&nbsp;&nbsp;by Richard<br>
Wright. But don't let his serious side fool you. Watch out when he's sitting across a<br>
poker table from you: he was brought up on cards, and he's out to get that BMW 3.0CSi<br>
with a sunroof. Will you be the one to provide the down payment?&nbsp;&nbsp;*
</p>
<p>
<b>As an alternative to defining</b> your own external "C" functions, you could use the<br>
<code>A5 </code>global library routines described in Technical Note #256, Stand-Alone Code, <i> ad</i><br>
<i>nauseam.</i>&nbsp;&nbsp;You could then use globals as well as the default code for<code> new </code>and<code> delete</code>.*
</p>
<p>
<b>Thanks to Pete Helme</b> for the<code> installDriver.c </code>code. *
</p>
<p>
<b>For More Information</b><br>
<i>Inside Macintosh,</i>&nbsp;&nbsp;volume II, chapter 6, "The Device Manager."<br>
Stanley Lippman:<i> The C++ Primer,</i>&nbsp;&nbsp;Addison-Wesley, 1989.<br>
Bjarne Stroustrup: <i>The C++ Programming Language,</i>&nbsp;&nbsp;Addison-Wesley, 1987. *
</p>
<p>
<b>Thanks to Our Technical Reviewers</b> Brian Bechtel and Jack Palevich&nbsp;&nbsp;*
</p>
</body>
</html>
