<html>
<head>
<!-- Extracted from develop - 1990 -->
<!-- on 2023-09-19 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by copyright of their respective owners -->
<title>January 90 - DEBUGGING DECLARATION ROMS</title>
<link href="styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h2>DEBUGGING DECLARATION ROMS</h2>
<h1>MARK BAUMWELL</h1>
<p>
<i>Through system software, the Macintosh can read the declaration ROMs in NuBus and</i><br>
<i>pseudo-NuBus slots, like those in the Macintosh SE/30.&nbsp;&nbsp;This article tells you what</i><br>
<i>you must know about NuBus addressing and the structure of correct declaration ROMs</i><br>
<i>to successfully debug the ROM.&nbsp;&nbsp;It walks you through the structure of an example</i><br>
<i>declaration ROM and gives common errors and strategies for debugging declaration</i><br>
<i>ROMs.</i>
</p>
<p>
The Slot Manager's flexibility in providing a layer between the hardware and<br>
higher-level software benefits developers and customers alike.&nbsp;&nbsp;Users can easily<br>
expand the Macintosh II family and the Macintosh SE/30 with additional hardware that<br>
goes in slots.&nbsp;&nbsp;The Macintosh card architecture lets them plug new cards into the<br>
Macintosh without worrying about using the right slot, setting dip switches, or<br>
running system configuration software.&nbsp;&nbsp;As a developer, you may need to know more<br>
about the architecture that makes this self-configuring environment possible.
</p>
<h2>THE SLOT MANAGER AND DECLARATION ROMS</h2>
<p>
Part of the Macintosh operating system, the Slot Manager can find the ROM on each<br>
expansion card installed in a system and identify the card's special capabilities.&nbsp;&nbsp;It<br>
makes use of predefined data structures called slot Resources (sResources) to<br>
initialize and configure a card and report the card's location. Each card installed in a<br>
Macintosh expansion slot needs a declaration ROM, also known as a configuration ROM,<br>
with information for using the card's hardware.&nbsp;&nbsp;The expansion hardware could be as<br>
simple as a memory card that needs to publish its address ranges or as complicated as a<br>
video card with initialization code, a driver, and declaration data.
</p>
<p>
In addition to letting the system determine what hardware is available, the Slot<br>
Manager frees applications from being dependent on a particular type of hardware.&nbsp;&nbsp;In<br>
other words, the Slot Manager helps insulate an application from the hardware by<br>
being able to locate underlying, intermediate driver software that will know about and<br>
talk to the specific hardware.&nbsp;&nbsp;The application can be free of the details and need only<br>
deal with higher-level functions.&nbsp;&nbsp;The degree of insulation depends on the software and<br>
data structures in the declaration ROM. 
</p>
<p>
The Slot Manager:
</p>
<ul>
<li>locates and lists the cards with declaration ROMs.</li>
<li>defines a uniform structure for information in the declaration ROM and a<br>
set of library routines to access the information.</li>
<li>includes routines to allow host applications to transparently access<br>
information in the ROMs without regard to NuBus or byte lanes.</li>
<li>allows ROM initialization code to run on the host CPU during the host's<br>
startup sequence.</li>
<li>allows cards to have drivers from their declaration ROMs loaded into the<br>
host CPU.</li>
<li>initializes and manipulates the parameter RAM on the host CPU for the<br>
card during startup.</li>
</ul>
<p>
When applications are insulated from particular hardware implementations, they<br>
don't have to be revised for each new version of a vendor's board, or even for<br>
compatible boards made by competitors.&nbsp;&nbsp;Besides reducing maintenance work for the<br>
developer, information hiding of this sort saves wear and tear on customers. 
</p>
<p>
Suppose a customer owns an application and a card and happens to buy another board,<br>
from the same or a different vendor, with even slightly different hardware.&nbsp;&nbsp;The<br>
difference might be a change in address or meaning of some register or memory<br>
location.&nbsp;&nbsp;The customer has to mix and match applications or drivers or INITs to<br>
boards.&nbsp;&nbsp;This is not very Macintosh-like, and the board manufacturer is sure to be<br>
savaged by the customers and the press.&nbsp;&nbsp;Matching various card-specific versions of<br>
software and different revisions of hardware can be a headache for distributors and<br>
dealers.&nbsp;&nbsp;Including card-specific software on each card's ROM in a universally<br>
accessible structure greatly simplifies installation and maintenance.
</p>
<h2>USING SRESOURCES</h2>
<p>
Don't confuse sResources on expansion cards with standard Macintosh resources.&nbsp;&nbsp;The<br>
small s indicates a slot resource as opposed to a real Macintosh resource.&nbsp;&nbsp;Although<br>
related conceptually, sResources are different and may contain anything from code to<br>
data--for example, icons, special fonts, or vendor-defined data.&nbsp;&nbsp;In fact, feel free to<br>
substitute "data structure" for "sResource" as you read.
</p>
<p>
Each card has one special sResource called a board sResource and usually one additional<br>
sResource for each function the card can perform, although additional supporting<br>
sResources are possible.&nbsp;&nbsp;An sResource affiliated with a function is called a functional<br>
sResource and gives information about that particular function, usually to high-level<br>
applications interested in accessing the function.
</p>
<p>
Most cards perform only one function.&nbsp;&nbsp;For example, a modem card might perform only<br>
a modem function, a video card might just do video, and so on. These cards would have<br>
only one functional sResource, along with the required board sResource.&nbsp;&nbsp;However, it<br>
is possible to build a multifunction expansion card--a card with a parallel, serial, and<br>
modem port, for example.&nbsp;&nbsp;In this case, the card's declaration ROM would have three<br>
functional sResources--one each for the card's functions.&nbsp;&nbsp;In addition to other,<br>
optional sResources, it would also have the required board sResource.
</p>
<p>
A high-level program may need to be able to find and use certain kinds of hardware in<br>
the Macintosh slots.&nbsp;&nbsp;For example, QuickDraw works with video cards made by<br>
different vendors.&nbsp;&nbsp;QuickDraw finds each video card by looking for the card's functional<br>
sResource that says it can do QuickDraw-compatible video.
</p>
<h2>AN EXAMPLE DECLARATION ROM</h2>
<p>
As far as the Slot Manager is concerned, at the startup scan of the cards a valid<br>
declaration ROM must have proper structures for the format block, sResource<br>
directory, and the board sResource.&nbsp;&nbsp;If any of these structures is in error, the Slot<br>
Manager marks the slot as empty, and no Slot Manager calls to that slot will work. <br>
Though other sResources or data structures may have errors, the Slot Manager doesn't<br>
check them at startup.&nbsp;&nbsp;These errors will show up during later calls to the Slot<br>
Manager by applications, INITs, drivers, and so forth.
</p>
<p>
We will look at these key structures in an example declaration ROM and will discuss<br>
some common errors developers make.&nbsp;&nbsp;The sample skeleton ROM has the required<br>
board sResource and one functional sResource.
</p>
<p>
The ROM can be divided into four major structures: the sResource directory,<br>
functional sResource, board sResource, and format block, as shown in the illustration.<br>
Let's look at these structures in more detail. 
</p>
<p>
<b>THE SRESOURCE DIRECTORY</b><br>
The source code begins with some includes and equates, followed by the sResource<br>
directory.&nbsp;&nbsp;A directory is a list of the sResources in the ROM.&nbsp;&nbsp;In the example, we have<br>
two sResources, the required board sResource and one functional sResource.&nbsp;&nbsp;The<br>
directory looks like this:
</p>
<pre>_sRsrcDir  OSLstEntry      sRsrcBoard,_sRsrcBoard
                            ;References Board sResource.
            OSLstEntry      sRsrcFun,_sRsrcFun
                            ;References functional sResource.
            DatLstEntry     endOfList,0
                            ;End of the list.</pre>
<p>
The OSLstEntry and DatLstEntry items are assembler macros, defined in the MPW<br>
ROMEqu.a file.&nbsp;&nbsp;These macros make creating declaration ROMs easier, since most<br>
declaration ROM structures fall into two different formats:
</p>
<ul>
<li>an ID byte followed by three bytes representing a 24-bit offset or</li>
<li>an ID byte followed by a 24-bit data value</li>
</ul>
<p>
A directory contains both of these formats.&nbsp;&nbsp;The first format is used for all sResource<br>
entries in a directory.&nbsp;&nbsp;Each sResource entry consists of one byte containing the<br>
sResource identification number, and three bytes containing the offset to the sResource<br>
itself. 
</p>
<p>
The offset list entry (OSLstEntry) macro is used to conveniently calculate and fill in<br>
these types of entries.&nbsp;&nbsp;It takes two arguments: the ID byte and a label designating the<br>
destination.&nbsp;&nbsp;The macro puts the first argument as is into the high byte, calculates the<br>
24-bit signed offset value to the destination label, and puts it into the next three<br>
bytes.&nbsp;&nbsp;In our example, the first entry of the directory looks like this:
</p>
<pre>_sRsrcDir   OSLstEntry  sRsrcBoard,_sRsrcBoard  ;References Board
                                                ;sResource.</pre>
<p>
The _sRsrcDir label designates the start of the directory.&nbsp;&nbsp;This label is needed because<br>
the offset to the directory will be calculated later.&nbsp;&nbsp;The first argument of the macro,<br>
sRsrcBoard, is equated to 1 (in the equates near the top of the source code file), and so<br>
a $01 will be put into the first byte.&nbsp;&nbsp;The second argument, _sRsrcBoard, is the label<br>
designating the start of the board sResource.&nbsp;&nbsp;The macro calculates the offset from the<br>
present point in the macro to the label and puts the resultant offset in the next three<br>
bytes.&nbsp;&nbsp;The _sRsrcBoard structure is $000C bytes away from the directory entry, so<br>
the offset is $000C.&nbsp;&nbsp;Putting them together, the complete directory entry for the board<br>
sResource looks like this in hexadecimal:
</p>
<pre>   $01000C</pre>
<p>
A similar calculation for the functional sResource is done with the offset from the<br>
directory to the _sRsrcFun label.
</p>
<p>
The second format is used in many places in declaration ROMs.&nbsp;&nbsp;It iscommonly used for<br>
the&nbsp;&nbsp;end-of-list entry, which marks the end of the list of directories and sResources. <br>
This entry always has an ID byte value of $FF followed by three bytes of zero.&nbsp;&nbsp;It can<br>
also be used to hold small pieces of data that fit into three bytes or less.
</p>
<p>
It is convenient to use the data list entry (DatLstEntry) macro for these types of<br>
entries.&nbsp;&nbsp;DatLstEntry is similar to OSLstEntry but simpler.&nbsp;&nbsp;It takes two arguments:<br>
the ID byte and the desired data value.&nbsp;&nbsp;It puts the first argument into the high byte and<br>
the data value into the next three bytes.
</p>
<p>
<b>SRESOURCES IN GENERAL</b><br>
Before looking at our example sResources, let's examine the structure of sResources<br>
in general.&nbsp;&nbsp;Every sResource includes an sRsrc_Type entry whose fields identify the<br>
sResource.&nbsp;&nbsp;Applications and drivers use the sRsrc_Type entry of each sResource to<br>
identify it and the function it performs.
</p>
<p>
The sRsrc_Type entry is comprised of an ID byte (always a $01), followed by an<br>
offset to the sResource type format.&nbsp;&nbsp;For this discussion, we will only look at the Apple<br>
defined format for the type format entry, indicated by the leading bit being a zero,<br>
since virtually all developers use it.
</p>
<p>
The sResource type format is a 64-bit value, separated into four fields of 16 bits<br>
each.&nbsp;&nbsp;The entry looks like this:
</p>
<p>
The type format fields have constant, fixed values for the board sResource, so let's look<br>
at the values for the more general case of functional sResources.&nbsp;&nbsp;The type format is<br>
hierarchical in nature, and the four fields can be considered to be "nested" under each<br>
other, with the Category being at the top of the hierarchy.&nbsp;&nbsp;While some of the fields<br>
have been predefined, new values can be and often are defined to suit developers'<br>
products.
</p>
<p>
A board can perform broad categories of possible functions, which are represented by<br>
the Category field of the type format.&nbsp;&nbsp;Within each Category are subset types that are<br>
represented by the cType value.&nbsp;&nbsp;Nested farther in the hierarchy are subset software<br>
driver identifiers (the DrvrSW value).&nbsp;&nbsp;Finally, under each DrvrSW&nbsp;&nbsp;entry, there are<br>
hardware identifiers (the DrvrHW value).&nbsp;&nbsp;The hierarchical relationship looks like:
</p>
<pre>Category
    cType
        DrvrSW
            DrvrHW</pre>
<p>
A given Category can have multiple cType interfaces for it, and each of those cTypes<br>
can have its own nested, underlying software interfaces.&nbsp;&nbsp;Many different pieces of<br>
hardware can belong to a given software architecture.&nbsp;&nbsp;Equates for many categories<br>
have been already defined, such as Display, Network, Communication, and CPU. <br>
Further, subtypes for some of these common categories have been defined, as well as<br>
software interfaces to go with some subtypes.
</p>
<p>
Let's see how this works with a common family of cards: video cards.&nbsp;&nbsp;A category for<br>
display functions has been defined (CatDisplay EQU $0001). Under it, a subtype for<br>
video displays has been defined (TypVideo EQU $0000).&nbsp;&nbsp;Since Apple has defined a<br>
driver and firmware interface for video display cards that are QuickDraw compatible,<br>
there is a software driver definition as well (DrSWApple EQU $0001).&nbsp;&nbsp;Now let's say<br>
a developer wants to make a QuickDraw-compatible video card -- the Amalgamated<br>
VaporWare Widget video board.&nbsp;&nbsp;The developer gets a hardware identifier from<br>
.Developer Technical Support;--let's say DTS assigns the developer DrHwWidget EQU<br>
$4321--and creates a functional sResource with an sRsrc_Type of
</p>
<pre>CatDisplay EQU $0001
TypVideo    EQU $0000
DrSwApple   EQU $0001
DrHwWidget  EQU $4321</pre>
<p>
or in the complete type format:
</p>
<pre>   0001000000014321</pre>
<p>
Now QuickDraw will recognize the card, because it looks for type formats that match<br>
<code>CatDisplay/TypVideo/DrSwApple</code>.&nbsp;&nbsp;During the search, QuickDraw will only look for<br>
a match down to its software architecture level and will mask off the hardware<br>
identifier.&nbsp;&nbsp;It does not care about the hardware identifier, because it knows the driver<br>
will deal with the underlying hardware.&nbsp;&nbsp;Notice that even though the first three entries<br>
in the type format will be the same for all QuickDraw-compatible video cards, the<br>
different hardware identifiers will make the entries unique.&nbsp;&nbsp;This is useful for the<br>
driver of the Widget card, which very much cares about the underlying hardware.&nbsp;&nbsp;It<br>
will want to locate the card and will do so by doing a match of the whole type format,<br>
including the hardware identifier.
</p>
<p>
Developers can take advantage of this if they want to have applications use their<br>
software/hardware architecture.&nbsp;&nbsp;By publishing the software interface and type<br>
format values, a developer can make a board that others can write applications for.
</p>
<p>
Besides the sRsrc_Type entry, sResources must also have a name entry<br>
(sRsrc_Name), which contains an ID byte (always $02), followed by an offset to a<br>
null-terminated string (a C string).&nbsp;&nbsp;In addition to these, the board sResource must<br>
have a board ID value (BoardId).&nbsp;&nbsp;All other entries defined for sResources and the<br>
board sResource are optional.
</p>
<p>
Now, let's take a look at the two sResources in detail.
</p>
<p>
<b>THE BOARD SRESOURCE</b><br>
Like the directory entries, our board sResource uses the macros we discussed earlier<br>
to calculate and fill in the various entries.&nbsp;&nbsp;Labels such as sRsrcType and sRsrcName<br>
are defined in the MPW ROMEqu.a file.&nbsp;&nbsp;Others, such as the board ID, are in the<br>
declaration ROM source code.&nbsp;&nbsp;The first part of our board sResource looks like this:
</p>
<pre>;=============================================================
;   The Board sResource
;=============================================================
_sRsrcBoard OSLstEntry  sRsrcType,_BoardType   
        ;References Rsrc_Type entry
    OSLstEntry  sRsrcName,_BoardName   
        ;References Rsrc_Name entry
    DatLstEntry boardId,TheBoardId 
        ;boardId **ASSIGNED BY MACDTS**
    OSLstEntry  primaryInit,_sPInitRec 
        ;Refs Primary init record.
    OSLstEntry  vendorInfo,_VendorInfo 
        ;References Vendor info list.
    DatLstEntry endOfList,0
        ;End of the list.</pre>
<p>
The _sRsrcType entry for the board sResource points to the board sResource type<br>
format.&nbsp;&nbsp;The type format is always the same for the board sResource-- that's how the<br>
board sResource is identified.&nbsp;&nbsp;The type format for the board sResource always has this<br>
definition:
</p>
<pre>_BoardType DC.W    CatBoard    ;ALWAYS $0001 for bd sResource
            DC.W    TypBoard    ;ALWAYS $0000 for bd sResource
            DC.W    DrSwBoard   ;ALWAYS $0000 for bd sResource
            DC.W    DrHwBoard   ;ALWAYS $0000 for bd sResource</pre>
<p>
Put together into the full 64 bits, it looks like this:
</p>
<pre>   $0001000000000000</pre>
<p>
The _sRsrcName entry points to the name string (a C string), which should be the<br>
official product name of the board:
</p>
<pre>_BoardName DC.L    'OFFICIAL PRODUCT NAME'
;The name of the Board - should be official product name</pre>
<p>
(At the beginning of the source code, there is a STRING C directive, to automatically<br>
generate c strings.)
</p>
<p>
After the name comes the required board ID, which, being a 16-bit value, can be filled<br>
in using a DatLstEntry macro.&nbsp;&nbsp;Board IDs are assigned by Macintosh DTS.&nbsp;&nbsp;To get board<br>
ID, contact Macintosh DTS with the following information:
</p>
<ul>
<li>the company name and address (mailing and electronic addresses, if<br>
possible)</li>
<li>the name of the person in the company responsible for the board (and a<br>
phone number, if possible)</li>
<li>the functions the board will perform</li>
<li>the official product name for the board (or a code name)</li>
<li>whether or not the board will have a software driver other than one that<br>
has been predefined (like Apple's video driver)</li>
<li>whether or not the driver will be in ROM</li>
</ul>
<p>
DTS will assign the board ID and any necessary functional sResource information.&nbsp;&nbsp;This<br>
information goes into a database, which is kept strictly confidential.&nbsp;&nbsp;There is a<br>
HyperCard&#174; stack on the Developer Services CD and on AppleLink that makes sending<br>
in this information easier. 
</p>
<p>
Next, the board sResource contains an entry for the primary initialization code.&nbsp;&nbsp;We<br>
have defined one, but it is in a separate file called PrimaryInit.a, which is referenced<br>
with an INCLUDE directive:
</p>
<pre>;-------------------------------------------------------------
;   .i.Primary Init Record; (if needed)
;-------------------------------------------------------------
_sPInitRec  DC.L    _EndsPInitRec-_sPInitRec
        ;physical Block Size
    INCLUDE 'PrimaryInit.a'
        ;Primary Init Code
_EndsPInitRec   EQU *   ;End of block
    STRING  C   ;Restore to 'c' string type.</pre>
<p>
The following is optional vendor data.&nbsp;&nbsp;It is up to the developer to decide what, if<br>
anything, goes in the VendorInfo entries.&nbsp;&nbsp;This example shows the way Apple typically<br>
uses the vendor information ;entries.
</p>
<pre>;-------------------------------------------------------------
;   Vendor Information record
;-------------------------------------------------------------
_VendorInfo OSLstEntry  VendorId,_VendorId  ;References
                                            ;the Vendor
                                            ;Id.
    OSLstEntry  RevLevel,_RevLevel          ;References
                                            ;the Revision
                                            ;Level.
    OSLstEntry  PartNum,_PartNum            ;References
                                            ;the Part
                                            ;Number.
    DatLstEntry endOfList,0                 ;End of the
                                            ;list.
_VendorId   DC.L    'COMPANY NAME'          ;The Vendor
                                            ;Id.  Most
                                            ;vendors use
                                            ;company name
_RevLevel   DC.L    'Release-1.0'           ;The Revision
                                            ;Level
_PartNum    DC.L    '12-3456'               ;The Part
                                            ;Number</pre>
<p>
<b>THE FUNCTIONAL SRESOURCE</b><br>
In our example, our card has only one function, so our ROM has just one functional<br>
sResource.&nbsp;&nbsp;For this example, we have defined a nonexistent set of Category, subtype,<br>
software, and driver identifiers, which normally would be replaced by the ones<br>
assigned by DTS.&nbsp;&nbsp;The functional sResource entry looks like this:
</p>
<pre>=============================================================
;   The Functional sResource
;=============================================================
_sRsrcFun   OSLstEntry  sRsrcType,_FunType
        ;References sRsrc_Type
    OSLstEntry  sRsrcName,_FunName
        ;References sRsrc_Name
    OSLstEntry  sRsrcDrvrDir,_FunDrvrDir
        ;References sResource driver dir
    DatLstEntry sRsrcHWDevId,1 
        ;The hardware device Id.
    OSLstEntry  MinorBaseOS,_MinorBase
        ;References Minor Base Offset.
    OSLstEntry  MinorLength,_MinorLength
        ;References Minor Base Length.
    DatLstEntry endOfList,0
        ;End of the list.</pre>
<p>
The type format for our fictional function looks like this:
</p>
<pre>_FunType   DC.W    CatExCat    ;&lt;Category&gt;
            DC.W    TypExTyp    ;&lt;Type&gt;
            DC.W    DrSwExSw    ;&lt;DrSw&gt;
            DC.W    DrHwExHw    ;&lt;DrHw&gt;</pre>
<p>
The sRsrc_Names for functional sResources follow a convention of concatenating the<br>
equates for the sRsrc_Type but stripping off the prefixes and separating the type<br>
format fields by underscore characters.&nbsp;&nbsp;Since our type<br>
is<code>CatExCat/TypExType/DrSwExSw/DrHwExHw</code>, the sRsrc_Name becomes:
</p>
<pre>_FunName   DC.L    'ExCat_ExType_ExSW_ExHW'</pre>
<p>
The driver directory identifies the type of driver and the driver itself.&nbsp;&nbsp;In the<br>
example, the driver is compatible with the Macintosh OS but contains Motorola 68020<br>
code. The driver itself is in a separate file and is referenced by an INCLUDE directive.
</p>
<pre>;-------------------------------------------------------------
;   Driver directory; (if there's an on-board driver)
;-------------------------------------------------------------
_FunDrvrDir OSLstEntry  sMacOS68020,_sMacOS68020   
        ;References Macintosh-OS
        ;68020 driver.
                DatLstEntry endOfList,0
        ;End of the list.
        ;Driver-1 (68020).
_sMacOS68020    DC.L    _End020Drvr-_sMacOS68020   
        ;The physical Block Size
                INCLUDE 'NameofDrvrSrcCodeFile.a'  
        ;The  driver code
_End020Drvr EQU *  
        ;The end of the driver.
    STRING  C</pre>
<p>
The hardware device ID; field (HWDevID) is optional and defined by the vendor.&nbsp;&nbsp;It can<br>
be used to indicate that an sResource is associated with a particular piece of hardware.<br>
This would be used in the case of cards that had multiple "hardware areas"--say,<br>
multifunction cards--that could be considered to be separate hardware devices.&nbsp;&nbsp;The<br>
field could be used to group certain sResources with the various devices.&nbsp;&nbsp;In this case,<br>
the functional sResources would have different HWDevID values depending on which<br>
hardware device on the card they describe.
</p>
<p>
For example, you have a card with two serial ports, which you label port 1 and port 2.<br>
You have three functional sResources--an asynchronous serial sResource, a MIDI<br>
sResource, and a network sResource.&nbsp;&nbsp;Let's say the async serial sResource is assigned<br>
to port 1.&nbsp;&nbsp;It is assigned HWDevID=1.&nbsp;&nbsp;Now let's say the network sResource can only be<br>
used with port 2.&nbsp;&nbsp;It is assigned HWDevID=2.&nbsp;&nbsp;Similarly, the MIDI sResource can only<br>
be used on port 1.&nbsp;&nbsp;It will also be assigned HWDevID=1.&nbsp;&nbsp;Now, by looking at the<br>
HWDevID fields, a driver or card software can tell which piece of hardware it is using<br>
in case different hardware on the card has different characteristics it must handle.&nbsp;&nbsp;If<br>
an sResource does not describe a hardware device, then the HWDevID field may be<br>
omitted.
</p>
<p>
The MajorBaseOS , MinorBaseOS, MajorLength, and MinorLength fields describe where<br>
the hardware area starts and how large it is.&nbsp;&nbsp;For example, a video sResource might<br>
have the MinorBaseOS be an offset to the starting address of the video frame buffer. <br>
The MinorLength field would tell how large it is.&nbsp;&nbsp;Other cards might use the<br>
MinorBaseOS to indicate where its hardware control registers are. 
</p>
<p>
Use Major vs. Minor depending whether you want to reference the area using super<br>
slot space or NuBus slot space addresses.
</p>
<p>
In the example, let's say this function has some RAM memory in NuBus slot space that<br>
we would like to reference:
</p>
<pre>_MinorBase     DC.L    defMinorBase    ;RAM Offset
_MinorLength    DC.L    defMinorLength  ;RAM length</pre>
<p>
<b>THE FORMAT BLOCK</b><br>
Declaration ROMs are recognized by the presence of the ROM's format block, which<br>
occupies the highest address of the ROM's slot address space. This is our example<br>
format block:
</p>
<pre>ORG    ROMSize-FHeaderRec.fhBlockSize
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   Format Block
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    DC.L    (_sRsrcDir-*)**$00FFFFFF   
        ;Offset to sResource directory
    DC.L    ROMSize
        ;Length of declaration data
    DC.L    0  
        ;CRC-can be patched by MPW crc tool
    DC.B    romRevision
        ;Revision level
    DC.B    AppleFormat
        ;Format
    DC.L    TestPattern
        ;Test pattern
    DC.B    0
        ;Reserved byte (must be zero)
    DC.B    $E1
        ;ByteLanes: 1110 0001 (bytelane 0)
ENDP
END</pre>
<p>
The first entry calculates the offset to the beginning of the directory, using the<br>
directory label.&nbsp;&nbsp;This must be a signed 24-bit value.
</p>
<p>
The ROM size;, revision level, format, test pattern, and reserved values are declared<br>
in the source and in the included MPW ROMEqu.a file. The CRC value can be generated<br>
and patched in by utilities such as MPW tools.&nbsp;&nbsp;Apple supplies two MPW tools on the<br>
Developer Services CD and AppleLink called Data and CRC.&nbsp;&nbsp;Data takes the assembled<br>
source code file, strips off the CODE 0 resource, and puts the CODE 1 segment (now the<br>
actual ROM image) into a data file.&nbsp;&nbsp;This will be convenient for later downloading to a<br>
ROM burner.&nbsp;&nbsp;The CRC tool takes the ROM image, calculates the CRC value, and inserts<br>
it into the proper place.
</p>
<p>
The last field in the block is the ByteLanes field, a signature byte that identifies which<br>
of the four NuBus byte lanes the ROM image appears on.&nbsp;&nbsp;The Slot Manager attempts to<br>
read a valid value in each of the four byte lanes at the end of the slot space.&nbsp;&nbsp;If the Slot<br>
Manager is unable to read a valid field, then an error is posted for this slot.&nbsp;&nbsp;If a valid<br>
ByteLanes value is read, this information is used to confirm a special test pattern, and<br>
perform a ROM validity check.&nbsp;&nbsp;If all verification passes, then the system can utilize<br>
the offset to the sResource directory.&nbsp;&nbsp;Note that the Slot Manager attempts to read the<br>
format block in both the 1 MB and 16 MB NuBus slot spaces.&nbsp;&nbsp;If any of these<br>
verification checks fails, the slot is marked as empty or invalid, and all Slot Manager<br>
calls to that slot will return errors.
</p>
<h2>POTENTIAL PROBLEMS</h2>
<p>
Now that we've covered the source code to the example ROM, let's look at some common<br>
problems developers experience.&nbsp;&nbsp;When trying to assemble the source code, if one or<br>
more of the arguments to the OSLstEntry or DatLstEntry macro is incorrectly defined<br>
or just left out, you will get an assembler error in the middle of the macro, and the<br>
assembler will complain with the error message:
</p>
<pre>   Invalid arithmetic operation on relocatable id</pre>
<p>
This message was generated as a result of the assembler's inability to resolve one of<br>
the two arguments to the macro.&nbsp;&nbsp;If you get this error, check both arguments and make<br>
sure the labels are correctly defined.&nbsp;&nbsp;The first argument must be equated to something<br>
in your source or the development system include files, and the second argument must<br>
be a label that exists in the source code.&nbsp;&nbsp;Please be aware that some of the predefined<br>
equates (in the assembler include files) changed from MPW 2.0 to 3.0.&nbsp;&nbsp;For instance,<br>
to improve readability, some IDs had the underscores in the middle removed<br>
(Cat_Board became CatBoard in a directory, for example).
</p>
<p>
Another error can arise from a bug in the macro defined up to and including MPW<br>
version 3.0.&nbsp;&nbsp;Most declaration ROM sources are arranged in a sequence like ours: the<br>
directory comes first in the source code (and so is lowest in memory), followed by the<br>
sResources, and finally the format block, which is at the very end of the source listing.
</p>
<p>
Structures referenced by sResources are usually defined after the sResources. That is,<br>
usually things are referenced in a forward manner and come later in the source code.
</p>
<p>
Laying out the sResources this way, the macro works fine.&nbsp;&nbsp;However, if you want to<br>
have the macro calculate a negative offset to a structure, to reference something that<br>
comes earlier in the source code, you may run into trouble.&nbsp;&nbsp;The following macro<br>
definition:
</p>
<pre>       MACRO
        OSLstEntry  &amp;Id,&amp;Offset
        DC.L    (&amp;Id<<24)+&amp;Offset-*
        ENDM</pre>
<p>
can be fixed by changing it to:
</p>
<pre>       MACRO
        OSLstEntry  &amp;Id,&amp;Offset
        DC.L    (&amp;Id<<24) ++ ((&amp;Offset-*) ** $00FFFFFF)
        ENDM</pre>
<p>
This correctly masks off the high byte of the 24-bit offset and thus allows the full<br>
range of positive as well as negative offsets to structures.
</p>
<p>
Often, the source code to the ROM will build, but because of errors in the declaration<br>
ROM data structures, the Slot Manager will fail to recognize the ROM, or will generate<br>
errors while looking at certain structures.&nbsp;&nbsp;When this happens, looking at the error<br>
generated and manually disassembling the ROM will usually find the error.&nbsp;&nbsp;This<br>
requires understanding how the ROM appears from a debugger.
</p>
<p>
<b>DISSEMBLING THE ROM</b><br>
Declaration ROMs often occupy only one or two of the four NuBus byte lanes, meaning<br>
you have to translate your assembly listing by hand.&nbsp;&nbsp;This is because the assembler<br>
generates the listing as though the ROM occupies all four byte lanes (that is, as though<br>
it would reside in RAM).&nbsp;&nbsp;To translate from the ROM listing to the actual physical<br>
addresses the ROM occupies requires knowledge of byte lanes, which are often<br>
misunderstood.
</p>
<p>
The NuBus bus width is 32 bits, or, very importantly, four bytes.&nbsp;&nbsp;Think of each<br>
group of four bytes as a chunk.&nbsp;&nbsp;A chunk on the NuBus would look like this:
</p>
<p>
The four bytes of each chunk are identified by the byte number as shown in the<br>
illustration.&nbsp;&nbsp;Byte number 3 on the NuBus side--the most significant--contains<br>
NuBus address and data bits 31-24, byte number 2 contains A/D bits 23-16, byte<br>
number 1 contains A/D bits 15-8, and byte number 0--the least<br>
significant--contains A/D bits 7-0.&nbsp;&nbsp;Bytes whose address modulo 4 equals 0 are<br>
carried on byte number 0, those whose address equals 1 are carried on byte number 1,<br>
whose address equals 2 are carried on byte number 2, and whose address equals 3 are<br>
carried on byte number 3. 
</p>
<p>
This address-to-byte-number mapping is conveniently set up for an Intel-type<br>
processor, which carries the most significant bits on a higher numbered address.&nbsp;&nbsp;The<br>
Macintosh uses a Motorola type processor, which has the most significant bits on a<br>
lower numbered address.&nbsp;&nbsp;In order to preserve consistency of byte addressing, Apple<br>
does byte swapping from the NuBus to the Motorola 680x0 CPU.
</p>
<p>
To see this more clearly, let's expand the byte lanes diagram from the address space<br>
chapter of Designing Cards and Drivers for the Macintosh Family.
</p>
<p>
The diagram looks quite complicated.&nbsp;&nbsp;Fortunately, once you understand the key<br>
concepts, it's not.&nbsp;&nbsp;The addressing of bytes within a chunk is in reverse order on the<br>
NuBus and 680x0 sides.&nbsp;&nbsp;However, the address range of a chunk is the same when<br>
viewed from the NuBus or 680x0 side.&nbsp;&nbsp;The hardware interface between the CPU on the<br>
motherboard swaps the bytes of a chunk when going to and from the NuBus.
</p>
<p>
Now that we understand the byte and address translation between our CPU and the<br>
NuBus, let's look at part of our assembled ROM listing.&nbsp;&nbsp;The best place to start is at the<br>
format block at the "top" or highest physical address of the ROM, since this is where<br>
the Slot Manager starts looking at startup time to find valid declaration ROMs. <br>
Assembled, the format block looks like:
</p>
<pre>00FEC  ;+++++++++++++++++++++++++++++++++++++++++++++++++
00FEC   ;   Format/Header Block
00FEC   ;+++++++++++++++++++++++++++++++++++++++++++++++++
00FEC   00FF F014   DC.L    (_sRsrcDir-*)**$00FFFFFF
        ;Offset to sResource directory
00FF0   0000 1000   DC.L    ROMSize
        ;Length of declaration data
00FF4   0000 0000   DC.L    0  
        ;CRC-can be patched by MPW crc tool
00FF8   01  DC.B    romRevision
        ;Revision level
00FF9   01  DC.B    AppleFormat
        ;Format
00FFA   5A93 2BC7   DC.L    TestPattern ;Test pattern
00FFE   00  DC.B    0  
        ;Reserved byte (must be zero)
00FFF   E1  DC.B    $E1
        ;ByteLanes: 1110 0001 (byte lane 0)
01000</pre>
<p>
The Slot Manager will start scanning from the highest address, looking for a ByteLanes<br>
value.&nbsp;&nbsp;From there, it will look for confirmation of the ByteLanes value by looking for<br>
the reserved values, the test pattern, proper format, and revision values, down to the<br>
CRC calculation.&nbsp;&nbsp;If there is a problem with the ByteLanes value or the way the card<br>
has been built, this Slot Manager check will fail.&nbsp;&nbsp;At this point, you should load up a<br>
debugger and look at the format block.&nbsp;&nbsp;Assuming the board is in slot $B, the above<br>
format block (residing on byte lane 3) might look like this in memory (as seen from<br>
MacsBug):
</p>
<pre>00BFFFB0 0000 0000 FF00 0000 F000 0000 1400 0000 ****************
00BFFFC0 0000 0000 0000 0000 1000 0000 0000 0000 ******** *******
00BFFFD0 9D00 0000 8600 0000 3400 0000 FE00 0000 ********4*******
00BFFFE0 0100 0000 0100 0000 5A00 0000 9300 0000 ********Z*******
00BFFFF0 2B00 0000 C700 0000 0000 0000 E100 0000 +***************</pre>
<p>
The lowest address is at the upper left, and the highest address is at the lower right,<br>
with increasing addresses going from left to right.&nbsp;&nbsp;Note that the MacsBug listing shows<br>
an example CRC value ($9D8634FE) that was calculated and patched in after the ROM<br>
was assembled.
</p>
<p>
<b>SLOT MANAGER ERRORS</b><br>
During evaluation at startup or in response to application/driver Slot Manager calls, a<br>
number of errors can be returned by the Slot Manager.&nbsp;&nbsp;Often this is due to an<br>
incorrect ByteLanes value or bad sResources.&nbsp;&nbsp;The error returned usually helps to<br>
narrow down the problem.&nbsp;&nbsp;You can look at the error, then manually track through<br>
sResources in the ROM.&nbsp;&nbsp;This requires disassembling and "playing Slot Manager" much<br>
as we did above.&nbsp;&nbsp;Drawing a diagram like the one in the front of the article with the<br>
addresses and values can often help. However, please note that many Slot Manager calls<br>
make other Slot Manager calls, and the error returned may reflect an error returned<br>
by one of those calls.
</p>
<p>
If an error or crash occurs in the ROM before a debugger is loaded (during the<br>
primary initialization routine, for example), you can defer the driver or primary<br>
initialization until after the boot process has begun and a debugger has been loaded.&nbsp;&nbsp;Do<br>
this by first making stubs for the driver and/or primary initialization, or deleting<br>
them entirely.&nbsp;&nbsp;Then run them from a high-level application, which can have the<br>
primary initialization or drivers in the application or possibly in separate files.
</p>
<p>
In order to keep the driver from being loaded until after the boot, you might have to<br>
temporarily change the functional sResource's type format.&nbsp;&nbsp;This is needed in the case<br>
of video boards, for example, since the startup code looks specially for video boards,<br>
runs their primary INITs, and opens the drivers.&nbsp;&nbsp;In this case, change the sRsrc_Type<br>
to something other than CatDisplay, TypVideo, DrSwApple so that the start code won't<br>
identify the video display function. Changing CatDisplay to CatNonsense EQU $0000<br>
would do the trick.
</p>
<h2>SUMMARY</h2>
<p>
Declaration ROMs store system-recognizable structures as well as vendor- specific<br>
data.&nbsp;&nbsp;Debugging declaration ROMs is complicated by the fact that the declaration ROM<br>
sits on the other side of the Nubus, and you have to translate the information you get. <br>
But using the techniques discussed in this article should make building, interpreting,<br>
and debugging declaration ROMS a little easier.
</p>
<p>
<b>Mark Baumwell</b> is a low-level O/S&nbsp;&nbsp;sort of guy.&nbsp;&nbsp;He started with Apple in 1981<br>
after a stint with Zilog as a test engineer.&nbsp;&nbsp;After three years in the Lisa division, Mark<br>
made the move to Macintosh DTS where&nbsp;&nbsp;he has fulfilled his lifelong dream of being&nbsp;&nbsp;a<br>
firefighter.&nbsp;&nbsp;He professes to be "outdoorsy," and getting an airplane pilot's license is<br>
hiscurrent passion.&nbsp;&nbsp;He claims that nothing we&nbsp;&nbsp;could say would sully his reputation<br>
more&nbsp;&nbsp;than it has already been.&nbsp;&nbsp;We tried, but&nbsp;&nbsp;Apple Legal wouldn't approve it.&nbsp;&nbsp;Would<br>
you fly with this guy? *
</p>
</body>
</html>
