<html>
<head>
<!-- Article ID: 19 - Extracted from develop-1990 -->
<!-- on 2023-12-27 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by copyright of their respective owners -->
<title>October 90 - THE PERILS OF POSTSCRIPT--THE SEQUEL</title>
<link href="styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h2>THE PERILS OF POSTSCRIPT--THE SEQUEL</h2>
<h1>SCOTT "ZZ" ZIMMERMAN</h1>
<p>
<i>Developers are discovering the advantages of using PostScript &#174; dictionaries in</i><br>
<i>applications, but along with the advantages come some perils. One peril awaits if you</i><br>
<i>download a dictionary using PostScriptHandle. Another can trip you up after</i><br>
<i>downloading a dictionary if you then download a font using the SetFont procedure I</i><br>
<i>described in </i>&nbsp;&nbsp;develop<i>, Issue 1. How to avoid these perils? Read on to learn some tricks</i><br>
<i>for dicts in picts.</i>
</p>
<p class="spacer">&nbsp;</p>
<p>
More and more developers are beginning to use direct PostScript code in their<br>
applications. In my "Perils of PostScript" article in develop, Issue 1, I addressed a<br>
couple of problems that arise when you use PostScript code to print documents. In this<br>
sequel, we'll look at some problems you will encounter if you attempt to use<br>
PostScript dictionaries in your applications.
</p>
<h2>ABOUT POSTSCRIPT DICTIONARIES</h2>
<p>
A PostScript dictionary is a collection of predefined variables and/or procedures.<br>
Using a PostScript dictionary can significantly reduce the size of the PostScript code<br>
generated by your application and make it more efficient. For instance, consider a<br>
large PostScript file in which the operator<code>currentpoint </code>is used frequently.&nbsp;&nbsp;You can<br>
define in your dictionary a PostScript procedure called <code>cp </code> that makes a call to the<br>
<code>currentpoint</code> operator.&nbsp;&nbsp;You can then replace <code>currentpoint </code>with <code>cp </code>throughout the<br>
file, thus reducing its size. Similarly, by defining a PostScript procedure to represent<br>
a series of operators, you can express a compound operation much more efficiently.<br>
And storing procedures in a dictionary that you create can also prevent you from<br>
inadvertently redefining something that has already been defined. 
</p>
<p>
One great example of a PostScript dictionary is the one used by the LaserWriter &#174;<br>
driver, variously called LaserPrep (after the file it resides in, at least until System<br>
7), AppleDict (the Apple name for it), and good ol' md (the PostScript name for it, and<br>
the one I prefer to use). The LaserWriter driver generally uses one or more md
</p>
<p>
routines to perform a particular QuickDraw operation. (See the sidebar on the next<br>
page for a review of how the LaserWriter driver works.) For example, a call to the<br>
QuickDraw <code> CopyBits&nbsp;&nbsp;</code>routine is translated by the driver into a call to the <code> db </code> or <br>
<code>cdb </code> operators stored in md. As another example, during font downloading the<br>
LaserWriter driver uses <code> bn&nbsp;&nbsp;</code>and <code> bu </code>, both stored in md, to call <code>save&nbsp;&nbsp;</code>and <br>
<code>restore&nbsp;&nbsp;</code>( <code> bn </code>calls save and <code> bu&nbsp;&nbsp;</code>calls restore).If you want to record a piece of<br>
PostScript code that references procedures contained in a dictionary, you must also<br>
record the dictionary.&nbsp;&nbsp;I describe how to download a dictionary, and how to avoid the<br>
pitfalls involved, in the next section.
</p>
<p>
Once your dictionary has been downloaded, you should be able to continue to reference<br>
it until the end of the job. But alas, this is not so, at least until the new printing<br>
architecture ships sometime after System 7. Under the current architecture, font<br>
downloading interferes with PostScript dictionaries. I discuss this problem and how to<br>
get around it under "The Perils of Font Downloading."
</p>
<h2>THE PERILS OF DICTIONARY DOWNLOADING</h2>
<p>
One of the easiest methods for downloading a PostScript dictionary is by using the <br>
<code>PostScriptHandle </code>picture comment. You can use this comment to download directly<br>
to the LaserWriter a block of PostScript code stored in a handle. (See Technical Note<br>
#91, Optimizing for the LaserWriter--PicComments, for more information.) When<br>
you use the <code> PostScriptHandle </code>comment, you must insert the <code> PostScriptBegin</code><br>
and <code> PostScriptEnd</code>picture comments around the block of PostScript code you are<br>
trying to download, like this:
</p>
<pre>PicComment(PostScriptBegin, 0, NIL);
(************************************************************)
(*** Your PostScript representation of document goes here.***)
(************************************************************)
PicComment(PostScriptHandle, size, handle);
(***********************************************************)
(*** Your QuickDraw representation of document goes here.***)
(***********************************************************)
PicComment(PostScriptEnd, 0, NIL);</pre>
<p>
As described in my first article, the <code>PostScriptBegin/End</code>comments are markers<br>
that ensure that the right piece of code will execute on the right device. When the<br>
LaserWriter driver sees <code>PostScriptBegin</code>, it ignores all QuickDraw drawing calls<br>
and just executes picture comments. When a <code>PostScriptEnd</code>is received, the<br>
LaserWriter driver will once again interpret QuickDraw calls. So when printing to a<br>
LaserWriter printer, only the picture comments are executed, while the QuickDraw<br>
code between <code>PostScriptBegin</code>and <code> PostScriptEnd</code>is ignored. But <br>
<code>PostScriptBegin </code>and <code> PostScriptEnd </code>also save and restore at least part of the<br>
state of the device, which can cause problems for your dictionary. To avoid this, you<br>
should use the picture comment <code> PostScriptBeginNoSave </code>(comment kind = 196) to<br>
prevent the save and restore from occurring, like this:
</p>
<pre>(***************************************************)
(*** Your definition of the dictionary goes here.***)
(***************************************************)

PicComment(PostScriptBeginNoSave, 0, NIL);
PicComment(PostScriptHandle, dictsize, dicthandle);
PicComment(PostScriptEnd, 0, NIL);
(**********************************)
(*** Now you send the document. ***)
(**********************************)

PicComment(PostScriptBegin, 0 NIL);
(************************************************************)
(*** Your PostScript representation of document goes here.***)
(************************************************************)
PicComment(PostScriptHandle, size, handle);
(***********************************************************)
(*** Your QuickDraw representation of document goes here.***)
(***********************************************************)
PicComment(PostScriptEnd, 0, NIL);</pre>
<p>
If you don't need to export your dictionary into picture files, you can get the<br>
LaserWriter driver to auto-download your dictionary by keeping the dictionary code<br>
in a PREC(103) resource. After the LaserWriter has saved its state, it does a blind <br>
<code>GetResource </code>(that is, from any open resource file) on PREC(103). If one is found, it<br>
is downloaded to the printer after the md dictionary, and before the job. You can use<br>
this method of downloading for dictionaries that are used only to contain state<br>
information about the current job. (When a graphic is copied onto the clipboard, only<br>
the state information, not the entire dictionary, is required for the code to execute.)
</p>
<p>
However, use of the PREC(103) resource does have some limitations. It only works at<br>
print time, and there can be only one. That is, the LaserWriter driver does <i> not </i><br>
attempt to download all the PREC(103) resources in all the open resource files. The<br>
first one it finds wins. (This method of downloading dictionaries is documented in<br>
Technical Note #192, Surprises in LaserWriter 5.2 and Newer.)
</p>
<h2>THE PERILS OF FONT DOWNLOADING</h2>
<p>
In my "Perils of PostScript" article in Issue 1 of develop,&nbsp;&nbsp;I showed a small procedure<br>
called <code>SetFont </code>that downloaded a font using QuickDraw, while maintaining the ability<br>
to reference that font using PostScript. The problem with that method is that the<br>
process of font downloading executes the PostScript <code> restore </code>operator. This operator<br>
restores the state of the printer to a state that was saved before your dictionary was<br>
defined. Because of this, any reference to your dictionary is lost.
</p>
<p>
Another way to understand what happens in this case is to look at what the LaserWriter<br>
driver does during printing. At the start of a print job, the LaserWriter driver<br>
configures the LaserWriter's graphics state to look more like QuickDraw. This<br>
includes moving the origin (0,0) from the bottom left (PostScript style) to the top<br>
left (QuickDraw style), and setting the default resolution to 72 dpi. After the driver<br>
has configured the printer, it performs a save, which saves the complete state of the<br>
device. The driver then begins downloading the rest of the job, containing the<br>
PostScript code generated by the LaserWriter as well as any additional PostScript code<br>
sent by the application.
</p>
<p>
The LaserWriter driver fully restores the state of the device, by executing the<br>
PostScript <code> restore</code>operator, before downloading a font. During font downloading, the<br>
characters of the font are actually defined, sometimes using normal PostScript<br>
drawing operators. Because of this, the LaserWriter driver restores the state of the<br>
printer before defining the characters. Once the characters have been defined, the state<br>
is saved again. This way, the LaserWriter driver can assume it knows the state of the<br>
device. Since the state saved by the LaserWriter driver does not contain any of the<br>
symbols defined by the application, all of them are lost after any attempt to download a<br>
font.
</p>
<p>
<b>WHICH WAY OUT?</b><br>
Now that we understand the problem, let's discuss potential solutions. The <code> restore</code><br>
operator affects everything that has changed except two areas: some of the PostScript<br>
stacks (specifically the operand, dict, and execution stacks), and the contents of<br>
PostScript strings. This suggests that to save small units of information, you can<br>
simply push them onto the stack, or convert them and store them as PostScript<br>
strings.
</p>
<p>
Unfortunately, it's not quite that easy.
</p>
<p>
PostScript makes a distinction between simple and composite objects.&nbsp;&nbsp;Simple objects<br>
(like numerical values and booleans) contain their value within the object.&nbsp;&nbsp;Composite<br>
objects (like strings, procedures, and dictionaries) contain only a pointer to the real<br>
data, which is stored elsewhere in PostScript Virtual Memory. Simple objects on the<br>
stack are indeed preserved across a <code> restore</code>, but if there are composite objects on<br>
the stack that are new (that is, newer than the state being&nbsp;&nbsp;restored), an <br>
<code>invalidrestore </code>error is generated.&nbsp;&nbsp;If your dictionary only contains simple objects,<br>
then you can indeed push each of the variables defined in the dictionary onto the stack<br>
separately and rebuild the dictionary after the <code> restore</code>.&nbsp;&nbsp;The overhead here is<br>
obviously enormous, though, and most useful dictionaries contain procedures and/or<br>
strings, rendering this technique useless.
</p>
<p>
In the case of strings being preserved across a <code> restore</code>, let me quote from the<br>
<i>PostScript Language Reference Manual</i> , p. 44: "In the current PostScript design, <br>
<code>restore </code>actually does not undo changes made to the elements of strings.&nbsp;&nbsp;We consider<br>
this behavior to be a defect, and do not recommend that PostScript programs take<br>
advantage of it." Beyond this easily ignored admonishment, though, is another problem.<br>
The strings in question must be preexisting: strings you create just before the <br>
<code>restore </code>will, of course, be destroyed by the <code> restore</code>, or, if they are on the stack,<br>
will cause an error.&nbsp;&nbsp;You could probably find some scratch strings in one of the<br>
standard dictionaries to use, but this is not recommended, for obvious reasons.
</p>
<p>
<b>AN END TO BN AND BU</b><br>
Another way to solve the problem would be to&nbsp;&nbsp;redefine <code> save </code>and <code>restore </code>to not do<br>
anything. This way, font downloading would not cause the state to be restored. This<br>
would make the application developer responsible for preserving the state, which is<br>
easily done using other PostScript operators. But unfortunately, the definitions of<br>
<code>save </code>and <code> restore </code>cannot be changed without exiting the server loop. That is, you<br>
cannot override their definitions from within a job. Because of this, you have to fall<br>
back on plan B: override the operators that call <code> save </code>and <code> restore</code>. In the case of<br>
font downloading, these operators are <code> bn </code>and <code> bu</code>, as mentioned earlier.
</p>
<p>
This method is the most widely used solution to our problem, has the fewest<br>
limitations, and is the method recommended here. Please note, however, that tinkering<br>
with md operators outside of this specific use is strongly discouraged. (See the sidebar<br>
on the next page.)
</p>
<p>
The main job of <code> bu </code>and <code> bn </code>is to preserve the state of the PostScript device. As long<br>
as your PostScript code preserves the state, these calls aren't even required. In the<br>
fragment that follows, we first create our own dictionary, called mydict, with room<br>
for ten symbols, although we don't define them all. Next we define <code> killbu</code>. <code>killbu </code>is<br>
responsible for first saving the old definition of the <code> bu</code>routine, and then setting its<br>
value to the empty procedure ( <code>{}</code>), which does nothing. The original definition of <code> bu</code><br>
is simply pushed onto the stack. Next we write a routine <code> restorebu</code>, to restore the<br>
definition of <code> bu </code>when we are through. This routine is responsible for popping the<br>
original value off the stack and storing it back into the <code> bu </code>symbol; it assumes that<br>
the definition of <code> bu </code>is on the top of the stack. Then we define two similar routines, <br>
<code>killbn </code>and <code>restorebn</code>, which take care of the <code> bn </code>operator. Finally, we define a fun<br>
little routine to call to make sure our dictionary is actually being preserved after font<br>
downloading. We call this one <code> titleshow</code>. So now we have a dictionary, all ready to<br>
use.
</p>
<pre>SendPostScript('/mydict 10 dict def');
SendPostScript('mydict begin');
SendPostScript('/killbu {//md /bu get //md /bu {} put} def');
SendPostScript('/restorebu {//md exch /bu exch put} def');
SendPostScript('/killbn {//md /bn get //md /bn {} put} def');
SendPostScript('/restorebn {//md exch /bn exch put} def');
SendPostScript('/titleshow {dup gsave');
SendPostScript('currentscreen 3 -1 roll pop 120 3 1 roll setscreen');
SendPostScript('.5 setgray show grestore true charpath gsave');
SendPostScript('1 setlinewidth 0 setgray stroke grestore');
SendPostScript('.5 setlinewidth 1 setgray stroke }def');
SendPostScript('end');</pre>
<p>
Okay, now that we have the routines for killing <code> bu </code>and <code> bn</code>, we need to call them. It's<br>
very important at this point to check for their existence before attempting to alter<br>
their definitions. This is because, as mentioned earlier, the new printing architecture<br>
that will ship sometime after System 7 will handle font downloading differently. The <br>
<code>bu </code>and <code> bn </code>operators will no longer exist; in fact, it's not clear that the md<br>
dictionary will still exist. The following PostScript commands check for the existence<br>
of both the dictionary and the symbol. If they don't exist, our code assumes it is<br>
running under the new printing architecture, and does nothing to insulate the<br>
dictionary. The code fragment executes fine on LaserWriter drivers up to and including<br>
System 7.0. It has also been tested in both foreground and background. Considering the<br>
future of <code> bn </code>and <code> bu</code>, it is very likely that this code will continue to work even under<br>
the new printing architecture. Here, then, is the code to check for and kill <code> bn </code>and <br>
<code>bu</code>:
</p>
<pre>SendPostScript('mydict begin');
SendPostScript('//md /bu known {killbu} if');
SendPostScript('//md /bn known {killbn} if');
SendPostScript('end');</pre>
<p>
Pretty straightforward: if the routine exists, call the correct routine to kill it. The<br>
most important thing to note here is the order of the routines. Since <code>killbu</code>and <br>
<code>killbn</code>push things onto the stack, <code>restorebu</code>and <code> restorebn</code>must be called in<br>
opposite order to get the correct results. So after the job is finished, we call:
</p>
<pre>SendPostScript('mydict begin');
SendPostScript('//md /bn known {restorebn} if');
SendPostScript('//md /bu known {restorebu} if');
SendPostScript('end');</pre>
<h2>TO SUM IT ALL UP</h2>
<p>
PostScript dictionaries are useful because they can significantly reduce the size of the<br>
PostScript code generated by your application, and can be exported into pictures.<br>
Perhaps the easiest way to record PostScript into a picture is by using the <br>
<code>PostScriptHandle</code>picture comment. In this case, remember to use the <code> PostScript</code><br>
<code>BeginNoSave </code>comment to prevent <code> PostScriptBegin </code>and <code>PostScriptEnd </code>from<br>
saving and restoring at least part of the state of the device, which can cause problems<br>
for your dictionary. To prevent font downloading from interfering with your<br>
PostScript dictionaries, you can override <code> bn </code>and <code> bu</code>, the PostScript operators that<br>
call <code> save </code>and <code> restore</code>. Outside of this solution, you should absolutely avoid using<br>
md operators.
</p>
<p>
The code included in the Perils of PS II folder on the <i> Developer Essentials </i> disc is<br>
basically the same code that has been shown here, rolled into an application shell that<br>
opens and initializes the Printing Manager. Also included is the definition of the <br>
<code>SendPostScript</code>procedure referenced in this article.
</p>
<h2>A REVIEW OF HOW THE LASERWRITER DRIVER WORKS</h2>
<p>
The LaserWriter driver is a complex piece of software that handles communications<br>
between an application and the LaserWriter printer. To print a document, the<br>
application opens the Printing Manager, which in turn loads and initializes the<br>
LaserWriter driver. The application then makes standard QuickDraw calls similar to<br>
those used to render the document on the screen. The LaserWriter driver intercepts<br>
these calls and converts them into the equivalent PostScript code for rendering the<br>
document on the LaserWriter printer.
</p>
<p>
(See Figure 1.) In some cases, one QuickDraw operation translates into one PostScript<br>
operation, but more frequently, the QuickDraw operation translates into several<br>
PostScript operations. To abbreviate these operations, the LaserWriter driver stores<br>
them as procedures in a PostScript dictionary.
</p>
<p>
&nbsp;When the LaserWriter driver first connects to the LaserWriter printer, it checks to<br>
see if its dictionary exists and if the version of the dictionary matches the version of<br>
the driver being used. If not, it downloads the correct dictionary before proceeding.<br>
(This is what the message "initializing printer" means when you print for the first<br>
time after turning on the printer.)
</p>
<p>
&nbsp;Once the correct dictionary is in place, the job of translation becomes much easier.<br>
Each QuickDraw operation now becomes one line of PostScript code, referencing a<br>
procedure defined by the dictionary. Complex QuickDraw operations (like font<br>
downloading) still require many lines of PostScript code, but in general, the<br>
translation is one for one. Since the QuickDraw code is translated rather than<br>
rendered, the LaserWriter driver doesn't need to spool the data to disk. Instead, each<br>
operation is translated and sent to the printer as it is received.
</p>
<p>
<img src="img/140.gif" width="569 px"></img>
</p>
<p>
<b>Figure 1</b> How the LaserWriter Driver Works
</p>
<h2>WARNING: CALLING MD ROUTINES MAY BE HAZARDOUS TO<br>
YOUR CODE</h2>
<p>
&nbsp;Many developers have started to call md routines from within the PostScript code<br>
generated by their applications.&nbsp;&nbsp;&nbsp;This is dangerous, for a number of reasons.
</p>
<p>
&nbsp;The first is that the md dictionary is defined and maintained by the LaserWriter<br>
driver. This means that it is always subject to change, and code that depends on the md<br>
dictionary must be version dependent. This is possible, but far from elegant. 
</p>
<p>
&nbsp;Another problem with using md operators is that they may not work the same way on<br>
all devices. Remember that the LaserWriter driver is used to drive a lot more devices<br>
than just an Apple LaserWriter.
</p>
<p>
&nbsp;Use of md operators has already led to compatibility problems with major<br>
applications, and most developers have realized the danger in using them. The easiest<br>
way to avoid problems with these routines is to not call them.&nbsp;&nbsp;If you really need the<br>
functionality of a particular md operator, simply redefine it in your own dictionary.<br>
Using tools like LaserTalk (formerly from Emerald City Software, now from Adobe),<br>
you can "disassemble" md operators back to their PostScript primitives. You can then<br>
redefine them using a different name in your own dictionary. Now you have a routine<br>
that does exactly what the md routine did, but you remain in control of its definition.<br>
Most of the md operators are very small, so the storage penalty of redefining them in<br>
your own dictionary is minimal.
</p>
<p>
Now that I've warned you, I'm going to show you how to tinker with two operators<br>
stored in md: bn and bu.&nbsp;&nbsp;&nbsp;All routines, including these two, are subject to change; by<br>
special arrangement with engineering, bn and bu will change in a compatible way, but<br>
this is<i>not</i> true for any of the other routines defined in md. This article shows a specific<br>
use of bn and bu, and checks for their existence before attempting to access them. This<br>
is <i>not</i> meant to endorse other uses of these or any other md routines. 
</p>
<p>
<b>SCOTT "ZZ" ZIMMERMAN</b> is a DTS&nbsp;&nbsp;printing guru. After two and a half years at<br>
Apple he says he's particularly impressed with the strictly enforced dress code. In his<br>
spare time he sails, scuba dives for lobsters, and plays the piano, guitar, and<br>
saxophone. Zz has a penchant for pets. His doorway is adorned by a melted gummy rat,<br>
a good luck charm left over from his Intel days.&nbsp;&nbsp;At home, atop his monitor is perched a<br>
rare Asian black scorpion (behind glass, we hope). His other cuddly pets include two<br>
geckos and a lovable iguana.&nbsp;&nbsp;*
</p>
<p>
<b>The definitive references</b> on the PostScript language are the<i> PostScript Language</i><br>
<i>Reference Manual </i> (Addison- Wesley, 1985, available from APDA--#T0182LL/A),<br>
the <i>PostScript Language Tutorial and Cookbook </i>&nbsp;&nbsp;(Addison-Wesley, 1985), and<br>
<i>PostScript Language Program Design </i> (Addison-Wesley, 1988). *
</p>
<p>
<b>Thanks to Our Technical Reviewers</b> Pete "Luke" Alexander, Jay Patel, David<br>
Williams*
</p>
</body>
</html>
