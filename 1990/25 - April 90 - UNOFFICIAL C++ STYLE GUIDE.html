<html>
<head>
<!-- Extracted from develop - 1990 -->
<!-- on 2023-09-06 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by copyright of their respective owners -->
<title>April 90 - UNOFFICIAL C++ STYLE GUIDE</title>
<link href="styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h2>UNOFFICIAL C++ STYLE GUIDE</h2>
<img src="img/153.gif" width="188 px"></img><br>
<h1>DAVID GOLDSMITH AND JACK PALEVICH</h1>
<p>
<i>C++ is fast emerging as the premier object-based language of the 1990s.&nbsp;&nbsp;Its<br>
expressive power combined with its down-and-dirty C heritage makes it a natural<br>
choice for writing Macintosh applications.&nbsp;&nbsp;But beware: all is not sweetness and light. <br>
Harnessing C++'s power without getting tripped up by some of its less savory features<br>
isn't all that easy.&nbsp;&nbsp;Here are guidelines that make it easier to write, debug, and change<br>
C++ programs.</i>
</p>
<p>
When we first started using C++ several years ago, we learned the hard way--by<br>
trial and error--a lot of what we're about to tell you.&nbsp;&nbsp;After thousands of hours of C++<br>
programming, we've formed strong opinions about the best way to use C++.&nbsp;&nbsp;In this<br>
unofficial style guide we tell you which features to use and which ones to avoid. <br>
Following our techniques will lead to programs that are easier to write, debug, and<br>
change.&nbsp;&nbsp;You may not agree with all of our guidelines--some are more a matter of taste<br>
than of science--but we hope you'll find them useful and enlightening.
</p>
<h2>PART 1: STYLE</h2>
<p>
In this part you'll find fairly simple advice on formatting source files.&nbsp;&nbsp;Even if you<br>
prefer to use a different style in your own work, you may be interested to see how we<br>
handle these standard matters of style.
</p>
<p>
<b>SOURCE FILE CONVENTIONS</b><br>
Use the following conventions to keep your source files easy to read, easy to use, and<br>
legally protected.
</p>
<p>
<b>Include a copyright notice.</b> To protect your intellectual property rights, include<br>
the following line at the front of every file you create:
</p>
<pre>// Copyright &#A9; 1990 ~~~Your name or company~~~.
// All rights reserved.</pre>
<p>
You can make the &#A9; by typing Option-g.&nbsp;&nbsp;The "All rights reserved" is specifically for<br>
our foreign friends. (We bet you thought all you had to say was "Copyright." Ha!) In<br>
addition, any binary files you ship should contain a copyright notice somewhere.
</p>
<p>
If you modify a file in more than one calendar year, you must list every year in which<br>
you modified it.&nbsp;&nbsp;For example,
</p>
<pre>// Copyright &#A9; 1988-1990 ~~~Your name or company~~~.
// All rights reserved.</pre>
<p>
<b>Add helpful comments.</b> We won't go into a lengthy discussion of comment style<br>
here. We'll only say it's good to have them. Also, comments that describe something<br>
subtle about the source are more helpful than comments like&nbsp;&nbsp;assign a to b.
</p>
<p>
<b>Be careful about omitting argument names in function prototypes. </b> It's OK<br>
to omit dummy argument names in function prototypes, but only if the meaning is<br>
clear without them. It's almost always necessary to include argument names when you<br>
have more than one argument of the same type, as it's impossible to figure out which<br>
one is which otherwise.
</p>
<pre>double cosine(double angle);        // Prototype with argument name.
double cosine(double);              // Reasonable omission of arg.
                                    // name.
TPoint::TPoint(short h, short v);   // Easy to understand.
TPoint::TPoint(short, short);       // Impossible to figure out.</pre>
<p>
If you are getting compiler warnings of the form "warning: foo not used" where&nbsp;&nbsp;foo is<br>
an argument to a function, leaving the argument name out of the function header for the<br>
function's implementation will stop the warning. Whether or not an argument name<br>
appears in the function's declaration has no bearing on the warning.
</p>
<pre>void f(short foo, long bar);                // Prototype.
void f(short /* foo */, long bar)           // Implementation.
    {
    bar = 7;
    }</pre>
<p>
<b>Put only related classes in one file.</b> To keep your class definitions under<br>
control and to make life easier for those trying to decipher them, follow the lead of the<br>
MPW {CIncludes} files. Limit each header file to a single class definition or a set of<br>
related class definitions. MPW C has always followed this convention, for example<br>
Windows.h, Controls.h versus Toolbox.h.
</p>
<p>
On the implementation side, put only one class implementation in a given source file<br>
(classes private to the implementation of the class may be declared and implemented in<br>
the same source file). Name the file after the class, but without the initial <i> T</i> --for<br>
example, put the class TMyView in MyView.c.
</p>
<p>
<b>Make it easy to use your header files.</b> Trying to figure out whether you've<br>
included all the necessary antecedents for a header file is a pain. To save your clients<br>
this pain, enclose the definitions in your header with code that looks like the following:
</p>
<pre>#ifndef __MYCLASS__
#define __MYCLASS__
#include "prerequisite1.h"
#include "prerequisite2.h"
... definitions for MyClass
#endif</pre>
<p>
Now you can include your header's prerequisites without caring whether they've<br>
already been included elsewhere (assuming that everyone follows this convention).<br>
The name of the preprocessor variable should be all upper case and consist of the file<br>
name (without .<i> h</i> ) surrounded by two underlines on either side.
</p>
<p>
To speed up compilation, you can even do this in your files that use foo.h:
</p>
<pre>#ifndef __FOO__
#include "foo.h"
#endif</pre>
<p>
which skips the overhead of reading and parsing foo.h.
</p>
<p>
<b>Store files in Projector.</b> As soon as a file is published for use by others (for<br>
example, you stick it on a file server so others can use it), you should start storing it<br>
in Projector. Projector is part of MPW 3.0. It consists of a collection of built-in<br>
MPW commands and windows that help programmers (both individuals and teams)<br>
control and account for changes to all the files (documentation, source, applications,<br>
and so forth) associated with a software project. This lets you recreate old versions if<br>
necessary, and makes sure things don't get lost.
</p>
<p>
Since the whole point of using Projector is to make it easier for those who follow you<br>
in the great chain of software being, please use the features that will make their lives<br>
easier. Try to maintain a proper set of versions (for example, don't remove your file<br>
from Projector and then add it again-- that loses all the revisions), and use the<br>
comment features when you check things in and out.
</p>
<p>
<b>NAMING CONVENTIONS</b><br>
To make C++ even more readable, you should adopt a consistent set of naming<br>
conventions. Here at Apple we use the following conventions:
</p>
<p>
<b>Type names</b><i> All </i> type names begin with a capital letter. In addition, class names begin<br>
with a <i> T </i> for base classes, and an <i> M </i> for mix-in classes. See "Multiple Inheritance" in<br>
Part 2. Examples:&nbsp;&nbsp;Boolean,TView, MAdjustable. Never use C types directly; see below.
</p>
<p>
<b>Member names</b> Member names should begin with an <i> f</i> , for "field." Member function<br>
names need only begin with a capital letter. Examples: fVisible, Draw.
</p>
<p>
<b>Global names</b> Names of global variables (<i>including </i> static members of classes) <br>
should begin with a <i> g.</i>&nbsp;&nbsp;Examples:gApplication, TGame::gPlayingField.
</p>
<p>
<b>Local and parameter names</b> Names of local variables and function arguments<br>
should begin with a word whose initial letter is lower case. Examples: i, thePort,<br>
aRegion.
</p>
<p>
<b>Constant names </b>Names of constants should begin with a <i> k.</i>&nbsp;&nbsp;Example:<br>
kSaveDialogResID.
</p>
<p>
<b>Abbreviations</b> It's best to avoid abbreviations, especially ad hoc ones. Inconsistent<br>
use of abbreviations makes it hard for clients to remember the correct name of a<br>
function or variable. Abbreviations are OK as long as they are consistent and<br>
universal. For example, don't use&nbsp;&nbsp;VisibleRegion some places and VisRgn others; use<br>
one or the other throughout.
</p>
<p>
<b>Multiple-word names</b> In any name that contains more than one word, the first<br>
word should follow the convention for the type of the name, and subsequent words<br>
should immediately follow, with the first letter of each word capitalized. Do not use<br>
underscores in names. Here are multiple-word examples of each type:
</p>
<p><table border="0"><tr><td><code>TSortedList</td><td></code>class name</td></tr>
<tr><td><code>fSubViews</td><td></code>data member of class</td></tr>
<tr><td><code>DrawContents</td><td></code>function member of class</td></tr>
<tr><td><code>gDeviceList</td><td></code>global or static data member</td></tr>
<tr><td><code>theCurrentSize</td><td></code>local or parameter</td></tr>
<tr><td><code>kMaxStringLength</td><td></code>constant</td></tr></table></p>
<p>
<b>Names with global scope</b>Any name with global scope (for example, class names,<br>
typedefs, constants, globals) should have a distinctive and unique name. This will help<br>
avoid name conflicts. Names like Short and Number are fairly nondescript and likely to<br>
wind up conflicting with identifiers from other header files accidentally (this is a big<br>
problem with MPW and the ROM interfaces today). Better in these cases would<br>
bekShortLived(to follow our advice on constant names) orStringLength(more<br>
descriptive of the function). When you name something with global scope, think about<br>
the fact that it's in a global name space and someone may have to figure out what it is<br>
without context. Use more specific names rather than more general ones. 
</p>
<p>
C++ relieves this problem somewhat by adding enumerations with class scope and<br>
static members. Enumerations declared inside classes are accessible using<br>
qualification, as in
</p>
<pre>class TFoo {
public:
    enum {kFred, kBarney};
...
};

i = TFoo::kFred;</pre>
<p>
This lets you put constants associated with different classes into different name spaces,<br>
somewhat like when C changed a few years back so that structure members from<br>
different structs were in different name spaces.
</p>
<p>
Static members let you put ordinary functions and global variables associated with a<br>
class into the scope of the class. For example:
</p>
<pre>class TView {
public:
    static void Initialize();
    static const TView kWhizzyView;
    static const long kMagicNumber;

...
};
TView::Initialize();
...TView::kWhizzyView...
i = TView::kMagicNumber;</pre>
<p>
Putting such global functions and variables into the scope of the class helps avoid name<br>
collisions. In fact, we frown on the use of ordinary globals: most global functions and<br>
variables should be static members of some class. The same with constants; they<br>
should be made members of an enumeration inside a class, if possible. Of course, global<br>
variables that are not constants of the sort shown above shouldn't be public at all;<br>
instead, access should be through static or normal member functions:
</p>
<pre>class TFoo {
public:
    static Boolean gWhoopeeFlag;// BAD!
}

TFoo::gWhoopeeFlag = TRUE; // BAD!</pre>
<p>
<b>THE PREPROCESSOR</b><br>
One of the most powerful features of the C and C++ languages is the C preprocessor.
</p>
<p>
Don't use it.
</p>
<p>
Except for include files and conditional compilation, C++ has features that supersede<br>
most of the techniques that used the preprocessor. Sometimes you need to use the<br>
preprocessor to accomplish things you can't with C++, but far less often than with<br>
straight C.
</p>
<p>
<b>Use const for constants.</b> Don't use #define for symbolic constants. Instead, C++<br>
defines the const storage class. As with #define symbols, these are evaluated at<br>
compile time. Unlike&nbsp;&nbsp;#define symbols, they follow the C scope rules and have types<br>
associated with them. You can also use enums. For example:
</p>
<pre>#define kGreen 1            // No no
const int kGreen = 1;               // Better
enum Color {kRed, kGreen, kBlue};   // Best</pre>
<p>
This prevents a host of problems. With #define symbols, for example, if you<br>
accidentally redefine a name, the compiler will silently change the meaning of your<br>
program. With const or enums, you'll get an error message. Even better, with enums<br>
you can put the identifiers in the scope of an enclosing class; see "Naming<br>
Conventions," earlier. As an extra bonus, each enumeration defined is treated as a<br>
separate type for purposes of type checking (much like the way scalars are handled in<br>
Pascal).
</p>
<p>
Unlike in ANSI C, objects in C++ that are declared const and initialized with<br>
compile-time expressions are themselves compile-time constants (but only if they<br>
are of integral type). Thus, they can be used as case labels and such.
</p>
<p>
<b>Use enum for a set of constants.</b> If your constants define a related set, don't&nbsp;&nbsp;use<br>
separate const definitions. Instead, make your constants an enumerated type.&nbsp;&nbsp;For<br>
example:
</p>
<pre>// Bleah.
const int kRed = 0;
const int kBlue = 1;
const in kGreen = 2;
// Allll Riiiight!
enum ColorComponent {kRed, kBlue, kGreen};</pre>
<p>
This causes ColorComponent to become a distinct type that is type-checked by the<br>
compiler. Values of type ColorComponent will be automatically converted to int as<br>
needed, but integers cannot be changed to ColorComponents without a cast. If you need<br>
to assign particular numerical values, you can do that too:
</p>
<pre>enum ColorComponent {kRed = 0x10, kGreenk = 0x20, kBlue = 0x40};</pre>
<p>
Where possible, the type declaration should occur within the scope of a class. Then,<br>
references to the constants outside of the class's member functions must be qualified:
</p>
<pre>class TColor {
public:
    ColorComponent enum {kRed, kGreen, kBlue};
...
}
foo = TColor::kRed;</pre>
<p>
Note that the enum type name is not local to the class; only the actual constants. The<br>
enum type name should not be qualified.
</p>
<p>
<b>Use inline for macro functions.</b> Function macros are another source of fun<br>
problems in C programs, like this classic example:
</p>
<pre>#define SQUARE(x) ((x)*(x))
SQUARE(y++);</pre>
<p>
C++ allows functions to be declared inline (see also "Inline Functions" in Part 2),<br>
which completely obviates the need for function macros. Like const, inline functions<br>
follow the C++ scope rules and allow argument type-checking. Both member functions<br>
and nonmember functions can be declared inline. So the preceding example becomes
</p>
<pre>inline int Square(int x)
{
    return x*x;
};
Square(y++);</pre>
<p>
which does the right thing, and is actually more efficient than the macro version (as<br>
well as being correct).
</p>
<p>
<b>Use the preprocessor only in these cases.</b> As stated earlier, the preprocessor<br>
is necessary for #include files, and preprocessor symbols are necessary for<br>
conditional compilation.
</p>
<p>
<b>USE OF CONST</b><br>
Both ANSI C and C++ add a new modifier to declarations,&nbsp;&nbsp;const. You use this modifier<br>
to declare that the specified object cannot be changed. The compiler can then optimize<br>
code, and also warn you if you do something that doesn't match the declaration. Here are<br>
some examples of const declarations:
</p>
<pre>const int *foo;</pre>
<p>
This is a modifiable pointer to constant integers.&nbsp;&nbsp;foo can be changed, but what it points<br>
to cannot be.
</p>
<pre>int *const foo;</pre>
<p>
This is a constant pointer to modifiable integers. The pointer cannot be changed (once<br>
initialized),but the integers it points to can be changed at will.
</p>
<pre>const int *const foo;</pre>
<p>
This is a constant pointer to a constant integer. Neither the pointer nor the integer it<br>
points to can be changed.
</p>
<p>
Note that const objects can be assigned to non-const objects (thereby making a copy),<br>
and the modifiable copy can of course be changed. However, <i> pointers </i> to const objects<br>
<i>cannot </i> be assigned to pointers to non-const objects, although the converse is allowed.<br>
Both of these assignments are legal:
</p>
<pre>(const int *) = (int *);
(int *) = (int *const);</pre>
<p>
Both of these assignments are illegal:
</p>
<pre>(int *) = (const int *);
(int *const) = (int *);</pre>
<p>
When const is used in an argument list, it means that the argument will not be<br>
modified. This is especially useful when you want to pass an argument by reference,<br>
but you don't want the argument to be modified. For example:
</p>
<pre>void BlockMove(const void* source, void* destination, size_t length);</pre>
<p>
Here we are explicitly stating that the source data will not be modified, but that the<br>
destination data will be modified. (Of course, if the length is 0, then the destination<br>
won't actually be modified.)
</p>
<p>
All of these rules apply to class objects as well; you can declare something ( const<br>
TView *). There used to be a hole in the language, however: you could call any member<br>
function of an object using a const pointer to it, and that member function could modify<br>
the object (since there was no way to declare which member functions modify the<br>
object). For example, this was legal:
</p>
<pre>const TView *aView;
...
aView-&gt;ModifySomething();</pre>
<p>
To plug this hole, member functions that will be called for const objects must now be<br>
declared const; see the 1985-1989 paper discussed in the sidebar "Background<br>
Reading" for details. The syntax looks like this:
</p>
<pre>class TFoo {
public:
    void Bar1() const;
    void Bar2();
};
...
const TFoo *fp;
fp-&gt;Bar1();      // legal
fp-&gt;Bar2();      // illegal (actually, just a warning for now)</pre>
<p>
Note that inside a const member function, the pointer has typeconst TFoo *, so you<br>
really can't change the object. You could cast the pointer to be just aTFoo *, but then<br>
you may be surprising your clients.&nbsp;&nbsp;&nbsp;Even though you think that your change to the<br>
object is not externally visible (that is, it doesn't change the state of the object as far<br>
as clients are concerned--one example is an internal cache), it can have an impact. If<br>
your object is being used by an interrupt routine that "reads" it, your client may<br>
assume that it's OK to call a const member function, since he or she thinks the object<br>
isn't going to change. However, if the internal state of the object changes anyway,<br>
access by multiple "readers" will cause its state to become corrupted. 
</p>
<p>
Another example is an object placed in ROM. The client thinks it's all right to call a<br>
const member function of the object, and then gets a bus error because the attempted<br>
write access fails.
</p>
<p>
The bottom line is that if you attempt to cast your&nbsp;&nbsp;this pointer to a non-const version<br>
inside a const member function, you had better think through the implications of this<br>
for your clients, and you had better document it.
</p>
<h2>PART 2: USING LANGUAGE FEATURES</h2>
<p>
In this part you'll find advice on using particular features of the C++ language. The<br>
topics are arranged roughly in order of increasing difficulty.
</p>
<p>
<b>GLOBAL VARIABLES (!)<br>
Static class members are the same as global variables (actually,</b><br>
<b>better). </b> Static class members do have one major advantage over regular globals:<br>
scope. Regular globals (that is,static externvariables) have global scope. That means<br>
there are potential name collisions with globals from any otherinclude file the<br>
developer may use. Static class members, however, have full scoping: they're qualified<br>
by the name of their class, and don't conflict with any identifier outside the class. They<br>
can also be protected. If you were going to have a simple global, consider a static<br>
member instead. 
</p>
<p>
<b>Be careful about static initialization.</b> If you design a class that depends on <br>
some other facility in its constructor, be careful about order dependencies in static<br>
initialization. The order in which static constructors (that is, the constructors of<br>
objects with static storage class) get called is <i>undefined. </i> You cannot count on one<br>
object being initialized before another. Therefore, if you have such a dependency, you<br>
must either document that your class cannot be used for static objects, or you must use<br>
"lazy evaluation" to defer the dependency until later.
</p>
<p>
<b>INLINE FUNCTIONS</b><br>
We mentioned inline functions under "The Preprocessor," earlier. Never use them.<br>
Well, hardly ever. The main reason is that they get compiled into your caller's code.<br>
This makes them a tad difficult to override. Also, you have to ship their source code to<br>
everyone. There are, however, a few times when it's OK to use them.
</p>
<p>
<b>Use an inline function if it expands to call to something else.</b> If your<br>
inline function just calls something else that isn't inline, that's fine, as long as the<br>
other function <i> has identical semantics</i> . An example: You might have a class that<br>
defines a virtual function&nbsp;&nbsp;IsEqual, which compares two objects for equality. It also has<br>
an inline definition for&nbsp;&nbsp;operator ==, as a notational convenience. Since&nbsp;&nbsp;operator==<br>
just turns around and calls the IsEqual function, it's OK for it to be inline and not<br>
virtual. This does <i> not</i>&nbsp;&nbsp;apply if your function just happens to have a one-line<br>
implementation.
</p>
<p>
<b>Use an inline function if efficiency is very, very important and you'll</b><br>
<b>never change it.</b> Of course, the othertime it's OK to use inline is if efficiency is<br>
extremely important. Note that code size may increase due to duplication of code. <i> You</i><br>
<i>may actually decrease system performance by making something inline</i>&nbsp;&nbsp;, since you're<br>
increasing the amount of code that must fit in memory. Also, once a function is more<br>
than a couple of lines long, the function call overhead is a very small fraction of the<br>
total time, and you are not buying much by making it inline.
</p>
<p>
An example is addition for a complex number type; here, the efficiency consideration<br>
together with the low probability of a future change makes an inline implementation a<br>
good idea. The complex number implementation shipped with C++ makes addition and<br>
subtraction inlines (fairly short), but makes multiplication and division regular<br>
functions (they are longer, so the overhead for a call is less important and the code<br>
size issue is more important). 
</p>
<p>
If you don't<i>know</i> (that is, God has told you in person) that your implementation must<br>
be inline,<i>don't make it inline</i> . Build it normally and then<i>measure</i> the performance.<br>
Experience has shown again and again that programmers spend lots of time optimizing<br>
code that hardly ever gets executed, while totally missing the real bottlenecks. The<br>
empirical approach is much more reliable. Experience has also shown that a better<br>
algorithm or smarter data structures will buy you a lot more performance than code<br>
tweaking. 
</p>
<p>
<b>Don't write inlines in declarations.</b> C++ has two ways of declaring an inline<br>
member function (of course). One is to declare the member function normally and then<br>
supply an inline function definition later in the same header file. The other is to write<br>
the function definition directly in the class declaration. Never use this latter form;<br>
always declare the function normally and then put an inline definition at the end of the<br>
file. That way, it's much easier to change between inline and regular implementations<br>
of a function, and it's no less efficient. The fact that something is inline should not be<br>
made obvious in the class declaration, since clients may start counting on it.
</p>
<pre>class TFoo {
public:
    int TweedleDee() { return 1; }; // Bad!
    int TweedleDum();               // Good!
};

inline int TFoo::TweedleDum()
{
    return 2;
};</pre>
<p>
<b>UNSPECIFIED AND DEFAULT ARGUMENTS</b><br>
It's possible to partially circumvent the strong type checking C++ imposes on function<br>
arguments. You should avoid doing this if at all possible.
</p>
<p>
<b>Don't use unspecified arguments.</b> C++, like ANSI C, allows you to cling to C's<br>
wild and woolly past, by declaring functions that take unspecified numbers and types of<br>
arguments, the classic example being
</p>
<p>
<code>void printf(char *, ...);</code>
</p>
<p>
This is a cheesy leftover from the Cretaceous era. There are very few functions indeed<br>
that need to have an interface like this. If you want to be able to omit arguments, for<br>
example, you can use defaultarguments or function overloading (both defined below).<br>
Unspecified arguments come from hell.
</p>
<p>
<b>Do use default arguments, but cautiously.</b> A better technique than unspecified<br>
arguments is default arguments. You can specify default values for arguments that are<br>
only used sometimes. This is especially handy in constructors. For example,
</p>
<pre>TView::TView(TVPoint itsSize, TVPoint itsLocation,
        TView *itsSuperView = NIL);</pre>
<p>
which can be called either with three arguments or with two. This can help you avoid<br>
that agonizing decision as to whether to include an option or not. However, be sparing;<br>
clearly, long strings of defaults can make it hard to figure out what's going on.<br>
Furthermore, you can only leave off arguments at the end, not the middle, so if you<br>
have ten defaults and someone wants to specify the last one, they must specify the<br>
preceding nine as well. This sort of defeats the idea. Having more than two default<br>
arguments is a bad idea, and even two is questionable.
</p>
<p>
Also remember that for both default arguments and function overloading, having too<br>
many versions of the same function decreases the safety provided by type checking, and<br>
makes it more likely that you will accidentally call a different version from the one<br>
you intended to call.
</p>
<p>
<b>FUNCTION NAME OVERLOADING</b><br>
C++ also lets you overload function names, by letting two functions (member or<br>
nonmember) have the same name as long as the types of their arguments differ. This<br>
feature is useful when you want to have different versions of the same function; they<br>
should all be related. For example, you may want to have a constructor that takes lots<br>
of options, as well as one that is simple to use. Also, you may want to make functions<br>
that take different types. Examples include:
</p>
<pre>Rectangle::Rectangle(Point leftTop, Point rightBottom)
Rectangle::Rectangle(short top, short left, short bottom,
    short right)
void TPort::MoveTo(short, short)
void TPort::MoveTo(Point)
TComplex TComplex::Add(TComplex)
TComplex TComplex::Add(int)</pre>
<p>
This can be very useful but also can cause problems.
</p>
<p>
<b>Don't unintentionally use the wrong argument type.</b> The biggest problem is<br>
the unintentional use of the wrong argument type when overloading, which defines a<br>
new function. If&nbsp;&nbsp;TView has a member function
</p>
<p>
<code>TView::Print(const TPrintRecord *)</code>
</p>
<p>
and you define a subclass where, intending to override this function, you declare
</p>
<p>
<code>TMyView::Print(const TStdPrintRecord *)</code>
</p>
<p>
or
</p>
<p>
<code>TMyView::Print(TPrintRecord *)</code>
</p>
<p>
or even
</p>
<p>
<code>TMyView::print(const TPrintRecord *)</code>
</p>
<p>
because you forgot the type of the original argument (or misspelled the name), C++<br>
assumes you don't want to overload the original function and simply declares it as a<br>
new function.&nbsp;&nbsp;You have <i> not</i> overridden the original; it's still available. The latest<br>
version of CFront will warn you about the first two cases, but not the last.
</p>
<p>
Also remember that, as mentioned earlier, the more variants a function has, the easier<br>
it is to call the wrong one unintentionally because the arguments you supply just<br>
happen to match another variant.
</p>
<p>
<b>Watch your overrides. </b>If you have an overloaded member function (whether<br>
virtual or not), and you override it in a derived class, then your override hides all<br>
overloaded variants of that member function, <i>not just the one you overrode</i>&nbsp;&nbsp;. Thus, if<br>
you want to override an overloaded member function, you must override <i>all </i> of the<br>
overloaded variants. C++ treats the overloaded function as a single entity; the scope<br>
resolution rule for C++ is to find the first class that has any function with that name<br>
defined, then look for a match based on argument type. The C++ team at AT&amp;T believes<br>
this is the correct rule; their reasoning is that an overloaded set of functions is really<br>
just one function with a bunch of variants, and that you should not be naming functions<br>
with the same name unless they are really the same function.
</p>
<p>
An example that illustrates this behavior follows:
</p>
<pre>class A {
public:
    void Foo(long);
    void Foo(double);
};

class B: public A {
public:
    void Foo(double);
};

B bar;
bar.Foo(2);</pre>
<p>
The call actually winds up calling <code>B::Foo(double)</code> after coercing the integer<br>
argument to double.
</p>
<p>
On a positive note, CFront will warn you if you override some but not all of a set of<br>
overloaded member functions. For details, see the 1985-1989 paper discussed in the<br>
"Background Reading" sidebar, and the reference manual.
</p>
<p>
<b>Don't abuse function overloading.</b> Function overloading can be abused. Functions<br>
should not have the same name unless they basically perform the same operation, as in<br>
the preceding examples. If that isthe case, then having the functions identically named<br>
can be a great help in reducing the number of things a programmer must remember.
</p>
<p>
<b>OPERATOR OVERLOADING</b><br>
Another fun C++ feature is the ability to define operators for your own classes. If you<br>
define a fixed- point data type, C++ lets you define the standard arithmetic operators<br>
for it, which makes code a lot easier to read.
</p>
<p>
<b>Use operator overloading only where appropriate and clear.</b> Operator<br>
overloading also has tremendous potential for abuse. Defining the + operator for<br>
fixed-point numbers helps clarify code. Defining it as set union is also fairly clear.<br>
Defining =&gt; to mean "send a message" is crazy. Operator redefinition only helps when<br>
the new function is similar to the standard meaning of the operator; otherwise, it just<br>
confuses people. An example is C++'s streams facility, which redefines&nbsp;&nbsp;&lt; and &gt; as<br>
output and input operators. This confuses a lot of people.
</p>
<p>
<b>If you like, use functional syntax to call a base class's operator.</b> C++<br>
occasionally delivers a pleasant surprise. One example is the syntax for calling<br>
overloaded operators. Of course, you can use the usual inline operator syntax; that's<br>
why C++ has operator overloading. The surprise is that you can also use functional<br>
syntax, which is sometimes essential, especially for calling a base class operator.<br>
Here is an example of a subclass operator using the base class's operator:
</p>
<pre>const TWindow&amp; TWindow::operator=(const TView &amp;v)
{
    this-&gt;TView::operator=(v);
    return *this;
}</pre>
<p>
(The explicit this-&gt; is actually unnecessary here but was included for clarity.) In this<br>
example,TWindow has a base class&nbsp;&nbsp;TView, and we want to be able to assign a&nbsp;&nbsp;TView to<br>
a TWindow by just copying the TView part and leaving the rest of&nbsp;&nbsp;TWindow alone. To do<br>
this, we want to use&nbsp;&nbsp;TView's assignment operator. The functional notation here is the<br>
only way to do it. The pleasant surprise was that this notation is allowed.
</p>
<p>
<b>TYPE COERCION</b><br>
<b>Use type coercion selectively.</b> Like so many C++ features, type coercion can<br>
either clarify or obfuscate your code. If a type coercion seems "natural," like the<br>
coercion between reals and integers, then providing a coercion function seems like a<br>
good idea. If the coercion is unusual or nonsensical, then the existence of a coercion<br>
function can make it very hard to figure out what's going on. In the latter case, you<br>
should define a conversion function that must be called explicitly.
</p>
<p>
In general, coercion operators are useful in a way similar to operator overloading, and<br>
the same guidelines make sense.
</p>
<p>
<b>Define type coercion rules for C++ to use.</b> C++ will automatically coerce one<br>
type to another, but only if there is a direct way of doing so. In other words, if a<br>
coercion is defined from type A to type B, C++ will use it automatically where<br>
appropriate. It will <i> not </i> concatenate coercion operators if there is not a direct<br>
coercion. So even though a coercion may be defined from type A to type B, and type B to<br>
type C, C++ will not automatically coercion type A to type C (you can do it explicitly<br>
via casts, though).
</p>
<p>
There are two ways of defining type coercions for C++ to use: constructors and type<br>
coercion operators. They are appropriate under different circumstances. Note that<br>
since all coercion operators must be member functions of some class, it is not possible<br>
to define a coercion from one nonclass type to another nonclass type. Also note that if<br>
more than one function is defined to perform the same coercion, they cannot be used<br>
implicitly or via a cast, since an ambiguity exists asto which to call. They can still be<br>
invoked explicitly.
</p>
<p>
If you have a constructor with a prototype that looks like any of the following:
</p>
<pre>TargetClass::TargetClass(SourceType)
TargetClass::TargetClass(SourceType &amp;)
TargetClass::TargetClass(const SourceType &amp;)</pre>
<p>
then C++ will use it to convert from&nbsp;&nbsp;SourceType to TargetClass where appropriate.<br>
This form is useful when (1) the target type is a class (it can't be used for a primitive<br>
target type), and (2) the author of the target type wants to provide a coercion. If<br>
either of these conditions don't hold, you can use the second form of type coercion.
</p>
<p>
If the source type is a class, you can define a member operator function to perform the<br>
coercion. These operators have prototypes that look like
</p>
<pre>SourceClass::operator TargetType()</pre>
<p>
TargetType may be either a primitive type or a class. It need not be the name of a type;<br>
it can be any type specifier (as long as it does not containarray of []or function ()<br>
forms. Those must be handled via a typedef). This form is appropriate when the target<br>
type is not a class, or the source code for the target type is not available (that is, the<br>
coercion is being provided by someone else). 
</p>
<p>
<b>ENCAPSULATION AND DATA-HIDING</b><br>
<b>Make explicit use of public, private, protected. </b> C++ thoughtfully allows<br>
you to leave out the private keyword in several places. Don't: it decreases C++'s<br>
well-known clarity. Class definitions should always explicitly state the visibility of<br>
their members and/or base classes. Write it like this:
</p>
<pre>class TFoo: public TBar, private MBaz {
public:
    public members;

protected:
    protected members;

private:
    private members;
};</pre>
<p>
Your public interface should come before your protected interface, and since your<br>
private interface is only necessary to make the compiler happy, it should be last.
</p>
<p>
<b>Use no public or protected members that aren't functions.</b> Always make <i>all</i><br>
member variables private. (It's OK to make functions protected or public. In fact,<br>
classes that don't are very boring.) You can provide access functions to get and set your<br>
variables if you want (although you should think about exporting a more abstract<br>
interface instead). If you're really concerned with performance, you can make those<br>
functions inline (but see "Inline Functions," earlier). Remember, don't compromise<br>
for the sake of performance <i> until you have numbers </i> to base your decision on!
</p>
<p>
<b>Understand what "protected" really means.</b> What the "protected" access mode<br>
means is not completely clear from Bjarne's various books and papers, so we will<br>
attempt to clarify the issue.
</p>
<p>
When a member of a class is declared protected, to clients of the class it is as if the<br>
member were private. Subclasses, however, can access the member as if it were<br>
declared private to them. This means that a subclass can access the member, but only<br>
as one of its own private fields. Specifically, it<i>cannot </i> access a protected field of its<br>
parent class via a pointer to the parent class, only via a pointer to itself (or a<br>
descendant). Here are some examples:
</p>
<pre>class A {
protected:
    void Bar();
};

class B: public A {
    void Foo();
};

class C: public B {
...
};

void B::Foo()
{
    A *pa;
    B *pb;
    C *pc;

    pa-&gt;Bar();       // Illegal: A::Bar() is "private"
    Bar();              // OK: "this" is of type B*
    pb-&gt;Bar();       // Also OK
    pc-&gt;Bar();       // Also OK
};</pre>
<p>
<b>Protect constructors for abstract base classes.</b> It's frequently useful to have<br>
a class that is not meant to be instantiated as an actual object, but only to be used as a<br>
base class for other classes. Examples include classes such as TApplication or&nbsp;&nbsp;TView.<br>
Such classes are called <i>abstract base classes. </i>&nbsp;&nbsp;If you want to enforce this status, you<br>
can make it impossible to instantiate such a class by making all of its constructors<br>
protected. In that case, the object cannot be created by itself, but only as part of a<br>
derived class.
</p>
<p>
In addition, there is a way to declare a member function abstract (that is, to require<br>
that it be overridden in descendants); this is called a <i> pure virtual function</i> . A class<br>
with such a member function cannot be instantiated, nor can any descendant class,<br>
unless all such functions are overridden. The syntax for this is as follows:
</p>
<pre>class Foo {
public:
    virtual void Bar() = 0;
};</pre>
<p>
You can also declare some (but not all) of the constructors for a class protected if you<br>
want those constructors to be used only by derived classes. The class can still be<br>
instantiated using the constructors that are public.
</p>
<p>
<b>As a shortcut, declare private base classes. </b> When you declare a base class<br>
private in C++, the derived class inherits all of its members as private members.<br>
This means that the derived class is <i> not</i> considered a subtype of the base class, even<br>
though it is a subclass. You cannot pass a pointer to an object of the derived class when<br>
a pointer to the base is expected. This lets you inherit the behavior of a class without<br>
inheriting its type signature.
</p>
<p>
Since the derived class is not a subtype, it doesn't have an "is-a" relationship with the<br>
base class. Why not just make it a member, then? This is what you would normally do.<br>
However, if you need toreexport most of the functionality of the base class, you would<br>
have to write wrapper functions in your derived class that turned around and called<br>
the member class functions. Instead, you can use this slimy shortcut.By making the<br>
class a private base class, you don't inherit the type signature, but you do inherit the<br>
functionality, which can be made selectively visible without having to write wrapper<br>
functions. If A is a private base class of B, and B wants to make&nbsp;&nbsp;A::Foo() visible, then<br>
write the following in the declaration of B:
</p>
<pre>...
public:
    void A::Foo();</pre>
<p>
which makes Foo() visible to clients of B.
</p>
<p>
<b>Use friends sparingly. </b>Friend classes and functions are another C++ feature.<br>
Needless to say, they are a breach in the safety of types and in the integrity of the data<br>
abstraction provided by classes. If you have friends, you're probably doing something<br>
wrong (like taking frequent showers).
</p>
<p>
About the only time this feature should be used is when implementing binary operators<br>
that can't be member functions. Another circumstance is a set of tightly related classes<br>
(an example from Bjarne's book is matrices and vectors). Generally, however, avoid<br>
friend classes and functions.
</p>
<p>
<b>Hide implementation classes by declaring them incomplete. </b> Sometimes a<br>
public class (one that you export to clients) must refer to a class that is only used in<br>
your implementation. How do you avoid exposing the implementation class? If the only<br>
reference is a pointer, then you can declare the implementation class as an incomplete<br>
class:
</p>
<pre>class TImplementation;

class TInterface {
...
private:
    TImplementation *fHidden;
};</pre>
<p>
This also works if your member functions have arguments of typeTImplementation *or<br>
TImplementation &amp;. If you have actualTImplementationobjects as fields, though, you<br>
must include the full declaration of TImplementation.&nbsp;&nbsp;<b>Don't expose yourself. </b>The<br>
most important thing to remember is not to expose your implementation to either your<br>
clients or your subclasses (which are really just another kind of client). If you do so,<br>
you are tying the hands of those who must enhance your code.
</p>
<p>
It is very important to make sure that your class acts like a black box. The interface<br>
you export to clients and subclasses should reflect precisely what they need to know<br>
and nothing more. You should ask yourself, for every member function you export<br>
(remember, you're not exporting any data members, right?), "Does my client (or<br>
subclass) really need to know this, or could I recast the interface to reveal less?"
</p>
<p>
If you find that the interface to your class consists mostly of functions to get and set<br>
your private data members, you should ask yourself whether your object is really<br>
defining an abstract enough interface. The key is to think about the abstraction that<br>
your object represents and how clients view and use that abstraction, not how it is<br>
implemented. This is possibly <i> the </i> hardest thing to do in object-based design, but is<br>
also one of the biggest advantages and has the biggest long-term payoff.
</p>
<p>
<b>See Alan Snyder's paper.</b> For an excellent discussion of the issues involved in&nbsp;&nbsp;data<br>
abstraction, encapsulation, and typing, see Alan Snyder's paper "Encapsulation and<br>
Inheritance in object-based Programming Languages" in the 1986 OOPSLA<br>
proceedings.
</p>
<h2>VIRTUAL FUNCTIONS</h2>
<p>
<b>(Almost) all member functions should be virtual. </b> Virtual functions are<br>
pretty inexpensive. Because of this, any class that is intended to be used in a<br>
polymorphic fashion (that is, a pointer to a subclass may be passed where a pointer to<br>
the class is expected) should have all of its functions virtual. It's hard to guess in<br>
advance which functions may be overridden in the future (although private functions<br>
can't be, and so need not be virtual).
</p>
<p>
You should only use nonvirtual functions where you are very sure that the class (or<br>
this particular aspect of it) will <i>never have a subclass</i>&nbsp;&nbsp;. An example is a fixed-point<br>
data type, which is self-contained, or a graphics point, or other similar classes.
</p>
<p>
The assignment operator is also a special case. Assignment isn't inherited like other<br>
operators. If you do not define an assignment operator, one is automatically defined for<br>
you; it consists of calls to the assignment operators of all of your base classes and<br>
members (this is discussed in the 1985-1989 paper mentioned in the sidebar<br>
"Background Reading"). It's OK to make your assignment operator virtual, but it's only<br>
useful under rather specialized circumstances. A virtual function call will be<br>
generated for a virtual assignment operator only when the left-hand side of an<br>
assignment is a reference or a dereferenced pointer.
</p>
<p>
<b>(Almost) all destructors should be virtual. </b>What the !@&#%! is a virtual<br>
destructor, you ask? And well you might, because this is actually something you should<br>
never have had to worry about. What do you think happens here?
</p>
<pre>class A {
    ~A();
};

class B: A {
    ~B();
};

A *foo = new B;
delete foo;</pre>
<p>
B::~B gets called, then A::~A, right? Wrong! Only&nbsp;&nbsp;A::~A gets called! Isn't that special?<br>
For the right thing to happen, you must declare your destructors virtual. For example,
</p>
<pre>virtual ~A();
virtual ~B();</pre>
<p>
If you do this, the right destructors will get called. Needless to say, <i> any</i>&nbsp;&nbsp;class that has<br>
a virtual member function, inherits one, or is used in a polymorphic fashion <i> must </i><br>
have its destructor declared virtual, or horrible things will happen.
</p>
<p>
<b>Be careful when you call virtual functions in constructors and</b><br>
<b>destructors.</b> If you call a virtual function from a constructor, be aware that the<br>
version of the function that corresponds to the constructor will be called, <i>not </i> the<br>
version that would normally be called. For example, if A has a method&nbsp;&nbsp;foo, B is a<br>
subclass of A, and B overrides&nbsp;&nbsp;foo, a call to&nbsp;&nbsp;foo from A's constructor calls&nbsp;&nbsp;A::foo, not<br>
B::foo. A call to foo from B's constructor does call&nbsp;&nbsp;B::foo. This is sufficiently confusing<br>
that it is best not to call a virtual function from a constructor at all. Naturally, this<br>
only applies to virtual functions of the object whose constructor is running; virtual<br>
functions of other objects (including those of the same class) are perfectly fine<br>
(unless they in turn call one of your virtual functions).
</p>
<p>
If you think about it, it doesn't make sense to call virtual functions from constructors<br>
and destructors. Since base class constructors are called before derived class<br>
constructors, and base class destructors are called after derived class destructors, the<br>
object is in a partially valid state. If a virtual function overridden in a derived class is<br>
called from the base class constructor, it may access derived class features that have<br>
not been initialized. Similarly, if it is called from the destructor, it may access<br>
features that have already been destroyed.
</p>
<p>
<b>Use virtual functions the right way. </b>If you are coming from the<br>
non-object-based programming world, a word about use of virtual functions might be<br>
in order. Virtual functions should be used whenever you want to have more than one<br>
implementation of the same abstract class. They allow the system to defer the decision<br>
on which function to execute until run time. 
</p>
<p>
The right way to use virtual functions is to structure them around well-defined<br>
abstractions. If someone is to override a virtual function, they must have a clear<br>
definition of what the function does, even if they only call the inherited version after a<br>
little bit of processing.
</p>
<p>
The <i>wrong </i> way to use virtual functions is via a "come-from" mechanism like some<br>
Macintosh trap patches. Don't override a virtual function because "I know it's called<br>
from over here with these parameters." Needless to say, this wreaks havoc with the<br>
data abstractions that are one of the major benefits of object-based programming. This<br>
is why the function must have a definition that is clear in terms of the object it<br>
belongs to, without any reference to its possible callers. If you override a function, the<br>
override must make sense in terms of the definition of the function itself.
</p>
<p>
<b>MULTIPLE INHERITANCE</b>Multiple inheritance is a fairly new feature in<br>
object-based languages. To understand it better, look at Figure 1. In the single<br>
inheritance class hierarchy on the left, each class has only one parent. By contrast, in<br>
the multiple inheritance class hierarchy on the right, a class can have more than one<br>
parent. Note, for instance, that&nbsp;&nbsp;TAirplane inherits from both MFlyingObject and<br>
MVehicle.
</p>
<p>
<img src="img/154.gif" width="519 px"></img>
</p>
<p>
<b>&nbsp;Figure 1. Single Inheritance vs. Multiple Inheritance</b>
</p>
<p>
<b>Use in a controlled fashion. </b>With multiple inheritance, there is great potential<br>
for designing a confusing class hierarchy that resembles a spaghetti bowl. Here are<br>
some guidelines for use of multiple inheritance.
</p>
<p>
We start by artificially partitioning classes into two categories: base classes and <br>
mix-in classes. To distinguish the two, base class names begin with <i> T</i>&nbsp;&nbsp;(for example,<br>
TView), and mix- in class names begin with <i>M</i>&nbsp;&nbsp;(for example, MEditable). Base classes<br>
represent fundamental functional objects (like a car); mix-ins represent optional<br>
functionality (like power steering).
</p>
<p>
The first guideline is: A class can inherit from <i> zero or one </i> base classes, plus <i>zero or</i><br>
<i>more </i> mix-in classes. If a class does not inherit from a base class, it probably should <br>
be a mix-in class (though not always, especially if it is at the root of a hierarchy).
</p>
<p>
The second guideline is: A class that inherits from a base class is itself a base class; it<br>
cannot be a mix-in class. Mix-in classes can only inherit from other mix-in classes.
</p>
<p>
The net effect of these two rules is that the base classes form a conventional, <br>
tree-structured inheritance hierarchy rather than an arbitrary acyclic graph. This<br>
makes the base class hierarchy much easier to understand. Mix-ins then become <br>
add-in "options" that do not fundamentally alter the inheritance hierarchy. Like all<br>
guidelines, this one is not meant to be hard and fast. Multiple inheritance can and<br>
should be used in other ways as well if it makes sense. The fundamental thing to keep in<br>
mind is that people (including programmers) are better at understanding regular<br>
structures than arbitrary acyclic graphs.
</p>
<p>
As part of multiple inheritance, C++ contains a new feature called virtual base<br>
classes. The trouble is, if both B and C are subclasses of A, and D has both B and C as<br>
base classes, then D will have two A's if A is not virtual, but only one A if it is. This is<br>
a very confusing situation, and no matter which alternative you choose, programmers<br>
will have a hard time understanding it. To avoid getting into a situation like this,<br>
follow the preceding guidelines for use of multiple inheritance. And incidentally, using<br>
virtual bases presents another problem: once you have a pointer to a virtual base,<br>
there's no way to convert it back into a pointer to its enclosing class. 
</p>
<p>
<b>It's OK to have multiple occurrences of a base.</b> Sometimes the same base class<br>
(it should be a mix-in) will occur more than once as an ancestor of a class. It doesn't<br>
hurt to have a base class twice (aside from wasting space because of multiple pointers<br>
to the virtual function table) and if you need to cast back from the base class pointer to<br>
something else you may not have a choice, but it's really only useful to have a base<br>
class twice if data members are associated with it.
</p>
<h2>PART 3: DESIGN ISSUES</h2>
<p>
In this part you'll find a discussion of general problems of programming in C++.
</p>
<p>
<b>WORKING IN A VALUE-BASED LANGUAGE</b><br>
C++ has a different object model from Object Pascal or Smalltalk. The most<br>
fundamental difference is that whereas Object Pascal and Smalltalk are reference<br>
based (that is, like Lisp, assignment means copying a pointer), C++ is value based. By<br>
this we mean that classes in C++ are treated just like primitive types, whereas in<br>
Object Pascal objects are treated very differently from primitive types.&nbsp;&nbsp;&nbsp;This is<br>
actually a benefit, since all types in a C++ program are handled in the same style, as<br>
opposed to the multiple styles in Object Pascal. (Smalltalk, like C++, is also<br>
self-consistent.) There are some implications for your C++ programming style,<br>
however. 
</p>
<p>
<b>Don't use pointers unless you mean it.</b> Pointers should be used in C++ in the<br>
same way you would use them in plain C or plain Pascal; that is, when you really want<br>
multiple references to the same object, or a dynamic data structure. If you really just<br>
want to pass something by reference to avoid copying, then you can use a reference<br>
rather than a pointer (see below). In fact, you can even pass a class by value if the<br>
copying overhead isn't too high and you don't care about polymorphism (for example,<br>
the class has no virtual functions).
</p>
<p>
<b>Don't allocate storage unless you must.</b> In a reference-based language like<br>
Object Pascal or Smalltalk, all objects must be heap allocated. In C++, it's better to<br>
treat values the same way you would in C. For example, instead of defining a&nbsp;&nbsp;Clone<br>
operator, overload the assignment operator; instead of allocating and returning an<br>
object, have the caller pass one in by reference and set it. This allows your classes to<br>
be treated just like primitive types, and in the same style. In general, leave storage<br>
allocation up to the class client.
</p>
<p>
By doing so, you can make use of one of C++'s unique features: the ability to have<br>
automatic and static objects, and objects as members of classes. No matter how clever<br>
or efficient a storage allocator we have, it can never be as fast as allocating an object<br>
on the stack, or as part of another object. If an object can be local to a function, there<br>
is no storage allocation overhead. Many objects have very localized scope and do not<br>
need to be allocated on the heap.
</p>
<p>
There is one exception to the rule about allocating an object and returning a pointer:<br>
you must do this when the type of the returned object may vary. Anytime a function<br>
must choose what type of object to return, the function must allocate the object, not<br>
the caller.
</p>
<p>
It's still all right for the caller to allocate storage even when the type of object being<br>
passed in may vary, since references, like pointers, can be used polymorphically<br>
(that is, you can specify a&nbsp;&nbsp;TSubFoo&amp;to an argument of type TFoo&amp;). The key question<br>
is whether the caller or the function must determine the type. In the former case,<br>
leave allocation to the client; in the latter, the function mustallocate the object on the<br>
heap and return it.
</p>
<p>
<b>Summary: pretend everything is a primitive.</b> In summary, you should design<br>
your classes so that using them is just like using a primitive type in C. This will let<br>
the client use them in a style that is "natural" for C. In cases where you wish to avoid<br>
copying, pass arguments by reference. Use pointers only when you want a truly<br>
dynamic data structure, or when polymorphism demands it (note that references allow<br>
for polymorphism also, since they are really just a different kind of pointer).
</p>
<p>
<b>POINTERS VERSUS REFERENCES</b><br>
C++ provides two very similar mechanisms for passing references to entities. One is<br>
the familiar pointer from classic C; the other is a new concept, the reference. Pointers<br>
are declared as follows:
</p>
<p>
<code>TFoo *fooPtr;</code>
</p>
<p>
But references are declared like this:
</p>
<p>
<code>TFoo &amp;fooRef;</code>
</p>
<p>
A pointer must be dereferenced to access what it points to, but a reference can be used<br>
as is, and acts as a synonym for the object it refers to, both for fetching and storing.<br>
This makes it similar to other highly refined mechanisms, such as FORTRAN's <br>
equivalence statement (or&nbsp;&nbsp;VAR parameters in Pascal). The entity to which a reference<br>
refers may only be set when the reference is created; in this respect it is somewhat<br>
like a const pointer that gets a&nbsp;&nbsp;virtual * put in front of it wherever it is used, and<br>
puts a virtual &amp; in front of the expression from which it is initialized. Here are two<br>
illustrative examples:
</p>
<pre>void Bump(int *ip)
{
    *ip += 1;
}
Bump(&amp;j);

void BumpR(int &amp;i)
{
    i += 1;
}
BumpR(j);</pre>
<p>
There are certain circumstances where references are mandatory--for example,<br>
overloading the assignment operator. In other cases, either a pointer or a reference<br>
can be used. The question is, which should be used when?
</p>
<p>
References should be used when a parameter is to be passed "by reference," as in<br>
Pascal. This means that the called function is going to forget about the argument as soon<br>
as it returns. A regularreference should be used if you are going to modify the<br>
argument ( TFoo &amp;), and a const reference should be used if you are not going to modify<br>
it but don't want the overhead of call by value ( const TFoo &amp;).
</p>
<p>
Pointers should be used when the function you are calling is going to retain a reference<br>
(an alias) to the object you are passing in, such as when you are constructing a<br>
dynamic data structure. An example is putting an object into a MacApp&nbsp;&nbsp;TList: the TList<br>
retains a pointer to your copy of the object. The explicit use of pointers lets the reader<br>
know that aliasing is occurring.
</p>
<p>
By using pointers and references appropriately, you can increase the readability of<br>
your code by giving the reader hints as to what is going on.
</p>
<p>
<b>PORTABILITY</b><br>
<b>Don't make assumptions.</b> The Macintosh is the best personal computer in the<br>
world, but there are times when you'll want to run your code on a different machine.<br>
For example, you might have access to a CRAY or a VAX. Don't make assumptions that<br>
are only valid for the 680x0 family of processors. For example:
</p>
<ul>
<li> Don't assume that int and  long are the same size.</li>
<li> Don't assume that longs, floats, doubles, or long doubles can be at any<br>
even address.</li>
<li> Don't assume you know the memory layout of a data type.</li>
<li> Especially don't assume you know how structs or classes are laid out in<br>
memory, or that they can be written to a data file as is.</li>
<li> Don't assume pointers and integers are interchangeable. Use  void * if<br>
you want an untyped pointer, not&nbsp;&nbsp;char *.</li>
<li> Don't assume you know how the calling conventions are implemented, or<br>
indeed any detail of the language implementation or run time.</li>
</ul>
<p>
ANSI specifies the following about C's built in types. <i> This is all you can safely assume:</i>
</p>
<ul>
<li> unsigned chars can hold at least 0 to 255. They may hold more.</li>
<li> signed chars can hold -127 to +127. They may hold more.</li>
<li> chars may be either unsigned chars or signed chars. You can't assume<br>
either. Therefore, don't use char unless you don't care about sign extension.</li>
<li> shorts can hold at least  -32,767 to 32,767 (signed) or 0 to 65,535<br>
(unsigned).</li>
<li> longs can hold at least -2,147,483,647 to 2,147,483,647 (signed) or<br>
0 to 4,294,967,295 (unsigned).</li>
<li> ints can hold at least  -32,767 to 32,767 (signed) or 0 to 65,535<br>
(unsigned). In other words, ints<i> cannot be counted on to hold any more than a </i> <br>
short. int is an appropriate type to use if a&nbsp;&nbsp;short would be big enough but you<br>
would like to use the processor's "natural" word size to improve efficiency<br>
(on some machines, a 32-bit operation is more efficient than a 16-bit<br>
operation because there is no need to do masking). <i>If you need something</i><br>
<i>larger than a </i>&nbsp;&nbsp;short<i> can hold, you must specify </i>&nbsp;&nbsp;long.</li>
</ul>
<p>
If you need exact information, you can use the symbols defined in limits.h. or float.h.<br>
Remember, though, that the values of these symbols can change from processor to<br>
processor or compiler to compiler, within the limits just defined (for more<br>
information, see the ANSI C specification). 
</p>
<p>
It's very easy to write nonportable code, and it takes some vigilance to avoid it. It's<br>
well worth the effort, however, the first time you port to a different processor, or try<br>
to use a different compiler.
</p>
<p>
<b>Pick a canonical format for messages and data files. </b> Remember that<br>
AppleTalk networks connect to non- Apple computers such as the Intel-8x86 based<br>
MS-DOS machines. Thus, if you write or read any data in a context where it might go to<br>
or come from a different CPU, you have to worry about formats.&nbsp;&nbsp;&nbsp;Such situations<br>
include reading or writing disk files, or sending data over a network (or even over<br>
NuBus). The other CPU might even have a different byte order! The only solution to<br>
this problem is to pick a canonical format for your messages or data files. 
</p>
<p>
Just because you have a canonical format doesn't mean you must pay a big overhead<br>
every time you access your data. An alternative is to perform the translation to or<br>
from canonical format at a predetermined time. For example, outline fonts might have<br>
a certain canonical format, which may not be convenient for a particular processor to<br>
deal with. However, they can certainly be converted to a convenient local format when<br>
the font is installed.
</p>
<p>
<b>Don't use (gasp!) naked C types.</b> Another way to make your life miserable is to<br>
use primitive C data types in your declarations. This is a bad idea, since if the<br>
implementation ever changes you have to do a lot of editing by hand. It's much better to<br>
declare a type (via class definition or typedef) that represents the abstract concept<br>
you want to represent, then phrase your declarations that way. This lets you change<br>
your implementation by simply editing the original type definition. Think of these<br>
types as giving your data physical units, like kilograms or meters/second. This<br>
prevents you from accidentally assigning a length to a variable with type&nbsp;&nbsp;Kilogram,<br>
catching more errors at compile time.
</p>
<p>
So instead of
</p>
<pre>long time;
short mouseX;
char *menuName;</pre>
<p>
use (for example)
</p>
<pre>typedef long TimeStamp;
typedef short Coordinate;
class TString { &#8230; };
.
.
.
TimeStamp time;
Coordinate mouseX;
TString menuName;</pre>
<p>
It's OK to use a raw C type under certain circumstances, such as when the quantity is<br>
machine dependent, or when it can be characterized as (for example) a small integer.<br>
Otherwise, though, it's best to give yourself flexibility down the road.
</p>
<p>
Two ANSI C header files, StdDef.h and Limits.h, contain useful definitions. Here are two<br>
of the more useful ones:
</p>
<p>
<code>size_t</code>
</p>
<p>
The type returned by the built-in Csizeoffunction. This is useful for representing the<br>
sizes of things. 
</p>
<p>
<code>ptrdiff_t</code>
</p>
<p>
A type that can represent the difference between any two pointers.
</p>
<p>
The astute reader has noticed that these names do not conform to our guidelines. In the<br>
interest ofclarity, however, we deem it better to use the names as defined by the ANSI<br>
C committee.
</p>
<p>
Another item worthy of note: if a data type is unsigned, declare it unsigned; this helps<br>
avoid nasty bugs down the road.
</p>
<p>
<b>ERROR REPORTING</b><br>
Returned error codes are (ironically) a very error-prone technique. MacApp's<br>
standard is to use exceptions: a structured technique for reporting exceptions back to a<br>
function's callers.
</p>
<p>
Unfortunately, the exception scheme does not handle an important case: an exception<br>
that occurs in a constructor. Handling this properly requires compiler support, since<br>
any base class and/or member constructors that have already been called must have<br>
their corresponding destructors called; only the compiler can know this. Until we get<br>
an official C++ exception scheme, you must handle this problem on a case-by-case<br>
basis.
</p>
<p>
Signaling an exception in a destructor is not a good idea, since any destructive behavior<br>
that has already taken place probably cannot be reversed. Don't do it.
</p>
<p>
<b>BACKGROUND READING Bring yourself up to date.</b> You've just finished reading<br>
Bjarne Stroustrup's book<i> The C++ Programming Language</i>&nbsp;&nbsp;(Prentice-Hall, 1987)<br>
and you're feeling pretty smug. You've finally got C++ nailed.
</p>
<p>
Wrong.
</p>
<p>
You still have one more reference to read: the paper "The Evolution of C++: 1985 to<br>
1989." This paper is included with the AT&amp;T C++ <i>Selected Readings</i>&nbsp;&nbsp;manual, which is<br>
available in conjunction with MPW C++.
</p>
<p>
At least one statement made in earlier versions of the paper (which were titled "The<br>
Evolution of C++: 1985 to 1987") is wrong. The order of execution of base class and<br>
member constructors and destructors is determined by their declaration order, not by<br>
the order in which calls are made to such constructors in your constructor's header.<br>
This is a change to the language that was made after the 1985-1987 paper was<br>
written; see the 1985-1989 version for a full discussion.
</p>
<p>
Other books that give a good discussion of features that are new in C++ 2.0 are <i> The</i><br>
<i>C++ Primer</i>&nbsp;&nbsp;by Lippman (Addison-Wesley, 1989) and <i>The C++ Answer Book</i>&nbsp;&nbsp;by<br>
Hansen (Addison-Wesley, 1990). The latter book not only discusses 2.0 but also gives<br>
solutions to all of the problems in Stroustrup's book.
</p>
<p>
Finally, look for Bjarne's own updated manual, <i> The Annotated C++ Reference Manual</i> <br>
(with Ellis, Addison- Wesley) to be published later this year.
</p>
<p>
<b>Read up on ANSI C</b>. If you were whelped on good ole Kernighan and Ritchie C, you<br>
may have a few surprises in store for you. There have been several changes to the<br>
language as part of the ANSI standardization process. If you learned C a while back, it<br>
might be a good idea to brush up on ANSI C. We highly recommend the second edition of<br>
Kernighan and Ritchie (<i> The C Programming Language</i>&nbsp;&nbsp;, Prentice-Hall, 1989), which<br>
has appendixes that detail the differences between the original language and the ANSI<br>
version. Another good book is C: <i> A Reference Manua</i> l, 2nd ed., by Harbison and Steele<br>
(Prentice- Hall, 1987). For purists, the ANSI C draft and rationale are available<br>
from ANSI itself (<i> Draft Proposed American National Standard for Information</i><br>
<i>Systems--Programming Language C</i> , 1988, ANSI Doc No X3J11/88-159).
</p>
<p>
<b>Study object-based design</b>. Doing a good job of object-based software design<br>
requires more than just learning an object-based language. The whole point of<br>
object-based languages is to permit a different approach to software design. This<br>
approach takes time and energy to learn. Without spending that time and energy, it's<br>
not possible to gain the full benefits of the approach.
</p>
<p>
That's why you should read<i>Abstraction and Specification in Program Development</i> by<br>
Liskov (McGraw-Hill, 1987) and<i> Object-Oriented Software Construction</i> by Meyer<br>
(Prentice-Hall, 1988). The first book does not discuss object-based design per se,<br>
but it does cover the topic of data abstraction, an important component of object-based<br>
design, very well. The second book is a little pedantic in places, but has many, many<br>
good suggestions and ideas in it. Reading both is hard work (especially since both are<br>
based on obscure languages), but will help you a great deal. 
</p>
<p>
One example of an issue that <i>Object-Oriented Software Construction</i>&nbsp;&nbsp;covers quite well<br>
is the question of whether to use a class as a base (inherit from it) or a member<br>
(include it as a field). As Bertrand Meyer notes, the distinction is whether the new<br>
class can act as an instance of its base class (that is, it "is-a" object of that type) or<br>
uses an instance of the class (it "has-a" object of that type). For example, an<br>
automobile "is- a" vehicle, but it "has-a" engine. For good discussions of this and<br>
other issues, read the book (this particular discussion starts&nbsp;&nbsp;on page 333).
</p>
<p>
Brian Wilkerson's "How to Design an Object-Based Application," in this issue of<br>
develop, is a good language-independent introduction to object-based design. You should<br>
find the design techniques presented in his article useful in your own work.
</p>
<p>
Taking the time to learn how to design with objects may be painful (after all, we're all<br>
working as hard as we can already), but it can make a big difference in the quality of<br>
the system when it's done. Every extra minute you take to improve the design now will<br>
pay off in easier maintenance and enhancements later.
</p>
<h2>CONCLUSION</h2>
<p>
We've covered a lot of ground in this article. Don't feel bad if you didn't understand<br>
every point we tried to make. It took us years of working with objects before we<br>
figured out what virtual base classes were good for! As you use C++ in your own work,<br>
think about the rules we've laid down and see if they aren't applicable to your own<br>
situation. Come back and read these guidelines every so often, just to refresh your<br>
memory. And finally, don't be shy about formulating some guidelines of your own! 
</p>
<p>
<b>DAVID GOLDSMITH</b> has been at Apple for four years, and now focuses his energies on<br>
future system software.&nbsp;&nbsp;He has also worked on MacApp and the Macintosh Toolbox<br>
(during the inception of System 6.0). He received an MA in physics from Harvard in<br>
1980, and since has worked for Wang, Mosaic Technologies, and as a contractor for<br>
Lotus. For him, the thrill of the job is "making computers available to people whose<br>
lives don't revolve around computers." His main interest outside the office is his<br>
family, with its new member, eight-month-old Jane.&nbsp;&nbsp;He also enjoys reading and<br>
listening to classical music. *
</p>
<p>
<b>"HackerJack" Palevich</b> is our local meerkat handler (look that one up in National<br>
Geographic!). He has a degree in computer science from MIT, where his "Thesis of<br>
Terror" was a prelude to his video game days at Atari. Two years at Apple have landed<br>
him in video conferencing and screen sharing.&nbsp;&nbsp;As the son of an American diplomat, he's<br>
lived in some pretty interesting places (Berlin, Poland, Laos, Greece, Maryland, and<br>
Cupertino). He didn't buy an Apple II in the eleventh grade, and has regretted it since.<br>
His interests include filmmaking, animation, and aerobics.&nbsp;&nbsp;He claims to be halfway a<br>
nerd, but only his wife knows for sure. He also likes to tell stories, so we're not sure<br>
that any of this is really true. *
</p>
<p>
<b>This</b> is an enhanced version of an internal, informal Apple style guide written by<br>
David Goldsmith.&nbsp;&nbsp;Jack Palevich edited the original document to bring it into its<br>
current form.&nbsp;&nbsp;The opinions expressed in this document are David's and/or Jack's.<br>
They are not necessarily those of Apple Computer, Incorporated.&nbsp;&nbsp;This work is<br>
Copyright &#A9; 1989-1990 Apple Computer, Inc. .&nbsp;&nbsp;All rights reserved.&nbsp;&nbsp;*
</p>
</body>
</html>
