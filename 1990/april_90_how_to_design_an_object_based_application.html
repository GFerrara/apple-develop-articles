<html>
<head>
<!-- Article ID: 28 - Extracted from develop-1990 -->
<!-- on 2023-12-27 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by copyright of their respective owners -->
<title>April 90 - HOW TO DESIGN AN OBJECT-BASED APPLICATION</title>
<link href="../common/styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h2>HOW TO DESIGN AN OBJECT-BASED APPLICATION</h2>
<img src="img/161.gif" width="189 px"></img><br>
<h1>BRIAN WILKERSON</h1>
<p>
<i>The object-based approach promises to make software easier to&nbsp;&nbsp;reuse, refine, test,</i><br>
<i>maintain, and extend. But simply implementing&nbsp;&nbsp;an application in an object-based</i><br>
<i>language does not guarantee these benefits. They can only be achieved if the</i><br>
<i>implementation is based on&nbsp;&nbsp;a sound object-based design. This article presents a</i><br>
<i>process for creating such a design.</i>
</p>
<p>
As every programmer knows, software applications are becoming increasingly<br>
complex, and as a result, increasingly expensive to build and maintain. The good news<br>
is that if you are willing to spend the time to carefully develop an object-based design<br>
for your software, implementation can proceed smoothly and quickly, and the resulting<br>
software will be relatively easy to reuse, refine, test, maintain, and extend. This<br>
article gives an overview of the object-based approach and then describes step by step<br>
a two-phase process for designing an object-based application.
</p>
<h2>BASIC CONCEPTS OF THE OBJECT-BASED APPROACH</h2>
<p>
Programmers familiar with non-object-based languages are used to dividing<br>
information into two distinct kinds: functions and data. Procedural programming,<br>
based on this division of information, focuses on <i>how </i> to accomplish the goals of the<br>
program. It begins by identifying the high-level tasks that need to be performed, and<br>
then decomposing each task into smaller tasks until the level of the language statement<br>
is reached. Procedural programming concerns itself almost immediately with the<br>
implementation of the program: the steps that compose each function, and the<br>
particulars of the data to be operated upon.
</p>
<p>
By contrast, the focus of the object-based approach is more abstract. It asks first<br>
about the intention of the program: asking <i>what, </i> not <i>how.</i>&nbsp;&nbsp;It views the programming<br>
process as one of modeling the world. It begins by identifying the things inhabiting the<br>
part of the world being modeled, and the behavior of those things, both as individuals<br>
and with respect to the other things in the world.
</p>
<p>
The object-based approach uses abstraction to manage the complexity inherent in<br>
real-world problems. An abstraction is a simplified picture of the world, arrived at <br>
by generalizing about details.&nbsp;&nbsp;The object-based approach relies on abstraction<br>
mechanisms such as encapsulation, information hiding, polymorphism, and<br>
inheritance.
</p>
<p>
<b>ENCAPSULATION</b><br>
Encapsulation is the enclosing of a number of separate related things within a single<br>
physical or conceptual capsule. For example, a telephone number encapsulates<br>
individual digits at a higher, abstract level at which the numbers form a single entity.<br>
When you think of your telephone number, you don't think of it as seven separate<br>
digits. You think of it as a single unit that happens, almost incidentally, to be composed<br>
of seven digits.
</p>
<p>
<b>INFORMATION HIDING</b><br>
Encapsulation makes complexity more manageable, but it doesn't reduce the amount of<br>
visible detail. Information hiding takes encapsulation a step further, reducing<br>
complexity by hiding some or all of the things that have been encapsulated. For<br>
example, when you use a compact disc player, you don't generally think of all the<br>
electrical and mechanical components within it. You don't need to know how it works.<br>
What's important is what it does: it plays the music you want to hear.
</p>
<p>
<b>OBJECTS</b><br>
An object is an encapsulation of data and the functions that manipulate that data. But<br>
more than that, an object hides the data and possibly some of the functions, revealing<br>
only those functions that need to be made available to other objects. The set of visible<br>
functions defined by an object is referred to as the behavior of the object.
</p>
<p>
The data and functions that are hidden within an object define the implementation of<br>
that object.&nbsp;&nbsp;&nbsp;That is, they define<i>how</i>&nbsp;&nbsp;that object does what it does. The behavior of an<br>
object defines<i>what</i>&nbsp;&nbsp;the object does. In keeping with the abstract nature of the<br>
object-based approach, object-based design focuses exclusively on the behavior of<br>
objects.&nbsp;&nbsp;The object-based approach views a program as a collection of objects that<br>
interact with other objects to accomplish the goals of the program. Objects interact<br>
with other objects by sending those objects messages requesting that a publicly visible<br>
function be executed. A message specifies the name of the function being requested and<br>
the arguments required by the receiver of the message to execute the function.
</p>
<p>
<b>POLYMORPHISM</b><br>
Polymorphism is an abstraction mechanism by which two or more different kinds of<br>
objects can respond to the same message, each in its own way. This means that an<br>
object can send a message to another without knowing how the receiver will respond,<br>
or what other messages the receiver might also understand. The sending object just<br>
needs to know that many different kinds of objects can be defined to respond to the<br>
message being sent and that the receiver is one of those. 
</p>
<p>
<b>CLASSES</b><br>
A class is a specification of the behavior of an arbitrary number of similar objects.<br>
Objects that share the same behavior are said to belong to the same class. The objects<br>
that belong to a class are referred to as instances of that class. The process of<br>
dynamically creating objects is known as instantiating a class. 
</p>
<p>
Classes are another abstraction mechanism. They allow us to focus on the kinds of<br>
objects in an application rather than on the individual objects.
</p>
<p>
Throughout the remainder of this article, when we refer to some aspect of a class, we<br>
mean the definition of that aspect of the instances of the class. For example, when we<br>
refer to the behavior of a class, we mean the definition of the behavior of the instances<br>
of that class. The meaning should be clear from context.
</p>
<p>
<b>INHERITANCE</b><br>
Inheritance is an abstraction mechanism by which new classes can be derived from<br>
existing ones, thereby "inheriting" both data and functions. The inheritor (called a<br>
subclass) reuses the code that it inherits from its superclass. Again, in the design<br>
phase, we are only interested in the inheritance of behavior.
</p>
<p>
<b>THE CLIENT-SERVER MODEL</b><br>
The model we use for our object-based design views the world as a system of objects<br>
collaborating to perform the work required of them: the client-server model.
</p>
<p>
The client-server model is a description of the interaction between two entities: the<br>
client and the server. A client makes requests of the server to perform services. A<br>
server provides a set of services upon request.
</p>
<p>
The ways in which the client can interact with the server are described by a contract:<br>
a description of the requests that can be made of the server by the client. Both must<br>
fulfill the contract: the client by making only those requests it specifies, and the<br>
server by correctly responding to those requests.
</p>
<p>
In an object-based design, both client and server are objects. Any object can act as<br>
either a client or a server at any given time. The design focuses on the contract<br>
between clients and servers by asking (1) what actions each object is responsible for,<br>
and (2) what information each object shares.
</p>
<h2>THE BENEFITS OF OBJECT-BASED DESIGN</h2>
<p>
If you spend a meaningful amount of time on carefully developing an object-based<br>
design for your software, implementation can proceed more smoothly and quickly than<br>
it would for a traditional procedural program. The resulting software can also be<br>
easier to test, maintain, refine, and extend.
</p>
<p>
An object-based design can improve implementation by encapsulating pieces of the<br>
program into components that can be implemented without considering the interactions<br>
with the rest of the system. If an interface between components then seems wrong for<br>
some reason, the system can be changed at just that one point; other parts of the<br>
system are not affected.
</p>
<p>
A careful design can also make it easier to test the application. Classes can be isolated<br>
and tested one at a time. An error can more easily be traced to a specific class. Classes<br>
can be shown to function before being plugged into the rest of the system. 
</p>
<p>
Similarly, the rigorous specification of the interfaces between classes allows testers <br>
to more easily spot discrepancies between the output of one component and the input<br>
required toanother. Such a careful specification of the interfaces requires a complete<br>
understanding of the responsibilities of each component. Holes in the system--places<br>
where a responsibility was omitted by the specification, or stated ambiguously, or<br>
made part of the wrong class--can more easily be spotted and filled.
</p>
<p>
After the application has been implemented, it's also easier to maintain. Encapsulation<br>
and information hiding rigidly constrain the patterns of communication within the<br>
application, so that they can be understood more easily. This makes it easier to<br>
determine where a problem lies and where any ramifications may appear after you fix<br>
the problem. In this way, you can guard against the notorious problem of one bug fix<br>
introducing other bugs. 
</p>
<p>
A system that can be understood can also be refined and extended. If the interfaces<br>
between classes have been rigorously controlled, new portions of the system can be<br>
created to use the same interfaces, but to do different things with them. You can also<br>
add new classes that respond to old requests in ways appropriate to the new system of<br>
which they are now a part. Functionality can thereby be increased at far less cost.
</p>
<p>
In sum, object-based design enables us to build classes that can be depended upon&nbsp;&nbsp;to<br>
behave in certain ways, and to know what state results from that behavior. Such<br>
classes can be reused in every application that can make use of this behavior and<br>
knowledge. With careful thought, you can construct classes that will be useful to many<br>
applications.
</p>
<h2>A TWO-PHASE PROCESS FOR DESIGNING AN APPLICATION</h2>
<p>
The remainder of this article describes a process for creating object-based designs.<br>
The result of this process, an object-based design, consists of a structure of classes<br>
modeling the problem, a description of the public behavior of those classes--their<br>
responsibilities, and a description of the patterns of communication among the classes.
</p>
<p>
The design process we use has two phases:
</p>
<ol>
<li>An initial exploration of the possibilities, which produces a preliminary<br>
design.</li>
<li>A rigorous analysis of the preliminary design.</li>
</ol>
<p>
Both of these phases play critical roles in the object-based design process.
</p>
<p>
The exploratory phase of object-based design concentrates on identifying the classes,<br>
assigning responsibilities to those classes, and determining which other classes<br>
collaborate with them to fulfill those responsibilities. At this stage of the engineering<br>
process, very little effort has been invested in any specific design. It is therefore<br>
relatively cheap to play with the possibilities, trying out various ways to configure<br>
your system. A little time spent exploring at this point can lead to a lot of time and<br>
effort saved later, as it will be easier to reuse parts of the design, or to refine and<br>
extend it.
</p>
<p>
The results of exploration, however, must be carefully pruned and edited. No one can<br>
count on getting it right the first time. The preliminary design must be critically<br>
examined, to maximize both encapsulation and inheritance. Only in this way can the<br>
use of object-based design fulfill its promise of producing software that is easy to<br>
reuse, refine, test, maintain, and extend.
</p>
<p>
To illustrate the design process described here, we'll use the example of a spreadsheet<br>
program, the specification for which appears in the sidebar. This example is too<br>
simple to be a true application, but for the purposes of this article it will give you a<br>
feeling for how to use the design process.<b>THE EXPLORATORY PHASE</b><br>
The exploratory phase of object-based design consists of three steps:
</p>
<ol>
<li>Finding the classes.</li>
<li>Assigning responsibilities to them.</li>
<li>Determining the collaborations required to fulfill those responsibilities.</li>
</ol>
<p>
Let's look at each of these steps individually.
</p>
<p>
<b>FINDING CLASSES</b><br>
Choosing the classes of objects that make up your application is a key part of modeling<br>
it. The classes should define the essence of your application; they should emphasize the<br>
important aspects, and discard irrelevancies.
</p>
<p>
<b>Generate candidate classes. </b>When you start your design, you frequently have<br>
nothing more than a specification outlining the functionality envisioned for the system<br>
as a whole. If that's all you have, that's what you start with. Begin by reading the<br>
specification until you are familiar with it. Now reread the specification, taking note<br>
of every noun or noun phrase in the document. These are your candidate classes.
</p>
<p>
The following list results from doing this with the spreadsheet specification:
</p>
<p class="spacer">&nbsp;</p>
<p><table border="0"><tr><td>spreadsheet program</td><td>decimal point</td><td>formula</td></tr>
<tr><td>application</td><td>monetary format</td><td>expression</td></tr>
<tr><td>user</td><td>dollar sign</td><td>simple expression</td></tr>
<tr><td>electronic spreadsheet</td><td>real format</td><td>additive operator</td></tr>
<tr><td>new spreadsheet</td><td>scientific format</td><td>term</td></tr>
<tr><td>existing spreadsheet</td><td>zero</td><td>multiplicative operator</td></tr>
<tr><td>files</td><td>one</td><td>factor</td></tr>
<tr><td>spreadsheet</td><td>exponent</td><td>constant</td></tr>
<tr><td>cell</td><td>text cell</td><td>cell name</td></tr>
<tr><td>row</td><td>arbitrary text</td><td>number</td></tr>
<tr><td>column</td><td>first character</td><td>argument</td></tr>
<tr><td>name</td><td>equal sign</td><td>comma operator</td></tr>
<tr><td>ordinal position</td><td>text</td><td>textual representation</td></tr>
<tr><td>value</td><td>left-aligned text</td><td>type</td></tr>
<tr><td>numeric cell</td><td>centered text</td><td>rectangular group of cells</td></tr>
<tr><td>numeric value</td><td>right-aligned text</td><td>individual cell</td></tr>
<tr><td>format</td><td>justified text</td><td>entire spreadsheet</td></tr>
<tr><td>integer format</td><td>expression cell</td><td>selected cell</td></tr></table></p>
<p class="spacer">&nbsp;</p>
<p class="spacer">&nbsp;</p>
<p>
<b>Choose classes from candidates.</b> Once you have a list of possible classes, you<br>
must decide which of them will become part of the model you are designing. The<br>
following guidelines are useful in choosing which noun phrases represent classes and<br>
which are spurious.
</p>
<ul>
<li> Model physical objects, such as windows on the display or printers on the<br>
network. The cells of a spreadsheet can be thought of in this way, so we<br>
tentatively create the class Cell.</li>
<li> If more than one word is used for the same concept, choose the one that is<br>
most meaningful in terms of the rest of the system.</li>
</ul>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For example, "application" really means "the spreadsheet program" in this<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context. The phrase that best describes the meaning is kept, while the rest are<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;discarded. In some cases, none of the phases is appropriate, so a new one must<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;be created.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Our list is full of such synonyms and naming problems. Following is a list of<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the words with synonyms. The words that remain candidates are followed by<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the synonyms we have rejected, indented below them.
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spreadsheet electronic spreadsheet new spreadsheet existing spreadsheet<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entire spreadsheet cell&nbsp;&nbsp;numeric cell text cell expression cell name cell name<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value numeric value text&nbsp;&nbsp;arbitrary text textual representation cell group<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rectangular group of cells individual cell selected cells
</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In addition, one more naming problem exists. Rows and columns are just<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rectangular groups of cells. The general concept capturing this commonality <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is "cell group."
</p>
<ul>
<li> Be wary of adjective-noun phrases. An adjective-noun combination can<br>
mean a dif- ferent kind of object, a different use of the same object, or it could<br>
be utterly irrelevant. Ask if the object represented by the noun behaves<br>
differently when the adjective is applied to it. If the use of the adjective<br>
signals that the behavior of the object is different, then make a new class.</li>
<li> Model categories of objects. Such categories represent abstract<br>
superclasses, and should therefore be modeled. "Expression" and "value" are<br>
examples of abstract superclasses; there are several different kinds of each in<br>
the spreadsheet.</li>
<li> Model known interfaces to the outside world, such as physical devices, a<br>
window- ing system, or the operating system, as fully as your initial<br>
understanding allows. The interface to the outside world in this case is<br>
represented by the noun "file," which becomes a candidate class&nbsp;&nbsp;Don't model<br>
things outside the application. Our list includes a variety of things obviously<br>
outside the bounds of the system, such as "user," "first character," and "type."</li>
<li> Model the values of attributes of objects, but not the attributes<br>
themselves. For example, each cell has a name. The name is an attribute whose<br>
value is a string of characters. Therefore, the class String should be created,<br>
but there will be no class called Name; it will be an attribute of the class Cell.<br>
The following table contains the phrases representing attributes, the<br>
class(es) of objects having that attribute, and the class(es) of the value of the<br>
attribute. </li>
</ul>
<p>
<img src="img/162.gif" width="600 px"></img>
</p>
<p>
&nbsp;How should formats be represented? The format controls the way in which the value<br>
is displayed. This kind of control is usually handled by either sending different<br>
messages to a class, or sending the same message to different classes. The former is<br>
preferred in this case&nbsp;&nbsp;because the format can change independent of the value. The<br>
format, therefore, should be the message with which the value is displayed (or an<br>
encoding of it if the target language does not support messages as objects). We can<br>
therefore discard all of the noun phrases representing types of formats, which were<br>
the following:
</p>
<p class="spacer">&nbsp;</p>
<p><table border="0"><tr><td>integer format</td><td>scientific format</td><td>right-aligned text</td></tr>
<tr><td>monetary format</td><td>left-aligned text</td><td>expression</td></tr>
<tr><td>real format</td><td>centered text</td><td>justified text</td></tr></table></p>
<p class="spacer">&nbsp;</p>
<p class="spacer">&nbsp;</p>
<p>
&nbsp;We replace the phrases describing the syntactic representation of expressions,&nbsp;&nbsp;given<br>
below, with classes representing the semantic structure of expressions.
</p>
<p class="spacer">&nbsp;</p>
<p><table border="0"><tr><td>formula</td><td>simple expression</td><td>multiplicative operator</td></tr>
<tr><td>expression</td><td>additive operator</td><td>factor</td></tr>
<tr><td>comma operator</td><td>term</td><td>constant</td></tr></table></p>
<p class="spacer">&nbsp;</p>
<p class="spacer">&nbsp;</p>
<p>
<b>&nbsp;Record classes.</b> When you have identified the first, tentative list of classes, they<br>
need to be recorded. For each class, take a 4" x 6" index card, and write the class name<br>
at the top of the card. You should use index cards to record classes because they are<br>
compact, easy to manipulate, and easy to modify or discard. Each index card will<br>
eventually contain the kinds of information indicated in Figure 1.
</p>
<p>
<img src="img/163.gif" width="578 px"></img>
</p>
<p>
<b>Figure 1. Contents of Each Index Card</b>
</p>
<p>
&nbsp;Some classes will be missing and others will be eliminated later, but don't worry.<br>
Your design will go through many stages on its way to completion, and you will have<br>
ample opportunity to revise.The final list of candidate classes is as follows:
</p>
<p class="spacer">&nbsp;</p>
<p><table border="0"><tr><td>Binary Expression</td><td>Computed Value</td><td>Spreadsheet</td></tr>
<tr><td>Cell</td><td>Constant Expression</td><td>Textual Value</td></tr>
<tr><td>Cell Group</td><td>Expression</td><td>Value</td></tr>
<tr><td>Cell Reference</td><td>File</td><td></td></tr>
<tr><td>Expression</td><td>Numeric Value</td><td></td></tr></table></p>
<p class="spacer">&nbsp;</p>
<p class="spacer">&nbsp;</p>
<p>
<b>ASSIGNING RESPONSIBILITIES</b><br>
You have now found the classes in your system. Next you must decide what behavior<br>
each of them is going to be responsible for.
</p>
<p>
Responsibilities include two key items:
</p>
<ul>
<li> the information other classes can ask for from a class    </li>
<li> the actions a class can perform</li>
</ul>
<p>
Responsibilities are meant to convey a sense of the purpose of a class and its place in<br>
the system. As you seek to identify responsibilities, use the conceptual model of the<br>
client-server contract. The contract between two classes represents the list of<br>
services one class can request of another. A service can be either the performance of<br>
some action or the return of some information. If an object provides a service, that is<br>
one of its responsibilities. All of the services listed in a particular contract are the<br>
responsibilities of the server for that contract.
</p>
<p>
<b>Find responsibilities.</b> To find responsibilities, return to the specification. This<br>
time, take note of all the verbs. Use your judgment to determine if each represents an<br>
action that some class within the system must perform. Also use the work you just<br>
performed when you identified classes. The fact that you identified a class indicates<br>
that you saw a need for it to fulfill at least one responsibility. The name you chose for<br>
that class probably suggests that responsibility, and possibly others. From the<br>
specification, we can derive the following candidate responsibilities:
</p>
<p class="spacer">&nbsp;</p>
<p><table border="0"><tr><td><p style="font-size:small;">open from a file</p></td><td><p style="font-size:small;">columns have cells</p></td><td><p style="font-size:small;">remove columns</p></td></tr>
<tr><td><p style="font-size:small;">save to a file</p></td><td><p style="font-size:small;">specify cell format</p></td><td><p style="font-size:small;">insert rows</p></td></tr>
<tr><td><p style="font-size:small;">maintain a collection of cells</p></td><td><p style="font-size:small;">numbers convert to text</p></td><td><p style="font-size:small;">insert columns</p></td></tr>
<tr><td><p style="font-size:small;">cell have names</p></td><td><p style="font-size:small;">users select rectangular</p></td><td><p style="font-size:small;">remove values of cells</p></td></tr>
<tr><td></td><td><p style="font-size:small;">groups of cells</p></td><td></td></tr>
<tr><td><p style="font-size:small;">cell have values</p></td><td><p style="font-size:small;">cut selected cells</p></td><td><p style="font-size:small;">replace values of cells</p></td></tr>
<tr><td><p style="font-size:small;">rows have names</p></td><td><p style="font-size:small;">copy selected cells</p></td><td><p style="font-size:small;">edit values of cells</p></td></tr>
<tr><td><p style="font-size:small;">rows have cells</p></td><td><p style="font-size:small;">paste cells</p></td><td><p style="font-size:small;">recompute values of cells</p></td></tr>
<tr><td><p style="font-size:small;">columns have names</p></td><td><p style="font-size:small;">remove rows</p></td><td></td></tr></table></p>
<p class="spacer">&nbsp;</p>
<p class="spacer">&nbsp;</p>
<p class="spacer">&nbsp;</p>
<p>
<b>Assign responsibilities to classes.</b> Once you have listed a number of candidate<br>
responsibilities for the classes in your application, you can go about assigning each<br>
responsibility to the appropriate class. The following guidelines can prove useful as<br>
you seek to apportion the responsibilities to each class.
</p>
<ul>
<li> Distribute system intelligence as evenly as possible. A system can be<br>
thought of as having a certain amount of intelligence, such intelligence being<br>
what the system knows and what actions it can perform. Within any system,<br>
some classes of objects can be viewed as being relatively "smart," while<br>
others seem less so. Distributing the intelligence embodied within your<br>
system among a variety of classes allows each class to know about relatively<br>
fewer things, thus producing a more flexible system, and one that is easier to<br>
modify.</li>
<li> Keep behavior with related information, if any. If a class is responsible<br>
for knowing certain information, it is logical also to assign it the<br>
responsibility of performing any operations necessary upon that information.<br>
Conversely, if a class requires cer- tain information in order to perform<br>
some operation for which it is responsible, it is logical (other things being<br>
equal) to assign it the responsibility for maintaining the information as well.</li>
<li> Keep information about one thing in one place. In general, the<br>
responsibility for knowing specific information should not be shared. Sharing<br>
information implies a duplication that could lead to inconsistency.</li>
<li> Share responsibilities among related objects. Occasionally, you may<br>
discover that a certain responsibility seems to be several responsibilities, or<br>
a compound responsibility, that is best divided or shared among two or more<br>
classes.</li>
</ul>
<p class="spacer">&nbsp;</p>
<p>
We now assign the responsibilities from the spreadsheet program.
</p>
<p>
open from a file<br>
save to a file<br>
It isn't clear which class to assign these responsibilities to. The closest candidate we<br>
have now is Spreadsheet itself, but it should be used to represent just the spreadsheet,<br>
not the full set of editing capabilities implied by the system. We therefore want a class<br>
that represents the application itself. Let's call this class Spreadsheet Editor, and<br>
assign these responsibilities to it.
</p>
<p>
maintain a collection of cells<br>
This is clearly a responsibility of the class Spreadsheet. After all, that is the class that<br>
must maintain the collection; therefore, it should have the responsibility for<br>
maintaining the information as well.
</p>
<p>
cells have names<br>
cells have values<br>
By the same token, the responsibility for maintaining this information belongs to the<br>
class Cell.
</p>
<p>
rows have cells<br>
columns have cells<br>
The responsibility for maintaining this information belongs to the class Cell Group.<br>
However, because rows and columns are merely different groupings of cells, we might<br>
wish to rephrase this responsibility more generally, stating that the class Cell Group<br>
knows which cells it contains.
</p>
<p>
At this point, we might notice that the responsibilities of Spreadsheet and the<br>
responsibilities of Cell Group are very similar; they both maintain information about<br>
the cells they contain. We should view Spreadsheet as being composed of a group of<br>
cells, rather than maintaining a collection of individual cells. The responsibility of the<br>
class Spreadsheet is to know the <i> group </i> of cells of which it is composed. The<br>
responsibility of the clas Cell Group need not change.
</p>
<p>
rows have names<br>
columns have names<br>
Names of rows and columns appear merely by way of explaining how cells get named.<br>
Cells must maintain their names, as we mentioned above, but row and column names<br>
are irrelevant, and do not need to be maintained by any class. There is no<br>
responsibility for maintaining this information.
</p>
<p>
specify cell forma<br>
This is actually a compound responsibility. The Spreadsheet Editor allows the user to<br>
specify the cell format, but the Cell must maintain its format thereafter.
</p>
<p>
numbers convert to text<br>
The responsibility for performing this conversion belongs to the class&nbsp;&nbsp;Numeric Value.
</p>
<p>
users select rectangular groups of cells<br>
cut selected cells<br>
copy selected cells<br>
paste cells<br>
remove rows<br>
remove columns<br>
insert rows<br>
insert columns<br>
remove values of cells<br>
replace values of cells<br>
edit values of cells<br>
The responsibility for receiving user input belongs to the class Spreadsheet Editor.<br>
Many of these responsibilities imply that other classes must perform other operations<br>
as well. We shall return to this point later, when we discuss collaborations.
</p>
<p>
recompute values of cells<br>
This is also a compound responsibility. The Spreadsheet Editor allows the user to<br>
request that the values be recomputed, but the Expression must perform the actual<br>
computation.
</p>
<p>
<b>Record responsibilities.</b> As you assign responsibilities to specific classes, record<br>
them on the card for that class, under the class name, on the left edge.
</p>
<p>
<b>DETERMINING COLLABORATIONS</b><br>
A collaboration is a request made of one object by another. It is the embodiment of the<br>
requests specified in the client-server contract. A single collaboration flows in one<br>
direction--from the client to the server. Every collaboration is associated with a<br>
single responsibility. It fulfills, or contributes to the fulfillment of, that<br>
responsibility.
</p>
<p>
Collaborations are important because the pattern of collaborations within your<br>
application reveals how control and information will flow during execution.<br>
Identifying collaborations between classes allows you to identify paths of<br>
communication between classes. Finding such paths will ultimately allow you to<br>
identify subsystems of collaborating classes. Finding such subsystems is one way in<br>
which you will later be able to further abstract your application.
</p>
<p>
<b>Identify collaborations.</b> To identify collaborations, ask the following questions for<br>
each responsibility of each class:
</p>
<ul>
<li> Is the class capable of fulfilling this responsibility itself?</li>
<li> If not, what is needed?</li>
<li> From what other class can it acquire what it needs?</li>
</ul>
<p>
Let's look at each of the responsibilities assigned to the classes in the spreadsheet<br>
application. In&nbsp;&nbsp;general, responsibilities to maintain information require no<br>
collaborations. Unless they are an exception, we will not discuss such responsibilities.
</p>
<p>
Expression:<br>
compute values<br>
This generic operation requires no collaborations. However, subclasses of the class<br>
Expression require collaborations in order to fulfill their specific responsibilities, as<br>
described later.
</p>
<p>
Binary Expression:<br>
compute values<br>
This operation requires a collaboration with the expressions representing the<br>
arguments to the binary operator. These expressions may be a member of any subclass<br>
of the class Expression. We therefore record a collaboration with the class Expression.
</p>
<p>
Cell Reference Expression:<br>
compute values<br>
This operation requires a collaboration with the cell being referenced, an instance of<br>
the class Cell.
</p>
<p>
Numeric Value:<br>
convert to text<br>
This operation occurs during the computation of expressions. It requires no <br>
collaborations.
</p>
<p>
Spreadsheet Editor:<br>
open from a file<br>
save to a file<br>
Clearly, this involves a collaboration with the class File.
</p>
<p>
allow user to specify cell format<br>
This responsibility involves a collaboration with the class Cell so that the format will<br>
be remembered.
</p>
<p>
users select rectangular groups of cells<br>
cut selected cells<br>
copy selected cells<br>
paste cells<br>
remove rows<br>
remove columns<br>
insert rows<br>
insert columns<br>
remove values of cells<br>
replace values of cells<br>
edit values of cells<br>
allow user to request to recompute values of cells<br>
The Spreadsheet Editor is responsible for interpreting user input. It must then inform<br>
the spreadsheet that it has changed, requiring a collaboration with the class<br>
Spreadsheet. Responsibilities that alter cells or groups of cells must similarly<br>
collaborate with the classes Cell or Cell Group.
</p>
<p>
<b>Record collaborations.</b> Record these classes as collaborations on the card for that<br>
class directly opposite the responsibility the collaboration supports. Check to see that<br>
a corresponding responsibility exists for every collaboration you record. Remember,<br>
however, that a collaboration might be with a subclass, but the responsibility might<br>
be recorded on the superclass card instead.
</p>
<p>
<b>Design walk-throughs. </b>As you make these design decisions, it's important for you<br>
to be able to determine their implications. For this purpose, you should walk through<br>
your system after each step. Choose a set of typical inputs to your system, and<br>
hand-simulate its behavior, given these inputs. In this way, you can more easily<br>
determine the implications of your decisions. Feel free to revise previous decisions as<br>
you go, and walk through your new configuration. The point of this stage of your design<br>
process is, after all, to explore as many different possibilities as seems reasonable.<br>
Walk-throughs can help you determine the implications of these various possibilities.
</p>
<p class="spacer">&nbsp;</p>
<p>
Let's look at what happens when a cell is asked for its value. Cells maintain their<br>
values indirectly bystoring an instance of a subclass of class Value. Therefore, cells<br>
must retrieve their values when requested by sending a message to a Value. The Value<br>
may represent the value directly, as with a number or text, or it may know the<br>
expression by which the value can be computed. In the latter case, the Value must ask<br>
the expression to evaluate itself.
</p>
<p>
Expressions evaluate themselves differently depending on which type of expression<br>
they are. Constant Expressions evaluate themselves by returning the constant they<br>
represent. Cell Reference Expressions evaluate themselves by asking for the value of<br>
the cell they reference. Binary Expressions evaluate themselves by applying their<br>
operator to the values of their two arguments. So far, it seems the sys- tem works the<br>
way it was intended to.
</p>
<p>
<b>THE ANALYSIS PHASE</b> The analysis phase of object-based design also consists of<br>
three steps:
</p>
<ol>
<li>Building optimal inheritance hierarchies.</li>
<li>Streamlining the collaborations between classes.</li>
<li>Defining the signatures for each responsibility.</li>
</ol>
<p>
Let's look at each of these steps individually.
</p>
<p>
<b>BUILDING HIERARCHIES</b><br>
A carefully considered and crafted inheritance hierarchy provides the maximum<br>
amount of reusable code. Carefully assigning responsibilities ensures that the <br>
resulting hierarchies of classes are easily reused, maintained, and extended.
</p>
<p>
<b>Record existing hierarchies.</b> First, examine the present class hierarchies in the<br>
design. Draw hierarchy graphs of your application. The hierarchy graph is rather<br>
simple. Classes are represented by rectangles, labeled with the class names.<br>
Inheritance is indicated by a line from superclass to subclass, and by position on the<br>
page--superclasses are above their subclasses.
</p>
<p>
Analyze the responsibilities assigned to each class to determine whether each class is<br>
abstract or concrete.
</p>
<ul>
<li> Abstract classes are designed to be inherited. Instances of abstract classes<br>
are never created as the system executes.</li>
<li> Concrete classes are designed to be instantiated. They are designed<br>
primarily so that their instances may be generally useful, and secondarily so<br>
that they may also be usefully inherited.</li>
</ul>
<p>
Go through your inheritance hierarchies, labeling each class as abstract or concrete on<br>
the cards and by filling in the upper-left corner of hierarchy graphs for abstract<br>
classes. If you have trouble deciding whether a given class is abstract or concrete,<br>
think about your working system. Will an instance of this class be used during<br>
execution? If so, the class is concrete.
</p>
<p>
Our spreadsheet program includes two abstract classes: Expression and Value.&nbsp;&nbsp;All<br>
other classes in this design are concrete. The hierarchy graphs for hierarchies<br>
containing more than one class appear as shown in Figure 2.
</p>
<p>
<img src="img/164.gif" width="344 px"></img>
</p>
<p>
<img src="img/165.gif" width="344 px"></img>
</p>
<p>
<b>&nbsp;Figure 2. Hierarchy Graphs for Our Abstract Classes</b>
</p>
<p>
<b>&nbsp;Restructure hierarchies.</b> Because our spreadsheet example is so small, there is<br>
nothing we can show you here to exemplify optimizing the hierarchy. Nevertheless,<br>
the following guidelines can help you build better hierarchies:
</p>
<ul>
<li> When you have determined how many abstract classes are presently in<br>
your design, speculate on abstract classes that might encapsulate behavior that<br>
could be reused by existing and future subclasses. In general, the more<br>
abstract classes an application has, the more code in the application can be<br>
reused. Therefore, define as many abstract classes as seems reasonable to<br>
capture the abstractions present in your design, or that you reasonably<br>
suspect you might have future use for. </li>
<li> Factor responsibilities as high as possible in the hierarchy. If a set of<br>
classes all support the same set of responsibilities, all the classes should<br>
inherit those responsibilities from a common superclass.&nbsp;&nbsp;If a common<br>
superclass does not exist, create one, and move the common&nbsp;&nbsp;responsibilities<br>
to it. After all, such a class is demonstrably useful--you have already shown<br>
that the responsibilities will be inherited by some classes. </li>
<li> Factor implementation details as low as possible in the hierarchy.  If a<br>
superclass supports its responsibilities in only the most generic possible<br>
way, (providing only templates, as it were, for the desired behavior), then<br>
implementation details cannot impede a new subclass from inheriting those<br>
responsibilities. Each subclass is free to implement the responsibilities in the<br>
way most appropriate for it. This can include subclasses unforeseen by the<br>
original design. </li>
<li> Ensure that each class encapsulates a single integral set of <br>
responsibilities. Each class should have a single, overarching purpose; each<br>
class should serve one main function in the&nbsp;&nbsp;system of which it is a part. These<br>
observations of what enhances or detracts from the reusability of a class lead<br>
to the principle that the appropriate use of inheritance is to model a type<br>
hierarchy: every class should be a particular kind of its superclasses.<br>
Subclasses should add responsibilities to their superclasses; they should not<br>
cancel inherited responsibilities, or override them to become errors, or no<br>
behavior at all. </li>
</ul>
<p>
&nbsp;When you have modified your design, redo your graphs and cards to correspond to the<br>
new state of your design. Then recheck your system. For each responsibility, make<br>
sure there is a corresponding collaboration, and vice versa. Once again, walk through<br>
the design to ensure that every object is still communicating with the rest of the<br>
system in the appropriate manner.
</p>
<p>
<b>Group responsibilities into contracts.</b> Once the responsibilities have been<br>
properly factored in the hierarchies, they need to be grouped into the contracts<br>
supported by each class. This is usually straightforward because classes usually<br>
support a small and cohesive set of responsibilities. If the responsibilities of a class<br>
are not cohesive, it should have more than one contract. Not all responsibilities will be<br>
public behavior for the class. Only public behavior should be grouped into contracts.<br>
Number the contracts so that they can be referenced.
</p>
<p class="spacer">&nbsp;</p>
<p>
Here are the contracts for the classes in the spreadsheet design:
</p>
<p>
Cell 1. Maintain the value and format 2. Compute the value
</p>
<p>
Cell Group 3. Know the cells contained in the group
</p>
<p>
Expression 4. Compute the value of the expression
</p>
<p>
File 5. Input and output to disk
</p>
<p>
Spreadsheet 6. Know the group of cells within it
</p>
<p>
Value 7. Compute the value represented
</p>
<p>
<b>STREAMLINING COLLABORATIONS</b><br>
We are now going to streamline the collaborations between classes--each<br>
communication path that can occur as information and execution flows through the<br>
system. We analyze these collaborations to attain an overall perspective, to identify<br>
natural ways to divide responsibilities between groups of classes, and thereby to<br>
simplify the various ways in which communication can flow. Simplifying the potential<br>
communication flow simplifies the application: the application becomes easier for<br>
others to understand, maintain, reuse, refine, and extend. 
</p>
<p>
Earlier, we discussed performing a walk-through of your system, trying out various<br>
scenarios, simu- lating the results of various typical inputs. Each such scenario<br>
brings to light one possible path along which information and control can flow.
</p>
<p>
To do a good job of analyzing collaborations between objects, you must first collect an<br>
exhaustive description of all the paths along which control and information can flow.<br>
You can then analyze the col - laborations between classes in order to simplify them. 
</p>
<p>
A collaborations graph is a tool for accomplishing this analysis. A collaborations graph<br>
allows you to examine the collaborations between classes in graphical form, so that<br>
you can better identify areas of unnecessary complexity or other design flaws.<br>
Collaborations graphs represent four distinct elements: classes, subsystems,<br>
contracts, and collaborations. 
</p>
<p>
Classes are shown as labeled rectangles. Subsystems are shown by drawing a rounded<br>
rectangle around the classes that comprise them. Contracts are shown as small<br>
semicircles inside the edges of the class or subsystem to which they belong. Draw one<br>
semicircle per contract, labeled by the&nbsp;&nbsp;contract number. Collaborations between<br>
classes or subsystems are represented by an arrow from the client to a contract<br>
supported by the server.&nbsp;&nbsp;If two objects both collaborate with a class by means of the<br>
samecontract, draw the arrows to the same&nbsp;&nbsp;semicircle. Otherwise, draw the arrows to<br>
different semicircles.
</p>
<p>
In addition, collaborations graphs show superclass/subclass relationships, such as<br>
that between the class Value and the specific kinds of values, or between Expression<br>
and the different kinds of expressions. A superclass represents the contracts supported<br>
by all of its subclasses; because of polymorphism, we can focus on the abstract<br>
contract. We need not consider whether the superclass, or one of its subclasses, will<br>
be the object actually providing the service during execution. This is represented in<br>
the collaborations graph by nesting subclasses within the bounds of their superclasses.
</p>
<p class="spacer">&nbsp;</p>
<p>
Figure 3 shows the collaborations graph of the spreadsheet application as we have so<br>
far designed it.
</p>
<p>
<img src="img/166.gif" width="600 px"></img>
</p>
<p>
<b>Figure 3. Initial Collaborations Graph for Our Spreadsheet Program</b>
</p>
<p>
The goal of this step in the design process is to simplify the patterns of collaboration.<br>
Without such simplification, the communication paths could flow from nearly any<br>
class to any other, with only the slenderest of justifications and no coherent<br>
structuring. Such anarchic flow leads to spaghetti code-- the same problem that<br>
eliminating "go to" statements was designed to avoid.
</p>
<p>
Because such applications are impossible to maintain or sensibly modify, we aim&nbsp;&nbsp;to<br>
simplify the patterns of collaboration. Successfully doing so translates into a <br>
simplification of the graph. The technique we will use, at least in part, is to work<br>
backward: we shall simplify the graph in order to simplify the collaborations. What<br>
criteria should you use to accomplish this simplification?
</p>
<ul>
<li> Minimize the number of different contracts supported by  each class and<br>
subsystem. Too many contracts for one class or subsystem can be a sign that<br>
too much of the application's&nbsp;&nbsp;intelligence is concentrated in that class or<br>
subsystem.</li>
<li> Each contract supported by a subsystem should be handled by only one<br>
class or subsystem. If the contract representing the external interface of a<br>
subsystem mediates direct collaborations with two or more classes, it can be a<br>
sign that a level of indirection is missing, or that the contract is really two or<br>
more con - tracts. </li>
<li> Minimize the number of classes and subsystems within a  subsystem that<br>
are collaborated with by classes or subsystems&nbsp;&nbsp;outside the subsystem.<br>
Otherwise, your subsystem does not truly encapsulate its component entities.<br>
It does not provide the desired level of abstraction.</li>
</ul>
<p>
&nbsp;Three basic mechanisms can be used to simplify your graph, and hence to streamline<br>
the collabora- tions between your classes and subsystems.
</p>
<ul>
<li> Build clean subsystems by centralizing communications to a  subsystem<br>
or introducing an intermediary to a subsystem.</li>
<li> Coalesce classes whose responsibilities overlap.</li>
<li> Split classes with too many contracts.</li>
</ul>
<p>
&nbsp;Our spreadsheet application can be cleanly divided into two large pieces: the editing<br>
capabilities and the structure being edited. For this reason, it makes sense to create a<br>
subsystem representing the structure of a spreadsheet, which we will call the<br>
Spreadsheet Subsystem. The Spreadsheet Subsystem is responsible for creating<br>
spreadsheets, and maintaining their structure.
</p>
<p>
&nbsp;It may well be that the Spreadsheet Editor is itself really a subsystem rather than a<br>
single class, but in the interests of simplicity let's presume that it is a class.
</p>
<p>
&nbsp;Having created the Spreadsheet Subsystem, we need to clean up the way in&nbsp;&nbsp;which the<br>
Spreadsheet Editor collaborates with it. In particular, the Spreadsheet Editor should<br>
not collaborate with so many of the classes inside the subsystem. We can simplify the<br>
paths of collabora- tion by forcing all accesses to other classes to go through the<br>
Spreadsheet. This implies that Spreadsheets must be able to understand and pass along<br>
all messages to the cells or cell groups that compose them. Spreadsheets therefore now<br>
collaborate with Cell Groups, which in turn collaborate with Cells. Two new<br>
collaborations therefore appear in the graph.
</p>
<p>
This set of changes results in the graph of the application shown in Figure 4.
</p>
<p>
<img src="img/167.gif" width="306 px"></img>
</p>
<p>
<b>&nbsp;Figure 4.&nbsp;&nbsp;Simplified Collaborations Graph for Our Spreadsheet</b><br>
<b>Program</b>
</p>
<p>
The collaborations within the Spreadsheet Subsystem would then look like Figure 5.
</p>
<p>
<img src="img/168.gif" width="600 px"></img>
</p>
<p>
<b>Figure 5.&nbsp;&nbsp;Collaborations Graph for the Spreadhseet Subsystem</b>
</p>
<p>
<b>DEFINING SIGNATURES</b>
</p>
<p class="spacer">&nbsp;</p>
<p>
Once the responsibilities have been assigned to classes, and changes are unlikely,&nbsp;&nbsp;the<br>
final stage of the design process is to refine the responsibilities into protocols.&nbsp;&nbsp;A<br>
<i>protocol </i> is a set of messages to which an object will respond.
</p>
<p>
The goal of this part of the process is to make the classes in your application, <br>
particularly their instances, as generally useful as possible. This is accomplished&nbsp;&nbsp;in<br>
two ways:
</p>
<ul>
<li> Maximize polymorphism. Polymorphism, as you recall, is the ability of<br>
instances of different classes to respond to the same message, each in its own<br>
appropriate way.&nbsp;&nbsp;&nbsp;Polymorphism has already been maximized by moving<br>
responsibilities as high in the hierarchy as they can reasonably go. By moving<br>
a responsibility from a class to its superclass, you increase the number of<br>
classes that can support that responsibility, and hence respond to that<br>
message.&nbsp;&nbsp;&nbsp;Polymorphism can also be maximized by carefully selecting<br>
message names, so that it makes sense for instances of many classes to respond<br>
to messages by those names. Use a single message name for each conceptual<br>
operation, wherever in the system it is found. Likewise, associate a single<br>
conceptual operation with each mes- sage name.</li>
<li> Make the protocol as generally useful as possible. Instances will be more<br>
reusable if the protocols used to make requests of them have been designed in<br>
anticipation of as many different uses as possible. Think about what might<br>
change if the system were modified or extended. Think about what related<br>
systems might wish to use.</li>
</ul>
<p>
First, define the most general message, one that allows clients to supply all possibly<br>
required parameters.&nbsp;&nbsp;&nbsp;Next, provide reasonable default behavior for as many<br>
parameters as possible. Finally, analyze how each client uses (or is likely in the<br>
future to use) this general message. From that analysis, define a useful set of messages<br>
that allows clients to specify only some of the parameters, while relying on the<br>
defaults for the others. 
</p>
<p>
List the contracts of each class or subsystem in your application, and turn each<br>
contract into a set of signatures. Each contract will have one or several messages<br>
associated with it. Name these messages thoughtfully, bearing in mind the<br>
considerations just described. Along with the message names, specify the types of all<br>
arguments required, and the type of object returned by the method, if any.&nbsp;&nbsp;Here is an<br>
example set of signatures for the class Spreadsheet:
</p>
<p>
Class: Spreadsheet&nbsp;&nbsp;6.&nbsp;&nbsp;Know the group of cells within it
</p>
<p class="spacer">&nbsp;</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cells() returns Cell Group<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cells(Cell Group) returns void<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;row(Integer) returns Cell Group<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;column(Integer) returns Cell Group<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rows(Integer, Integer) returns Cell Group<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;columns(Integer, Integer) returns Cell Group<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rowsAndColumns(Integer, Integer, Integer, Integer) returns Cell Group<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;positionOfCell(Cell) returns String<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cellAt(Integer, Integer) returns Cell<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cellNamed(String) returns Cell
</p>
<p>
You are now ready to write a formal specification for each class. The specification will<br>
state the name of the class and its overall purpose, whether it is abstract or concrete,<br>
its position in its inheritance hierarchy and the collaborations graph, and its contracts<br>
and their associated signatures. Each&nbsp;&nbsp;signature should be followed by a description of<br>
the behavior captured by the signature. In addition, include any notes on special<br>
implementation considerations, such as algorithms, behavioral constraints, or error<br>
conditions. 
</p>
<p>
As a result of this design process, you now have one or more collaborations graphs, one<br>
or more&nbsp;&nbsp;hierarchy graphs, a specification for each class, and a set of formal <br>
contracts for each class.
</p>
<p>
You are now ready to implement your application.
</p>
<h2>CONCLUSION</h2>
<p>
The result of this process is a design based on objects. The responsibilities of each<br>
object become messages to which the object will respond by providing the services<br>
requested. Collaborations represent classes from which an object must request<br>
operations or information in order to fulfill its own responsibilities.
</p>
<p>
The design therefore supports the basic concepts of object-based technology--it<br>
encapsulates operations and information within objects, it hides details of the state of<br>
an object, and it uses inheritance to incrementally refine the definitions of objects,<br>
maximizing the amount of reusable code.
</p>
<p>
Classes and subsystems can be tested before they are connected to the entire<br>
application. Because the paths of communication are mapped out and rigorously<br>
controlled, maintenance can be performed without risking unpredictable side-effects.<br>
Finally, because the software has been designed from the start with future extensions<br>
in mind, functionality can be added to the application with a minimum&nbsp;&nbsp;of difficulty.
</p>
<p>
Applications implemented from such a design can therefore reap the benefits of<br>
object-based technology.
</p>
<h2>THE SPREADSHEET SPECIFICATION</h2>
<p>
The spreadsheet program is an application that allows users to create and edit<br>
electronic spreadsheets.
</p>
<p>
Users can create new spreadsheets. Existing spreadsheets can be opened from and saved<br>
to files.
</p>
<p>
<b>The Spreadsheet</b><br>
A spreadsheet is a collection of cells arranged in rows and columns.
</p>
<p>
Rows and columns consist of cells and have names. The name of a column is the letter C<br>
followed by the ordinal position of that column. The name of a row is the letter R<br>
followed by the ordinal position of thatrow.
</p>
<p>
Each cell has a name and a value. The name of a cell is the concatenation of the name of<br>
the cell's column and the name of the cell's row, in either order.
</p>
<p>
There are three different types of cells: numeric, text, and expression.
</p>
<p>
Numeric cells contain numeric values. The user can specify the format in which the<br>
value of a numeric cell is displayed. There are four different formats:
</p>
<ul>
<li> integer (no decimal point)</li>
<li> monetary (two places after the decimal point, preceded by a dollar sign)</li>
<li> real (one or more places after the decimal point)</li>
<li> scientific (as a value between zero and one, and an exponent)</li>
</ul>
<p>
Text cells contain arbitrary text, except that the first character cannot be an equal<br>
sign. The text can be formatted to be left aligned, centered, right aligned,&nbsp;&nbsp;or fully<br>
justified.
</p>
<p>
Expression cells contain a formula, but display the value of the formula. Formulas are<br>
entered as text, using the syntax defined by the following syntax definition:
</p>
<pre>&lt;formula&gt; ::= '=' &lt;expression&gt;
&lt;expression&gt; ::= [&lt;expression&gt; ','] &lt;simple expression&gt;
&lt;simple expression&gt; ::=
    [&lt;simple expression&gt; &lt;additive operator&gt;] &lt;term&gt;
&lt;term&gt; ::= [&lt;term&gt; &lt;multiplicative operator&gt;] &lt;factor&gt;
&lt;factor&gt; ::= &lt;constant&gt; | &lt;cell name&gt; | '(' &lt;expression&gt; ')'
&lt;constant&gt; ::= &lt;number&gt; | &lt;text&gt;
&lt;additive operator&gt; ::= '+' | '-'
&lt;multiplicative operator&gt; ::= '*' | '/'</pre>
<p>
Arguments to additive and multiplicative operators must be numeric. The result is a<br>
number. Arguments to the comma operator (text concatenation) may be either text or<br>
numbers, the numbers being converted to a textual representation in the latter case.<br>
The result is text.
</p>
<p>
The value of an expression cell can be formatted either as numeric cells or text cells,<br>
depending on the type of the result. 
</p>
<p>
<b>Operations</b><br>
Users must be able to select rectangular groups of cells, from individual cells to the<br>
entire spreadsheet, including rows and columns. Selected cells can be cut, copied, and<br>
pasted. At least one cell must be selected at all times.
</p>
<p>
If one or more complete rows or columns are selected and cut, the rows or columns are<br>
removed from the spreadsheet. If one or more rows or columns are pasted, they are<br>
inserted to the left of or above the topmost selected row or column, respectively.
</p>
<p>
If a portion of some rows and columns is cut, the values in those cells are removed, but<br>
the empty cells remain. If such a portion is pasted, the values of the same shape of<br>
cells are replaced with the values of the cells, with the upper leftmost cell in the paste<br>
buffer being aligned with the upper leftmost cell of the selected cells.
</p>
<p>
Users must have the ability to edit the values in individual cells, and to force<br>
recomputation of the values shown in expression cells.
</p>
<h2>FURTHER READING ON OBJECT-BASED DESIGN.</h2>
<ul>
<li>Beck, Kent, and Ward Cunningham, "A Laboratory for Teaching<br>
object-based Thinking," <i> OOPSLA'89 Conference Proceedings</i> , SIGPLAN<br>
Notices, October 1989, pp. 1-6.</li>
<li>Cox, Brad, "Message/Object Programming: An Evolutionary Change in<br>
Programming Technology,"&nbsp;&nbsp;IEEE Software, January 1984, pp. 50-61.</li>
<li>Halbert, Daniel, and Patrick O'Brien, "Using Types and Inheritance<br>
inobject-based Languages,"&nbsp;&nbsp;IEEE Software, September 1987, pp. 71-79.</li>
<li>Johnson, Ralph, and Brian Foote, "Designing Reusable Classes," <i>Journal</i><br>
<i>of</i>&nbsp;&nbsp;object-based Programming, June/July 1988, pp. 22-35.</li>
<li>LaLonde, Wilf, "Designing Families of Data Types Using Exemplars," <i>ACM</i></li>
<li>Transactions on Programming Languages and Systems, April 1989, pp.<br>
212-248.</li>
<li>Meyer, Bertrand, "Reusability: The Case for object-based Design," <i>IEEE</i> <br>
Software, March 1987, pp. 50-64.</li>
<li>Snyder, Alan, "Encapsulation and Inheritance in object-based<br>
Programming Languages,"<i> OOPSLA'86 Conference Proceedings</i> , SIGPLAN<br>
Notices, November 1986, pp. 38-45.</li>
<li>Wirfs-Brock, Allen, and Brian Wilkerson, "Variables Limit<br>
Reusability," <i>Journal of object-based Programming</i> ,&nbsp;&nbsp;May/June 1989, pp.<br>
34-40.</li>
<li>Wirfs-Brock, Rebecca, and Brian Wilkerson, "object-based Design: A</li>
<li>Responsibility-Driven Approach,"<i> OOPSLA'89 Conference Proceedings</i> ,<br>
SIGPLAN Notices, October 1989, pp. 71-76.</li>
<li>C++ Primer, Stanley B. Lippman, Addison Wesley, 1989</li>
<li>C++ Programming Language, Bjarne Stroustrup, Addison Wesley, 1987</li>
<li>Object Oriented Software Construction, Bertrand Meyer, Prentice Hall,<br>
1988</li>
<li>MPW C++ 3.1b1 Reference Manual, Apple Computer, 1989 (APDA, part<br>
of MPW C++ 3.1b1 Product)</li>
</ul>
<p>
<b>BRIAN WILKERSON</b> is an object-oriented systems specialist for Instantiations,<br>
Inc., a consulting firm in Portland, Oregon.&nbsp;&nbsp;He studied computer science at the<br>
University of Alberta.&nbsp;&nbsp;After receiving his degree, he worked for Tektronix prior to<br>
joining his current company. Brian has developed a course about object-oriented<br>
design at Instantiations, and has also co-authored a book entitled Designing<br>
Object-Oriented Software, to be published this spring by Prentice-Hall.&nbsp;&nbsp;When he's<br>
not writing or working, he enjoys day hiking and attending jazz concerts. *
</p>
</body>
</html>
