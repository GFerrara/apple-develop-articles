<html>
<head>
<!-- Extracted from develop - 1990 -->
<!-- on 2023-09-06 by Giorgio Ferrara - giorgio<dot>ferrara<at>gmail<dot>com -->
<!-- The content is protected by copyright of their respective owners -->
<title>April 90 - SPEED YOUR SOFTWARE DEVELOPMENT WITH MACAPP</title>
<link href="styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>
<h2>SPEED YOUR SOFTWARE DEVELOPMENT WITH MACAPP</h2>
<img src="img/155.gif" width="203 px"></img><br>
<h1>CHRIS KNEPPER</h1>
<p>
<i>Using MacApp, Apple's object-based application framework, saves time and effort for<br>
programmers, and results in an application with the authentic Macintosh look and feel.<br>
Developing a Macintosh application can become a simple matter of selecting and<br>
integrating functionally specific routines with MacApp and letting MacApp take care of<br>
the user interface and other standard application behavior, as this article shows. </i>
</p>
<p>
Wouldn't it be nice if you could develop a Macintosh application using previously<br>
existing routines? Think of the time and effort you could save if you were able to<br>
integrate functionally specific routines from an application you'd written for another<br>
platform. Or if you were able to obtain such routines from a public source and use<br>
them in your Macintosh application. Or if you could develop such routines yourself, in<br>
a language of your choice, and then use them in multiple applications.
</p>
<p>
And wouldn't it be nice if you had available to you libraries of routines that did the<br>
tedious work of creating the interface Macintosh users have come to expect? You<br>
wouldn't have to spend time and effort making sure your application did all the things a<br>
well-behaved Macintosh application should do.
</p>
<p>
Dream no more. MacApp makes all of this possible.
</p>
<h2>INTRODUCING MACAPP</h2>
<p>
MacApp is an application framework--a skeletal structure for a program that must be<br>
fleshed out before it is useful. The bones of this skeletal structure are the MacApp<br>
libraries, which handle standard application behavior such as initialization; accessing<br>
documents; managing user interface components, such as windows, buttons,<br>
scrollbars, and text; managing memory; and handling user input. You flesh out this<br>
skeleton by adding functionally specific routines and application-specific code. Figure<br>
1 shows how these pieces fit together.
</p>
<p>
<img src="img/156.gif" width="600 px"></img>
</p>
<p>
<b>Figure 1. How MacApp Relates to Your Application</b>
</p>
<p>
Because of Apple's commitment to MacApp, the MacApp libraries have been maintained<br>
and have matured over time. This has produced libraries that are both versatile,<br>
having been used in many applications to address a variety of needs, and robust,<br>
because they've been tested and debugged in hundreds of applications and on a wide<br>
variety of Macintosh configurations. You can use the code as is or modify pieces that<br>
don't meet your needs exactly.
</p>
<p>
The MacApp libraries are written in Object Pascal, and are distributed via APDA along<br>
with interfaces in Object Pascal and C++. Also, p1 Modula-2, Version 4.1, an object<br>
language based on Modula-2 now available from the MacApp Developer's Association is<br>
fully compatible with MacApp 2.0 and includes interfaces to the MacApp libraries.<br>
MPW allows you to develop in Object Pascal, C, C++, FORTRAN, and Modula-2 and<br>
still get the benefits of MacApp.
</p>
<h2>WHAT MACAPP CAN DO FOR YOU</h2>
<p>
&nbsp;MacApp can speed your application development process and help you create more<br>
robust applications for the Macintosh. Specifically, MacApp manages the user<br>
interface, handles events, implements memory management services, manages<br>
printing services, provides basic debugging services, and gives you high-level access<br>
to code via Mouser. In addition, when you use MacApp, a number of support<br>
organizations and class libraries are available to you. We'll take a closer look at each<br>
of these benefits. 
</p>
<p>
<b>&nbsp;Manages the user interface. </b>Macintosh users are a demanding audience, having<br>
grown accustomed to the Macintosh's distinctive look and feel. Apple has explicitly<br>
defined the elements of this look and feel in its Human Interface Guidelines, available<br>
from APDA. If your application is to succeed, it must conform to these guidelines. The<br>
most significant benefit of using MacApp as your application framework is that it<br>
provides for all aspects of Apple's Human Interface Guidelines. MacApp handles user<br>
interaction, creates draggable, resizable windows, supports pull-down menus, and<br>
provides default behavior for a number of contingencies.
</p>
<p>
&nbsp;Furthermore, MacApp ships with a tool called ViewEdit that enables you to graphically<br>
manipulate and edit the user interface aspects of your software, such as the location,<br>
size, and text of buttons and scrollable lists. Creating a dialog box with various<br>
controls becomes a simple matter of sketching out these items much as you would<br>
sketch a drawing with MacDraw. Figure 2 shows the ViewEdit editing window from the<br>
DemoDialogs example that comes with MacApp, offering the programmer the chance to<br>
edit the Save As dialog.
</p>
<p>
<img src="img/157.gif" width="600 px"></img>
</p>
<p>
<b>&nbsp;Figure 2. Editing the Save As Dialog in the ViewEdit Window</b>
</p>
<p>
<b>&nbsp;Handles events. </b>User interaction produces events that an application gets through<br>
the Main Event Loop. Programming this code from scratch is both time-consuming and<br>
difficult. MacApp frees you from this requirement, managing the extensive code to<br>
handle events and dispatching them accordingly.
</p>
<p>
<b>&nbsp;Implements memory management services. </b>The most difficult part of<br>
Macintosh programming, as veteran Macintosh programmers will attest, is careful<br>
memory management. Memory management services are fully implemented in MacApp,<br>
along with support for failure notification and a simple but elegant mechanism for<br>
recovering from failure conditions, such as a memory allocation failure in<br>
low-memory situations. 
</p>
<p>
<b>&nbsp;Manages printing services. </b>Most Macintosh applications require some degree of<br>
printing services.&nbsp;&nbsp;&nbsp;Writing good printing code is difficult and demanding. MacApp<br>
makes the job of providing printing capabilities in an application easy, freeing most<br>
developers from the necessity of writing even a single line of printing code. MacApp's<br>
generalized printing model correctly manages most printing needs. It provides support<br>
for monochrome and color printing and for the print dialog boxes, and provides a<br>
default notification when the application is busy printing. 
</p>
<p>
<b>Provides basic debugging services. </b>Debugging is always a chore. But MacApp<br>
eases this chore by supplying a built-in debugger that provides basic debugging<br>
services, such as a notification each time a code segment is loaded, and a built-in<br>
inspector that allows you to inspect your objects dynamically.&nbsp;&nbsp;&nbsp;Also, SADE 1.1,<br>
Apple's standard debugging environment and an excellent debugging tool, supports<br>
source code debugging of MacApp applications. 
</p>
<p>
<b>Gives you high-level access to code via Mouser.&nbsp;&nbsp;</b>MacApp ships with a tool<br>
called Mouser that allows you to access both the MacApp libraries and your source code<br>
by class, method, and field. For details, see the sidebar "About Mouser" by Mary<br>
Boetcher, author of Mouser.
</p>
<p>
<b>Makes support organizations available to you. </b>When you program for the<br>
Macintosh, you can turn to a number of organizations for support. The MacApp<br>
Developer's Association (MADA) provides regular newsletters, source code disks, and<br>
MacApp tools for developers. Also, a large developer group address on AppleLink called<br>
MacApp.Tech$ provides quick answers to technical questions. Many of MacApp's<br>
current and former engineers appear on this group address to answer questions.
</p>
<p>
<b>Makes class libraries available to you. </b>Last but not least, if you program with<br>
MacApp, you can use existing class libraries from a variety of sources. MacApp comes<br>
bundled with five fully functional demo applications in Object Pascal and three in C++.<br>
Code can be copied and pasted from these examples into your application. MADA<br>
maintains a catalog of powerful classes that are available for purchase, such as an<br>
offscreen-imaging unit to improve graphics rendering, a database unit to integrate<br>
database capabilities into your application, and several more.
</p>
<h2>ABOUT MOUSER</h2>
<p>
by Mary "Mouser Woman" Boetcher
</p>
<p>
Mouser is a browser, a program for viewing and editing source code files.
</p>
<p>
The difference between a browser and an editor is that the browser "knows" something<br>
about the structure of the language and/or development system the code is written in. 
</p>
<p>
Mouser knows about the structure of Object Pascal and C++ programs, and can use<br>
this information to allow you to quickly navigate among the classes and methods of a<br>
program. The leftmost pane of the browser window displays a list of the program's<br>
classes. Clicking on a class name brings up lists of the class's methods and fields. You<br>
can then click on a method or field name to see its source code.
</p>
<p>
<img src="img/158.gif" width="600 px"></img>
</p>
<p>
<b>Figure 3 Mouser Provides High-level Access to code</b>
</p>
<p>
You can get a list of
</p>
<ul>
<li>all the methods that reference a particular string</li>
<li>all the methods with a particular name</li>
<li>all the fields or methods of a class, including those of its superclasses</li>
</ul>
<p>
You can also find out
</p>
<ul>
<li>which segment a method is in</li>
<li>which source file a method or class definition is in very useful for<br>
MacApp!)</li>
<li>the inherited form of a method</li>
<li>the source code for some selected text</li>
</ul>
<p>
&nbsp;Mouser provides a number of commands for getting information about your program. 
</p>
<h2>MACAPP'S FLEXIBILITY</h2>
<p>
What if there's something your application needs to do slightly differently from the<br>
MacApp libraries? The fact that these libraries are written in an object-based<br>
language (Object Pascal) means that you can easily modify the pieces of the libraries<br>
that don't exactly meet your needs. (If you're not familiar with object programming,<br>
and words like <i> object, class, subclass, superclass, method, </i> and<i>inheritance </i> mean<br>
nothing to you, you might want to consult the section entitled "Basic Concepts of the<br>
Object-Based Approach" in Brian Wilkerson's article "How to Design an Object-Based<br>
Application" in this issue for help in understanding the next couple of paragraphs.)
</p>
<p>
Suppose, for example, you want to add a Preferences item to the standard File menu<br>
supported by MacApp. In MacApp, the <code>TApplication.DoMenuCommand </code>method (or<br>
member function, in C++ terminology) handles the standard menu items (those<br>
creating a new document, opening a document, quitting the application, and so on). In<br>
your subclass <code> TMyApplication </code>of the MacApp class <code>TApplication</code>, you define a<br>
method that will override the inherited <code> DoMenuCommand </code>method to handle the case<br>
where the user selects Preferences from the File menu. If the item the user selects<br>
from the File menu is not Preferences, then your method simply calls the inherited<br>
version of the method so <code>TApplication </code>can handle the menu selection.
</p>
<p>
The following simple method allocates a Preferences command object if Preferences is<br>
chosen from the File menu, and otherwise calls the inherited version of the method:
</p>
<pre>FUNCTION TMyApplication.DoMenuCommand(aCmdNumber: CmdNumber):
        TCommand; OVERRIDE;
    VAR aPreferencesCommand: TPreferencesCommand;
    BEGIN
        DoMenuCommand := NIL;
        CASE aCmdNumber OF
            cPreferences:
                BEGIN
                New(aPreferencesCommand);
                FailNil(aPreferencesCommand);
                aPreferencesCommand.IPreferencesCommand(aCmdNumber);
                DoMenuCommand := aPreferencesCommand;
                END;
            OTHERWISE
            DoMenuCommand := INHERITED DoMenuCommand(aCmdNumber);
        END; { CASE aCmdNumber }
    END; { TMyApplication.DoMenuCommand }</pre>
<p>
Note that for this example to work, you would also have to add the Preferences&nbsp;&nbsp;item to<br>
the <code>cmnu</code> resource of the application, and override <code>DoSetupMenus</code> in <code>TMyApplication</code><br>
to enable the menu item.
</p>
<h2>WHAT IT TAKES TO USE MACAPP</h2>
<p>
While MacApp will save you time and effort in the long run, you must invest time and<br>
effort up front to learn how to use it. If you are new to the Macintosh, you face two<br>
steep learning curves: first learning the Macintosh (the Toolbox, operating system,<br>
and user interface) and then learning MacApp. Learning MacApp also requires learning<br>
object programming.
</p>
<p>
But don't let this discourage you. Apple Developer University offers excellent<br>
introductory courses on the Macintosh programming environment and on MacApp.<br>
These courses make the learning process easier and provide programming labs in<br>
which you can immediately apply what you learn. Furthermore, using Mouser to<br>
browse the MacApp classes can help speed your learning. Finally, the MacApp example<br>
applications are a rich source of ideas and examples of how to implement a wide<br>
variety of features. And by the end of this article, if you read the next section carefully<br>
and try the exercise I lead you through, you will already have some familiarity with<br>
MacApp.
</p>
<h2>NOW, AN EXAMPLE</h2>
<p>
Now that you know what MacApp can do for you, and what you must do for MacApp, let's<br>
look at an example of how you might use MacApp to develop an application that<br>
integrates previously existing routines.
</p>
<p>
Say we want to develop a database package for the Macintosh based on an application<br>
we've developed for another platform. The application has many capabilities that we<br>
can reuse (such as b- tree creation and management, graphing, searching, and<br>
sorting) and some capabilities that we should not use (such as window management and<br>
data entry screens). In this example we'll focus on reusing the graphing capability.
</p>
<p>
The source code for the graphing capability is in two files of graphics routines written<br>
in C. We've been careful in the design of our graphics routines, ensuring that they<br>
make no assumptions about their environment, such as graphics parameters or<br>
hardware attributes. For example, the routines avoid drawing and instead have an<br>
interface that describes what should be drawn. This lets the application that uses the<br>
routines determine how the drawing should occur.
</p>
<p>
We start, then, with our graphics routines. We will create a class that encapsulates<br>
the services offered by these routines. Then, you will learn step by step how to<br>
seamlessly integrate this code into a MacApp sample application, using MPW.
</p>
<p>
<b>START WITH YOUR ROUTINES</b><br>
Our graphics routines reside in a set of two files: Graph.h, which contains the<br>
interfaces to the routines, and Graph.c, which contains the source to the graphics<br>
routines. You'll find a complete listing of these files on develop, the disc.
</p>
<p>
For this example, these files reside on the Macintosh. In your case, the files you want<br>
to use may reside on another platform. To transfer your files to the Macintosh, you<br>
should consider either a disk transfer or a file transfer. A disk transfer, to transfer<br>
the files from another disk, is best accomplished with a utility such as Apple File<br>
Exchange. A file transfer is best accomplished with either a terminal emulator, to<br>
download the file using standard file transfer protocols, or a file server, such as<br>
AppleShare, to access the other platform over AppleTalk and transfer the files.
</p>
<p>
Now I'll point out selected features of our files Graph.h and Graph.c.
</p>
<p>
The header file Graph.h contains some type and constant declarations, including the<br>
following:
</p>
<pre>#define kMaxPoints 20 /* Maximum number of points we support. */</pre>
<p>
This file also contains some type definitions, like these:
</p>
<pre>typedef enum {kBar, kStackedBar, kPie, kLine} GraphType;
/* These are the kinds of graphs that the graph routines support;
   only the bar graph is implemented for this example. */
typedef GraphValue GData[kMaxPoints-1];
                             /* Zero-based array of points. */
typedef struct {
  GraphType thisGraph;       /* Type of graph it is. */
  short     numPoints;       /* Number of points in this graph. */
  short     top;
  short     left;
  short     bottom;
  short     right;           /* The graph's rectangle with respect */
                             /*to which our graph is computed. */
  short     graphYMax;       /* The graph's maximum Y coord value. */
  short     graphYMin;       /* the graph's minimum Y coord value. */
                             /* Use these to scale the graph. */
  GData     graphItems;      /* The data points in the graph. */
} GraphStruct, *GraphStructPtr;</pre>
<p>
Finally, Graph.h also contains some function declarations, such as:
</p>
<pre>GraphStructPtr DoGraphInit( GraphType whichGraphType );
void DoGraphSetGraphRect( short top, short left, short bottom,
            short right, GraphStructPtr graphStorage );
void DoGraphSetPoint( short which, short value,
            GraphStructPtr graphStorage );</pre>
<p>
The actual routines are implemented in Graph.c. Here's a sample from this file:
</p>
<pre>GraphStructPtr DoGraphInit( GraphType whichGraphType )
{
    GraphStructPtr  graphStorage = 0;
    short           counter;
    GraphValue      aGraphValue;
   
    if (!(graphStorage =
             (GraphStructPtr) malloc(sizeof (GraphStruct))))
        return 0;               /* Error... */
    switch ( whichGraphType ) {
        case kBar:
            graphStorage-&gt;numPoints = graphStorage-&gt;top =
                graphStorage-&gt;left = graphStorage-&gt;bottom =
                graphStorage-&gt;right = graphStorage-&gt;graphYMax =
                graphStorage-&gt;graphYMin = 0;
            for (counter = 0; counter   graphItems[counter];
                aGraphValue.whichOne = aGraphValue.value =
                aGraphValue.top = aGraphValue.left =
                aGraphValue.right = aGraphValue.bottom = 0;
            }
            break;
        case kStackedBar:
        case kPie:
        case kLine:
            /* These are unsupported in this version. */
            break;
    }
    return graphStorage;
}</pre>
<p>
<b>CREATE A CLASS TO ENCAPSULATE SERVICES</b><br>
We next encapsulate the services of our graphics routines in a C++ class. To do this<br>
requires changes to our header. We modify our header files by surrounding our<br>
function declarations with the extern<code>"</code>C<code>"</code> directive as follows:
</p>
<pre>#ifdef __cplusplus

extern "C" {
#endif
// Function declarations go here, for example:
GraphStructPtr DoGraphInit( short graphType );
// and so on.
#ifdef __cplusplus
}
#endif</pre>
<p>
This ensures that when CFront, the C++ preprocessor, reads in this header, it won't<br>
mangle the names of our C routines.
</p>
<p>
Next we create a "wrapper object" for these routines. In essence, this is a class that<br>
can be used to define objects that provide all the services of the graph routines. This<br>
class can then be used in a MacApp application. Such a class can be defined in Object<br>
Pascal or C++. In this example, we'll create a class in C++ that provides the services<br>
of the graph routines.
</p>
<p>
&nbsp;To create the C++ wrapper object--<code>TGraph</code>--for our graph routines, we make two<br>
new files: UGraph.h and UGraph.cp (following MacApp's naming convention). The first<br>
file contains the class definition, and the second contains the class implementation. See<br>
develop, the disk, for a complete listing of these two files.
</p>
<p>
&nbsp;Creating these files is a three-step procedure, as follows:
</p>
<ol>
<li> After putting our copyright notices at the top of these two files, we put in<br>
UGraph.h the following basic structure:

<pre>      #ifndef __UGRAPH__
      #define __UGRAPH__
      // * Auto-Include the requirements for this unit's
      interface.
      #ifndef __UMacApp__
      #include "UMacApp.h"
      #endif
      #include "Graph.h"
      // The interface to this class goes here.
      #endif</pre>
<p>
&nbsp;This allows the MPW C++ compiler to perform at its best by only making it<br>
do the work to include this unit's interface (and the requirements for this<br>
unit's interface) when it's not already included.
</p>
</li>
<li> Next, we create the definition for <code>TGraph </code>and put the definition in<br>
UGraph.h.

<p>
&nbsp;To do this, we must choose which class <code>TGraph </code>will descend from.&nbsp;&nbsp;Since<br>
graphs are things that are drawn on the screen and are&nbsp;&nbsp;viewed, we decide to<br>
make the graph class descend from MacApp's<code> TView </code>class. Ideally, we would<br>
create a generalized base class for a&nbsp;&nbsp;graph, such as <code>TGraph</code> descended from<br>
<code>TView</code>, and then create&nbsp;&nbsp;specialized subclasses of <code>TGraph </code>for the various kinds<br>
of graphs. A&nbsp;&nbsp;bar graph--<code>TBarGraph</code>--would descend from <code>TGraph</code>; a line <br>
chart-- <code>TLineGraph</code>--would descend from <code>TGraph</code>; and so on.&nbsp;&nbsp;&nbsp;However, to<br>
keep this example simple, we'll make the bar graph&nbsp;&nbsp;class descend directly<br>
from <code>TView</code>.
</p>
<p>
&nbsp;Here's the class definition we come up with:
</p>
<pre>      class TGraph : public TView {
      public:
          virtual pascal void IRes(TDocument *itsDocument,
              TView *itsSuperView, Ptr *itsParams);
          // Initialize the graph view from its resource template.
          virtual pascal void SetGraphRect(Rect graphRect);
          // Initialize the graph data structure to be the size of
          // this view.
          virtual pascal void SetPoint( short which, long value );
          // Set a point to a value.
          virtual pascal short GetNumPoints();
          // Return the number of points in the graph.
          virtual pascal void ComputeBars(Boolean redraw);
          // The graph library computes each of the bars for this
          // graph and if redraw is TRUE forces the view to redraw
          // itself.
          virtual pascal void GetCoordinateRange(Rect *coordRange);
          // Return min &amp; max Y coordinates, and min &amp; max X
          // coordinates, useful for labeling the axes of the graph.
          virtual pascal void Draw(Rect *area);
          // Draw the graph.
         
          virtual pascal void Free(void);
          // Free the data allocated by this class.
      private:
          GraphStructPtrfData;
          };</pre>
<p>
There are several things to note about this wrapper object.
</p>
<p>
First, note that the class functions don't map one-to-one with the graph<br>
routines. Rather, there is an attempt to abstract from the routines various<br>
services available for this class. For example, instead of retrieving the<br>
maximum value of a point on the Y-axis with a call to the routine<br>
<code>DoGraphGetYMax</code>, we abstract from this routine the notion of retrieving the<br>
range of values on both axes (useful in setting up labels on the axes), and<br>
implement the class member function <code>GetCoordinateRange</code>, which retrieves<br>
the range of values on the X- and Y-axes and returns the result in a <code> Rect</code>.
</p>
<p>
Also note that instead of retrieving a specific bar by calling the<br>
routine<code>DoGraphGetBar</code>, we attempt to hide that activity behind the class<br>
member function<code>Draw</code>, which simply draws the graph, iterating over all bars<br>
in the bar graph.
</p>
<p>
&nbsp;And note that since this class descends directly from <code>TView</code>, three member<br>
functions in this class definition override <code>TView's</code> member functions: <code>IRes</code>,<br>
which initializes the view and calls the graph routine to allocate and initialize<br>
the graph data structure;<code> Draw</code>, which does the work of drawing the graph;<br>
and <code> Free</code>, which calls the graph routines to dispose of the graph data<br>
structure.
</p>
</li>
<li> Finally, we create the file UGraph.cp, which contains the implementation<br>
of the class <code>TGraph</code> in C++. The first thing to add here (after the copyright<br>
notice) is an #include so that the header file is included:

<pre>      #ifndef __UGRAPH__
      #include "UGraph.h"
      #endif</pre>
<p>
&nbsp;This ensures that the <code>TGraph</code>implementation "sees" its class definition, as<br>
well as any other necessary definitions. We then list the implementation of the<br>
<code>TGraph </code>class in the body of the file UGraph.cp. The <code>TGraph::IRes </code>member<br>
function implemented in this file might look something like this:
</p>
<pre>      pascal void
      
      TGraph::IRes(TDocument *itsDocument, TView
              *itsSuperView, Ptr *itsParams)
      
      {
          GraphStructPtr aGraphStructPtr;
          Rect aRect;
      
          inherited::IRes(itsDocument, itsSuperView, itsParams);
          aGraphStructPtr = DoGraphInit(kBar);
          fData = aGraphStructPtr;
          aRect = gZeroRect;
          if (Focus())
              GetQDExtent(&amp;aRect);
          SetGraphRect(aRect);
          }</pre>
<p>
&nbsp;This member function initializes the <code>TView</code> object by calling its&nbsp;&nbsp;inherited<br>
<code>IRes </code>member function and then initializes the graph&nbsp;&nbsp;routines by calling<br>
<code>DoGraphInit.</code> This view object then attempts&nbsp;&nbsp;to get information about its<br>
graphics environment and lets the&nbsp;&nbsp;routines set up various values for this<br>
environment.
</p></li></ol>
<p>
<b>INTEGRATE THE CLASS INTO AN APPLICATION</b><br>
At this point, we have a C++ class that encapsulates the services offered by our<br>
graphics routines. To see how you can use this C++ class in a MacApp application, try<br>
the following exercise. In this exercise, you'll modify the C++ version of the<br>
DemoDialogs sample application that comes with MacApp 2.0, by adding a bar graph to<br>
the Monthly Values Dialog. All the files you need are ondevelop, the disc. 
</p>
<p>
<img src="img/159.gif" width="600 px"></img>
</p>
<p>
<b>Figure 4. The Monthly Values Dialog Before Modification</b>
</p>
<ol>
<li>Put the following files in the DemoDialogs folder: Graph.h, Graph.c,<br>
UGraph.h, UGraph.cp. Use MPW to set this folder as the current directory.</li>
<li>Open the file DemoDialogs.r and locate the Monthly Values Dialog resource<br>
description:

<pre>      resource 'view' (cMonthlyDialog, purgeable) {
          {
          ...
          }};</pre></li>

<li>Increase the width of the <code>DialogView </code>from <code>500 </code>to <code>600 </code>as follows:</li>

<pre>      'SCLR', 'DLOG', { 0, 0 }, { 1000, 600 },</pre></li>

<li>Add to the end of this resource description (that is, inside the<br>
second-to-last&nbsp;&nbsp;right curly brace) the following description:

<pre>         ;
          'DLOG', 'graf', { 25, 300 }, { 300, 300 },
          sizeFixed, sizeFixed, shown, disabled,
          View { "TGraph" }</pre>
<p>
&nbsp;This puts a <code>TGraph </code>view in the Monthly Values Dialog and ensures that the<br>
<code>TGraph </code>object is allocated and initialized via its<code> IRes </code>member function when<br>
the dialog is created.
</p></li>

<li>To make sure that the DemoDialogs headers know about your graph<br>
routines,&nbsp;&nbsp;add the following line at the end of the list of<code>#include </code>files at the<br>
top of the&nbsp;&nbsp;file UDemoDialogs.h:

<pre>      #include "UGraph.h"</pre></li>

<li>Since your graph view is a subview of the Monthly Values Dialog, modify<br>
that&nbsp;&nbsp;class so that the graph recomputes and redraws whenever a new monthly<br>
value&nbsp;&nbsp;is typed in. To do this, modify the file UDemoDialogs.h by adding the<br>
following to the<code>TMonthlyDialog </code>class:

<pre>       virtual pascal Boolean DeselectCurrentEditText(void);</pre></li>

<li>Then add the implementation for this member function to the file <br>
UDemoDialogs.cp:

<pre>      pascal Boolean
          TMonthlyDialog::DeselectCurrentEditText(void)
      
      {
          TGraph      *aGraph;
          TNumberText *theNumberText;
         
          aGraph = (TGraph *) FindSubView('graf');
          for (short which = 0; which   fIdentifier ==
                      gMonthIDs[which]) {
                  theNumberText =
                      (TNumberText *) FindSubView(gMonthIDs[which]);
                  if (theNumberText)
                      aGraph-&gt;SetPoint(which+1,
                          theNumberText-&gt;GetValue());
                  aGraph-&gt;ComputeBars(kRedraw);
                  break;
              }
          }
          return inherited::DeselectCurrentEditText();
      }</pre></li>

<li>Next, to prevent the linker from stripping the <code>TGraph </code>class, modify <br>
<code>TTestApplication::ITestApplication </code>to include the following variable:

<pre>      TGraph *aGraph;</pre>
<p>
&nbsp;and to allocate this variable within the <code>gDeadStripSuppression</code> section at <br>
the end of this function:
</p>
<pre>      if (gDeadStripSuppression) {
          ...
          aGraph = new TGraph;
      }</pre></li>

<li>Then, so that the graph points are set up as the Monthly Values are set up,<br>
modify <code>TMonthlyDialog::StuffValues </code>as follows:

<pre>      pascal void
      TMonthlyDialog::StuffValues()
      
      {
          TGraph *aGraph;
          TNumberText *aNumberText;
         
          aGraph = (TGraph *) FindSubView('graf');
          for (short i = 0; i    
          SetValue(gMonthlyValues[i], kDontRedraw);
              aGraph-&gt;SetPoint(i+1, gMonthlyValues[i]);
          }
          aGraph-&gt;ComputeBars(kDontRedraw);
      }</pre></li>

<li> Finally, so that the graph unit and the file of graph routines are built<br>
when this example is built, add the following lines to the end of the file<br>
DemoDialogs MAMake:

<pre>      OtherLinkFiles = &#8706;
      
      "{CLibraries}"StdCLib.o &#8706;
                  "{ObjApp}UGraph.cp.o" &#8706;
                  "{ObjApp}Graph.c.o"
      
      "{ObjApp}Graph.c.o" &#402; &#8706;
                  "{SrcApp}Graph.c" &#8706;
                  "{SrcApp}Graph.h"
                 
      {MAEcho} {EchoOptions} "Compiling: Graph.c"
      {MAC} "{SrcApp}Graph.c" &#8706;
          -i "{SrcApp}" &#8706;
          -i "{CIncludes}" &#8706;
          -i "{MACIncludes}" &#8706;
          -o "{ObjApp}Graph.c.o" &#8706;
          {COptions} &#8706;
          {OtherCOptions}
      
      "{ObjApp}UGraph.cp.o" &#402; &#8706;
                  "{SrcApp}UGraph.h" &#8706;
                  "{SrcApp}Graph.h" &#8706;
                  {MacAppIntf}</pre></li>

<li> Compile DemoDialogs and run it. You will see your graph class at work<br>
calling your&nbsp;&nbsp;graph routines and drawing the graph in the Monthly Values<br>
Dialog.

<p>
<img src="img/160.gif" width="600 px"></img>
</p>
<p>
<b>&nbsp;Figure 5. </b>The Monthly Values Dialog After Modification
</p></li></ol>
<h2>SUMMARY</h2>
<p>
You've learned that using MacApp as your framework in developing a Macintosh<br>
application not only enables you to reuse your functionally specific code routines, but<br>
also saves you time and effort by providing standard application behavior. You've also<br>
learned that because the MacApp libraries are written in an object-based language<br>
(Object Pascal), you can easily modify the pieces that don't meet your needs. You've<br>
watched as we've created a class to encapsulate the functionality of an existing group of<br>
routines, and you've gone through the process of integrating this class into a MacApp<br>
sample application. Now you're ready to integrate some of your own code into the<br>
MacApp sample application ondevelop, the disc. With the help of MacApp, you'll soon be<br>
reusing your code in Macintosh applications that present users with the interface they<br>
know and love. 
</p>
<p>
<b>CHRIS KNEPPER</b> is this issue's token beer connoisseur.&nbsp;&nbsp;He's proud that he has<br>
never drunk a Mountain Dew in his life, and never plans to.&nbsp;&nbsp;He received a BSEE/CS<br>
from Stanford in 1984, and since then has worked in a Dickensian industrial sweat<br>
shop (he won't say exactly why or where) and at a small Macintosh consulting firm. <br>
Since he came to Apple in 1986, he has done a variety of jobs including software<br>
testing, developer technical support, and work for Apple Integrated Systems--all the<br>
while consuming record amounts of coffee.&nbsp;&nbsp;When he's not hanging out at local<br>
breweries, he's reading, cycling, rooting for the San Francisco Giants, or playing his<br>
favorite sport. What is it?&nbsp;&nbsp;Hint--he's been saving his pennies for his dream vanity<br>
plate:TNSNE1. . .&nbsp;&nbsp;*
</p>
<p>
<b>MACAPP</b>, its manuals, and other useful books on MacApp and object programming are<br>
available from APDA.&nbsp;&nbsp;*
</p>
<p>
<b>Note</b> that whatever work you do with MacApp and Object Pascal is restricted to the<br>
Macintosh, because Apple's implementation of Object Pascal has not been endorsed by<br>
other vendors on other platforms. If you want to eventually use your code on another<br>
platform, consider coding in C++, as C++ compilers are available on other platforms.<br>
Of course, you will need to be careful how you structure your application as it<br>
develops on the Macintosh (and vice versa) to ensure compatibility across hardware<br>
platforms.&nbsp;&nbsp;*
</p>
<p>
<b>You</b> can contact MADA at P.O. Box 23; Everett, WA; 98206; phone (206) 252-6946;<br>
AppleLink address MADA. To join the AppleLink group address MacApp.Tech$, contact<br>
AppleLink address MacApp.Admin.&nbsp;&nbsp;*
</p>
</body>
</html>
